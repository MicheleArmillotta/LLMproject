[
  {
    "function_name": "xfs_rtpick_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "1266-1302",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_rtpick_extent(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tlen,\t\t/* allocation length (rtextents) */\n\txfs_rtblock_t\t*pick)\t\t/* result rt extent */\n{\n\txfs_rtblock_t\tb;\t\t/* result block */\n\tint\t\tlog2;\t\t/* log of sequence number */\n\t__uint64_t\tresid;\t\t/* residual after log removed */\n\t__uint64_t\tseq;\t\t/* sequence number of file creation */\n\t__uint64_t\t*seqp;\t\t/* pointer to seqno in inode */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\tseqp = (__uint64_t *)&mp->m_rbmip->i_d.di_atime;\n\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {\n\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*seqp = 0;\n\t}\n\tseq = *seqp;\n\tif ((log2 = xfs_highbit64(seq)) == -1)\n\t\tb = 0;\n\telse {\n\t\tresid = seq - (1ULL << log2);\n\t\tb = (mp->m_sb.sb_rextents * ((resid << 1) + 1ULL)) >>\n\t\t    (log2 + 1);\n\t\tif (b >= mp->m_sb.sb_rextents)\n\t\t\tb = do_mod(b, mp->m_sb.sb_rextents);\n\t\tif (b + len > mp->m_sb.sb_rextents)\n\t\t\tb = mp->m_sb.sb_rextents - len;\n\t}\n\t*seqp = seq + 1;\n\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t*pick = b;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "mp->m_rbmip",
            "XFS_ILOG_CORE"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "b",
            "mp->m_sb.sb_rextents"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_highbit64",
          "args": [
            "seq"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_highbit64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "48-51",
          "snippet": "static inline int xfs_highbit64(__uint64_t v)\n{\n\treturn fls64(v) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_highbit64(__uint64_t v)\n{\n\treturn fls64(v) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtpick_extent(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tlen,\t\t/* allocation length (rtextents) */\n\txfs_rtblock_t\t*pick)\t\t/* result rt extent */\n{\n\txfs_rtblock_t\tb;\t\t/* result block */\n\tint\t\tlog2;\t\t/* log of sequence number */\n\t__uint64_t\tresid;\t\t/* residual after log removed */\n\t__uint64_t\tseq;\t\t/* sequence number of file creation */\n\t__uint64_t\t*seqp;\t\t/* pointer to seqno in inode */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\tseqp = (__uint64_t *)&mp->m_rbmip->i_d.di_atime;\n\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {\n\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*seqp = 0;\n\t}\n\tseq = *seqp;\n\tif ((log2 = xfs_highbit64(seq)) == -1)\n\t\tb = 0;\n\telse {\n\t\tresid = seq - (1ULL << log2);\n\t\tb = (mp->m_sb.sb_rextents * ((resid << 1) + 1ULL)) >>\n\t\t    (log2 + 1);\n\t\tif (b >= mp->m_sb.sb_rextents)\n\t\t\tb = do_mod(b, mp->m_sb.sb_rextents);\n\t\tif (b + len > mp->m_sb.sb_rextents)\n\t\t\tb = mp->m_sb.sb_rextents - len;\n\t}\n\t*seqp = seq + 1;\n\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t*pick = b;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtunmount_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "1249-1257",
    "snippet": "void\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_rsumip"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_rbmip"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_rtunmount_inodes(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_rbmip)\n\t\tIRELE(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\tIRELE(mp->m_rsumip);\n}"
  },
  {
    "function_name": "xfs_rtmount_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "1225-1247",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_rtmount_inodes(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\terror;\t\t/* error return value */\n\txfs_sb_t\t*sbp;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rbmino == NULLFSINO)\n\t\treturn 0;\n\terror = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\tASSERT(mp->m_rbmip != NULL);\n\tASSERT(sbp->sb_rsumino != NULLFSINO);\n\terror = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip);\n\tif (error) {\n\t\tIRELE(mp->m_rbmip);\n\t\treturn error;\n\t}\n\tASSERT(mp->m_rsumip != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_rsumip != NULL"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_rbmip"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "sbp->sb_rsumino",
            "0",
            "0",
            "&mp->m_rsumip"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sbp->sb_rsumino != NULLFSINO"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_rbmip != NULL"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtmount_inodes(\n\txfs_mount_t\t*mp)\t\t/* file system mount structure */\n{\n\tint\t\terror;\t\t/* error return value */\n\txfs_sb_t\t*sbp;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rbmino == NULLFSINO)\n\t\treturn 0;\n\terror = xfs_iget(mp, NULL, sbp->sb_rbmino, 0, 0, &mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\tASSERT(mp->m_rbmip != NULL);\n\tASSERT(sbp->sb_rsumino != NULLFSINO);\n\terror = xfs_iget(mp, NULL, sbp->sb_rsumino, 0, 0, &mp->m_rsumip);\n\tif (error) {\n\t\tIRELE(mp->m_rbmip);\n\t\treturn error;\n\t}\n\tASSERT(mp->m_rsumip != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtmount_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "1177-1219",
    "snippet": "int\t\t\t\t/* error */\nxfs_rtmount_init(\n\tstruct xfs_mount\t*mp)\t/* file system mount structure */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer for last block of subvolume */\n\tstruct xfs_sb\t\t*sbp;\t/* filesystem superblock copy in mount */\n\txfs_daddr_t\t\td;\t/* address of last block of subvolume */\n\tint\t\t\terror;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rblocks == 0)\n\t\treturn 0;\n\tif (mp->m_rtdev_targp == NULL) {\n\t\txfs_warn(mp,\n\t\"Filesystem has a realtime volume, use rtdev=device option\");\n\t\treturn -ENODEV;\n\t}\n\tmp->m_rsumlevels = sbp->sb_rextslog + 1;\n\tmp->m_rsumsize =\n\t\t(uint)sizeof(xfs_suminfo_t) * mp->m_rsumlevels *\n\t\tsbp->sb_rbmblocks;\n\tmp->m_rsumsize = roundup(mp->m_rsumsize, sbp->sb_blocksize);\n\tmp->m_rbmip = mp->m_rsumip = NULL;\n\t/*\n\t * Check that the realtime section is an ok size.\n\t */\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_rblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_rblocks) {\n\t\txfs_warn(mp, \"realtime mount -- %llu != %llu\",\n\t\t\t(unsigned long long) XFS_BB_TO_FSB(mp, d),\n\t\t\t(unsigned long long) mp->m_sb.sb_rblocks);\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"realtime device size check failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"realtime device size check failed\""
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "mp->m_rtdev_targp",
            "d - XFS_FSB_TO_BB(mp, 1)",
            "XFS_FSB_TO_BB(mp, 1)",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"realtime mount -- %llu != %llu\"",
            "(unsigned long long) XFS_BB_TO_FSB(mp, d)",
            "(unsigned long long) mp->m_sb.sb_rblocks"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "d"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "d"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mp->m_sb.sb_rblocks"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "mp->m_rsumsize",
            "sbp->sb_blocksize"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Filesystem has a realtime volume, use rtdev=device option\""
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t/* error */\nxfs_rtmount_init(\n\tstruct xfs_mount\t*mp)\t/* file system mount structure */\n{\n\tstruct xfs_buf\t\t*bp;\t/* buffer for last block of subvolume */\n\tstruct xfs_sb\t\t*sbp;\t/* filesystem superblock copy in mount */\n\txfs_daddr_t\t\td;\t/* address of last block of subvolume */\n\tint\t\t\terror;\n\n\tsbp = &mp->m_sb;\n\tif (sbp->sb_rblocks == 0)\n\t\treturn 0;\n\tif (mp->m_rtdev_targp == NULL) {\n\t\txfs_warn(mp,\n\t\"Filesystem has a realtime volume, use rtdev=device option\");\n\t\treturn -ENODEV;\n\t}\n\tmp->m_rsumlevels = sbp->sb_rextslog + 1;\n\tmp->m_rsumsize =\n\t\t(uint)sizeof(xfs_suminfo_t) * mp->m_rsumlevels *\n\t\tsbp->sb_rbmblocks;\n\tmp->m_rsumsize = roundup(mp->m_rsumsize, sbp->sb_blocksize);\n\tmp->m_rbmip = mp->m_rsumip = NULL;\n\t/*\n\t * Check that the realtime section is an ok size.\n\t */\n\td = (xfs_daddr_t)XFS_FSB_TO_BB(mp, mp->m_sb.sb_rblocks);\n\tif (XFS_BB_TO_FSB(mp, d) != mp->m_sb.sb_rblocks) {\n\t\txfs_warn(mp, \"realtime mount -- %llu != %llu\",\n\t\t\t(unsigned long long) XFS_BB_TO_FSB(mp, d),\n\t\t\t(unsigned long long) mp->m_sb.sb_rblocks);\n\t\treturn -EFBIG;\n\t}\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\t\td - XFS_FSB_TO_BB(mp, 1),\n\t\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error) {\n\t\txfs_warn(mp, \"realtime device size check failed\");\n\t\treturn error;\n\t}\n\txfs_buf_relse(bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtallocate_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "1097-1172",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_rtallocate_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_alloctype_t\ttype,\t\t/* allocation type XFS_ALLOCTYPE... */\n\tint\t\twasdel,\t\t/* was a delayed allocation extent */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tr;\t\t/* result allocated block */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp;\t\t/* summary file block buffer */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\tASSERT(minlen > 0 && minlen <= maxlen);\n\n\t/*\n\t * If prod is set then figure out what to do to minlen and maxlen.\n\t */\n\tif (prod > 1) {\n\t\txfs_extlen_t\ti;\n\n\t\tif ((i = maxlen % prod))\n\t\t\tmaxlen -= i;\n\t\tif ((i = minlen % prod))\n\t\t\tminlen += prod - i;\n\t\tif (maxlen < minlen) {\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsumbp = NULL;\n\t/*\n\t * Allocate by size, or near another block, or exactly at some block.\n\t */\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\t\terror = xfs_rtallocate_extent_size(mp, tp, minlen, maxlen, len,\n\t\t\t\t&sumbp,\t&sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_rtallocate_extent_near(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\tASSERT(0);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If it worked, update the superblock.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\tlong\tslen = (long)*len;\n\n\t\tASSERT(*len >= minlen && *len <= maxlen);\n\t\tif (wasdel)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RES_FREXTENTS, -slen);\n\t\telse\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, -slen);\n\t}\n\t*rtblock = r;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_FREXTENTS",
            "-slen"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*len >= minlen && *len <= maxlen"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_exact",
          "args": [
            "mp",
            "tp",
            "bno",
            "minlen",
            "maxlen",
            "len",
            "&sumbp",
            "&sb",
            "prod",
            "&r"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "342-414",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_near",
          "args": [
            "mp",
            "tp",
            "bno",
            "minlen",
            "maxlen",
            "len",
            "&sumbp",
            "&sb",
            "prod",
            "&r"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "421-609",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_near(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\tany;\t\t/* any useful extents from summary */\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block offset (loop control) */\n\tint\t\tj;\t\t/* secondary loop control */\n\tint\t\tlog2len;\t/* log2 of minlen */\n\txfs_rtblock_t\tn;\t\t/* next block to try */\n\txfs_rtblock_t\tr;\t\t/* result block */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * If the block number given is off the end, silently set it to\n\t * the last block.\n\t */\n\tif (bno >= mp->m_sb.sb_rextents)\n\t\tbno = mp->m_sb.sb_rextents - 1;\n\t/*\n\t * Try the exact allocation first.\n\t */\n\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen, len,\n\t\trbpp, rsb, prod, &r);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If the exact allocation worked, return that.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\t*rtblock = r;\n\t\treturn 0;\n\t}\n\tbbno = XFS_BITTOBLOCK(mp, bno);\n\ti = 0;\n\tASSERT(minlen != 0);\n\tlog2len = xfs_highbit32(minlen);\n\t/*\n\t * Loop over all bitmap blocks (bbno + i is current block).\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Get summary information of extents of all useful levels\n\t\t * starting in this bitmap block.\n\t\t */\n\t\terror = xfs_rtany_summary(mp, tp, log2len, mp->m_rsumlevels - 1,\n\t\t\tbbno + i, rbpp, rsb, &any);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any useful extents starting here, try\n\t\t * allocating one.\n\t\t */\n\t\tif (any) {\n\t\t\t/*\n\t\t\t * On the positive side of the starting location.\n\t\t\t */\n\t\t\tif (i >= 0) {\n\t\t\t\t/*\n\t\t\t\t * Try to allocate an extent starting in\n\t\t\t\t * this block.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it worked, return it.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * On the negative side of the starting location.\n\t\t\t */\n\t\t\telse {\t\t/* i < 0 */\n\t\t\t\t/*\n\t\t\t\t * Loop backwards through the bitmap blocks from\n\t\t\t\t * the starting point-1 up to where we are now.\n\t\t\t\t * There should be an extent which ends in this\n\t\t\t\t * bitmap block and is long enough.\n\t\t\t\t */\n\t\t\t\tfor (j = -1; j > i; j--) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Grab the summary information for\n\t\t\t\t\t * this bitmap block.\n\t\t\t\t\t */\n\t\t\t\t\terror = xfs_rtany_summary(mp, tp,\n\t\t\t\t\t\tlog2len, mp->m_rsumlevels - 1,\n\t\t\t\t\t\tbbno + j, rbpp, rsb, &any);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If there's no extent given in the\n\t\t\t\t\t * summary that means the extent we\n\t\t\t\t\t * found must carry over from an\n\t\t\t\t\t * earlier block.  If there is an\n\t\t\t\t\t * extent given, we've already tried\n\t\t\t\t\t * that allocation, don't do it again.\n\t\t\t\t\t */\n\t\t\t\t\tif (any)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\terror = xfs_rtallocate_extent_block(mp,\n\t\t\t\t\t\ttp, bbno + j, minlen, maxlen,\n\t\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If it works, return the extent.\n\t\t\t\t\t */\n\t\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t\t*rtblock = r;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * There weren't intervening bitmap blocks\n\t\t\t\t * with a long enough extent, or the\n\t\t\t\t * allocation didn't work for some reason\n\t\t\t\t * (i.e. it's a little * too short).\n\t\t\t\t * Try to allocate from the summary block\n\t\t\t\t * that we found.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it works, return the extent.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Loop control.  If we were on the positive side, and there's\n\t\t * still more blocks on the negative side, go there.\n\t\t */\n\t\tif (i > 0 && (int)bbno - i >= 0)\n\t\t\ti = -i;\n\t\t/*\n\t\t * If positive, and no more negative, but there are more\n\t\t * positive, go there.\n\t\t */\n\t\telse if (i > 0 && (int)bbno + i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti++;\n\t\t/*\n\t\t * If negative or 0 (just started), and there are positive\n\t\t * blocks to go, go there.  The 0 case moves to block 1.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno - i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti = 1 - i;\n\t\t/*\n\t\t * If negative or 0 and there are more negative blocks,\n\t\t * go there.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno + i > 0)\n\t\t\ti--;\n\t\t/*\n\t\t * Must be done.  Return failure.\n\t\t */\n\t\telse\n\t\t\tbreak;\n\t}\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_near(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\tany;\t\t/* any useful extents from summary */\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block offset (loop control) */\n\tint\t\tj;\t\t/* secondary loop control */\n\tint\t\tlog2len;\t/* log2 of minlen */\n\txfs_rtblock_t\tn;\t\t/* next block to try */\n\txfs_rtblock_t\tr;\t\t/* result block */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * If the block number given is off the end, silently set it to\n\t * the last block.\n\t */\n\tif (bno >= mp->m_sb.sb_rextents)\n\t\tbno = mp->m_sb.sb_rextents - 1;\n\t/*\n\t * Try the exact allocation first.\n\t */\n\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen, len,\n\t\trbpp, rsb, prod, &r);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If the exact allocation worked, return that.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\t*rtblock = r;\n\t\treturn 0;\n\t}\n\tbbno = XFS_BITTOBLOCK(mp, bno);\n\ti = 0;\n\tASSERT(minlen != 0);\n\tlog2len = xfs_highbit32(minlen);\n\t/*\n\t * Loop over all bitmap blocks (bbno + i is current block).\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Get summary information of extents of all useful levels\n\t\t * starting in this bitmap block.\n\t\t */\n\t\terror = xfs_rtany_summary(mp, tp, log2len, mp->m_rsumlevels - 1,\n\t\t\tbbno + i, rbpp, rsb, &any);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any useful extents starting here, try\n\t\t * allocating one.\n\t\t */\n\t\tif (any) {\n\t\t\t/*\n\t\t\t * On the positive side of the starting location.\n\t\t\t */\n\t\t\tif (i >= 0) {\n\t\t\t\t/*\n\t\t\t\t * Try to allocate an extent starting in\n\t\t\t\t * this block.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it worked, return it.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * On the negative side of the starting location.\n\t\t\t */\n\t\t\telse {\t\t/* i < 0 */\n\t\t\t\t/*\n\t\t\t\t * Loop backwards through the bitmap blocks from\n\t\t\t\t * the starting point-1 up to where we are now.\n\t\t\t\t * There should be an extent which ends in this\n\t\t\t\t * bitmap block and is long enough.\n\t\t\t\t */\n\t\t\t\tfor (j = -1; j > i; j--) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Grab the summary information for\n\t\t\t\t\t * this bitmap block.\n\t\t\t\t\t */\n\t\t\t\t\terror = xfs_rtany_summary(mp, tp,\n\t\t\t\t\t\tlog2len, mp->m_rsumlevels - 1,\n\t\t\t\t\t\tbbno + j, rbpp, rsb, &any);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If there's no extent given in the\n\t\t\t\t\t * summary that means the extent we\n\t\t\t\t\t * found must carry over from an\n\t\t\t\t\t * earlier block.  If there is an\n\t\t\t\t\t * extent given, we've already tried\n\t\t\t\t\t * that allocation, don't do it again.\n\t\t\t\t\t */\n\t\t\t\t\tif (any)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\terror = xfs_rtallocate_extent_block(mp,\n\t\t\t\t\t\ttp, bbno + j, minlen, maxlen,\n\t\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If it works, return the extent.\n\t\t\t\t\t */\n\t\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t\t*rtblock = r;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * There weren't intervening bitmap blocks\n\t\t\t\t * with a long enough extent, or the\n\t\t\t\t * allocation didn't work for some reason\n\t\t\t\t * (i.e. it's a little * too short).\n\t\t\t\t * Try to allocate from the summary block\n\t\t\t\t * that we found.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it works, return the extent.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Loop control.  If we were on the positive side, and there's\n\t\t * still more blocks on the negative side, go there.\n\t\t */\n\t\tif (i > 0 && (int)bbno - i >= 0)\n\t\t\ti = -i;\n\t\t/*\n\t\t * If positive, and no more negative, but there are more\n\t\t * positive, go there.\n\t\t */\n\t\telse if (i > 0 && (int)bbno + i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti++;\n\t\t/*\n\t\t * If negative or 0 (just started), and there are positive\n\t\t * blocks to go, go there.  The 0 case moves to block 1.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno - i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti = 1 - i;\n\t\t/*\n\t\t * If negative or 0 and there are more negative blocks,\n\t\t * go there.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno + i > 0)\n\t\t\ti--;\n\t\t/*\n\t\t * Must be done.  Return failure.\n\t\t */\n\t\telse\n\t\t\tbreak;\n\t}\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_size",
          "args": [
            "mp",
            "tp",
            "minlen",
            "maxlen",
            "len",
            "&sumbp",
            "&sb",
            "prod",
            "&r"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "616-755",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_size(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block number */\n\tint\t\tl;\t\t/* level number (loop control) */\n\txfs_rtblock_t\tn;\t\t/* next block to be tried */\n\txfs_rtblock_t\tr;\t\t/* result block number */\n\txfs_suminfo_t\tsum;\t\t/* summary information for extents */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over all the levels starting with maxlen.\n\t * At each level, look at all the bitmap blocks, to see if there\n\t * are extents starting there that are long enough (>= maxlen).\n\t * Note, only on the initial level can the allocation fail if\n\t * the summary says there's an extent.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l < mp->m_rsumlevels; l++) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary for this level/block.\n\t\t\t */\n\t\t\terror = xfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t&sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Nothing there, on to the next block.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try allocating the extent.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i, maxlen,\n\t\t\t\tmaxlen, len, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Didn't find any maxlen blocks.  Try smaller ones, unless\n\t * we're asking for a fixed size extent.\n\t */\n\tif (minlen > --maxlen) {\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\tASSERT(minlen != 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over sizes, from maxlen down to minlen.\n\t * This time, when we do the allocations, allow smaller ones\n\t * to succeed.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l >= xfs_highbit32(minlen); l--) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks, try an allocation\n\t\t * starting in that block.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary information for this level/block.\n\t\t\t */\n\t\t\terror =\txfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t\t\t  &sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If nothing there, go on to next.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try the allocation.  Make sure the specified\n\t\t\t * minlen/maxlen are in the possible range for\n\t\t\t * this summary level.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i,\n\t\t\t\t\tXFS_RTMAX(minlen, 1 << l),\n\t\t\t\t\tXFS_RTMIN(maxlen, (1 << (l + 1)) - 1),\n\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that extent.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Got nothing, return failure.\n\t */\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_size(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block number */\n\tint\t\tl;\t\t/* level number (loop control) */\n\txfs_rtblock_t\tn;\t\t/* next block to be tried */\n\txfs_rtblock_t\tr;\t\t/* result block number */\n\txfs_suminfo_t\tsum;\t\t/* summary information for extents */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over all the levels starting with maxlen.\n\t * At each level, look at all the bitmap blocks, to see if there\n\t * are extents starting there that are long enough (>= maxlen).\n\t * Note, only on the initial level can the allocation fail if\n\t * the summary says there's an extent.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l < mp->m_rsumlevels; l++) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary for this level/block.\n\t\t\t */\n\t\t\terror = xfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t&sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Nothing there, on to the next block.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try allocating the extent.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i, maxlen,\n\t\t\t\tmaxlen, len, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Didn't find any maxlen blocks.  Try smaller ones, unless\n\t * we're asking for a fixed size extent.\n\t */\n\tif (minlen > --maxlen) {\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\tASSERT(minlen != 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over sizes, from maxlen down to minlen.\n\t * This time, when we do the allocations, allow smaller ones\n\t * to succeed.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l >= xfs_highbit32(minlen); l--) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks, try an allocation\n\t\t * starting in that block.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary information for this level/block.\n\t\t\t */\n\t\t\terror =\txfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t\t\t  &sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If nothing there, go on to next.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try the allocation.  Make sure the specified\n\t\t\t * minlen/maxlen are in the possible range for\n\t\t\t * this summary level.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i,\n\t\t\t\t\tXFS_RTMAX(minlen, 1 << l),\n\t\t\t\t\tXFS_RTMIN(maxlen, (1 << (l + 1)) - 1),\n\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that extent.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Got nothing, return failure.\n\t */\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen > 0 && minlen <= maxlen"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtallocate_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_alloctype_t\ttype,\t\t/* allocation type XFS_ALLOCTYPE... */\n\tint\t\twasdel,\t\t/* was a delayed allocation extent */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tr;\t\t/* result allocated block */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp;\t\t/* summary file block buffer */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\tASSERT(minlen > 0 && minlen <= maxlen);\n\n\t/*\n\t * If prod is set then figure out what to do to minlen and maxlen.\n\t */\n\tif (prod > 1) {\n\t\txfs_extlen_t\ti;\n\n\t\tif ((i = maxlen % prod))\n\t\t\tmaxlen -= i;\n\t\tif ((i = minlen % prod))\n\t\t\tminlen += prod - i;\n\t\tif (maxlen < minlen) {\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsumbp = NULL;\n\t/*\n\t * Allocate by size, or near another block, or exactly at some block.\n\t */\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\t\terror = xfs_rtallocate_extent_size(mp, tp, minlen, maxlen, len,\n\t\t\t\t&sumbp,\t&sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_rtallocate_extent_near(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\tASSERT(0);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If it worked, update the superblock.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\tlong\tslen = (long)*len;\n\n\t\tASSERT(*len >= minlen && *len <= maxlen);\n\t\tif (wasdel)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RES_FREXTENTS, -slen);\n\t\telse\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, -slen);\n\t}\n\t*rtblock = r;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_growfs_rt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "884-1090",
    "snippet": "int\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "nmp"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_sb",
          "args": [
            "tp",
            "XFS_TRANS_SB_FREXTENTS",
            "nsbp->sb_rextents - sbp->sb_rextents"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "297-395",
          "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancelflags"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtfree_range",
          "args": [
            "nmp",
            "tp",
            "sbp->sb_rextents",
            "nsbp->sb_rextents - sbp->sb_rextents",
            "&bp",
            "&sumbno"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "671-741",
          "snippet": "int\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfree_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to free */\n\txfs_extlen_t\tlen,\t\t/* length to free */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the freed extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock;\t/* first block freed > end */\n\txfs_rtblock_t\tpreblock;\t/* first block freed < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Modify the bitmap to mark this extent freed.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 1);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Assume we're freeing out of the middle of an allocated extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of allocated extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If there are blocks not being freed at the front of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being freed at the end of the\n\t * old extent, add summary data for them to be allocated.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), -1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Increment the summary information corresponding to the entire\n\t * (new) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtcopy_summary",
          "args": [
            "mp",
            "nmp",
            "tp"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtcopy_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "109-145",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtcopy_summary(\n\txfs_mount_t\t*omp,\t\t/* old file system mount point */\n\txfs_mount_t\t*nmp,\t\t/* new file system mount point */\n\txfs_trans_t\t*tp)\t\t/* transaction pointer */\n{\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* summary buffer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\tlog;\t\t/* summary level number (log length) */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tbp = NULL;\n\tfor (log = omp->m_rsumlevels - 1; log >= 0; log--) {\n\t\tfor (bbno = omp->m_sb.sb_rbmblocks - 1;\n\t\t     (xfs_srtblock_t)bbno >= 0;\n\t\t     bbno--) {\n\t\t\terror = xfs_rtget_summary(omp, tp, log, bbno, &bp,\n\t\t\t\t&sumbno, &sum);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (sum == 0)\n\t\t\t\tcontinue;\n\t\t\terror = xfs_rtmodify_summary(omp, tp, log, bbno, -sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_rtmodify_summary(nmp, tp, log, bbno, sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(sum > 0);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtcopy_summary(\n\txfs_mount_t\t*omp,\t\t/* old file system mount point */\n\txfs_mount_t\t*nmp,\t\t/* new file system mount point */\n\txfs_trans_t\t*tp)\t\t/* transaction pointer */\n{\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* summary buffer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\tlog;\t\t/* summary level number (log length) */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tbp = NULL;\n\tfor (log = omp->m_rsumlevels - 1; log >= 0; log--) {\n\t\tfor (bbno = omp->m_sb.sb_rbmblocks - 1;\n\t\t     (xfs_srtblock_t)bbno >= 0;\n\t\t     bbno--) {\n\t\t\terror = xfs_rtget_summary(omp, tp, log, bbno, &bp,\n\t\t\t\t&sumbno, &sum);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (sum == 0)\n\t\t\t\tcontinue;\n\t\t\terror = xfs_rtmodify_summary(omp, tp, log, bbno, -sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_rtmodify_summary(nmp, tp, log, bbno, sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(sum > 0);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "mp->m_rsumip",
            "XFS_ILOG_CORE"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "mp->m_rsumip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "mp->m_rsumip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_growrtfree",
            "0",
            "0"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_GROWFSRT_FREE"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "nrsumblocks"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "nrsumsize"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_highbit32",
          "args": [
            "nsbp->sb_rextents"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_highbit32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "42-45",
          "snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nsbp->sb_rextents != 0"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nsbp->sb_rextents",
            "nsbp->sb_rextsize"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMIN",
          "args": [
            "nrblocks",
            "nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(*nmp)",
            "KM_SLEEP"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_rt_alloc",
          "args": [
            "mp",
            "rsumblocks",
            "nrsumblocks",
            "mp->m_rsumip"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_rt_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "760-875",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_growfs_rt_alloc(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_extlen_t\toblocks,\t/* old count of blocks */\n\txfs_extlen_t\tnblocks,\t/* new count of blocks */\n\txfs_inode_t\t*ip)\t\t/* inode (bitmap/summary) */\n{\n\txfs_fileoff_t\tbno;\t\t/* block number in file */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer for zeroing */\n\tint\t\tcommitted;\t/* transaction committed flag */\n\txfs_daddr_t\td;\t\t/* disk block address */\n\tint\t\terror;\t\t/* error return value */\n\txfs_fsblock_t\tfirstblock;\t/* first block allocated in xaction */\n\txfs_bmap_free_t\tflist;\t\t/* list of freed blocks */\n\txfs_fsblock_t\tfsbno;\t\t/* filesystem block for bno */\n\txfs_bmbt_irec_t\tmap;\t\t/* block map output */\n\tint\t\tnmap;\t\t/* number of block maps */\n\tint\t\tresblks;\t/* space reservation */\n\n\t/*\n\t * Allocate space to the file, as necessary.\n\t */\n\twhile (oblocks < nblocks) {\n\t\tint\t\tcancelflags = 0;\n\t\txfs_trans_t\t*tp;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ALLOC);\n\t\tresblks = XFS_GROWFSRT_SPACE_RES(mp, nblocks - oblocks);\n\t\t/*\n\t\t * Reserve space & log for one extent added to the file.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtalloc,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t\t/*\n\t\t * Lock the inode.\n\t\t */\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\t/*\n\t\t * Allocate blocks to the bitmap file.\n\t\t */\n\t\tnmap = 1;\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\terror = xfs_bmapi_write(tp, ip, oblocks, nblocks - oblocks,\n\t\t\t\t\tXFS_BMAPI_METADATA, &firstblock,\n\t\t\t\t\tresblks, &map, &nmap, &flist);\n\t\tif (!error && nmap < 1)\n\t\t\terror = -ENOSPC;\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Free any blocks freed up in the transaction, then commit.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error;\n\t\t/*\n\t\t * Now we need to clear the allocated blocks.\n\t\t * Do this one block per transaction, to keep it simple.\n\t\t */\n\t\tcancelflags = 0;\n\t\tfor (bno = map.br_startoff, fsbno = map.br_startblock;\n\t\t     bno < map.br_startoff + map.br_blockcount;\n\t\t     bno++, fsbno++) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ZERO);\n\t\t\t/*\n\t\t\t * Reserve log for one block zeroing.\n\t\t\t */\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtzero,\n\t\t\t\t\t\t  0, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t\t/*\n\t\t\t * Lock the bitmap inode.\n\t\t\t */\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\t\t\t/*\n\t\t\t * Get a buffer for the block.\n\t\t\t */\n\t\t\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\tmp->m_bsize, 0);\n\t\t\tif (bp == NULL) {\n\t\t\t\terror = -EIO;\nerror_cancel:\n\t\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset(bp->b_addr, 0, mp->m_sb.sb_blocksize);\n\t\t\txfs_trans_log_buf(tp, bp, 0, mp->m_sb.sb_blocksize - 1);\n\t\t\t/*\n\t\t\t * Commit the transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_commit(tp, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * Go on to the next extent, if any.\n\t\t */\n\t\toblocks = map.br_startoff + map.br_blockcount;\n\t}\n\treturn 0;\n\nerror:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_growfs_rt_alloc(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_extlen_t\toblocks,\t/* old count of blocks */\n\txfs_extlen_t\tnblocks,\t/* new count of blocks */\n\txfs_inode_t\t*ip)\t\t/* inode (bitmap/summary) */\n{\n\txfs_fileoff_t\tbno;\t\t/* block number in file */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer for zeroing */\n\tint\t\tcommitted;\t/* transaction committed flag */\n\txfs_daddr_t\td;\t\t/* disk block address */\n\tint\t\terror;\t\t/* error return value */\n\txfs_fsblock_t\tfirstblock;\t/* first block allocated in xaction */\n\txfs_bmap_free_t\tflist;\t\t/* list of freed blocks */\n\txfs_fsblock_t\tfsbno;\t\t/* filesystem block for bno */\n\txfs_bmbt_irec_t\tmap;\t\t/* block map output */\n\tint\t\tnmap;\t\t/* number of block maps */\n\tint\t\tresblks;\t/* space reservation */\n\n\t/*\n\t * Allocate space to the file, as necessary.\n\t */\n\twhile (oblocks < nblocks) {\n\t\tint\t\tcancelflags = 0;\n\t\txfs_trans_t\t*tp;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ALLOC);\n\t\tresblks = XFS_GROWFSRT_SPACE_RES(mp, nblocks - oblocks);\n\t\t/*\n\t\t * Reserve space & log for one extent added to the file.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtalloc,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t\t/*\n\t\t * Lock the inode.\n\t\t */\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\t/*\n\t\t * Allocate blocks to the bitmap file.\n\t\t */\n\t\tnmap = 1;\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\terror = xfs_bmapi_write(tp, ip, oblocks, nblocks - oblocks,\n\t\t\t\t\tXFS_BMAPI_METADATA, &firstblock,\n\t\t\t\t\tresblks, &map, &nmap, &flist);\n\t\tif (!error && nmap < 1)\n\t\t\terror = -ENOSPC;\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Free any blocks freed up in the transaction, then commit.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error;\n\t\t/*\n\t\t * Now we need to clear the allocated blocks.\n\t\t * Do this one block per transaction, to keep it simple.\n\t\t */\n\t\tcancelflags = 0;\n\t\tfor (bno = map.br_startoff, fsbno = map.br_startblock;\n\t\t     bno < map.br_startoff + map.br_blockcount;\n\t\t     bno++, fsbno++) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ZERO);\n\t\t\t/*\n\t\t\t * Reserve log for one block zeroing.\n\t\t\t */\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtzero,\n\t\t\t\t\t\t  0, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t\t/*\n\t\t\t * Lock the bitmap inode.\n\t\t\t */\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\t\t\t/*\n\t\t\t * Get a buffer for the block.\n\t\t\t */\n\t\t\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\tmp->m_bsize, 0);\n\t\t\tif (bp == NULL) {\n\t\t\t\terror = -EIO;\nerror_cancel:\n\t\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset(bp->b_addr, 0, mp->m_sb.sb_blocksize);\n\t\t\txfs_trans_log_buf(tp, bp, 0, mp->m_sb.sb_blocksize - 1);\n\t\t\t/*\n\t\t\t * Commit the transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_commit(tp, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * Go on to the next extent, if any.\n\t\t */\n\t\toblocks = map.br_startoff + map.br_blockcount;\n\t}\n\treturn 0;\n\nerror:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "mp->m_rsumip->i_d.di_size"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "mp->m_rbmip->i_d.di_size"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "nrsumblocks"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "nrsumsize"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany_64",
          "args": [
            "nrextents",
            "NBBY * sbp->sb_blocksize"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "howmany_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "340-345",
          "snippet": "static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "nrextents",
            "in->extsize"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "mp->m_rtdev_targp",
            "XFS_FSB_TO_BB(mp, nrblocks - 1)",
            "XFS_FSB_TO_BB(mp, 1)",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "nrblocks - 1"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_validate_fsb_count",
          "args": [
            "sbp",
            "nrblocks"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_validate_fsb_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "167-179",
          "snippet": "int\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_growfs_rt_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "760-875",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_growfs_rt_alloc(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_extlen_t\toblocks,\t/* old count of blocks */\n\txfs_extlen_t\tnblocks,\t/* new count of blocks */\n\txfs_inode_t\t*ip)\t\t/* inode (bitmap/summary) */\n{\n\txfs_fileoff_t\tbno;\t\t/* block number in file */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer for zeroing */\n\tint\t\tcommitted;\t/* transaction committed flag */\n\txfs_daddr_t\td;\t\t/* disk block address */\n\tint\t\terror;\t\t/* error return value */\n\txfs_fsblock_t\tfirstblock;\t/* first block allocated in xaction */\n\txfs_bmap_free_t\tflist;\t\t/* list of freed blocks */\n\txfs_fsblock_t\tfsbno;\t\t/* filesystem block for bno */\n\txfs_bmbt_irec_t\tmap;\t\t/* block map output */\n\tint\t\tnmap;\t\t/* number of block maps */\n\tint\t\tresblks;\t/* space reservation */\n\n\t/*\n\t * Allocate space to the file, as necessary.\n\t */\n\twhile (oblocks < nblocks) {\n\t\tint\t\tcancelflags = 0;\n\t\txfs_trans_t\t*tp;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ALLOC);\n\t\tresblks = XFS_GROWFSRT_SPACE_RES(mp, nblocks - oblocks);\n\t\t/*\n\t\t * Reserve space & log for one extent added to the file.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtalloc,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t\t/*\n\t\t * Lock the inode.\n\t\t */\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\t/*\n\t\t * Allocate blocks to the bitmap file.\n\t\t */\n\t\tnmap = 1;\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\terror = xfs_bmapi_write(tp, ip, oblocks, nblocks - oblocks,\n\t\t\t\t\tXFS_BMAPI_METADATA, &firstblock,\n\t\t\t\t\tresblks, &map, &nmap, &flist);\n\t\tif (!error && nmap < 1)\n\t\t\terror = -ENOSPC;\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Free any blocks freed up in the transaction, then commit.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error;\n\t\t/*\n\t\t * Now we need to clear the allocated blocks.\n\t\t * Do this one block per transaction, to keep it simple.\n\t\t */\n\t\tcancelflags = 0;\n\t\tfor (bno = map.br_startoff, fsbno = map.br_startblock;\n\t\t     bno < map.br_startoff + map.br_blockcount;\n\t\t     bno++, fsbno++) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ZERO);\n\t\t\t/*\n\t\t\t * Reserve log for one block zeroing.\n\t\t\t */\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtzero,\n\t\t\t\t\t\t  0, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t\t/*\n\t\t\t * Lock the bitmap inode.\n\t\t\t */\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\t\t\t/*\n\t\t\t * Get a buffer for the block.\n\t\t\t */\n\t\t\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\tmp->m_bsize, 0);\n\t\t\tif (bp == NULL) {\n\t\t\t\terror = -EIO;\nerror_cancel:\n\t\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset(bp->b_addr, 0, mp->m_sb.sb_blocksize);\n\t\t\txfs_trans_log_buf(tp, bp, 0, mp->m_sb.sb_blocksize - 1);\n\t\t\t/*\n\t\t\t * Commit the transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_commit(tp, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * Go on to the next extent, if any.\n\t\t */\n\t\toblocks = map.br_startoff + map.br_blockcount;\n\t}\n\treturn 0;\n\nerror:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "mp->m_sb.sb_blocksize - 1"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_addr",
            "0",
            "mp->m_sb.sb_blocksize"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancelflags"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "d",
            "mp->m_bsize",
            "0"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "fsbno"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_growrtzero",
            "0",
            "0"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_GROWFSRT_ZERO"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&flist",
            "&committed"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "tp",
            "ip",
            "oblocks",
            "nblocks - oblocks",
            "XFS_BMAPI_METADATA",
            "&firstblock",
            "resblks",
            "&map",
            "&nmap",
            "&flist"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&flist",
            "&firstblock"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_GROWFSRT_SPACE_RES",
          "args": [
            "mp",
            "nblocks - oblocks"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_growfs_rt_alloc(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_extlen_t\toblocks,\t/* old count of blocks */\n\txfs_extlen_t\tnblocks,\t/* new count of blocks */\n\txfs_inode_t\t*ip)\t\t/* inode (bitmap/summary) */\n{\n\txfs_fileoff_t\tbno;\t\t/* block number in file */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer for zeroing */\n\tint\t\tcommitted;\t/* transaction committed flag */\n\txfs_daddr_t\td;\t\t/* disk block address */\n\tint\t\terror;\t\t/* error return value */\n\txfs_fsblock_t\tfirstblock;\t/* first block allocated in xaction */\n\txfs_bmap_free_t\tflist;\t\t/* list of freed blocks */\n\txfs_fsblock_t\tfsbno;\t\t/* filesystem block for bno */\n\txfs_bmbt_irec_t\tmap;\t\t/* block map output */\n\tint\t\tnmap;\t\t/* number of block maps */\n\tint\t\tresblks;\t/* space reservation */\n\n\t/*\n\t * Allocate space to the file, as necessary.\n\t */\n\twhile (oblocks < nblocks) {\n\t\tint\t\tcancelflags = 0;\n\t\txfs_trans_t\t*tp;\n\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ALLOC);\n\t\tresblks = XFS_GROWFSRT_SPACE_RES(mp, nblocks - oblocks);\n\t\t/*\n\t\t * Reserve space & log for one extent added to the file.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtalloc,\n\t\t\t\t\t  resblks, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t\t/*\n\t\t * Lock the inode.\n\t\t */\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\t/*\n\t\t * Allocate blocks to the bitmap file.\n\t\t */\n\t\tnmap = 1;\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\terror = xfs_bmapi_write(tp, ip, oblocks, nblocks - oblocks,\n\t\t\t\t\tXFS_BMAPI_METADATA, &firstblock,\n\t\t\t\t\tresblks, &map, &nmap, &flist);\n\t\tif (!error && nmap < 1)\n\t\t\terror = -ENOSPC;\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Free any blocks freed up in the transaction, then commit.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error;\n\t\t/*\n\t\t * Now we need to clear the allocated blocks.\n\t\t * Do this one block per transaction, to keep it simple.\n\t\t */\n\t\tcancelflags = 0;\n\t\tfor (bno = map.br_startoff, fsbno = map.br_startblock;\n\t\t     bno < map.br_startoff + map.br_blockcount;\n\t\t     bno++, fsbno++) {\n\t\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_ZERO);\n\t\t\t/*\n\t\t\t * Reserve log for one block zeroing.\n\t\t\t */\n\t\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtzero,\n\t\t\t\t\t\t  0, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t\t/*\n\t\t\t * Lock the bitmap inode.\n\t\t\t */\n\t\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\t\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\t\t\t/*\n\t\t\t * Get a buffer for the block.\n\t\t\t */\n\t\t\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\tmp->m_bsize, 0);\n\t\t\tif (bp == NULL) {\n\t\t\t\terror = -EIO;\nerror_cancel:\n\t\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemset(bp->b_addr, 0, mp->m_sb.sb_blocksize);\n\t\t\txfs_trans_log_buf(tp, bp, 0, mp->m_sb.sb_blocksize - 1);\n\t\t\t/*\n\t\t\t * Commit the transaction.\n\t\t\t */\n\t\t\terror = xfs_trans_commit(tp, 0);\n\t\t\tif (error)\n\t\t\t\tgoto error;\n\t\t}\n\t\t/*\n\t\t * Go on to the next extent, if any.\n\t\t */\n\t\toblocks = map.br_startoff + map.br_blockcount;\n\t}\n\treturn 0;\n\nerror:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_rtallocate_extent_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "616-755",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_size(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block number */\n\tint\t\tl;\t\t/* level number (loop control) */\n\txfs_rtblock_t\tn;\t\t/* next block to be tried */\n\txfs_rtblock_t\tr;\t\t/* result block number */\n\txfs_suminfo_t\tsum;\t\t/* summary information for extents */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over all the levels starting with maxlen.\n\t * At each level, look at all the bitmap blocks, to see if there\n\t * are extents starting there that are long enough (>= maxlen).\n\t * Note, only on the initial level can the allocation fail if\n\t * the summary says there's an extent.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l < mp->m_rsumlevels; l++) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary for this level/block.\n\t\t\t */\n\t\t\terror = xfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t&sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Nothing there, on to the next block.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try allocating the extent.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i, maxlen,\n\t\t\t\tmaxlen, len, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Didn't find any maxlen blocks.  Try smaller ones, unless\n\t * we're asking for a fixed size extent.\n\t */\n\tif (minlen > --maxlen) {\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\tASSERT(minlen != 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over sizes, from maxlen down to minlen.\n\t * This time, when we do the allocations, allow smaller ones\n\t * to succeed.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l >= xfs_highbit32(minlen); l--) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks, try an allocation\n\t\t * starting in that block.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary information for this level/block.\n\t\t\t */\n\t\t\terror =\txfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t\t\t  &sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If nothing there, go on to next.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try the allocation.  Make sure the specified\n\t\t\t * minlen/maxlen are in the possible range for\n\t\t\t * this summary level.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i,\n\t\t\t\t\tXFS_RTMAX(minlen, 1 << l),\n\t\t\t\t\tXFS_RTMIN(maxlen, (1 << (l + 1)) - 1),\n\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that extent.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Got nothing, return failure.\n\t */\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "n"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "n"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_block",
          "args": [
            "mp",
            "tp",
            "i",
            "XFS_RTMAX(minlen, 1 << l)",
            "XFS_RTMIN(maxlen, (1 << (l + 1)) - 1)",
            "len",
            "&n",
            "rbpp",
            "rsb",
            "prod",
            "&r"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "229-334",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_RTMIN",
          "args": [
            "maxlen",
            "(1 << (l + 1)) - 1"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTMAX",
          "args": [
            "minlen",
            "1 << l"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtget_summary",
          "args": [
            "mp",
            "tp",
            "l",
            "i",
            "rbpp",
            "rsb",
            "&sum"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtget_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "46-57",
          "snippet": "static int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_highbit32",
          "args": [
            "minlen"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_highbit32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "42-45",
          "snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "maxlen != 0"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen != 0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "n"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "n"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "maxlen != 0"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen % prod == 0 && maxlen % prod == 0"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_size(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block number */\n\tint\t\tl;\t\t/* level number (loop control) */\n\txfs_rtblock_t\tn;\t\t/* next block to be tried */\n\txfs_rtblock_t\tr;\t\t/* result block number */\n\txfs_suminfo_t\tsum;\t\t/* summary information for extents */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over all the levels starting with maxlen.\n\t * At each level, look at all the bitmap blocks, to see if there\n\t * are extents starting there that are long enough (>= maxlen).\n\t * Note, only on the initial level can the allocation fail if\n\t * the summary says there's an extent.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l < mp->m_rsumlevels; l++) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary for this level/block.\n\t\t\t */\n\t\t\terror = xfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t&sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Nothing there, on to the next block.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try allocating the extent.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i, maxlen,\n\t\t\t\tmaxlen, len, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Didn't find any maxlen blocks.  Try smaller ones, unless\n\t * we're asking for a fixed size extent.\n\t */\n\tif (minlen > --maxlen) {\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\tASSERT(minlen != 0);\n\tASSERT(maxlen != 0);\n\n\t/*\n\t * Loop over sizes, from maxlen down to minlen.\n\t * This time, when we do the allocations, allow smaller ones\n\t * to succeed.\n\t */\n\tfor (l = xfs_highbit32(maxlen); l >= xfs_highbit32(minlen); l--) {\n\t\t/*\n\t\t * Loop over all the bitmap blocks, try an allocation\n\t\t * starting in that block.\n\t\t */\n\t\tfor (i = 0; i < mp->m_sb.sb_rbmblocks; i++) {\n\t\t\t/*\n\t\t\t * Get the summary information for this level/block.\n\t\t\t */\n\t\t\terror =\txfs_rtget_summary(mp, tp, l, i, rbpp, rsb,\n\t\t\t\t\t\t  &sum);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If nothing there, go on to next.\n\t\t\t */\n\t\t\tif (!sum)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Try the allocation.  Make sure the specified\n\t\t\t * minlen/maxlen are in the possible range for\n\t\t\t * this summary level.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_extent_block(mp, tp, i,\n\t\t\t\t\tXFS_RTMAX(minlen, 1 << l),\n\t\t\t\t\tXFS_RTMIN(maxlen, (1 << (l + 1)) - 1),\n\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If it worked, return that extent.\n\t\t\t */\n\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t*rtblock = r;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If the \"next block to try\" returned from the\n\t\t\t * allocator is beyond the next bitmap block,\n\t\t\t * skip to that bitmap block.\n\t\t\t */\n\t\t\tif (XFS_BITTOBLOCK(mp, n) > i + 1)\n\t\t\t\ti = XFS_BITTOBLOCK(mp, n) - 1;\n\t\t}\n\t}\n\t/*\n\t * Got nothing, return failure.\n\t */\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtallocate_extent_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "421-609",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_near(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\tany;\t\t/* any useful extents from summary */\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block offset (loop control) */\n\tint\t\tj;\t\t/* secondary loop control */\n\tint\t\tlog2len;\t/* log2 of minlen */\n\txfs_rtblock_t\tn;\t\t/* next block to try */\n\txfs_rtblock_t\tr;\t\t/* result block */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * If the block number given is off the end, silently set it to\n\t * the last block.\n\t */\n\tif (bno >= mp->m_sb.sb_rextents)\n\t\tbno = mp->m_sb.sb_rextents - 1;\n\t/*\n\t * Try the exact allocation first.\n\t */\n\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen, len,\n\t\trbpp, rsb, prod, &r);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If the exact allocation worked, return that.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\t*rtblock = r;\n\t\treturn 0;\n\t}\n\tbbno = XFS_BITTOBLOCK(mp, bno);\n\ti = 0;\n\tASSERT(minlen != 0);\n\tlog2len = xfs_highbit32(minlen);\n\t/*\n\t * Loop over all bitmap blocks (bbno + i is current block).\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Get summary information of extents of all useful levels\n\t\t * starting in this bitmap block.\n\t\t */\n\t\terror = xfs_rtany_summary(mp, tp, log2len, mp->m_rsumlevels - 1,\n\t\t\tbbno + i, rbpp, rsb, &any);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any useful extents starting here, try\n\t\t * allocating one.\n\t\t */\n\t\tif (any) {\n\t\t\t/*\n\t\t\t * On the positive side of the starting location.\n\t\t\t */\n\t\t\tif (i >= 0) {\n\t\t\t\t/*\n\t\t\t\t * Try to allocate an extent starting in\n\t\t\t\t * this block.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it worked, return it.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * On the negative side of the starting location.\n\t\t\t */\n\t\t\telse {\t\t/* i < 0 */\n\t\t\t\t/*\n\t\t\t\t * Loop backwards through the bitmap blocks from\n\t\t\t\t * the starting point-1 up to where we are now.\n\t\t\t\t * There should be an extent which ends in this\n\t\t\t\t * bitmap block and is long enough.\n\t\t\t\t */\n\t\t\t\tfor (j = -1; j > i; j--) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Grab the summary information for\n\t\t\t\t\t * this bitmap block.\n\t\t\t\t\t */\n\t\t\t\t\terror = xfs_rtany_summary(mp, tp,\n\t\t\t\t\t\tlog2len, mp->m_rsumlevels - 1,\n\t\t\t\t\t\tbbno + j, rbpp, rsb, &any);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If there's no extent given in the\n\t\t\t\t\t * summary that means the extent we\n\t\t\t\t\t * found must carry over from an\n\t\t\t\t\t * earlier block.  If there is an\n\t\t\t\t\t * extent given, we've already tried\n\t\t\t\t\t * that allocation, don't do it again.\n\t\t\t\t\t */\n\t\t\t\t\tif (any)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\terror = xfs_rtallocate_extent_block(mp,\n\t\t\t\t\t\ttp, bbno + j, minlen, maxlen,\n\t\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If it works, return the extent.\n\t\t\t\t\t */\n\t\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t\t*rtblock = r;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * There weren't intervening bitmap blocks\n\t\t\t\t * with a long enough extent, or the\n\t\t\t\t * allocation didn't work for some reason\n\t\t\t\t * (i.e. it's a little * too short).\n\t\t\t\t * Try to allocate from the summary block\n\t\t\t\t * that we found.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it works, return the extent.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Loop control.  If we were on the positive side, and there's\n\t\t * still more blocks on the negative side, go there.\n\t\t */\n\t\tif (i > 0 && (int)bbno - i >= 0)\n\t\t\ti = -i;\n\t\t/*\n\t\t * If positive, and no more negative, but there are more\n\t\t * positive, go there.\n\t\t */\n\t\telse if (i > 0 && (int)bbno + i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti++;\n\t\t/*\n\t\t * If negative or 0 (just started), and there are positive\n\t\t * blocks to go, go there.  The 0 case moves to block 1.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno - i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti = 1 - i;\n\t\t/*\n\t\t * If negative or 0 and there are more negative blocks,\n\t\t * go there.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno + i > 0)\n\t\t\ti--;\n\t\t/*\n\t\t * Must be done.  Return failure.\n\t\t */\n\t\telse\n\t\t\tbreak;\n\t}\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_block",
          "args": [
            "mp",
            "tp",
            "bbno + i",
            "minlen",
            "maxlen",
            "len",
            "&n",
            "rbpp",
            "rsb",
            "prod",
            "&r"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "229-334",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtany_summary",
          "args": [
            "mp",
            "tp",
            "log2len",
            "mp->m_rsumlevels - 1",
            "bbno + j",
            "rbpp",
            "rsb",
            "&any"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtany_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "63-102",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtany_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlow,\t\t/* low log2 extent size */\n\tint\t\thigh,\t\t/* high log2 extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\tint\t\t*stat)\t\t/* out: any good extents here? */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\tlog;\t\t/* loop counter, log2 of ext. size */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\n\t/*\n\t * Loop over logs of extent sizes.  Order is irrelevant.\n\t */\n\tfor (log = low; log <= high; log++) {\n\t\t/*\n\t\t * Get one summary datum.\n\t\t */\n\t\terror = xfs_rtget_summary(mp, tp, log, bbno, rbpp, rsb, &sum);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any, return success.\n\t\t */\n\t\tif (sum) {\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Found nothing, return failure.\n\t */\n\t*stat = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtany_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlow,\t\t/* low log2 extent size */\n\tint\t\thigh,\t\t/* high log2 extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\tint\t\t*stat)\t\t/* out: any good extents here? */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\tlog;\t\t/* loop counter, log2 of ext. size */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\n\t/*\n\t * Loop over logs of extent sizes.  Order is irrelevant.\n\t */\n\tfor (log = low; log <= high; log++) {\n\t\t/*\n\t\t * Get one summary datum.\n\t\t */\n\t\terror = xfs_rtget_summary(mp, tp, log, bbno, rbpp, rsb, &sum);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any, return success.\n\t\t */\n\t\tif (sum) {\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Found nothing, return failure.\n\t */\n\t*stat = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_highbit32",
          "args": [
            "minlen"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_highbit32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "42-45",
          "snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen != 0"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "bno"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent_exact",
          "args": [
            "mp",
            "tp",
            "bno",
            "minlen",
            "maxlen",
            "len",
            "rbpp",
            "rsb",
            "prod",
            "&r"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "342-414",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen % prod == 0 && maxlen % prod == 0"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_near(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\tany;\t\t/* any useful extents from summary */\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\tint\t\terror;\t\t/* error value */\n\tint\t\ti;\t\t/* bitmap block offset (loop control) */\n\tint\t\tj;\t\t/* secondary loop control */\n\tint\t\tlog2len;\t/* log2 of minlen */\n\txfs_rtblock_t\tn;\t\t/* next block to try */\n\txfs_rtblock_t\tr;\t\t/* result block */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * If the block number given is off the end, silently set it to\n\t * the last block.\n\t */\n\tif (bno >= mp->m_sb.sb_rextents)\n\t\tbno = mp->m_sb.sb_rextents - 1;\n\t/*\n\t * Try the exact allocation first.\n\t */\n\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen, len,\n\t\trbpp, rsb, prod, &r);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If the exact allocation worked, return that.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\t*rtblock = r;\n\t\treturn 0;\n\t}\n\tbbno = XFS_BITTOBLOCK(mp, bno);\n\ti = 0;\n\tASSERT(minlen != 0);\n\tlog2len = xfs_highbit32(minlen);\n\t/*\n\t * Loop over all bitmap blocks (bbno + i is current block).\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Get summary information of extents of all useful levels\n\t\t * starting in this bitmap block.\n\t\t */\n\t\terror = xfs_rtany_summary(mp, tp, log2len, mp->m_rsumlevels - 1,\n\t\t\tbbno + i, rbpp, rsb, &any);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any useful extents starting here, try\n\t\t * allocating one.\n\t\t */\n\t\tif (any) {\n\t\t\t/*\n\t\t\t * On the positive side of the starting location.\n\t\t\t */\n\t\t\tif (i >= 0) {\n\t\t\t\t/*\n\t\t\t\t * Try to allocate an extent starting in\n\t\t\t\t * this block.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it worked, return it.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * On the negative side of the starting location.\n\t\t\t */\n\t\t\telse {\t\t/* i < 0 */\n\t\t\t\t/*\n\t\t\t\t * Loop backwards through the bitmap blocks from\n\t\t\t\t * the starting point-1 up to where we are now.\n\t\t\t\t * There should be an extent which ends in this\n\t\t\t\t * bitmap block and is long enough.\n\t\t\t\t */\n\t\t\t\tfor (j = -1; j > i; j--) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Grab the summary information for\n\t\t\t\t\t * this bitmap block.\n\t\t\t\t\t */\n\t\t\t\t\terror = xfs_rtany_summary(mp, tp,\n\t\t\t\t\t\tlog2len, mp->m_rsumlevels - 1,\n\t\t\t\t\t\tbbno + j, rbpp, rsb, &any);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If there's no extent given in the\n\t\t\t\t\t * summary that means the extent we\n\t\t\t\t\t * found must carry over from an\n\t\t\t\t\t * earlier block.  If there is an\n\t\t\t\t\t * extent given, we've already tried\n\t\t\t\t\t * that allocation, don't do it again.\n\t\t\t\t\t */\n\t\t\t\t\tif (any)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\terror = xfs_rtallocate_extent_block(mp,\n\t\t\t\t\t\ttp, bbno + j, minlen, maxlen,\n\t\t\t\t\t\tlen, &n, rbpp, rsb, prod, &r);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treturn error;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If it works, return the extent.\n\t\t\t\t\t */\n\t\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t\t*rtblock = r;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * There weren't intervening bitmap blocks\n\t\t\t\t * with a long enough extent, or the\n\t\t\t\t * allocation didn't work for some reason\n\t\t\t\t * (i.e. it's a little * too short).\n\t\t\t\t * Try to allocate from the summary block\n\t\t\t\t * that we found.\n\t\t\t\t */\n\t\t\t\terror = xfs_rtallocate_extent_block(mp, tp,\n\t\t\t\t\tbbno + i, minlen, maxlen, len, &n, rbpp,\n\t\t\t\t\trsb, prod, &r);\n\t\t\t\tif (error) {\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If it works, return the extent.\n\t\t\t\t */\n\t\t\t\tif (r != NULLRTBLOCK) {\n\t\t\t\t\t*rtblock = r;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Loop control.  If we were on the positive side, and there's\n\t\t * still more blocks on the negative side, go there.\n\t\t */\n\t\tif (i > 0 && (int)bbno - i >= 0)\n\t\t\ti = -i;\n\t\t/*\n\t\t * If positive, and no more negative, but there are more\n\t\t * positive, go there.\n\t\t */\n\t\telse if (i > 0 && (int)bbno + i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti++;\n\t\t/*\n\t\t * If negative or 0 (just started), and there are positive\n\t\t * blocks to go, go there.  The 0 case moves to block 1.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno - i < mp->m_sb.sb_rbmblocks - 1)\n\t\t\ti = 1 - i;\n\t\t/*\n\t\t * If negative or 0 and there are more negative blocks,\n\t\t * go there.\n\t\t */\n\t\telse if (i <= 0 && (int)bbno + i > 0)\n\t\t\ti--;\n\t\t/*\n\t\t * Must be done.  Return failure.\n\t\t */\n\t\telse\n\t\t\tbreak;\n\t}\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtallocate_extent_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "342-414",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtallocate_range",
          "args": [
            "mp",
            "tp",
            "bno",
            "maxlen",
            "rbpp",
            "rsb"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "150-221",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtcheck_range",
          "args": [
            "mp",
            "tp",
            "bno",
            "maxlen",
            "1",
            "&next",
            "&isfree"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtcheck_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "747-917",
          "snippet": "int\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "minlen % prod == 0 && maxlen % prod == 0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_exact(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_extlen_t\ti;\t\t/* extent length trimmed due to prod */\n\tint\t\tisfree;\t\t/* extent is free */\n\txfs_rtblock_t\tnext;\t\t/* next block to try (dummy) */\n\n\tASSERT(minlen % prod == 0 && maxlen % prod == 0);\n\t/*\n\t * Check if the range in question (for maxlen) is free.\n\t */\n\terror = xfs_rtcheck_range(mp, tp, bno, maxlen, 1, &next, &isfree);\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (isfree) {\n\t\t/*\n\t\t * If it is, allocate it and return success.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = maxlen;\n\t\t*rtblock = bno;\n\t\treturn 0;\n\t}\n\t/*\n\t * If not, allocate what there is, if it's at least minlen.\n\t */\n\tmaxlen = next - bno;\n\tif (maxlen < minlen) {\n\t\t/*\n\t\t * Failed, return failure status.\n\t\t */\n\t\t*rtblock = NULLRTBLOCK;\n\t\treturn 0;\n\t}\n\t/*\n\t * Trim off tail of extent, if prod is specified.\n\t */\n\tif (prod > 1 && (i = maxlen % prod)) {\n\t\tmaxlen -= i;\n\t\tif (maxlen < minlen) {\n\t\t\t/*\n\t\t\t * Now we can't do it, return failure status.\n\t\t\t */\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Allocate what we can and return it.\n\t */\n\terror = xfs_rtallocate_range(mp, tp, bno, maxlen, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*len = maxlen;\n\t*rtblock = bno;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtallocate_extent_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "229-334",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtallocate_range",
          "args": [
            "mp",
            "tp",
            "besti",
            "bestlen",
            "rbpp",
            "rsb"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "150-221",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "bestlen",
            "prod"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtfind_forw",
          "args": [
            "mp",
            "tp",
            "next",
            "end",
            "&i"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfind_forw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "257-421",
          "snippet": "int\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtcheck_range",
          "args": [
            "mp",
            "tp",
            "i",
            "maxlen",
            "1",
            "&next",
            "&stat"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtcheck_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "747-917",
          "snippet": "int\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtcheck_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block number of extent */\n\txfs_extlen_t\tlen,\t\t/* length of extent */\n\tint\t\tval,\t\t/* 1 for free, 0 for allocated */\n\txfs_rtblock_t\t*new,\t\t/* out: first block not matching */\n\tint\t\t*stat)\t\t/* out: 1 for matches, 0 for not */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zero's; 1 (free) => all one's.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not examined.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ val)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Mask of relevant bits.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ val) & mask)) {\n\t\t\t/*\n\t\t\t * Different, compute first wrong bit and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*new = start + i;\n\t\t\t*stat = 0;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * Successful, return.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*new = start + i;\n\t*stat = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKTOBIT",
          "args": [
            "mp",
            "bbno + 1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BLOCKTOBIT",
          "args": [
            "mp",
            "bbno"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_extent_block(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_rtblock_t\t*nextp,\t\t/* out: next block to try */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_rtblock_t\tbesti;\t\t/* best rtblock found so far */\n\txfs_rtblock_t\tbestlen;\t/* best length found so far */\n\txfs_rtblock_t\tend;\t\t/* last rtblock in chunk */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current rtblock trying */\n\txfs_rtblock_t\tnext;\t\t/* next rtblock to try */\n\tint\t\tstat;\t\t/* status from internal calls */\n\n\t/*\n\t * Loop over all the extents starting in this bitmap block,\n\t * looking for one that's long enough.\n\t */\n\tfor (i = XFS_BLOCKTOBIT(mp, bbno), besti = -1, bestlen = 0,\n\t\tend = XFS_BLOCKTOBIT(mp, bbno + 1) - 1;\n\t     i <= end;\n\t     i++) {\n\t\t/*\n\t\t * See if there's a free extent of maxlen starting at i.\n\t\t * If it's not so then next will contain the first non-free.\n\t\t */\n\t\terror = xfs_rtcheck_range(mp, tp, i, maxlen, 1, &next, &stat);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\tif (stat) {\n\t\t\t/*\n\t\t\t * i for maxlen is all free, allocate and return that.\n\t\t\t */\n\t\t\terror = xfs_rtallocate_range(mp, tp, i, maxlen, rbpp,\n\t\t\t\trsb);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t*len = maxlen;\n\t\t\t*rtblock = i;\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * In the case where we have a variable-sized allocation\n\t\t * request, figure out how big this free piece is,\n\t\t * and if it's big enough for the minimum, and the best\n\t\t * so far, remember it.\n\t\t */\n\t\tif (minlen < maxlen) {\n\t\t\txfs_rtblock_t\tthislen;\t/* this extent size */\n\n\t\t\tthislen = next - i;\n\t\t\tif (thislen >= minlen && thislen > bestlen) {\n\t\t\t\tbesti = i;\n\t\t\t\tbestlen = thislen;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * If not done yet, find the start of the next free space.\n\t\t */\n\t\tif (next < end) {\n\t\t\terror = xfs_rtfind_forw(mp, tp, next, end, &i);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\t/*\n\t * Searched the whole thing & didn't find a maxlen free extent.\n\t */\n\tif (minlen < maxlen && besti != -1) {\n\t\txfs_extlen_t\tp;\t/* amount to trim length by */\n\n\t\t/*\n\t\t * If size should be a multiple of prod, make that so.\n\t\t */\n\t\tif (prod > 1 && (p = do_mod(bestlen, prod)))\n\t\t\tbestlen -= p;\n\t\t/*\n\t\t * Allocate besti for bestlen & return that.\n\t\t */\n\t\terror = xfs_rtallocate_range(mp, tp, besti, bestlen, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t*len = bestlen;\n\t\t*rtblock = besti;\n\t\treturn 0;\n\t}\n\t/*\n\t * Allocation failed.  Set *nextp to the next block to try.\n\t */\n\t*nextp = next;\n\t*rtblock = NULLRTBLOCK;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtallocate_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "150-221",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtmodify_range",
          "args": [
            "mp",
            "tp",
            "start",
            "len",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "514-665",
          "snippet": "int\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to modify */\n\txfs_extlen_t\tlen,\t\t/* length of extent to modify */\n\tint\t\tval)\t\t/* 1 for free, 0 for allocated */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtword_t\t*first;\t\t/* first used word in the buffer */\n\tint\t\ti;\t\t/* current bit number rel. to start */\n\tint\t\tlastbit;\t/* last useful bit in word */\n\txfs_rtword_t\tmask;\t\t/* mask o frelevant bits for value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute starting bitmap block number.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\t/*\n\t * Read the bitmap block, and point to its data.\n\t */\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Compute the starting word's address, and starting bit.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tfirst = b = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\t/*\n\t * 0 (allocated) => all zeroes; 1 (free) => all ones.\n\t */\n\tval = -val;\n\t/*\n\t * If not starting on a word boundary, deal with the first\n\t * (partial) word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Compute first bit not changed and mask of relevant bits.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Set the word value correctly.\n\t\t */\n\t\t*b = val;\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to the next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * Log the changed part of this block.\n\t\t\t * Get the next one.\n\t\t\t */\n\t\t\txfs_trans_log_buf(tp, bp,\n\t\t\t\t(uint)((char *)first - (char *)bufp),\n\t\t\t\t(uint)((char *)b - (char *)bufp));\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tfirst = b = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Compute a mask of relevant bits.\n\t\t */\n\t\tbit = 0;\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Set/clear the active bits.\n\t\t */\n\t\tif (val)\n\t\t\t*b |= mask;\n\t\telse\n\t\t\t*b &= ~mask;\n\t\tb++;\n\t}\n\t/*\n\t * Log any remaining changed bytes.\n\t */\n\tif (b > first)\n\t\txfs_trans_log_buf(tp, bp, (uint)((char *)first - (char *)bufp),\n\t\t\t(uint)((char *)b - (char *)bufp - 1));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtmodify_summary",
          "args": [
            "mp",
            "tp",
            "XFS_RTBLOCKLOG(postblock - end)",
            "XFS_BITTOBLOCK(mp, end + 1)",
            "1",
            "rbpp",
            "rsb"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "496-508",
          "snippet": "int\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "end + 1"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "postblock - end"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "preblock"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "start - preblock"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BITTOBLOCK",
          "args": [
            "mp",
            "preblock"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_RTBLOCKLOG",
          "args": [
            "postblock + 1 - preblock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtfind_forw",
          "args": [
            "mp",
            "tp",
            "end",
            "mp->m_sb.sb_rextents - 1",
            "&postblock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfind_forw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "257-421",
          "snippet": "int\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_forw(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlastbit;\t/* last useful bit in the word */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = limit - start + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit) {\n\t\t/*\n\t\t * Calculate last (rightmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tlastbit = XFS_RTMIN(bit + len, XFS_NBWORD);\n\t\tmask = (((xfs_rtword_t)1 << (lastbit - bit)) - 1) << bit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = XFS_RTLOBIT(wdiff) - bit;\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = lastbit - bit;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the next one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to next block if that's where the next word is\n\t\t * and we need the next word.\n\t\t */\n\t\tif (++word == XFS_BLOCKWSIZE(mp) && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the next one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, ++block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tb = bufp = bp->b_addr;\n\t\t\tword = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the next word in the buffer.\n\t\t\t */\n\t\t\tb++;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif ((lastbit = len - i)) {\n\t\t/*\n\t\t * Calculate mask for all the relevant bits in this word.\n\t\t */\n\t\tmask = ((xfs_rtword_t)1 << lastbit) - 1;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_RTLOBIT(wdiff);\n\t\t\t*rtblock = start + i - 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start + i - 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtfind_back",
          "args": [
            "mp",
            "tp",
            "start",
            "0",
            "&preblock"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfind_back",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "82-251",
          "snippet": "int\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtfind_back(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* starting block to look at */\n\txfs_rtblock_t\tlimit,\t\t/* last block to look at */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block found */\n{\n\txfs_rtword_t\t*b;\t\t/* current word in buffer */\n\tint\t\tbit;\t\t/* bit number in the word */\n\txfs_rtblock_t\tblock;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* buf for the block */\n\txfs_rtword_t\t*bufp;\t\t/* starting word in buffer */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tfirstbit;\t/* first useful bit in the word */\n\txfs_rtblock_t\ti;\t\t/* current bit number rel. to start */\n\txfs_rtblock_t\tlen;\t\t/* length of inspected area */\n\txfs_rtword_t\tmask;\t\t/* mask of relevant bits for value */\n\txfs_rtword_t\twant;\t\t/* mask for \"good\" values */\n\txfs_rtword_t\twdiff;\t\t/* difference from wanted value */\n\tint\t\tword;\t\t/* word number in the buffer */\n\n\t/*\n\t * Compute and read in starting bitmap block for starting block.\n\t */\n\tblock = XFS_BITTOBLOCK(mp, start);\n\terror = xfs_rtbuf_get(mp, tp, block, 0, &bp);\n\tif (error) {\n\t\treturn error;\n\t}\n\tbufp = bp->b_addr;\n\t/*\n\t * Get the first word's index & point to it.\n\t */\n\tword = XFS_BITTOWORD(mp, start);\n\tb = &bufp[word];\n\tbit = (int)(start & (XFS_NBWORD - 1));\n\tlen = start - limit + 1;\n\t/*\n\t * Compute match value, based on the bit at start: if 1 (free)\n\t * then all-ones, else all-zeroes.\n\t */\n\twant = (*b & ((xfs_rtword_t)1 << bit)) ? -1 : 0;\n\t/*\n\t * If the starting position is not word-aligned, deal with the\n\t * partial word.\n\t */\n\tif (bit < XFS_NBWORD - 1) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_RTMAX((xfs_srtblock_t)(bit - len + 1), 0);\n\t\tmask = (((xfs_rtword_t)1 << (bit - firstbit + 1)) - 1) <<\n\t\t\tfirstbit;\n\t\t/*\n\t\t * Calculate the difference between the value there\n\t\t * and what we're looking for.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different.  Mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti = bit - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti = bit - firstbit + 1;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Starting on a word boundary, no partial word.\n\t\t */\n\t\ti = 0;\n\t}\n\t/*\n\t * Loop over whole words in buffers.  When we use up one buffer\n\t * we move on to the previous one.\n\t */\n\twhile (len - i >= XFS_NBWORD) {\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = *b ^ want)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\ti += XFS_NBWORD;\n\t\t/*\n\t\t * Go on to previous block if that's where the previous word is\n\t\t * and we need the previous word.\n\t\t */\n\t\tif (--word == -1 && i < len) {\n\t\t\t/*\n\t\t\t * If done with this block, get the previous one.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\terror = xfs_rtbuf_get(mp, tp, --block, 0, &bp);\n\t\t\tif (error) {\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbufp = bp->b_addr;\n\t\t\tword = XFS_BLOCKWMASK(mp);\n\t\t\tb = &bufp[word];\n\t\t} else {\n\t\t\t/*\n\t\t\t * Go on to the previous word in the buffer.\n\t\t\t */\n\t\t\tb--;\n\t\t}\n\t}\n\t/*\n\t * If not ending on a word boundary, deal with the last\n\t * (partial) word.\n\t */\n\tif (len - i) {\n\t\t/*\n\t\t * Calculate first (leftmost) bit number to look at,\n\t\t * and mask for all the relevant bits in this word.\n\t\t */\n\t\tfirstbit = XFS_NBWORD - (len - i);\n\t\tmask = (((xfs_rtword_t)1 << (len - i)) - 1) << firstbit;\n\t\t/*\n\t\t * Compute difference between actual and desired value.\n\t\t */\n\t\tif ((wdiff = (*b ^ want) & mask)) {\n\t\t\t/*\n\t\t\t * Different, mark where we are and return.\n\t\t\t */\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\ti += XFS_NBWORD - 1 - XFS_RTHIBIT(wdiff);\n\t\t\t*rtblock = start - i + 1;\n\t\t\treturn 0;\n\t\t} else\n\t\t\ti = len;\n\t}\n\t/*\n\t * No match, return that we scanned the whole area.\n\t */\n\txfs_trans_brelse(tp, bp);\n\t*rtblock = start - i + 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtallocate_range(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tstart,\t\t/* start block to allocate */\n\txfs_extlen_t\tlen,\t\t/* length to allocate */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\txfs_rtblock_t\tend;\t\t/* end of the allocated extent */\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tpostblock = 0;\t/* first block allocated > end */\n\txfs_rtblock_t\tpreblock = 0;\t/* first block allocated < start */\n\n\tend = start + len - 1;\n\t/*\n\t * Assume we're allocating out of the middle of a free extent.\n\t * We need to find the beginning and end of the extent so we can\n\t * properly update the summary.\n\t */\n\terror = xfs_rtfind_back(mp, tp, start, 0, &preblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Find the next allocated block (end of free extent).\n\t */\n\terror = xfs_rtfind_forw(mp, tp, end, mp->m_sb.sb_rextents - 1,\n\t\t&postblock);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Decrement the summary information corresponding to the entire\n\t * (old) free extent.\n\t */\n\terror = xfs_rtmodify_summary(mp, tp,\n\t\tXFS_RTBLOCKLOG(postblock + 1 - preblock),\n\t\tXFS_BITTOBLOCK(mp, preblock), -1, rbpp, rsb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * If there are blocks not being allocated at the front of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (preblock < start) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(start - preblock),\n\t\t\tXFS_BITTOBLOCK(mp, preblock), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * If there are blocks not being allocated at the end of the\n\t * old extent, add summary data for them to be free.\n\t */\n\tif (postblock > end) {\n\t\terror = xfs_rtmodify_summary(mp, tp,\n\t\t\tXFS_RTBLOCKLOG(postblock - end),\n\t\t\tXFS_BITTOBLOCK(mp, end + 1), 1, rbpp, rsb);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n\t/*\n\t * Modify the bitmap to mark this extent allocated.\n\t */\n\terror = xfs_rtmodify_range(mp, tp, start, len, 0);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_rtcopy_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "109-145",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtcopy_summary(\n\txfs_mount_t\t*omp,\t\t/* old file system mount point */\n\txfs_mount_t\t*nmp,\t\t/* new file system mount point */\n\txfs_trans_t\t*tp)\t\t/* transaction pointer */\n{\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* summary buffer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\tlog;\t\t/* summary level number (log length) */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tbp = NULL;\n\tfor (log = omp->m_rsumlevels - 1; log >= 0; log--) {\n\t\tfor (bbno = omp->m_sb.sb_rbmblocks - 1;\n\t\t     (xfs_srtblock_t)bbno >= 0;\n\t\t     bbno--) {\n\t\t\terror = xfs_rtget_summary(omp, tp, log, bbno, &bp,\n\t\t\t\t&sumbno, &sum);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (sum == 0)\n\t\t\t\tcontinue;\n\t\t\terror = xfs_rtmodify_summary(omp, tp, log, bbno, -sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_rtmodify_summary(nmp, tp, log, bbno, sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(sum > 0);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sum > 0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtmodify_summary",
          "args": [
            "nmp",
            "tp",
            "log",
            "bbno",
            "sum",
            "&bp",
            "&sumbno"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "496-508",
          "snippet": "int\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb)\t\t/* in/out: summary block number */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno,\n\t\t\t\t\tdelta, rbpp, rsb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtget_summary",
          "args": [
            "omp",
            "tp",
            "log",
            "bbno",
            "&bp",
            "&sumbno",
            "&sum"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtget_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "46-57",
          "snippet": "static int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtcopy_summary(\n\txfs_mount_t\t*omp,\t\t/* old file system mount point */\n\txfs_mount_t\t*nmp,\t\t/* new file system mount point */\n\txfs_trans_t\t*tp)\t\t/* transaction pointer */\n{\n\txfs_rtblock_t\tbbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* summary buffer */\n\tint\t\terror;\t\t/* error return value */\n\tint\t\tlog;\t\t/* summary level number (log length) */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tbp = NULL;\n\tfor (log = omp->m_rsumlevels - 1; log >= 0; log--) {\n\t\tfor (bbno = omp->m_sb.sb_rbmblocks - 1;\n\t\t     (xfs_srtblock_t)bbno >= 0;\n\t\t     bbno--) {\n\t\t\terror = xfs_rtget_summary(omp, tp, log, bbno, &bp,\n\t\t\t\t&sumbno, &sum);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (sum == 0)\n\t\t\t\tcontinue;\n\t\t\terror = xfs_rtmodify_summary(omp, tp, log, bbno, -sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_rtmodify_summary(nmp, tp, log, bbno, sum,\n\t\t\t\t&bp, &sumbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(sum > 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtany_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "63-102",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_rtany_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlow,\t\t/* low log2 extent size */\n\tint\t\thigh,\t\t/* high log2 extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\tint\t\t*stat)\t\t/* out: any good extents here? */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\tlog;\t\t/* loop counter, log2 of ext. size */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\n\t/*\n\t * Loop over logs of extent sizes.  Order is irrelevant.\n\t */\n\tfor (log = low; log <= high; log++) {\n\t\t/*\n\t\t * Get one summary datum.\n\t\t */\n\t\terror = xfs_rtget_summary(mp, tp, log, bbno, rbpp, rsb, &sum);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any, return success.\n\t\t */\n\t\tif (sum) {\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Found nothing, return failure.\n\t */\n\t*stat = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtget_summary",
          "args": [
            "mp",
            "tp",
            "log",
            "bbno",
            "rbpp",
            "rsb",
            "&sum"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtget_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "46-57",
          "snippet": "static int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_rtany_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlow,\t\t/* low log2 extent size */\n\tint\t\thigh,\t\t/* high log2 extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\tint\t\t*stat)\t\t/* out: any good extents here? */\n{\n\tint\t\terror;\t\t/* error value */\n\tint\t\tlog;\t\t/* loop counter, log2 of ext. size */\n\txfs_suminfo_t\tsum;\t\t/* summary data */\n\n\t/*\n\t * Loop over logs of extent sizes.  Order is irrelevant.\n\t */\n\tfor (log = low; log <= high; log++) {\n\t\t/*\n\t\t * Get one summary datum.\n\t\t */\n\t\terror = xfs_rtget_summary(mp, tp, log, bbno, rbpp, rsb, &sum);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If there are any, return success.\n\t\t */\n\t\tif (sum) {\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * Found nothing, return failure.\n\t */\n\t*stat = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_rtget_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
    "lines": "46-57",
    "snippet": "static int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}",
    "includes": [
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_buf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rtmodify_summary_int",
          "args": [
            "mp",
            "tp",
            "log",
            "bbno",
            "0",
            "rbpp",
            "rsb",
            "sum"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtmodify_summary_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "432-494",
          "snippet": "int\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_rtmodify_summary_int(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\tint\t\tdelta,\t\t/* change to make to summary info */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\txfs_buf_t\t*bp;\t\t/* buffer for the summary block */\n\tint\t\terror;\t\t/* error value */\n\txfs_fsblock_t\tsb;\t\t/* summary fsblock */\n\tint\t\tso;\t\t/* index into the summary file */\n\txfs_suminfo_t\t*sp;\t\t/* pointer to returned data */\n\n\t/*\n\t * Compute entry number in the summary file.\n\t */\n\tso = XFS_SUMOFFS(mp, log, bbno);\n\t/*\n\t * Compute the block number in the summary file.\n\t */\n\tsb = XFS_SUMOFFSTOBLOCK(mp, so);\n\t/*\n\t * If we have an old buffer, and the block number matches, use that.\n\t */\n\tif (*rbpp && *rsb == sb)\n\t\tbp = *rbpp;\n\t/*\n\t * Otherwise we have to get the buffer.\n\t */\n\telse {\n\t\t/*\n\t\t * If there was an old one, get rid of it first.\n\t\t */\n\t\tif (*rbpp)\n\t\t\txfs_trans_brelse(tp, *rbpp);\n\t\terror = xfs_rtbuf_get(mp, tp, sb, 1, &bp);\n\t\tif (error) {\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Remember this buffer and block for the next call.\n\t\t */\n\t\t*rbpp = bp;\n\t\t*rsb = sb;\n\t}\n\t/*\n\t * Point to the summary information, modify/log it, and/or copy it out.\n\t */\n\tsp = XFS_SUMPTR(mp, bp, so);\n\tif (delta) {\n\t\tuint first = (uint)((char *)sp - (char *)bp->b_addr);\n\n\t\t*sp += delta;\n\t\txfs_trans_log_buf(tp, bp, first, first + sizeof(*sp) - 1);\n\t}\n\tif (sum)\n\t\t*sum = *sp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_rtget_summary(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\tint\t\tlog,\t\t/* log2 of extent size */\n\txfs_rtblock_t\tbbno,\t\t/* bitmap block number */\n\txfs_buf_t\t**rbpp,\t\t/* in/out: summary block buffer */\n\txfs_fsblock_t\t*rsb,\t\t/* in/out: summary block number */\n\txfs_suminfo_t\t*sum)\t\t/* out: summary info for this block */\n{\n\treturn xfs_rtmodify_summary_int(mp, tp, log, bbno, 0, rbpp, rsb, sum);\n}"
  }
]