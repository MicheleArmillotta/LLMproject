[
  {
    "function_name": "ramoops_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "635-640",
    "snippet": "static void __exit ramoops_exit(void)\n{\n\tplatform_driver_unregister(&ramoops_driver);\n\tplatform_device_unregister(dummy);\n\tkfree(dummy_data);\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct platform_device *dummy;",
      "static struct ramoops_platform_data *dummy_data;",
      "static struct platform_driver ramoops_driver = {\n\t.probe\t\t= ramoops_probe,\n\t.remove\t\t= __exit_p(ramoops_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"ramoops\",\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dummy_data"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_device_unregister",
          "args": [
            "dummy"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_driver_unregister",
          "args": [
            "&ramoops_driver"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic struct platform_device *dummy;\nstatic struct ramoops_platform_data *dummy_data;\nstatic struct platform_driver ramoops_driver = {\n\t.probe\t\t= ramoops_probe,\n\t.remove\t\t= __exit_p(ramoops_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"ramoops\",\n\t},\n};\n\nstatic void __exit ramoops_exit(void)\n{\n\tplatform_driver_unregister(&ramoops_driver);\n\tplatform_device_unregister(dummy);\n\tkfree(dummy_data);\n}"
  },
  {
    "function_name": "ramoops_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "628-632",
    "snippet": "static int __init ramoops_init(void)\n{\n\tramoops_register_dummy();\n\treturn platform_driver_register(&ramoops_driver);\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct platform_driver ramoops_driver = {\n\t.probe\t\t= ramoops_probe,\n\t.remove\t\t= __exit_p(ramoops_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"ramoops\",\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "platform_driver_register",
          "args": [
            "&ramoops_driver"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ramoops_register_dummy",
          "args": [],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_register_dummy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "593-626",
          "snippet": "static void ramoops_register_dummy(void)\n{\n\tif (!mem_size)\n\t\treturn;\n\n\tpr_info(\"using module parameters\\n\");\n\n\tdummy_data = kzalloc(sizeof(*dummy_data), GFP_KERNEL);\n\tif (!dummy_data) {\n\t\tpr_info(\"could not allocate pdata\\n\");\n\t\treturn;\n\t}\n\n\tdummy_data->mem_size = mem_size;\n\tdummy_data->mem_address = mem_address;\n\tdummy_data->mem_type = 0;\n\tdummy_data->record_size = record_size;\n\tdummy_data->console_size = ramoops_console_size;\n\tdummy_data->ftrace_size = ramoops_ftrace_size;\n\tdummy_data->pmsg_size = ramoops_pmsg_size;\n\tdummy_data->dump_oops = dump_oops;\n\t/*\n\t * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC\n\t * (using 1 byte for ECC isn't much of use anyway).\n\t */\n\tdummy_data->ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\n\n\tdummy = platform_device_register_data(NULL, \"ramoops\", -1,\n\t\t\tdummy_data, sizeof(struct ramoops_platform_data));\n\tif (IS_ERR(dummy)) {\n\t\tpr_info(\"could not create platform device: %ld\\n\",\n\t\t\tPTR_ERR(dummy));\n\t}\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong record_size = MIN_MEM_SIZE;",
            "static ulong ramoops_console_size = MIN_MEM_SIZE;",
            "static ulong ramoops_ftrace_size = MIN_MEM_SIZE;",
            "static ulong ramoops_pmsg_size = MIN_MEM_SIZE;",
            "static ulong mem_address;",
            "static ulong mem_size;",
            "static unsigned int mem_type;",
            "static int dump_oops = 1;",
            "static int ramoops_ecc;",
            "static struct platform_device *dummy;",
            "static struct ramoops_platform_data *dummy_data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ulong record_size = MIN_MEM_SIZE;\nstatic ulong ramoops_console_size = MIN_MEM_SIZE;\nstatic ulong ramoops_ftrace_size = MIN_MEM_SIZE;\nstatic ulong ramoops_pmsg_size = MIN_MEM_SIZE;\nstatic ulong mem_address;\nstatic ulong mem_size;\nstatic unsigned int mem_type;\nstatic int dump_oops = 1;\nstatic int ramoops_ecc;\nstatic struct platform_device *dummy;\nstatic struct ramoops_platform_data *dummy_data;\n\nstatic void ramoops_register_dummy(void)\n{\n\tif (!mem_size)\n\t\treturn;\n\n\tpr_info(\"using module parameters\\n\");\n\n\tdummy_data = kzalloc(sizeof(*dummy_data), GFP_KERNEL);\n\tif (!dummy_data) {\n\t\tpr_info(\"could not allocate pdata\\n\");\n\t\treturn;\n\t}\n\n\tdummy_data->mem_size = mem_size;\n\tdummy_data->mem_address = mem_address;\n\tdummy_data->mem_type = 0;\n\tdummy_data->record_size = record_size;\n\tdummy_data->console_size = ramoops_console_size;\n\tdummy_data->ftrace_size = ramoops_ftrace_size;\n\tdummy_data->pmsg_size = ramoops_pmsg_size;\n\tdummy_data->dump_oops = dump_oops;\n\t/*\n\t * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC\n\t * (using 1 byte for ECC isn't much of use anyway).\n\t */\n\tdummy_data->ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\n\n\tdummy = platform_device_register_data(NULL, \"ramoops\", -1,\n\t\t\tdummy_data, sizeof(struct ramoops_platform_data));\n\tif (IS_ERR(dummy)) {\n\t\tpr_info(\"could not create platform device: %ld\\n\",\n\t\t\tPTR_ERR(dummy));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic struct platform_driver ramoops_driver = {\n\t.probe\t\t= ramoops_probe,\n\t.remove\t\t= __exit_p(ramoops_remove),\n\t.driver\t\t= {\n\t\t.name\t= \"ramoops\",\n\t},\n};\n\nstatic int __init ramoops_init(void)\n{\n\tramoops_register_dummy();\n\treturn platform_driver_register(&ramoops_driver);\n}"
  },
  {
    "function_name": "ramoops_register_dummy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "593-626",
    "snippet": "static void ramoops_register_dummy(void)\n{\n\tif (!mem_size)\n\t\treturn;\n\n\tpr_info(\"using module parameters\\n\");\n\n\tdummy_data = kzalloc(sizeof(*dummy_data), GFP_KERNEL);\n\tif (!dummy_data) {\n\t\tpr_info(\"could not allocate pdata\\n\");\n\t\treturn;\n\t}\n\n\tdummy_data->mem_size = mem_size;\n\tdummy_data->mem_address = mem_address;\n\tdummy_data->mem_type = 0;\n\tdummy_data->record_size = record_size;\n\tdummy_data->console_size = ramoops_console_size;\n\tdummy_data->ftrace_size = ramoops_ftrace_size;\n\tdummy_data->pmsg_size = ramoops_pmsg_size;\n\tdummy_data->dump_oops = dump_oops;\n\t/*\n\t * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC\n\t * (using 1 byte for ECC isn't much of use anyway).\n\t */\n\tdummy_data->ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\n\n\tdummy = platform_device_register_data(NULL, \"ramoops\", -1,\n\t\t\tdummy_data, sizeof(struct ramoops_platform_data));\n\tif (IS_ERR(dummy)) {\n\t\tpr_info(\"could not create platform device: %ld\\n\",\n\t\t\tPTR_ERR(dummy));\n\t}\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong record_size = MIN_MEM_SIZE;",
      "static ulong ramoops_console_size = MIN_MEM_SIZE;",
      "static ulong ramoops_ftrace_size = MIN_MEM_SIZE;",
      "static ulong ramoops_pmsg_size = MIN_MEM_SIZE;",
      "static ulong mem_address;",
      "static ulong mem_size;",
      "static unsigned int mem_type;",
      "static int dump_oops = 1;",
      "static int ramoops_ecc;",
      "static struct platform_device *dummy;",
      "static struct ramoops_platform_data *dummy_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"could not create platform device: %ld\\n\"",
            "PTR_ERR(dummy)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dummy"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dummy"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_device_register_data",
          "args": [
            "NULL",
            "\"ramoops\"",
            "-1",
            "dummy_data",
            "sizeof(struct ramoops_platform_data)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"could not allocate pdata\\n\""
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dummy_data)",
            "GFP_KERNEL"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"using module parameters\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ulong record_size = MIN_MEM_SIZE;\nstatic ulong ramoops_console_size = MIN_MEM_SIZE;\nstatic ulong ramoops_ftrace_size = MIN_MEM_SIZE;\nstatic ulong ramoops_pmsg_size = MIN_MEM_SIZE;\nstatic ulong mem_address;\nstatic ulong mem_size;\nstatic unsigned int mem_type;\nstatic int dump_oops = 1;\nstatic int ramoops_ecc;\nstatic struct platform_device *dummy;\nstatic struct ramoops_platform_data *dummy_data;\n\nstatic void ramoops_register_dummy(void)\n{\n\tif (!mem_size)\n\t\treturn;\n\n\tpr_info(\"using module parameters\\n\");\n\n\tdummy_data = kzalloc(sizeof(*dummy_data), GFP_KERNEL);\n\tif (!dummy_data) {\n\t\tpr_info(\"could not allocate pdata\\n\");\n\t\treturn;\n\t}\n\n\tdummy_data->mem_size = mem_size;\n\tdummy_data->mem_address = mem_address;\n\tdummy_data->mem_type = 0;\n\tdummy_data->record_size = record_size;\n\tdummy_data->console_size = ramoops_console_size;\n\tdummy_data->ftrace_size = ramoops_ftrace_size;\n\tdummy_data->pmsg_size = ramoops_pmsg_size;\n\tdummy_data->dump_oops = dump_oops;\n\t/*\n\t * For backwards compatibility ramoops.ecc=1 means 16 bytes ECC\n\t * (using 1 byte for ECC isn't much of use anyway).\n\t */\n\tdummy_data->ecc_info.ecc_size = ramoops_ecc == 1 ? 16 : ramoops_ecc;\n\n\tdummy = platform_device_register_data(NULL, \"ramoops\", -1,\n\t\t\tdummy_data, sizeof(struct ramoops_platform_data));\n\tif (IS_ERR(dummy)) {\n\t\tpr_info(\"could not create platform device: %ld\\n\",\n\t\t\tPTR_ERR(dummy));\n\t}\n}"
  },
  {
    "function_name": "ramoops_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "564-583",
    "snippet": "static int __exit ramoops_remove(struct platform_device *pdev)\n{\n#if 0\n\t/* TODO(kees): We cannot unload ramoops since pstore doesn't support\n\t * unregistering yet.\n\t */\n\tstruct ramoops_context *cxt = &oops_cxt;\n\n\tiounmap(cxt->virt_addr);\n\trelease_mem_region(cxt->phys_addr, cxt->size);\n\tcxt->max_dump_cnt = 0;\n\n\t/* TODO(kees): When pstore supports unregistering, call it here. */\n\tkfree(cxt->pstore.buf);\n\tcxt->pstore.bufsize = 0;\n\n\treturn 0;\n#endif\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ramoops_context oops_cxt = {\n\t.pstore = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ramoops\",\n\t\t.open\t= ramoops_pstore_open,\n\t\t.read\t= ramoops_pstore_read,\n\t\t.write_buf\t= ramoops_pstore_write_buf,\n\t\t.erase\t= ramoops_pstore_erase,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->pstore.buf"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_mem_region",
          "args": [
            "cxt->phys_addr",
            "cxt->size"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "cxt->virt_addr"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic struct ramoops_context oops_cxt = {\n\t.pstore = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ramoops\",\n\t\t.open\t= ramoops_pstore_open,\n\t\t.read\t= ramoops_pstore_read,\n\t\t.write_buf\t= ramoops_pstore_write_buf,\n\t\t.erase\t= ramoops_pstore_erase,\n\t},\n};\n\nstatic int __exit ramoops_remove(struct platform_device *pdev)\n{\n#if 0\n\t/* TODO(kees): We cannot unload ramoops since pstore doesn't support\n\t * unregistering yet.\n\t */\n\tstruct ramoops_context *cxt = &oops_cxt;\n\n\tiounmap(cxt->virt_addr);\n\trelease_mem_region(cxt->phys_addr, cxt->size);\n\tcxt->max_dump_cnt = 0;\n\n\t/* TODO(kees): When pstore supports unregistering, call it here. */\n\tkfree(cxt->pstore.buf);\n\tcxt->pstore.bufsize = 0;\n\n\treturn 0;\n#endif\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "ramoops_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "447-562",
    "snippet": "static int ramoops_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ramoops_platform_data *pdata = pdev->dev.platform_data;\n\tstruct ramoops_context *cxt = &oops_cxt;\n\tsize_t dump_mem_sz;\n\tphys_addr_t paddr;\n\tint err = -EINVAL;\n\n\t/* Only a single ramoops area allowed at a time, so fail extra\n\t * probes.\n\t */\n\tif (cxt->max_dump_cnt)\n\t\tgoto fail_out;\n\n\tif (!pdata->mem_size || (!pdata->record_size && !pdata->console_size &&\n\t\t\t!pdata->ftrace_size && !pdata->pmsg_size)) {\n\t\tpr_err(\"The memory size and the record/console size must be \"\n\t\t\t\"non-zero\\n\");\n\t\tgoto fail_out;\n\t}\n\n\tif (pdata->record_size && !is_power_of_2(pdata->record_size))\n\t\tpdata->record_size = rounddown_pow_of_two(pdata->record_size);\n\tif (pdata->console_size && !is_power_of_2(pdata->console_size))\n\t\tpdata->console_size = rounddown_pow_of_two(pdata->console_size);\n\tif (pdata->ftrace_size && !is_power_of_2(pdata->ftrace_size))\n\t\tpdata->ftrace_size = rounddown_pow_of_two(pdata->ftrace_size);\n\tif (pdata->pmsg_size && !is_power_of_2(pdata->pmsg_size))\n\t\tpdata->pmsg_size = rounddown_pow_of_two(pdata->pmsg_size);\n\n\tcxt->size = pdata->mem_size;\n\tcxt->phys_addr = pdata->mem_address;\n\tcxt->memtype = pdata->mem_type;\n\tcxt->record_size = pdata->record_size;\n\tcxt->console_size = pdata->console_size;\n\tcxt->ftrace_size = pdata->ftrace_size;\n\tcxt->pmsg_size = pdata->pmsg_size;\n\tcxt->dump_oops = pdata->dump_oops;\n\tcxt->ecc_info = pdata->ecc_info;\n\n\tpaddr = cxt->phys_addr;\n\n\tdump_mem_sz = cxt->size - cxt->console_size - cxt->ftrace_size\n\t\t\t- cxt->pmsg_size;\n\terr = ramoops_init_przs(dev, cxt, &paddr, dump_mem_sz);\n\tif (err)\n\t\tgoto fail_out;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->cprz, &paddr,\n\t\t\t       cxt->console_size, 0);\n\tif (err)\n\t\tgoto fail_init_cprz;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->fprz, &paddr, cxt->ftrace_size,\n\t\t\t       LINUX_VERSION_CODE);\n\tif (err)\n\t\tgoto fail_init_fprz;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->mprz, &paddr, cxt->pmsg_size, 0);\n\tif (err)\n\t\tgoto fail_init_mprz;\n\n\tcxt->pstore.data = cxt;\n\t/*\n\t * Console can handle any buffer size, so prefer LOG_LINE_MAX. If we\n\t * have to handle dumps, we must have at least record_size buffer. And\n\t * for ftrace, bufsize is irrelevant (if bufsize is 0, buf will be\n\t * ZERO_SIZE_PTR).\n\t */\n\tif (cxt->console_size)\n\t\tcxt->pstore.bufsize = 1024; /* LOG_LINE_MAX */\n\tcxt->pstore.bufsize = max(cxt->record_size, cxt->pstore.bufsize);\n\tcxt->pstore.buf = kmalloc(cxt->pstore.bufsize, GFP_KERNEL);\n\tspin_lock_init(&cxt->pstore.buf_lock);\n\tif (!cxt->pstore.buf) {\n\t\tpr_err(\"cannot allocate pstore buffer\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_clear;\n\t}\n\n\terr = pstore_register(&cxt->pstore);\n\tif (err) {\n\t\tpr_err(\"registering with pstore failed\\n\");\n\t\tgoto fail_buf;\n\t}\n\n\t/*\n\t * Update the module parameter variables as well so they are visible\n\t * through /sys/module/ramoops/parameters/\n\t */\n\tmem_size = pdata->mem_size;\n\tmem_address = pdata->mem_address;\n\trecord_size = pdata->record_size;\n\tdump_oops = pdata->dump_oops;\n\n\tpr_info(\"attached 0x%lx@0x%llx, ecc: %d/%d\\n\",\n\t\tcxt->size, (unsigned long long)cxt->phys_addr,\n\t\tcxt->ecc_info.ecc_size, cxt->ecc_info.block_size);\n\n\treturn 0;\n\nfail_buf:\n\tkfree(cxt->pstore.buf);\nfail_clear:\n\tcxt->pstore.bufsize = 0;\n\tkfree(cxt->mprz);\nfail_init_mprz:\n\tkfree(cxt->fprz);\nfail_init_fprz:\n\tkfree(cxt->cprz);\nfail_init_cprz:\n\tramoops_free_przs(cxt);\nfail_out:\n\treturn err;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong record_size = MIN_MEM_SIZE;",
      "static ulong mem_address;",
      "static ulong mem_size;",
      "static unsigned int mem_type;",
      "static int dump_oops = 1;",
      "static struct ramoops_context oops_cxt = {\n\t.pstore = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ramoops\",\n\t\t.open\t= ramoops_pstore_open,\n\t\t.read\t= ramoops_pstore_read,\n\t\t.write_buf\t= ramoops_pstore_write_buf,\n\t\t.erase\t= ramoops_pstore_erase,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ramoops_free_przs",
          "args": [
            "cxt"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_free_przs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "358-369",
          "snippet": "static void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->cprz"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->fprz"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->mprz"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->pstore.buf"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"attached 0x%lx@0x%llx, ecc: %d/%d\\n\"",
            "cxt->size",
            "(unsigned long long)cxt->phys_addr",
            "cxt->ecc_info.ecc_size",
            "cxt->ecc_info.block_size"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"registering with pstore failed\\n\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_register",
          "args": [
            "&cxt->pstore"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "pstore_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/platform.c",
          "lines": "416-462",
          "snippet": "int pstore_register(struct pstore_info *psi)\n{\n\tstruct module *owner = psi->owner;\n\n\tif (backend && strcmp(backend, psi->name))\n\t\treturn -EPERM;\n\n\tspin_lock(&pstore_lock);\n\tif (psinfo) {\n\t\tspin_unlock(&pstore_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!psi->write)\n\t\tpsi->write = pstore_write_compat;\n\tpsinfo = psi;\n\tmutex_init(&psinfo->read_mutex);\n\tspin_unlock(&pstore_lock);\n\n\tif (owner && !try_module_get(owner)) {\n\t\tpsinfo = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tallocate_buf_for_compression();\n\n\tif (pstore_is_mounted())\n\t\tpstore_get_records(0);\n\n\tkmsg_dump_register(&pstore_dumper);\n\n\tif ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {\n\t\tpstore_register_console();\n\t\tpstore_register_ftrace();\n\t\tpstore_register_pmsg();\n\t}\n\n\tif (pstore_update_ms >= 0) {\n\t\tpstore_timer.expires = jiffies +\n\t\t\tmsecs_to_jiffies(pstore_update_ms);\n\t\tadd_timer(&pstore_timer);\n\t}\n\n\tpr_info(\"Registered %s as persistent store backend\\n\", psi->name);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/module.h>",
            "#include <linux/console.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pstore_update_ms = -1;",
            "static DEFINE_SPINLOCK(pstore_lock);",
            "struct pstore_info *psinfo;",
            "static char *backend;",
            "static struct kmsg_dumper pstore_dumper = {\n\t.dump = pstore_dump,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kmsg_dump.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/atomic.h>\n\nstatic int pstore_update_ms = -1;\nstatic DEFINE_SPINLOCK(pstore_lock);\nstruct pstore_info *psinfo;\nstatic char *backend;\nstatic struct kmsg_dumper pstore_dumper = {\n\t.dump = pstore_dump,\n};\n\nint pstore_register(struct pstore_info *psi)\n{\n\tstruct module *owner = psi->owner;\n\n\tif (backend && strcmp(backend, psi->name))\n\t\treturn -EPERM;\n\n\tspin_lock(&pstore_lock);\n\tif (psinfo) {\n\t\tspin_unlock(&pstore_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!psi->write)\n\t\tpsi->write = pstore_write_compat;\n\tpsinfo = psi;\n\tmutex_init(&psinfo->read_mutex);\n\tspin_unlock(&pstore_lock);\n\n\tif (owner && !try_module_get(owner)) {\n\t\tpsinfo = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tallocate_buf_for_compression();\n\n\tif (pstore_is_mounted())\n\t\tpstore_get_records(0);\n\n\tkmsg_dump_register(&pstore_dumper);\n\n\tif ((psi->flags & PSTORE_FLAGS_FRAGILE) == 0) {\n\t\tpstore_register_console();\n\t\tpstore_register_ftrace();\n\t\tpstore_register_pmsg();\n\t}\n\n\tif (pstore_update_ms >= 0) {\n\t\tpstore_timer.expires = jiffies +\n\t\t\tmsecs_to_jiffies(pstore_update_ms);\n\t\tadd_timer(&pstore_timer);\n\t}\n\n\tpr_info(\"Registered %s as persistent store backend\\n\", psi->name);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cannot allocate pstore buffer\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cxt->pstore.buf_lock"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "cxt->pstore.bufsize",
            "GFP_KERNEL"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "cxt->record_size",
            "cxt->pstore.bufsize"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramoops_init_prz",
          "args": [
            "dev",
            "cxt",
            "&cxt->mprz",
            "&paddr",
            "cxt->pmsg_size",
            "0"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_init_prz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "417-445",
          "snippet": "static int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,\n\t\t\t    struct persistent_ram_zone **prz,\n\t\t\t    phys_addr_t *paddr, size_t sz, u32 sig)\n{\n\tif (!sz)\n\t\treturn 0;\n\n\tif (*paddr + sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tsz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\t*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info, cxt->memtype);\n\tif (IS_ERR(*prz)) {\n\t\tint err = PTR_ERR(*prz);\n\n\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\tsz, (unsigned long long)*paddr, err);\n\t\treturn err;\n\t}\n\n\tpersistent_ram_zap(*prz);\n\n\t*paddr += sz;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,\n\t\t\t    struct persistent_ram_zone **prz,\n\t\t\t    phys_addr_t *paddr, size_t sz, u32 sig)\n{\n\tif (!sz)\n\t\treturn 0;\n\n\tif (*paddr + sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tsz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\t*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info, cxt->memtype);\n\tif (IS_ERR(*prz)) {\n\t\tint err = PTR_ERR(*prz);\n\n\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\tsz, (unsigned long long)*paddr, err);\n\t\treturn err;\n\t}\n\n\tpersistent_ram_zap(*prz);\n\n\t*paddr += sz;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramoops_init_przs",
          "args": [
            "dev",
            "cxt",
            "&paddr",
            "dump_mem_sz"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_init_przs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "371-415",
          "snippet": "static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,\n\t\t\t     phys_addr_t *paddr, size_t dump_mem_sz)\n{\n\tint err = -ENOMEM;\n\tint i;\n\n\tif (!cxt->record_size)\n\t\treturn 0;\n\n\tif (*paddr + dump_mem_sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for dumps\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxt->max_dump_cnt = dump_mem_sz / cxt->record_size;\n\tif (!cxt->max_dump_cnt)\n\t\treturn -ENOMEM;\n\n\tcxt->przs = kzalloc(sizeof(*cxt->przs) * cxt->max_dump_cnt,\n\t\t\t     GFP_KERNEL);\n\tif (!cxt->przs) {\n\t\tdev_err(dev, \"failed to initialize a prz array for dumps\\n\");\n\t\tgoto fail_prz;\n\t}\n\n\tfor (i = 0; i < cxt->max_dump_cnt; i++) {\n\t\tsize_t sz = cxt->record_size;\n\n\t\tcxt->przs[i] = persistent_ram_new(*paddr, sz, 0,\n\t\t\t\t\t\t  &cxt->ecc_info,\n\t\t\t\t\t\t  cxt->memtype);\n\t\tif (IS_ERR(cxt->przs[i])) {\n\t\t\terr = PTR_ERR(cxt->przs[i]);\n\t\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\t\tsz, (unsigned long long)*paddr, err);\n\t\t\tgoto fail_prz;\n\t\t}\n\t\t*paddr += sz;\n\t}\n\n\treturn 0;\nfail_prz:\n\tramoops_free_przs(cxt);\n\treturn err;\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong record_size = MIN_MEM_SIZE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ulong record_size = MIN_MEM_SIZE;\n\nstatic int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,\n\t\t\t     phys_addr_t *paddr, size_t dump_mem_sz)\n{\n\tint err = -ENOMEM;\n\tint i;\n\n\tif (!cxt->record_size)\n\t\treturn 0;\n\n\tif (*paddr + dump_mem_sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for dumps\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxt->max_dump_cnt = dump_mem_sz / cxt->record_size;\n\tif (!cxt->max_dump_cnt)\n\t\treturn -ENOMEM;\n\n\tcxt->przs = kzalloc(sizeof(*cxt->przs) * cxt->max_dump_cnt,\n\t\t\t     GFP_KERNEL);\n\tif (!cxt->przs) {\n\t\tdev_err(dev, \"failed to initialize a prz array for dumps\\n\");\n\t\tgoto fail_prz;\n\t}\n\n\tfor (i = 0; i < cxt->max_dump_cnt; i++) {\n\t\tsize_t sz = cxt->record_size;\n\n\t\tcxt->przs[i] = persistent_ram_new(*paddr, sz, 0,\n\t\t\t\t\t\t  &cxt->ecc_info,\n\t\t\t\t\t\t  cxt->memtype);\n\t\tif (IS_ERR(cxt->przs[i])) {\n\t\t\terr = PTR_ERR(cxt->przs[i]);\n\t\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\t\tsz, (unsigned long long)*paddr, err);\n\t\t\tgoto fail_prz;\n\t\t}\n\t\t*paddr += sz;\n\t}\n\n\treturn 0;\nfail_prz:\n\tramoops_free_przs(cxt);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "pdata->pmsg_size"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "pdata->pmsg_size"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "pdata->ftrace_size"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "pdata->ftrace_size"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "pdata->console_size"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "pdata->console_size"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "pdata->record_size"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "pdata->record_size"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"The memory size and the record/console size must be \"\n\t\t\t\"non-zero\\n\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ulong record_size = MIN_MEM_SIZE;\nstatic ulong mem_address;\nstatic ulong mem_size;\nstatic unsigned int mem_type;\nstatic int dump_oops = 1;\nstatic struct ramoops_context oops_cxt = {\n\t.pstore = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ramoops\",\n\t\t.open\t= ramoops_pstore_open,\n\t\t.read\t= ramoops_pstore_read,\n\t\t.write_buf\t= ramoops_pstore_write_buf,\n\t\t.erase\t= ramoops_pstore_erase,\n\t},\n};\n\nstatic int ramoops_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ramoops_platform_data *pdata = pdev->dev.platform_data;\n\tstruct ramoops_context *cxt = &oops_cxt;\n\tsize_t dump_mem_sz;\n\tphys_addr_t paddr;\n\tint err = -EINVAL;\n\n\t/* Only a single ramoops area allowed at a time, so fail extra\n\t * probes.\n\t */\n\tif (cxt->max_dump_cnt)\n\t\tgoto fail_out;\n\n\tif (!pdata->mem_size || (!pdata->record_size && !pdata->console_size &&\n\t\t\t!pdata->ftrace_size && !pdata->pmsg_size)) {\n\t\tpr_err(\"The memory size and the record/console size must be \"\n\t\t\t\"non-zero\\n\");\n\t\tgoto fail_out;\n\t}\n\n\tif (pdata->record_size && !is_power_of_2(pdata->record_size))\n\t\tpdata->record_size = rounddown_pow_of_two(pdata->record_size);\n\tif (pdata->console_size && !is_power_of_2(pdata->console_size))\n\t\tpdata->console_size = rounddown_pow_of_two(pdata->console_size);\n\tif (pdata->ftrace_size && !is_power_of_2(pdata->ftrace_size))\n\t\tpdata->ftrace_size = rounddown_pow_of_two(pdata->ftrace_size);\n\tif (pdata->pmsg_size && !is_power_of_2(pdata->pmsg_size))\n\t\tpdata->pmsg_size = rounddown_pow_of_two(pdata->pmsg_size);\n\n\tcxt->size = pdata->mem_size;\n\tcxt->phys_addr = pdata->mem_address;\n\tcxt->memtype = pdata->mem_type;\n\tcxt->record_size = pdata->record_size;\n\tcxt->console_size = pdata->console_size;\n\tcxt->ftrace_size = pdata->ftrace_size;\n\tcxt->pmsg_size = pdata->pmsg_size;\n\tcxt->dump_oops = pdata->dump_oops;\n\tcxt->ecc_info = pdata->ecc_info;\n\n\tpaddr = cxt->phys_addr;\n\n\tdump_mem_sz = cxt->size - cxt->console_size - cxt->ftrace_size\n\t\t\t- cxt->pmsg_size;\n\terr = ramoops_init_przs(dev, cxt, &paddr, dump_mem_sz);\n\tif (err)\n\t\tgoto fail_out;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->cprz, &paddr,\n\t\t\t       cxt->console_size, 0);\n\tif (err)\n\t\tgoto fail_init_cprz;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->fprz, &paddr, cxt->ftrace_size,\n\t\t\t       LINUX_VERSION_CODE);\n\tif (err)\n\t\tgoto fail_init_fprz;\n\n\terr = ramoops_init_prz(dev, cxt, &cxt->mprz, &paddr, cxt->pmsg_size, 0);\n\tif (err)\n\t\tgoto fail_init_mprz;\n\n\tcxt->pstore.data = cxt;\n\t/*\n\t * Console can handle any buffer size, so prefer LOG_LINE_MAX. If we\n\t * have to handle dumps, we must have at least record_size buffer. And\n\t * for ftrace, bufsize is irrelevant (if bufsize is 0, buf will be\n\t * ZERO_SIZE_PTR).\n\t */\n\tif (cxt->console_size)\n\t\tcxt->pstore.bufsize = 1024; /* LOG_LINE_MAX */\n\tcxt->pstore.bufsize = max(cxt->record_size, cxt->pstore.bufsize);\n\tcxt->pstore.buf = kmalloc(cxt->pstore.bufsize, GFP_KERNEL);\n\tspin_lock_init(&cxt->pstore.buf_lock);\n\tif (!cxt->pstore.buf) {\n\t\tpr_err(\"cannot allocate pstore buffer\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail_clear;\n\t}\n\n\terr = pstore_register(&cxt->pstore);\n\tif (err) {\n\t\tpr_err(\"registering with pstore failed\\n\");\n\t\tgoto fail_buf;\n\t}\n\n\t/*\n\t * Update the module parameter variables as well so they are visible\n\t * through /sys/module/ramoops/parameters/\n\t */\n\tmem_size = pdata->mem_size;\n\tmem_address = pdata->mem_address;\n\trecord_size = pdata->record_size;\n\tdump_oops = pdata->dump_oops;\n\n\tpr_info(\"attached 0x%lx@0x%llx, ecc: %d/%d\\n\",\n\t\tcxt->size, (unsigned long long)cxt->phys_addr,\n\t\tcxt->ecc_info.ecc_size, cxt->ecc_info.block_size);\n\n\treturn 0;\n\nfail_buf:\n\tkfree(cxt->pstore.buf);\nfail_clear:\n\tcxt->pstore.bufsize = 0;\n\tkfree(cxt->mprz);\nfail_init_mprz:\n\tkfree(cxt->fprz);\nfail_init_fprz:\n\tkfree(cxt->cprz);\nfail_init_cprz:\n\tramoops_free_przs(cxt);\nfail_out:\n\treturn err;\n}"
  },
  {
    "function_name": "ramoops_init_prz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "417-445",
    "snippet": "static int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,\n\t\t\t    struct persistent_ram_zone **prz,\n\t\t\t    phys_addr_t *paddr, size_t sz, u32 sig)\n{\n\tif (!sz)\n\t\treturn 0;\n\n\tif (*paddr + sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tsz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\t*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info, cxt->memtype);\n\tif (IS_ERR(*prz)) {\n\t\tint err = PTR_ERR(*prz);\n\n\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\tsz, (unsigned long long)*paddr, err);\n\t\treturn err;\n\t}\n\n\tpersistent_ram_zap(*prz);\n\n\t*paddr += sz;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_zap",
          "args": [
            "*prz"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "376-381",
          "snippet": "void persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"failed to request mem region (0x%zx@0x%llx): %d\\n\"",
            "sz",
            "(unsigned long long)*paddr",
            "err"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*prz"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*prz"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_new",
          "args": [
            "*paddr",
            "sz",
            "sig",
            "&cxt->ecc_info",
            "cxt->memtype"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "514-539",
          "snippet": "struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstruct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\"",
            "sz",
            "(unsigned long long)*paddr",
            "cxt->size",
            "(unsigned long long)cxt->phys_addr"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__on_dev_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "370-389",
          "snippet": "static void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic int ramoops_init_prz(struct device *dev, struct ramoops_context *cxt,\n\t\t\t    struct persistent_ram_zone **prz,\n\t\t\t    phys_addr_t *paddr, size_t sz, u32 sig)\n{\n\tif (!sz)\n\t\treturn 0;\n\n\tif (*paddr + sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for mem region (0x%zx@0x%llx) in (0x%lx@0x%llx)\\n\",\n\t\t\tsz, (unsigned long long)*paddr,\n\t\t\tcxt->size, (unsigned long long)cxt->phys_addr);\n\t\treturn -ENOMEM;\n\t}\n\n\t*prz = persistent_ram_new(*paddr, sz, sig, &cxt->ecc_info, cxt->memtype);\n\tif (IS_ERR(*prz)) {\n\t\tint err = PTR_ERR(*prz);\n\n\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\tsz, (unsigned long long)*paddr, err);\n\t\treturn err;\n\t}\n\n\tpersistent_ram_zap(*prz);\n\n\t*paddr += sz;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ramoops_init_przs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "371-415",
    "snippet": "static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,\n\t\t\t     phys_addr_t *paddr, size_t dump_mem_sz)\n{\n\tint err = -ENOMEM;\n\tint i;\n\n\tif (!cxt->record_size)\n\t\treturn 0;\n\n\tif (*paddr + dump_mem_sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for dumps\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxt->max_dump_cnt = dump_mem_sz / cxt->record_size;\n\tif (!cxt->max_dump_cnt)\n\t\treturn -ENOMEM;\n\n\tcxt->przs = kzalloc(sizeof(*cxt->przs) * cxt->max_dump_cnt,\n\t\t\t     GFP_KERNEL);\n\tif (!cxt->przs) {\n\t\tdev_err(dev, \"failed to initialize a prz array for dumps\\n\");\n\t\tgoto fail_prz;\n\t}\n\n\tfor (i = 0; i < cxt->max_dump_cnt; i++) {\n\t\tsize_t sz = cxt->record_size;\n\n\t\tcxt->przs[i] = persistent_ram_new(*paddr, sz, 0,\n\t\t\t\t\t\t  &cxt->ecc_info,\n\t\t\t\t\t\t  cxt->memtype);\n\t\tif (IS_ERR(cxt->przs[i])) {\n\t\t\terr = PTR_ERR(cxt->przs[i]);\n\t\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\t\tsz, (unsigned long long)*paddr, err);\n\t\t\tgoto fail_prz;\n\t\t}\n\t\t*paddr += sz;\n\t}\n\n\treturn 0;\nfail_prz:\n\tramoops_free_przs(cxt);\n\treturn err;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong record_size = MIN_MEM_SIZE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ramoops_free_przs",
          "args": [
            "cxt"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_free_przs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "358-369",
          "snippet": "static void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"failed to request mem region (0x%zx@0x%llx): %d\\n\"",
            "sz",
            "(unsigned long long)*paddr",
            "err"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cxt->przs[i]"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cxt->przs[i]"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_new",
          "args": [
            "*paddr",
            "sz",
            "0",
            "&cxt->ecc_info",
            "cxt->memtype"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "514-539",
          "snippet": "struct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nstruct persistent_ram_zone *persistent_ram_new(phys_addr_t start, size_t size,\n\t\t\tu32 sig, struct persistent_ram_ecc_info *ecc_info,\n\t\t\tunsigned int memtype)\n{\n\tstruct persistent_ram_zone *prz;\n\tint ret = -ENOMEM;\n\n\tprz = kzalloc(sizeof(struct persistent_ram_zone), GFP_KERNEL);\n\tif (!prz) {\n\t\tpr_err(\"failed to allocate persistent ram zone\\n\");\n\t\tgoto err;\n\t}\n\n\tret = persistent_ram_buffer_map(start, size, prz, memtype);\n\tif (ret)\n\t\tgoto err;\n\n\tret = persistent_ram_post_init(prz, sig, ecc_info);\n\tif (ret)\n\t\tgoto err;\n\n\treturn prz;\nerr:\n\tpersistent_ram_free(prz);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"failed to initialize a prz array for dumps\\n\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cxt->przs) * cxt->max_dump_cnt",
            "GFP_KERNEL"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_err",
          "args": [
            "dev",
            "\"no room for dumps\\n\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ulong record_size = MIN_MEM_SIZE;\n\nstatic int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,\n\t\t\t     phys_addr_t *paddr, size_t dump_mem_sz)\n{\n\tint err = -ENOMEM;\n\tint i;\n\n\tif (!cxt->record_size)\n\t\treturn 0;\n\n\tif (*paddr + dump_mem_sz - cxt->phys_addr > cxt->size) {\n\t\tdev_err(dev, \"no room for dumps\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcxt->max_dump_cnt = dump_mem_sz / cxt->record_size;\n\tif (!cxt->max_dump_cnt)\n\t\treturn -ENOMEM;\n\n\tcxt->przs = kzalloc(sizeof(*cxt->przs) * cxt->max_dump_cnt,\n\t\t\t     GFP_KERNEL);\n\tif (!cxt->przs) {\n\t\tdev_err(dev, \"failed to initialize a prz array for dumps\\n\");\n\t\tgoto fail_prz;\n\t}\n\n\tfor (i = 0; i < cxt->max_dump_cnt; i++) {\n\t\tsize_t sz = cxt->record_size;\n\n\t\tcxt->przs[i] = persistent_ram_new(*paddr, sz, 0,\n\t\t\t\t\t\t  &cxt->ecc_info,\n\t\t\t\t\t\t  cxt->memtype);\n\t\tif (IS_ERR(cxt->przs[i])) {\n\t\t\terr = PTR_ERR(cxt->przs[i]);\n\t\t\tdev_err(dev, \"failed to request mem region (0x%zx@0x%llx): %d\\n\",\n\t\t\t\tsz, (unsigned long long)*paddr, err);\n\t\t\tgoto fail_prz;\n\t\t}\n\t\t*paddr += sz;\n\t}\n\n\treturn 0;\nfail_prz:\n\tramoops_free_przs(cxt);\n\treturn err;\n}"
  },
  {
    "function_name": "ramoops_free_przs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "358-369",
    "snippet": "static void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt->przs"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_free",
          "args": [
            "cxt->przs[i]"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "496-512",
          "snippet": "void persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free(struct persistent_ram_zone *prz)\n{\n\tif (!prz)\n\t\treturn;\n\n\tif (prz->vaddr) {\n\t\tif (pfn_valid(prz->paddr >> PAGE_SHIFT)) {\n\t\t\tvunmap(prz->vaddr);\n\t\t} else {\n\t\t\tiounmap(prz->vaddr);\n\t\t\trelease_mem_region(prz->paddr, prz->size);\n\t\t}\n\t\tprz->vaddr = NULL;\n\t}\n\tpersistent_ram_free_old(prz);\n\tkfree(prz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "cxt->przs[i]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic void ramoops_free_przs(struct ramoops_context *cxt)\n{\n\tint i;\n\n\tcxt->max_dump_cnt = 0;\n\tif (!cxt->przs)\n\t\treturn;\n\n\tfor (i = 0; !IS_ERR_OR_NULL(cxt->przs[i]); i++)\n\t\tpersistent_ram_free(cxt->przs[i]);\n\tkfree(cxt->przs);\n}"
  },
  {
    "function_name": "ramoops_pstore_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "316-345",
    "snippet": "static int ramoops_pstore_erase(enum pstore_type_id type, u64 id, int count,\n\t\t\t\tstruct timespec time, struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tif (id >= cxt->max_dump_cnt)\n\t\t\treturn -EINVAL;\n\t\tprz = cxt->przs[id];\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tprz = cxt->cprz;\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tprz = cxt->fprz;\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tprz = cxt->mprz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpersistent_ram_free_old(prz);\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_zap",
          "args": [
            "prz"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "376-381",
          "snippet": "void persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_zap(struct persistent_ram_zone *prz)\n{\n\tatomic_set(&prz->buffer->start, 0);\n\tatomic_set(&prz->buffer->size, 0);\n\tpersistent_ram_update_header_ecc(prz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_free_old",
          "args": [
            "prz"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_free_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "369-374",
          "snippet": "void persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid persistent_ram_free_old(struct persistent_ram_zone *prz)\n{\n\tkfree(prz->old_log);\n\tprz->old_log = NULL;\n\tprz->old_log_size = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic int ramoops_pstore_erase(enum pstore_type_id type, u64 id, int count,\n\t\t\t\tstruct timespec time, struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\n\tswitch (type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tif (id >= cxt->max_dump_cnt)\n\t\t\treturn -EINVAL;\n\t\tprz = cxt->przs[id];\n\t\tbreak;\n\tcase PSTORE_TYPE_CONSOLE:\n\t\tprz = cxt->cprz;\n\t\tbreak;\n\tcase PSTORE_TYPE_FTRACE:\n\t\tprz = cxt->fprz;\n\t\tbreak;\n\tcase PSTORE_TYPE_PMSG:\n\t\tprz = cxt->mprz;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpersistent_ram_free_old(prz);\n\tpersistent_ram_zap(prz);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ramoops_pstore_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "251-314",
    "snippet": "static int notrace ramoops_pstore_write_buf(enum pstore_type_id type,\n\t\t\t\t\t    enum kmsg_dump_reason reason,\n\t\t\t\t\t    u64 *id, unsigned int part,\n\t\t\t\t\t    const char *buf,\n\t\t\t\t\t    bool compressed, size_t size,\n\t\t\t\t\t    struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\tsize_t hlen;\n\n\tif (type == PSTORE_TYPE_CONSOLE) {\n\t\tif (!cxt->cprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->cprz, buf, size);\n\t\treturn 0;\n\t} else if (type == PSTORE_TYPE_FTRACE) {\n\t\tif (!cxt->fprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->fprz, buf, size);\n\t\treturn 0;\n\t} else if (type == PSTORE_TYPE_PMSG) {\n\t\tif (!cxt->mprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->mprz, buf, size);\n\t\treturn 0;\n\t}\n\n\tif (type != PSTORE_TYPE_DMESG)\n\t\treturn -EINVAL;\n\n\t/* Out of the various dmesg dump types, ramoops is currently designed\n\t * to only store crash logs, rather than storing general kernel logs.\n\t */\n\tif (reason != KMSG_DUMP_OOPS &&\n\t    reason != KMSG_DUMP_PANIC)\n\t\treturn -EINVAL;\n\n\t/* Skip Oopes when configured to do so. */\n\tif (reason == KMSG_DUMP_OOPS && !cxt->dump_oops)\n\t\treturn -EINVAL;\n\n\t/* Explicitly only take the first part of any new crash.\n\t * If our buffer is larger than kmsg_bytes, this can never happen,\n\t * and if our buffer is smaller than kmsg_bytes, we don't want the\n\t * report split across multiple records.\n\t */\n\tif (part != 1)\n\t\treturn -ENOSPC;\n\n\tif (!cxt->przs)\n\t\treturn -ENOSPC;\n\n\tprz = cxt->przs[cxt->dump_write_cnt];\n\n\thlen = ramoops_write_kmsg_hdr(prz, compressed);\n\tif (size + hlen > prz->buffer_size)\n\t\tsize = prz->buffer_size - hlen;\n\tpersistent_ram_write(prz, buf, size);\n\n\tcxt->dump_write_cnt = (cxt->dump_write_cnt + 1) % cxt->max_dump_cnt;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dump_oops = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_write",
          "args": [
            "prz",
            "buf",
            "size"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "329-357",
          "snippet": "int notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nint notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramoops_write_kmsg_hdr",
          "args": [
            "prz",
            "compressed"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_write_kmsg_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "228-249",
          "snippet": "static size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\n\t\t\t\t     bool compressed)\n{\n\tchar *hdr;\n\tstruct timespec timestamp;\n\tsize_t len;\n\n\t/* Report zeroed timestamp if called before timekeeping has resumed. */\n\tif (__getnstimeofday(&timestamp)) {\n\t\ttimestamp.tv_sec = 0;\n\t\ttimestamp.tv_nsec = 0;\n\t}\n\thdr = kasprintf(GFP_ATOMIC, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n\",\n\t\t(long)timestamp.tv_sec, (long)(timestamp.tv_nsec / 1000),\n\t\tcompressed ? 'C' : 'D');\n\tWARN_ON_ONCE(!hdr);\n\tlen = hdr ? strlen(hdr) : 0;\n\tpersistent_ram_write(prz, hdr, len);\n\tkfree(hdr);\n\n\treturn len;\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RAMOOPS_KERNMSG_HDR \"====\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\n#define RAMOOPS_KERNMSG_HDR \"====\"\n\nstatic size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\n\t\t\t\t     bool compressed)\n{\n\tchar *hdr;\n\tstruct timespec timestamp;\n\tsize_t len;\n\n\t/* Report zeroed timestamp if called before timekeeping has resumed. */\n\tif (__getnstimeofday(&timestamp)) {\n\t\ttimestamp.tv_sec = 0;\n\t\ttimestamp.tv_nsec = 0;\n\t}\n\thdr = kasprintf(GFP_ATOMIC, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n\",\n\t\t(long)timestamp.tv_sec, (long)(timestamp.tv_nsec / 1000),\n\t\tcompressed ? 'C' : 'D');\n\tWARN_ON_ONCE(!hdr);\n\tlen = hdr ? strlen(hdr) : 0;\n\tpersistent_ram_write(prz, hdr, len);\n\tkfree(hdr);\n\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic int dump_oops = 1;\n\nstatic int notrace ramoops_pstore_write_buf(enum pstore_type_id type,\n\t\t\t\t\t    enum kmsg_dump_reason reason,\n\t\t\t\t\t    u64 *id, unsigned int part,\n\t\t\t\t\t    const char *buf,\n\t\t\t\t\t    bool compressed, size_t size,\n\t\t\t\t\t    struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\tsize_t hlen;\n\n\tif (type == PSTORE_TYPE_CONSOLE) {\n\t\tif (!cxt->cprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->cprz, buf, size);\n\t\treturn 0;\n\t} else if (type == PSTORE_TYPE_FTRACE) {\n\t\tif (!cxt->fprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->fprz, buf, size);\n\t\treturn 0;\n\t} else if (type == PSTORE_TYPE_PMSG) {\n\t\tif (!cxt->mprz)\n\t\t\treturn -ENOMEM;\n\t\tpersistent_ram_write(cxt->mprz, buf, size);\n\t\treturn 0;\n\t}\n\n\tif (type != PSTORE_TYPE_DMESG)\n\t\treturn -EINVAL;\n\n\t/* Out of the various dmesg dump types, ramoops is currently designed\n\t * to only store crash logs, rather than storing general kernel logs.\n\t */\n\tif (reason != KMSG_DUMP_OOPS &&\n\t    reason != KMSG_DUMP_PANIC)\n\t\treturn -EINVAL;\n\n\t/* Skip Oopes when configured to do so. */\n\tif (reason == KMSG_DUMP_OOPS && !cxt->dump_oops)\n\t\treturn -EINVAL;\n\n\t/* Explicitly only take the first part of any new crash.\n\t * If our buffer is larger than kmsg_bytes, this can never happen,\n\t * and if our buffer is smaller than kmsg_bytes, we don't want the\n\t * report split across multiple records.\n\t */\n\tif (part != 1)\n\t\treturn -ENOSPC;\n\n\tif (!cxt->przs)\n\t\treturn -ENOSPC;\n\n\tprz = cxt->przs[cxt->dump_write_cnt];\n\n\thlen = ramoops_write_kmsg_hdr(prz, compressed);\n\tif (size + hlen > prz->buffer_size)\n\t\tsize = prz->buffer_size - hlen;\n\tpersistent_ram_write(prz, buf, size);\n\n\tcxt->dump_write_cnt = (cxt->dump_write_cnt + 1) % cxt->max_dump_cnt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ramoops_write_kmsg_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "228-249",
    "snippet": "static size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\n\t\t\t\t     bool compressed)\n{\n\tchar *hdr;\n\tstruct timespec timestamp;\n\tsize_t len;\n\n\t/* Report zeroed timestamp if called before timekeeping has resumed. */\n\tif (__getnstimeofday(&timestamp)) {\n\t\ttimestamp.tv_sec = 0;\n\t\ttimestamp.tv_nsec = 0;\n\t}\n\thdr = kasprintf(GFP_ATOMIC, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n\",\n\t\t(long)timestamp.tv_sec, (long)(timestamp.tv_nsec / 1000),\n\t\tcompressed ? 'C' : 'D');\n\tWARN_ON_ONCE(!hdr);\n\tlen = hdr ? strlen(hdr) : 0;\n\tpersistent_ram_write(prz, hdr, len);\n\tkfree(hdr);\n\n\treturn len;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RAMOOPS_KERNMSG_HDR \"====\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hdr"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_write",
          "args": [
            "prz",
            "hdr",
            "len"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "329-357",
          "snippet": "int notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nint notrace persistent_ram_write(struct persistent_ram_zone *prz,\n\tconst void *s, unsigned int count)\n{\n\tint rem;\n\tint c = count;\n\tsize_t start;\n\n\tif (unlikely(c > prz->buffer_size)) {\n\t\ts += c - prz->buffer_size;\n\t\tc = prz->buffer_size;\n\t}\n\n\tbuffer_size_add(prz, c);\n\n\tstart = buffer_start_add(prz, c);\n\n\trem = prz->buffer_size - start;\n\tif (unlikely(rem < c)) {\n\t\tpersistent_ram_update(prz, s, start, rem);\n\t\ts += rem;\n\t\tc -= rem;\n\t\tstart = 0;\n\t}\n\tpersistent_ram_update(prz, s, start, c);\n\n\tpersistent_ram_update_header_ecc(prz);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hdr"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!hdr"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_ATOMIC",
            "RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n\"",
            "(long)timestamp.tv_sec",
            "(long)(timestamp.tv_nsec / 1000)",
            "compressed ? 'C' : 'D'"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getnstimeofday",
          "args": [
            "&timestamp"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\n#define RAMOOPS_KERNMSG_HDR \"====\"\n\nstatic size_t ramoops_write_kmsg_hdr(struct persistent_ram_zone *prz,\n\t\t\t\t     bool compressed)\n{\n\tchar *hdr;\n\tstruct timespec timestamp;\n\tsize_t len;\n\n\t/* Report zeroed timestamp if called before timekeeping has resumed. */\n\tif (__getnstimeofday(&timestamp)) {\n\t\ttimestamp.tv_sec = 0;\n\t\ttimestamp.tv_nsec = 0;\n\t}\n\thdr = kasprintf(GFP_ATOMIC, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n\",\n\t\t(long)timestamp.tv_sec, (long)(timestamp.tv_nsec / 1000),\n\t\tcompressed ? 'C' : 'D');\n\tWARN_ON_ONCE(!hdr);\n\tlen = hdr ? strlen(hdr) : 0;\n\tpersistent_ram_write(prz, hdr, len);\n\tkfree(hdr);\n\n\treturn len;\n}"
  },
  {
    "function_name": "ramoops_pstore_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "181-226",
    "snippet": "static ssize_t ramoops_pstore_read(u64 *id, enum pstore_type_id *type,\n\t\t\t\t   int *count, struct timespec *time,\n\t\t\t\t   char **buf, bool *compressed,\n\t\t\t\t   struct pstore_info *psi)\n{\n\tssize_t size;\n\tssize_t ecc_notice_size;\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\tint header_length;\n\n\tprz = ramoops_get_next_prz(cxt->przs, &cxt->dump_read_cnt,\n\t\t\t\t   cxt->max_dump_cnt, id, type,\n\t\t\t\t   PSTORE_TYPE_DMESG, 1);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->cprz, &cxt->console_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_CONSOLE, 0);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->fprz, &cxt->ftrace_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_FTRACE, 0);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->mprz, &cxt->pmsg_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_PMSG, 0);\n\tif (!prz_ok(prz))\n\t\treturn 0;\n\n\tif (!persistent_ram_old(prz))\n\t\treturn 0;\n\n\tsize = persistent_ram_old_size(prz);\n\theader_length = ramoops_read_kmsg_hdr(persistent_ram_old(prz), time,\n\t\t\tcompressed);\n\tsize -= header_length;\n\n\t/* ECC correction notice */\n\tecc_notice_size = persistent_ram_ecc_string(prz, NULL, 0);\n\n\t*buf = kmalloc(size + ecc_notice_size + 1, GFP_KERNEL);\n\tif (*buf == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(*buf, (char *)persistent_ram_old(prz) + header_length, size);\n\tpersistent_ram_ecc_string(prz, *buf + size, ecc_notice_size + 1);\n\n\treturn size + ecc_notice_size;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_ecc_string",
          "args": [
            "prz",
            "*buf + size",
            "ecc_notice_size + 1"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_ecc_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "280-296",
          "snippet": "ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buf",
            "(char *)persistent_ram_old(prz) + header_length",
            "size"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "persistent_ram_old",
          "args": [
            "prz"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "364-367",
          "snippet": "void *persistent_ram_old(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nvoid *persistent_ram_old(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + ecc_notice_size + 1",
            "GFP_KERNEL"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramoops_read_kmsg_hdr",
          "args": [
            "persistent_ram_old(prz)",
            "time",
            "compressed"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_read_kmsg_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "152-173",
          "snippet": "static int ramoops_read_kmsg_hdr(char *buffer, struct timespec *time,\n\t\t\t\t  bool *compressed)\n{\n\tchar data_type;\n\tint header_length = 0;\n\n\tif (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n%n\", &time->tv_sec,\n\t\t\t&time->tv_nsec, &data_type, &header_length) == 3) {\n\t\tif (data_type == 'C')\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu\\n%n\",\n\t\t\t&time->tv_sec, &time->tv_nsec, &header_length) == 2) {\n\t\t\t*compressed = false;\n\t} else {\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\t*compressed = false;\n\t}\n\treturn header_length;\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RAMOOPS_KERNMSG_HDR \"====\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\n#define RAMOOPS_KERNMSG_HDR \"====\"\n\nstatic int ramoops_read_kmsg_hdr(char *buffer, struct timespec *time,\n\t\t\t\t  bool *compressed)\n{\n\tchar data_type;\n\tint header_length = 0;\n\n\tif (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n%n\", &time->tv_sec,\n\t\t\t&time->tv_nsec, &data_type, &header_length) == 3) {\n\t\tif (data_type == 'C')\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu\\n%n\",\n\t\t\t&time->tv_sec, &time->tv_nsec, &header_length) == 2) {\n\t\t\t*compressed = false;\n\t} else {\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\t*compressed = false;\n\t}\n\treturn header_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_old_size",
          "args": [
            "prz"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_old_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "359-362",
          "snippet": "size_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prz_ok",
          "args": [
            "prz"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "prz_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "175-179",
          "snippet": "static bool prz_ok(struct persistent_ram_zone *prz)\n{\n\treturn !!prz && !!(persistent_ram_old_size(prz) +\n\t\t\t   persistent_ram_ecc_string(prz, NULL, 0));\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic bool prz_ok(struct persistent_ram_zone *prz)\n{\n\treturn !!prz && !!(persistent_ram_old_size(prz) +\n\t\t\t   persistent_ram_ecc_string(prz, NULL, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ramoops_get_next_prz",
          "args": [
            "&cxt->mprz",
            "&cxt->pmsg_read_cnt",
            "1",
            "id",
            "type",
            "PSTORE_TYPE_PMSG",
            "0"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ramoops_get_next_prz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
          "lines": "123-150",
          "snippet": "static struct persistent_ram_zone *\nramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,\n\t\t     u64 *id,\n\t\t     enum pstore_type_id *typep, enum pstore_type_id type,\n\t\t     bool update)\n{\n\tstruct persistent_ram_zone *prz;\n\tint i = (*c)++;\n\n\tif (i >= max)\n\t\treturn NULL;\n\n\tprz = przs[i];\n\tif (!prz)\n\t\treturn NULL;\n\n\t/* Update old/shadowed buffer. */\n\tif (update)\n\t\tpersistent_ram_save_old(prz);\n\n\tif (!persistent_ram_old_size(prz))\n\t\treturn NULL;\n\n\t*typep = type;\n\t*id = i;\n\n\treturn prz;\n}",
          "includes": [
            "#include <linux/pstore_ram.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/ioport.h>",
            "#include <linux/io.h>",
            "#include <linux/time.h>",
            "#include <linux/pstore.h>",
            "#include <linux/version.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic struct persistent_ram_zone *\nramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,\n\t\t     u64 *id,\n\t\t     enum pstore_type_id *typep, enum pstore_type_id type,\n\t\t     bool update)\n{\n\tstruct persistent_ram_zone *prz;\n\tint i = (*c)++;\n\n\tif (i >= max)\n\t\treturn NULL;\n\n\tprz = przs[i];\n\tif (!prz)\n\t\treturn NULL;\n\n\t/* Update old/shadowed buffer. */\n\tif (update)\n\t\tpersistent_ram_save_old(prz);\n\n\tif (!persistent_ram_old_size(prz))\n\t\treturn NULL;\n\n\t*typep = type;\n\t*id = i;\n\n\treturn prz;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic ssize_t ramoops_pstore_read(u64 *id, enum pstore_type_id *type,\n\t\t\t\t   int *count, struct timespec *time,\n\t\t\t\t   char **buf, bool *compressed,\n\t\t\t\t   struct pstore_info *psi)\n{\n\tssize_t size;\n\tssize_t ecc_notice_size;\n\tstruct ramoops_context *cxt = psi->data;\n\tstruct persistent_ram_zone *prz;\n\tint header_length;\n\n\tprz = ramoops_get_next_prz(cxt->przs, &cxt->dump_read_cnt,\n\t\t\t\t   cxt->max_dump_cnt, id, type,\n\t\t\t\t   PSTORE_TYPE_DMESG, 1);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->cprz, &cxt->console_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_CONSOLE, 0);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->fprz, &cxt->ftrace_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_FTRACE, 0);\n\tif (!prz_ok(prz))\n\t\tprz = ramoops_get_next_prz(&cxt->mprz, &cxt->pmsg_read_cnt,\n\t\t\t\t\t   1, id, type, PSTORE_TYPE_PMSG, 0);\n\tif (!prz_ok(prz))\n\t\treturn 0;\n\n\tif (!persistent_ram_old(prz))\n\t\treturn 0;\n\n\tsize = persistent_ram_old_size(prz);\n\theader_length = ramoops_read_kmsg_hdr(persistent_ram_old(prz), time,\n\t\t\tcompressed);\n\tsize -= header_length;\n\n\t/* ECC correction notice */\n\tecc_notice_size = persistent_ram_ecc_string(prz, NULL, 0);\n\n\t*buf = kmalloc(size + ecc_notice_size + 1, GFP_KERNEL);\n\tif (*buf == NULL)\n\t\treturn -ENOMEM;\n\n\tmemcpy(*buf, (char *)persistent_ram_old(prz) + header_length, size);\n\tpersistent_ram_ecc_string(prz, *buf + size, ecc_notice_size + 1);\n\n\treturn size + ecc_notice_size;\n}"
  },
  {
    "function_name": "prz_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "175-179",
    "snippet": "static bool prz_ok(struct persistent_ram_zone *prz)\n{\n\treturn !!prz && !!(persistent_ram_old_size(prz) +\n\t\t\t   persistent_ram_ecc_string(prz, NULL, 0));\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_ecc_string",
          "args": [
            "prz",
            "NULL",
            "0"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_ecc_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "280-296",
          "snippet": "ssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nssize_t persistent_ram_ecc_string(struct persistent_ram_zone *prz,\n\tchar *str, size_t len)\n{\n\tssize_t ret;\n\n\tif (!prz->ecc_info.ecc_size)\n\t\treturn 0;\n\n\tif (prz->corrected_bytes || prz->bad_blocks)\n\t\tret = snprintf(str, len, \"\"\n\t\t\t\"\\n%d Corrected bytes, %d unrecoverable blocks\\n\",\n\t\t\tprz->corrected_bytes, prz->bad_blocks);\n\telse\n\t\tret = snprintf(str, len, \"\\nNo errors detected\\n\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_old_size",
          "args": [
            "prz"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_old_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "359-362",
          "snippet": "size_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic bool prz_ok(struct persistent_ram_zone *prz)\n{\n\treturn !!prz && !!(persistent_ram_old_size(prz) +\n\t\t\t   persistent_ram_ecc_string(prz, NULL, 0));\n}"
  },
  {
    "function_name": "ramoops_read_kmsg_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "152-173",
    "snippet": "static int ramoops_read_kmsg_hdr(char *buffer, struct timespec *time,\n\t\t\t\t  bool *compressed)\n{\n\tchar data_type;\n\tint header_length = 0;\n\n\tif (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n%n\", &time->tv_sec,\n\t\t\t&time->tv_nsec, &data_type, &header_length) == 3) {\n\t\tif (data_type == 'C')\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu\\n%n\",\n\t\t\t&time->tv_sec, &time->tv_nsec, &header_length) == 2) {\n\t\t\t*compressed = false;\n\t} else {\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\t*compressed = false;\n\t}\n\treturn header_length;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RAMOOPS_KERNMSG_HDR \"====\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buffer",
            "RAMOOPS_KERNMSG_HDR \"%lu.%lu\\n%n\"",
            "&time->tv_sec",
            "&time->tv_nsec",
            "&header_length"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buffer",
            "RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n%n\"",
            "&time->tv_sec",
            "&time->tv_nsec",
            "&data_type",
            "&header_length"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\n#define RAMOOPS_KERNMSG_HDR \"====\"\n\nstatic int ramoops_read_kmsg_hdr(char *buffer, struct timespec *time,\n\t\t\t\t  bool *compressed)\n{\n\tchar data_type;\n\tint header_length = 0;\n\n\tif (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu-%c\\n%n\", &time->tv_sec,\n\t\t\t&time->tv_nsec, &data_type, &header_length) == 3) {\n\t\tif (data_type == 'C')\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t} else if (sscanf(buffer, RAMOOPS_KERNMSG_HDR \"%lu.%lu\\n%n\",\n\t\t\t&time->tv_sec, &time->tv_nsec, &header_length) == 2) {\n\t\t\t*compressed = false;\n\t} else {\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\t*compressed = false;\n\t}\n\treturn header_length;\n}"
  },
  {
    "function_name": "ramoops_get_next_prz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "123-150",
    "snippet": "static struct persistent_ram_zone *\nramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,\n\t\t     u64 *id,\n\t\t     enum pstore_type_id *typep, enum pstore_type_id type,\n\t\t     bool update)\n{\n\tstruct persistent_ram_zone *prz;\n\tint i = (*c)++;\n\n\tif (i >= max)\n\t\treturn NULL;\n\n\tprz = przs[i];\n\tif (!prz)\n\t\treturn NULL;\n\n\t/* Update old/shadowed buffer. */\n\tif (update)\n\t\tpersistent_ram_save_old(prz);\n\n\tif (!persistent_ram_old_size(prz))\n\t\treturn NULL;\n\n\t*typep = type;\n\t*id = i;\n\n\treturn prz;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "persistent_ram_old_size",
          "args": [
            "prz"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_old_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "359-362",
          "snippet": "size_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nsize_t persistent_ram_old_size(struct persistent_ram_zone *prz)\n{\n\treturn prz->old_log_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "persistent_ram_save_old",
          "args": [
            "prz"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "persistent_ram_save_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram_core.c",
          "lines": "306-327",
          "snippet": "void persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/pstore_ram.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/rslib.h>",
            "#include <linux/memblock.h>",
            "#include <linux/list.h>",
            "#include <linux/io.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;",
            "static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/pstore_ram.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/rslib.h>\n#include <linux/memblock.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/device.h>\n\nstatic size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;\nstatic void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;\n\nvoid persistent_ram_save_old(struct persistent_ram_zone *prz)\n{\n\tstruct persistent_ram_buffer *buffer = prz->buffer;\n\tsize_t size = buffer_size(prz);\n\tsize_t start = buffer_start(prz);\n\n\tif (!size)\n\t\treturn;\n\n\tif (!prz->old_log) {\n\t\tpersistent_ram_ecc_old(prz);\n\t\tprz->old_log = kmalloc(size, GFP_KERNEL);\n\t}\n\tif (!prz->old_log) {\n\t\tpr_err(\"failed to allocate buffer\\n\");\n\t\treturn;\n\t}\n\n\tprz->old_log_size = size;\n\tmemcpy(prz->old_log, &buffer->data[start], size - start);\n\tmemcpy(prz->old_log + size - start, &buffer->data[0], start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic struct persistent_ram_zone *\nramoops_get_next_prz(struct persistent_ram_zone *przs[], uint *c, uint max,\n\t\t     u64 *id,\n\t\t     enum pstore_type_id *typep, enum pstore_type_id type,\n\t\t     bool update)\n{\n\tstruct persistent_ram_zone *prz;\n\tint i = (*c)++;\n\n\tif (i >= max)\n\t\treturn NULL;\n\n\tprz = przs[i];\n\tif (!prz)\n\t\treturn NULL;\n\n\t/* Update old/shadowed buffer. */\n\tif (update)\n\t\tpersistent_ram_save_old(prz);\n\n\tif (!persistent_ram_old_size(prz))\n\t\treturn NULL;\n\n\t*typep = type;\n\t*id = i;\n\n\treturn prz;\n}"
  },
  {
    "function_name": "ramoops_pstore_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/ram.c",
    "lines": "112-121",
    "snippet": "static int ramoops_pstore_open(struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\n\tcxt->dump_read_cnt = 0;\n\tcxt->console_read_cnt = 0;\n\tcxt->ftrace_read_cnt = 0;\n\tcxt->pmsg_read_cnt = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/pstore_ram.h>",
      "#include <linux/compiler.h>",
      "#include <linux/slab.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/ioport.h>",
      "#include <linux/io.h>",
      "#include <linux/time.h>",
      "#include <linux/pstore.h>",
      "#include <linux/version.h>",
      "#include <linux/module.h>",
      "#include <linux/err.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/pstore_ram.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/pstore.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n\nstatic int ramoops_pstore_open(struct pstore_info *psi)\n{\n\tstruct ramoops_context *cxt = psi->data;\n\n\tcxt->dump_read_cnt = 0;\n\tcxt->console_read_cnt = 0;\n\tcxt->ftrace_read_cnt = 0;\n\tcxt->pmsg_read_cnt = 0;\n\treturn 0;\n}"
  }
]