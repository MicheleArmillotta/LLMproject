[
  {
    "function_name": "gfs2_recover_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "594-610",
    "snippet": "int gfs2_recover_journal(struct gfs2_jdesc *jd, bool wait)\n{\n\tint rv;\n\n\tif (test_and_set_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\treturn -EBUSY;\n\n\t/* we have JDF_RECOVERY, queue should always succeed */\n\trv = queue_work(gfs_recovery_wq, &jd->jd_work);\n\tBUG_ON(!rv);\n\n\tif (wait)\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\treturn wait ? jd->jd_recover_error : 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *gfs_recovery_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&jd->jd_flags",
            "JDF_RECOVERY",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rv"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "gfs_recovery_wq",
            "&jd->jd_work"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "JDF_RECOVERY",
            "&jd->jd_flags"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct workqueue_struct *gfs_recovery_wq;\n\nint gfs2_recover_journal(struct gfs2_jdesc *jd, bool wait)\n{\n\tint rv;\n\n\tif (test_and_set_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\treturn -EBUSY;\n\n\t/* we have JDF_RECOVERY, queue should always succeed */\n\trv = queue_work(gfs_recovery_wq, &jd->jd_work);\n\tBUG_ON(!rv);\n\n\tif (wait)\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\treturn wait ? jd->jd_recover_error : 0;\n}"
  },
  {
    "function_name": "gfs2_recover_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "451-592",
    "snippet": "void gfs2_recover_func(struct work_struct *work)\n{\n\tstruct gfs2_jdesc *jd = container_of(work, struct gfs2_jdesc, jd_work);\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_holder j_gh, ji_gh, thaw_gh;\n\tunsigned long t;\n\tint ro = 0;\n\tunsigned int pass;\n\tint error;\n\tint jlocked = 0;\n\n\tif (sdp->sd_args.ar_spectator ||\n\t    (jd->jd_jid != sdp->sd_lockstruct.ls_jid)) {\n\t\tfs_info(sdp, \"jid=%u: Trying to acquire journal lock...\\n\",\n\t\t\tjd->jd_jid);\n\t\tjlocked = 1;\n\t\t/* Acquire the journal lock so we can do recovery */\n\n\t\terror = gfs2_glock_nq_num(sdp, jd->jd_jid, &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t\t  LM_FLAG_NOEXP | LM_FLAG_TRY | GL_NOCACHE,\n\t\t\t\t\t  &j_gh);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase GLR_TRYFAILED:\n\t\t\tfs_info(sdp, \"jid=%u: Busy\\n\", jd->jd_jid);\n\t\t\terror = 0;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t};\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_NOCACHE, &ji_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_j;\n\t} else {\n\t\tfs_info(sdp, \"jid=%u, already locked for use\\n\", jd->jd_jid);\n\t}\n\n\tfs_info(sdp, \"jid=%u: Looking at journal...\\n\", jd->jd_jid);\n\n\terror = gfs2_jdesc_check(jd);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tfs_info(sdp, \"jid=%u: Acquiring the transaction lock...\\n\",\n\t\t\tjd->jd_jid);\n\n\t\tt = jiffies;\n\n\t\t/* Acquire a shared hold on the freeze lock */\n\n\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | LM_FLAG_PRIORITY,\n\t\t\t\t\t   &thaw_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_ji;\n\n\t\tif (test_bit(SDF_RORECOVERY, &sdp->sd_flags)) {\n\t\t\tro = 1;\n\t\t} else if (test_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags)) {\n\t\t\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\t\t\tro = 1;\n\t\t} else {\n\t\t\tif (sdp->sd_vfs->s_flags & MS_RDONLY) {\n\t\t\t\t/* check if device itself is read-only */\n\t\t\t\tro = bdev_read_only(sdp->sd_vfs->s_bdev);\n\t\t\t\tif (!ro) {\n\t\t\t\t\tfs_info(sdp, \"recovery required on \"\n\t\t\t\t\t\t\"read-only filesystem.\\n\");\n\t\t\t\t\tfs_info(sdp, \"write access will be \"\n\t\t\t\t\t\t\"enabled during recovery.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ro) {\n\t\t\tfs_warn(sdp, \"jid=%u: Can't replay: read-only block \"\n\t\t\t\t\"device\\n\", jd->jd_jid);\n\t\t\terror = -EROFS;\n\t\t\tgoto fail_gunlock_thaw;\n\t\t}\n\n\t\tfs_info(sdp, \"jid=%u: Replaying journal...\\n\", jd->jd_jid);\n\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlops_before_scan(jd, &head, pass);\n\t\t\terror = foreach_descriptor(jd, head.lh_tail,\n\t\t\t\t\t\t   head.lh_blkno, pass);\n\t\t\tlops_after_scan(jd, error, pass);\n\t\t\tif (error)\n\t\t\t\tgoto fail_gunlock_thaw;\n\t\t}\n\n\t\terror = clean_journal(jd, &head);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_thaw;\n\n\t\tgfs2_glock_dq_uninit(&thaw_gh);\n\t\tt = DIV_ROUND_UP(jiffies - t, HZ);\n\t\tfs_info(sdp, \"jid=%u: Journal replayed in %lus\\n\",\n\t\t\tjd->jd_jid, t);\n\t}\n\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_SUCCESS);\n\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: Done\\n\", jd->jd_jid);\n\tgoto done;\n\nfail_gunlock_thaw:\n\tgfs2_glock_dq_uninit(&thaw_gh);\nfail_gunlock_ji:\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail_gunlock_j:\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: %s\\n\", jd->jd_jid, (error) ? \"Failed\" : \"Done\");\nfail:\n\tjd->jd_recover_error = error;\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_GAVEUP);\ndone:\n\tclear_bit(JDF_RECOVERY, &jd->jd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&jd->jd_flags, JDF_RECOVERY);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&jd->jd_flags",
            "JDF_RECOVERY"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "JDF_RECOVERY",
            "&jd->jd_flags"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_recovery_done",
          "args": [
            "sdp",
            "jd->jd_jid",
            "LM_RD_GAVEUP"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_recovery_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "432-449",
          "snippet": "static void gfs2_recovery_done(struct gfs2_sbd *sdp, unsigned int jid,\n                               unsigned int message)\n{\n\tchar env_jid[20];\n\tchar env_status[20];\n\tchar *envp[] = { env_jid, env_status, NULL };\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n        ls->ls_recover_jid_done = jid;\n        ls->ls_recover_jid_status = message;\n\tsprintf(env_jid, \"JID=%u\", jid);\n\tsprintf(env_status, \"RECOVERY=%s\",\n\t\tmessage == LM_RD_SUCCESS ? \"Done\" : \"Failed\");\n        kobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_recovery_result)\n\t\tsdp->sd_lockstruct.ls_ops->lm_recovery_result(sdp, jid, message);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void gfs2_recovery_done(struct gfs2_sbd *sdp, unsigned int jid,\n                               unsigned int message)\n{\n\tchar env_jid[20];\n\tchar env_status[20];\n\tchar *envp[] = { env_jid, env_status, NULL };\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n        ls->ls_recover_jid_done = jid;\n        ls->ls_recover_jid_status = message;\n\tsprintf(env_jid, \"JID=%u\", jid);\n\tsprintf(env_status, \"RECOVERY=%s\",\n\t\tmessage == LM_RD_SUCCESS ? \"Done\" : \"Failed\");\n        kobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_recovery_result)\n\t\tsdp->sd_lockstruct.ls_ops->lm_recovery_result(sdp, jid, message);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"jid=%u: %s\\n\"",
            "jd->jd_jid",
            "(error) ? \"Failed\" : \"Done\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&j_gh"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "jiffies - t",
            "HZ"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_journal",
          "args": [
            "jd",
            "&head"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "clean_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "381-429",
          "snippet": "static int clean_journal(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tunsigned int lblock;\n\tstruct gfs2_log_header *lh;\n\tu32 hash;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tlblock = head->lh_blkno;\n\tgfs2_replay_incr_blk(sdp, &lblock);\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, lblock, &bh_map, 0);\n\tif (error)\n\t\treturn error;\n\tif (!bh_map.b_blocknr) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\tbh = sb_getblk(sdp->sd_vfs, bh_map.b_blocknr);\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n\tunlock_buffer(bh);\n\n\tlh = (struct gfs2_log_header *)bh->b_data;\n\tmemset(lh, 0, sizeof(struct gfs2_log_header));\n\tlh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tlh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);\n\tlh->lh_header.__pad0 = cpu_to_be64(0);\n\tlh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);\n\tlh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlh->lh_sequence = cpu_to_be64(head->lh_sequence + 1);\n\tlh->lh_flags = cpu_to_be32(GFS2_LOG_HEAD_UNMOUNT);\n\tlh->lh_blkno = cpu_to_be32(lblock);\n\thash = gfs2_disk_hash((const char *)lh, sizeof(struct gfs2_log_header));\n\tlh->lh_hash = cpu_to_be32(hash);\n\n\tset_buffer_dirty(bh);\n\tif (sync_dirty_buffer(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbrelse(bh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int clean_journal(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tunsigned int lblock;\n\tstruct gfs2_log_header *lh;\n\tu32 hash;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tlblock = head->lh_blkno;\n\tgfs2_replay_incr_blk(sdp, &lblock);\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, lblock, &bh_map, 0);\n\tif (error)\n\t\treturn error;\n\tif (!bh_map.b_blocknr) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\tbh = sb_getblk(sdp->sd_vfs, bh_map.b_blocknr);\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n\tunlock_buffer(bh);\n\n\tlh = (struct gfs2_log_header *)bh->b_data;\n\tmemset(lh, 0, sizeof(struct gfs2_log_header));\n\tlh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tlh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);\n\tlh->lh_header.__pad0 = cpu_to_be64(0);\n\tlh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);\n\tlh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlh->lh_sequence = cpu_to_be64(head->lh_sequence + 1);\n\tlh->lh_flags = cpu_to_be32(GFS2_LOG_HEAD_UNMOUNT);\n\tlh->lh_blkno = cpu_to_be32(lblock);\n\thash = gfs2_disk_hash((const char *)lh, sizeof(struct gfs2_log_header));\n\tlh->lh_hash = cpu_to_be32(hash);\n\n\tset_buffer_dirty(bh);\n\tif (sync_dirty_buffer(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbrelse(bh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lops_after_scan",
          "args": [
            "jd",
            "error",
            "pass"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "lops_after_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lops.h",
          "lines": "94-101",
          "snippet": "static inline void lops_after_scan(struct gfs2_jdesc *jd, int error,\n\t\t\t\t   unsigned int pass)\n{\n\tint x;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_before_scan)\n\t\t\tgfs2_log_ops[x]->lo_after_scan(jd, error, pass);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/list.h>\n\nstatic inline void lops_after_scan(struct gfs2_jdesc *jd, int error,\n\t\t\t\t   unsigned int pass)\n{\n\tint x;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_before_scan)\n\t\t\tgfs2_log_ops[x]->lo_after_scan(jd, error, pass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "foreach_descriptor",
          "args": [
            "jd",
            "head.lh_tail",
            "head.lh_blkno",
            "pass"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "foreach_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "313-369",
          "snippet": "static int foreach_descriptor(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t      unsigned int end, int pass)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_descriptor *ld;\n\tint error = 0;\n\tu32 length;\n\t__be64 *ptr;\n\tunsigned int offset = sizeof(struct gfs2_log_descriptor);\n\toffset += sizeof(__be64) - 1;\n\toffset &= ~(sizeof(__be64) - 1);\n\n\twhile (start != end) {\n\t\terror = gfs2_replay_read_block(jd, start, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (gfs2_meta_check(sdp, bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tld = (struct gfs2_log_descriptor *)bh->b_data;\n\t\tlength = be32_to_cpu(ld->ld_length);\n\n\t\tif (be32_to_cpu(ld->ld_header.mh_type) == GFS2_METATYPE_LH) {\n\t\t\tstruct gfs2_log_header_host lh;\n\t\t\terror = get_log_header(jd, start, &lh);\n\t\t\tif (!error) {\n\t\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 1) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\t\terror = -EIO;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t} else if (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_LD)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tptr = (__be64 *)(bh->b_data + offset);\n\t\terror = lops_scan_elements(jd, start, ld, ptr, pass);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (length--)\n\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int foreach_descriptor(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t      unsigned int end, int pass)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_descriptor *ld;\n\tint error = 0;\n\tu32 length;\n\t__be64 *ptr;\n\tunsigned int offset = sizeof(struct gfs2_log_descriptor);\n\toffset += sizeof(__be64) - 1;\n\toffset &= ~(sizeof(__be64) - 1);\n\n\twhile (start != end) {\n\t\terror = gfs2_replay_read_block(jd, start, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (gfs2_meta_check(sdp, bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tld = (struct gfs2_log_descriptor *)bh->b_data;\n\t\tlength = be32_to_cpu(ld->ld_length);\n\n\t\tif (be32_to_cpu(ld->ld_header.mh_type) == GFS2_METATYPE_LH) {\n\t\t\tstruct gfs2_log_header_host lh;\n\t\t\terror = get_log_header(jd, start, &lh);\n\t\t\tif (!error) {\n\t\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 1) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\t\terror = -EIO;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t} else if (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_LD)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tptr = (__be64 *)(bh->b_data + offset);\n\t\terror = lops_scan_elements(jd, start, ld, ptr, pass);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (length--)\n\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lops_before_scan",
          "args": [
            "jd",
            "&head",
            "pass"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "lops_before_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lops.h",
          "lines": "67-75",
          "snippet": "static inline void lops_before_scan(struct gfs2_jdesc *jd,\n\t\t\t\t    struct gfs2_log_header_host *head,\n\t\t\t\t    unsigned int pass)\n{\n\tint x;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_before_scan)\n\t\t\tgfs2_log_ops[x]->lo_before_scan(jd, head, pass);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/list.h>\n\nstatic inline void lops_before_scan(struct gfs2_jdesc *jd,\n\t\t\t\t    struct gfs2_log_header_host *head,\n\t\t\t\t    unsigned int pass)\n{\n\tint x;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_before_scan)\n\t\t\tgfs2_log_ops[x]->lo_before_scan(jd, head, pass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"jid=%u: Can't replay: read-only block \"\n\t\t\t\t\"device\\n\"",
            "jd->jd_jid"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"write access will be \"\n\t\t\t\t\t\t\"enabled during recovery.\\n\""
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sdp->sd_vfs->s_bdev"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_JOURNAL_LIVE",
            "&sdp->sd_flags"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "sdp->sd_freeze_gl",
            "LM_ST_SHARED",
            "LM_FLAG_NOEXP | LM_FLAG_PRIORITY",
            "&thaw_gh"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_find_jhead",
          "args": [
            "jd",
            "&head"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_find_jhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "263-299",
          "snippet": "int gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_jdesc_check",
          "args": [
            "jd"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_jdesc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "346-363",
          "snippet": "int gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nint gfs2_jdesc_check(struct gfs2_jdesc *jd)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tu64 size = i_size_read(jd->jd_inode);\n\n\tif (gfs2_check_internal_file_size(jd->jd_inode, 8 << 20, 1 << 30))\n\t\treturn -EIO;\n\n\tjd->jd_blocks = size >> sdp->sd_sb.sb_bsize_shift;\n\n\tif (gfs2_write_alloc_required(ip, 0, size)) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_num",
          "args": [
            "sdp",
            "jd->jd_jid",
            "&gfs2_journal_glops",
            "LM_ST_EXCLUSIVE",
            "LM_FLAG_NOEXP | LM_FLAG_TRY | GL_NOCACHE",
            "&j_gh"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1128-1142",
          "snippet": "int gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_num(struct gfs2_sbd *sdp, u64 number,\n\t\t      const struct gfs2_glock_operations *glops,\n\t\t      unsigned int state, int flags, struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl;\n\tint error;\n\n\terror = gfs2_glock_get(sdp, number, glops, CREATE, &gl);\n\tif (!error) {\n\t\terror = gfs2_glock_nq_init(gl, state, flags, gh);\n\t\tgfs2_glock_put(gl);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "jd->jd_inode"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structgfs2_jdesc",
            "jd_work"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid gfs2_recover_func(struct work_struct *work)\n{\n\tstruct gfs2_jdesc *jd = container_of(work, struct gfs2_jdesc, jd_work);\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct gfs2_log_header_host head;\n\tstruct gfs2_holder j_gh, ji_gh, thaw_gh;\n\tunsigned long t;\n\tint ro = 0;\n\tunsigned int pass;\n\tint error;\n\tint jlocked = 0;\n\n\tif (sdp->sd_args.ar_spectator ||\n\t    (jd->jd_jid != sdp->sd_lockstruct.ls_jid)) {\n\t\tfs_info(sdp, \"jid=%u: Trying to acquire journal lock...\\n\",\n\t\t\tjd->jd_jid);\n\t\tjlocked = 1;\n\t\t/* Acquire the journal lock so we can do recovery */\n\n\t\terror = gfs2_glock_nq_num(sdp, jd->jd_jid, &gfs2_journal_glops,\n\t\t\t\t\t  LM_ST_EXCLUSIVE,\n\t\t\t\t\t  LM_FLAG_NOEXP | LM_FLAG_TRY | GL_NOCACHE,\n\t\t\t\t\t  &j_gh);\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase GLR_TRYFAILED:\n\t\t\tfs_info(sdp, \"jid=%u: Busy\\n\", jd->jd_jid);\n\t\t\terror = 0;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t};\n\n\t\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | GL_NOCACHE, &ji_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_j;\n\t} else {\n\t\tfs_info(sdp, \"jid=%u, already locked for use\\n\", jd->jd_jid);\n\t}\n\n\tfs_info(sdp, \"jid=%u: Looking at journal...\\n\", jd->jd_jid);\n\n\terror = gfs2_jdesc_check(jd);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\terror = gfs2_find_jhead(jd, &head);\n\tif (error)\n\t\tgoto fail_gunlock_ji;\n\n\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {\n\t\tfs_info(sdp, \"jid=%u: Acquiring the transaction lock...\\n\",\n\t\t\tjd->jd_jid);\n\n\t\tt = jiffies;\n\n\t\t/* Acquire a shared hold on the freeze lock */\n\n\t\terror = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED,\n\t\t\t\t\t   LM_FLAG_NOEXP | LM_FLAG_PRIORITY,\n\t\t\t\t\t   &thaw_gh);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_ji;\n\n\t\tif (test_bit(SDF_RORECOVERY, &sdp->sd_flags)) {\n\t\t\tro = 1;\n\t\t} else if (test_bit(SDF_JOURNAL_CHECKED, &sdp->sd_flags)) {\n\t\t\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\t\t\tro = 1;\n\t\t} else {\n\t\t\tif (sdp->sd_vfs->s_flags & MS_RDONLY) {\n\t\t\t\t/* check if device itself is read-only */\n\t\t\t\tro = bdev_read_only(sdp->sd_vfs->s_bdev);\n\t\t\t\tif (!ro) {\n\t\t\t\t\tfs_info(sdp, \"recovery required on \"\n\t\t\t\t\t\t\"read-only filesystem.\\n\");\n\t\t\t\t\tfs_info(sdp, \"write access will be \"\n\t\t\t\t\t\t\"enabled during recovery.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ro) {\n\t\t\tfs_warn(sdp, \"jid=%u: Can't replay: read-only block \"\n\t\t\t\t\"device\\n\", jd->jd_jid);\n\t\t\terror = -EROFS;\n\t\t\tgoto fail_gunlock_thaw;\n\t\t}\n\n\t\tfs_info(sdp, \"jid=%u: Replaying journal...\\n\", jd->jd_jid);\n\n\t\tfor (pass = 0; pass < 2; pass++) {\n\t\t\tlops_before_scan(jd, &head, pass);\n\t\t\terror = foreach_descriptor(jd, head.lh_tail,\n\t\t\t\t\t\t   head.lh_blkno, pass);\n\t\t\tlops_after_scan(jd, error, pass);\n\t\t\tif (error)\n\t\t\t\tgoto fail_gunlock_thaw;\n\t\t}\n\n\t\terror = clean_journal(jd, &head);\n\t\tif (error)\n\t\t\tgoto fail_gunlock_thaw;\n\n\t\tgfs2_glock_dq_uninit(&thaw_gh);\n\t\tt = DIV_ROUND_UP(jiffies - t, HZ);\n\t\tfs_info(sdp, \"jid=%u: Journal replayed in %lus\\n\",\n\t\t\tjd->jd_jid, t);\n\t}\n\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_SUCCESS);\n\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: Done\\n\", jd->jd_jid);\n\tgoto done;\n\nfail_gunlock_thaw:\n\tgfs2_glock_dq_uninit(&thaw_gh);\nfail_gunlock_ji:\n\tif (jlocked) {\n\t\tgfs2_glock_dq_uninit(&ji_gh);\nfail_gunlock_j:\n\t\tgfs2_glock_dq_uninit(&j_gh);\n\t}\n\n\tfs_info(sdp, \"jid=%u: %s\\n\", jd->jd_jid, (error) ? \"Failed\" : \"Done\");\nfail:\n\tjd->jd_recover_error = error;\n\tgfs2_recovery_done(sdp, jd->jd_jid, LM_RD_GAVEUP);\ndone:\n\tclear_bit(JDF_RECOVERY, &jd->jd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&jd->jd_flags, JDF_RECOVERY);\n}"
  },
  {
    "function_name": "gfs2_recovery_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "432-449",
    "snippet": "static void gfs2_recovery_done(struct gfs2_sbd *sdp, unsigned int jid,\n                               unsigned int message)\n{\n\tchar env_jid[20];\n\tchar env_status[20];\n\tchar *envp[] = { env_jid, env_status, NULL };\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n        ls->ls_recover_jid_done = jid;\n        ls->ls_recover_jid_status = message;\n\tsprintf(env_jid, \"JID=%u\", jid);\n\tsprintf(env_status, \"RECOVERY=%s\",\n\t\tmessage == LM_RD_SUCCESS ? \"Done\" : \"Failed\");\n        kobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_recovery_result)\n\t\tsdp->sd_lockstruct.ls_ops->lm_recovery_result(sdp, jid, message);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sdp->sd_lockstruct.ls_ops->lm_recovery_result",
          "args": [
            "sdp",
            "jid",
            "message"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_uevent_env",
          "args": [
            "&sdp->sd_kobj",
            "KOBJ_CHANGE",
            "envp"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "env_status",
            "\"RECOVERY=%s\"",
            "message == LM_RD_SUCCESS ? \"Done\" : \"Failed\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "env_jid",
            "\"JID=%u\"",
            "jid"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic void gfs2_recovery_done(struct gfs2_sbd *sdp, unsigned int jid,\n                               unsigned int message)\n{\n\tchar env_jid[20];\n\tchar env_status[20];\n\tchar *envp[] = { env_jid, env_status, NULL };\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n        ls->ls_recover_jid_done = jid;\n        ls->ls_recover_jid_status = message;\n\tsprintf(env_jid, \"JID=%u\", jid);\n\tsprintf(env_status, \"RECOVERY=%s\",\n\t\tmessage == LM_RD_SUCCESS ? \"Done\" : \"Failed\");\n        kobject_uevent_env(&sdp->sd_kobj, KOBJ_CHANGE, envp);\n\n\tif (sdp->sd_lockstruct.ls_ops->lm_recovery_result)\n\t\tsdp->sd_lockstruct.ls_ops->lm_recovery_result(sdp, jid, message);\n}"
  },
  {
    "function_name": "clean_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "381-429",
    "snippet": "static int clean_journal(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tunsigned int lblock;\n\tstruct gfs2_log_header *lh;\n\tu32 hash;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tlblock = head->lh_blkno;\n\tgfs2_replay_incr_blk(sdp, &lblock);\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, lblock, &bh_map, 0);\n\tif (error)\n\t\treturn error;\n\tif (!bh_map.b_blocknr) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\tbh = sb_getblk(sdp->sd_vfs, bh_map.b_blocknr);\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n\tunlock_buffer(bh);\n\n\tlh = (struct gfs2_log_header *)bh->b_data;\n\tmemset(lh, 0, sizeof(struct gfs2_log_header));\n\tlh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tlh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);\n\tlh->lh_header.__pad0 = cpu_to_be64(0);\n\tlh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);\n\tlh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlh->lh_sequence = cpu_to_be64(head->lh_sequence + 1);\n\tlh->lh_flags = cpu_to_be32(GFS2_LOG_HEAD_UNMOUNT);\n\tlh->lh_blkno = cpu_to_be32(lblock);\n\thash = gfs2_disk_hash((const char *)lh, sizeof(struct gfs2_log_header));\n\tlh->lh_hash = cpu_to_be32(hash);\n\n\tset_buffer_dirty(bh);\n\tif (sync_dirty_buffer(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbrelse(bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_io_error_bh",
          "args": [
            "sdp",
            "bh"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "hash"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_disk_hash",
          "args": [
            "(const char *)lh",
            "sizeof(struct gfs2_log_header)"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_disk_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.h",
          "lines": "57-60",
          "snippet": "static inline u32 gfs2_disk_hash(const char *data, int len)\n{\n        return crc32_le((u32)~0, data, len) ^ (u32)~0;\n}",
          "includes": [
            "#include <linux/crc32.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crc32.h>\n#include <linux/dcache.h>\n\nstatic inline u32 gfs2_disk_hash(const char *data, int len)\n{\n        return crc32_le((u32)~0, data, len) ^ (u32)~0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lblock"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_LOG_HEAD_UNMOUNT"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "head->lh_sequence + 1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sdp->sd_jdesc->jd_jid"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_FORMAT_LH"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_METATYPE_LH"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lh",
            "0",
            "sizeof(struct gfs2_log_header)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "bh->b_size"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sdp->sd_vfs",
            "bh_map.b_blocknr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_block_map",
          "args": [
            "&ip->i_inode",
            "lblock",
            "&bh_map",
            "0"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "603-677",
          "snippet": "int gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_block_map(struct inode *inode, sector_t lblock,\n\t\t   struct buffer_head *bh_map, int create)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tunsigned int bsize = sdp->sd_sb.sb_bsize;\n\tconst size_t maxlen = bh_map->b_size >> inode->i_blkbits;\n\tconst u64 *arr = sdp->sd_heightsize;\n\t__be64 *ptr;\n\tu64 size;\n\tstruct metapath mp;\n\tint ret;\n\tint eob;\n\tunsigned int len;\n\tstruct buffer_head *bh;\n\tu8 height;\n\n\tBUG_ON(maxlen == 0);\n\n\tmemset(mp.mp_bh, 0, sizeof(mp.mp_bh));\n\tbmap_lock(ip, create);\n\tclear_buffer_mapped(bh_map);\n\tclear_buffer_new(bh_map);\n\tclear_buffer_boundary(bh_map);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, 1);\n\tif (gfs2_is_dir(ip)) {\n\t\tbsize = sdp->sd_jbsize;\n\t\tarr = sdp->sd_jheightsize;\n\t}\n\n\tret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);\n\tif (ret)\n\t\tgoto out;\n\n\theight = ip->i_height;\n\tsize = (lblock + 1) * bsize;\n\twhile (size > arr[height])\n\t\theight++;\n\tfind_metapath(sdp, lblock, &mp, height);\n\tret = 1;\n\tif (height > ip->i_height || gfs2_is_stuffed(ip))\n\t\tgoto do_alloc;\n\tret = lookup_metapath(ip, &mp);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret != ip->i_height)\n\t\tgoto do_alloc;\n\tptr = metapointer(ip->i_height - 1, &mp);\n\tif (*ptr == 0)\n\t\tgoto do_alloc;\n\tmap_bh(bh_map, inode->i_sb, be64_to_cpu(*ptr));\n\tbh = mp.mp_bh[ip->i_height - 1];\n\tlen = gfs2_extent_length(bh->b_data, bh->b_size, ptr, maxlen, &eob);\n\tbh_map->b_size = (len << inode->i_blkbits);\n\tif (eob)\n\t\tset_buffer_boundary(bh_map);\n\tret = 0;\nout:\n\trelease_metapath(&mp);\n\ttrace_gfs2_bmap(ip, bh_map, lblock, create, ret);\n\tbmap_unlock(ip, create);\n\treturn ret;\n\ndo_alloc:\n\t/* All allocations are done here, firstly check create flag */\n\tif (!create) {\n\t\tBUG_ON(gfs2_is_stuffed(ip));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* At this point ret is the tree depth of already allocated blocks */\n\tret = gfs2_bmap_alloc(inode, lblock, bh_map, &mp, ret, height, maxlen);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_replay_incr_blk",
          "args": [
            "sdp",
            "&lblock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_replay_incr_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.h",
          "lines": "17-21",
          "snippet": "static inline void gfs2_replay_incr_blk(struct gfs2_sbd *sdp, unsigned int *blk)\n{\n\tif (++*blk == sdp->sd_jdesc->jd_blocks)\n\t        *blk = 0;\n}",
          "includes": [
            "#include \"incore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n\nstatic inline void gfs2_replay_incr_blk(struct gfs2_sbd *sdp, unsigned int *blk)\n{\n\tif (++*blk == sdp->sd_jdesc->jd_blocks)\n\t        *blk = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "jd->jd_inode"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int clean_journal(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tunsigned int lblock;\n\tstruct gfs2_log_header *lh;\n\tu32 hash;\n\tstruct buffer_head *bh;\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tlblock = head->lh_blkno;\n\tgfs2_replay_incr_blk(sdp, &lblock);\n\tbh_map.b_size = 1 << ip->i_inode.i_blkbits;\n\terror = gfs2_block_map(&ip->i_inode, lblock, &bh_map, 0);\n\tif (error)\n\t\treturn error;\n\tif (!bh_map.b_blocknr) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\tbh = sb_getblk(sdp->sd_vfs, bh_map.b_blocknr);\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, bh->b_size);\n\tset_buffer_uptodate(bh);\n\tclear_buffer_dirty(bh);\n\tunlock_buffer(bh);\n\n\tlh = (struct gfs2_log_header *)bh->b_data;\n\tmemset(lh, 0, sizeof(struct gfs2_log_header));\n\tlh->lh_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tlh->lh_header.mh_type = cpu_to_be32(GFS2_METATYPE_LH);\n\tlh->lh_header.__pad0 = cpu_to_be64(0);\n\tlh->lh_header.mh_format = cpu_to_be32(GFS2_FORMAT_LH);\n\tlh->lh_header.mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlh->lh_sequence = cpu_to_be64(head->lh_sequence + 1);\n\tlh->lh_flags = cpu_to_be32(GFS2_LOG_HEAD_UNMOUNT);\n\tlh->lh_blkno = cpu_to_be32(lblock);\n\thash = gfs2_disk_hash((const char *)lh, sizeof(struct gfs2_log_header));\n\tlh->lh_hash = cpu_to_be32(hash);\n\n\tset_buffer_dirty(bh);\n\tif (sync_dirty_buffer(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbrelse(bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "foreach_descriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "313-369",
    "snippet": "static int foreach_descriptor(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t      unsigned int end, int pass)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_descriptor *ld;\n\tint error = 0;\n\tu32 length;\n\t__be64 *ptr;\n\tunsigned int offset = sizeof(struct gfs2_log_descriptor);\n\toffset += sizeof(__be64) - 1;\n\toffset &= ~(sizeof(__be64) - 1);\n\n\twhile (start != end) {\n\t\terror = gfs2_replay_read_block(jd, start, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (gfs2_meta_check(sdp, bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tld = (struct gfs2_log_descriptor *)bh->b_data;\n\t\tlength = be32_to_cpu(ld->ld_length);\n\n\t\tif (be32_to_cpu(ld->ld_header.mh_type) == GFS2_METATYPE_LH) {\n\t\t\tstruct gfs2_log_header_host lh;\n\t\t\terror = get_log_header(jd, start, &lh);\n\t\t\tif (!error) {\n\t\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 1) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\t\terror = -EIO;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t} else if (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_LD)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tptr = (__be64 *)(bh->b_data + offset);\n\t\terror = lops_scan_elements(jd, start, ld, ptr, pass);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (length--)\n\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_replay_incr_blk",
          "args": [
            "sdp",
            "&start"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_replay_incr_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.h",
          "lines": "17-21",
          "snippet": "static inline void gfs2_replay_incr_blk(struct gfs2_sbd *sdp, unsigned int *blk)\n{\n\tif (++*blk == sdp->sd_jdesc->jd_blocks)\n\t        *blk = 0;\n}",
          "includes": [
            "#include \"incore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n\nstatic inline void gfs2_replay_incr_blk(struct gfs2_sbd *sdp, unsigned int *blk)\n{\n\tif (++*blk == sdp->sd_jdesc->jd_blocks)\n\t        *blk = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lops_scan_elements",
          "args": [
            "jd",
            "start",
            "ld",
            "ptr",
            "pass"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "lops_scan_elements",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lops.h",
          "lines": "77-92",
          "snippet": "static inline int lops_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t\t     struct gfs2_log_descriptor *ld,\n\t\t\t\t     __be64 *ptr,\n\t\t\t\t     unsigned int pass)\n{\n\tint x, error;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_scan_elements) {\n\t\t\terror = gfs2_log_ops[x]->lo_scan_elements(jd, start,\n\t\t\t\t\t\t\t\t  ld, ptr, pass);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/list.h>\n\nstatic inline int lops_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t\t     struct gfs2_log_descriptor *ld,\n\t\t\t\t     __be64 *ptr,\n\t\t\t\t     unsigned int pass)\n{\n\tint x, error;\n\tfor (x = 0; gfs2_log_ops[x]; x++)\n\t\tif (gfs2_log_ops[x]->lo_scan_elements) {\n\t\t\terror = gfs2_log_ops[x]->lo_scan_elements(jd, start,\n\t\t\t\t\t\t\t\t  ld, ptr, pass);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bh",
            "GFS2_METATYPE_LD"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "GFS2_I(jd->jd_inode)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_log_header",
          "args": [
            "jd",
            "start",
            "&lh"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "get_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "150-176",
          "snippet": "static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ld->ld_header.mh_type"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ld->ld_length"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_check",
          "args": [
            "sdp",
            "bh"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "83-94",
          "snippet": "static inline int gfs2_meta_check(struct gfs2_sbd *sdp,\n\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;\n\tu32 magic = be32_to_cpu(mh->mh_magic);\n\tif (unlikely(magic != GFS2_MAGIC)) {\n\t\tpr_err(\"Magic number missing at %llu\\n\",\n\t\t       (unsigned long long)bh->b_blocknr);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline int gfs2_meta_check(struct gfs2_sbd *sdp,\n\t\t\t\t    struct buffer_head *bh)\n{\n\tstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;\n\tu32 magic = be32_to_cpu(mh->mh_magic);\n\tif (unlikely(magic != GFS2_MAGIC)) {\n\t\tpr_err(\"Magic number missing at %llu\\n\",\n\t\t       (unsigned long long)bh->b_blocknr);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_replay_read_block",
          "args": [
            "jd",
            "start",
            "&bh"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_replay_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "32-53",
          "snippet": "int gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "jd->jd_inode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int foreach_descriptor(struct gfs2_jdesc *jd, unsigned int start,\n\t\t\t      unsigned int end, int pass)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_descriptor *ld;\n\tint error = 0;\n\tu32 length;\n\t__be64 *ptr;\n\tunsigned int offset = sizeof(struct gfs2_log_descriptor);\n\toffset += sizeof(__be64) - 1;\n\toffset &= ~(sizeof(__be64) - 1);\n\n\twhile (start != end) {\n\t\terror = gfs2_replay_read_block(jd, start, &bh);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (gfs2_meta_check(sdp, bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tld = (struct gfs2_log_descriptor *)bh->b_data;\n\t\tlength = be32_to_cpu(ld->ld_length);\n\n\t\tif (be32_to_cpu(ld->ld_header.mh_type) == GFS2_METATYPE_LH) {\n\t\t\tstruct gfs2_log_header_host lh;\n\t\t\terror = get_log_header(jd, start, &lh);\n\t\t\tif (!error) {\n\t\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error == 1) {\n\t\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\t\terror = -EIO;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t} else if (gfs2_metatype_check(sdp, bh, GFS2_METATYPE_LD)) {\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tptr = (__be64 *)(bh->b_data + offset);\n\t\terror = lops_scan_elements(jd, start, ld, ptr, pass);\n\t\tif (error) {\n\t\t\tbrelse(bh);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (length--)\n\t\t\tgfs2_replay_incr_blk(sdp, &start);\n\n\t\tbrelse(bh);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_find_jhead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "263-299",
    "snippet": "int gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhead_scan",
          "args": [
            "jd",
            "&lh_1"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "jhead_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "223-250",
          "snippet": "static int jhead_scan(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tunsigned int blk = head->lh_blkno;\n\tstruct gfs2_log_header_host lh;\n\tint error;\n\n\tfor (;;) {\n\t\tif (++blk == jd->jd_blocks)\n\t\t\tblk = 0;\n\n\t\terror = get_log_header(jd, blk, &lh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 1)\n\t\t\tcontinue;\n\n\t\tif (lh.lh_sequence == head->lh_sequence) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (lh.lh_sequence < head->lh_sequence)\n\t\t\tbreak;\n\n\t\t*head = lh;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int jhead_scan(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tunsigned int blk = head->lh_blkno;\n\tstruct gfs2_log_header_host lh;\n\tint error;\n\n\tfor (;;) {\n\t\tif (++blk == jd->jd_blocks)\n\t\t\tblk = 0;\n\n\t\terror = get_log_header(jd, blk, &lh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 1)\n\t\t\tcontinue;\n\n\t\tif (lh.lh_sequence == head->lh_sequence) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (lh.lh_sequence < head->lh_sequence)\n\t\t\tbreak;\n\n\t\t*head = lh;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_good_lh",
          "args": [
            "jd",
            "&blk_m",
            "&lh_m"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "find_good_lh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "191-210",
          "snippet": "static int find_good_lh(struct gfs2_jdesc *jd, unsigned int *blk,\n\t\t\tstruct gfs2_log_header_host *head)\n{\n\tunsigned int orig_blk = *blk;\n\tint error;\n\n\tfor (;;) {\n\t\terror = get_log_header(jd, *blk, head);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\n\t\tif (++*blk == jd->jd_blocks)\n\t\t\t*blk = 0;\n\n\t\tif (*blk == orig_blk) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int find_good_lh(struct gfs2_jdesc *jd, unsigned int *blk,\n\t\t\tstruct gfs2_log_header_host *head)\n{\n\tunsigned int orig_blk = *blk;\n\tint error;\n\n\tfor (;;) {\n\t\terror = get_log_header(jd, *blk, head);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\n\t\tif (++*blk == jd->jd_blocks)\n\t\t\t*blk = 0;\n\n\t\tif (*blk == orig_blk) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "jhead_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "223-250",
    "snippet": "static int jhead_scan(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tunsigned int blk = head->lh_blkno;\n\tstruct gfs2_log_header_host lh;\n\tint error;\n\n\tfor (;;) {\n\t\tif (++blk == jd->jd_blocks)\n\t\t\tblk = 0;\n\n\t\terror = get_log_header(jd, blk, &lh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 1)\n\t\t\tcontinue;\n\n\t\tif (lh.lh_sequence == head->lh_sequence) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (lh.lh_sequence < head->lh_sequence)\n\t\t\tbreak;\n\n\t\t*head = lh;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "GFS2_I(jd->jd_inode)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_log_header",
          "args": [
            "jd",
            "blk",
            "&lh"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "get_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "150-176",
          "snippet": "static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int jhead_scan(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tunsigned int blk = head->lh_blkno;\n\tstruct gfs2_log_header_host lh;\n\tint error;\n\n\tfor (;;) {\n\t\tif (++blk == jd->jd_blocks)\n\t\t\tblk = 0;\n\n\t\terror = get_log_header(jd, blk, &lh);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 1)\n\t\t\tcontinue;\n\n\t\tif (lh.lh_sequence == head->lh_sequence) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (lh.lh_sequence < head->lh_sequence)\n\t\t\tbreak;\n\n\t\t*head = lh;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_good_lh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "191-210",
    "snippet": "static int find_good_lh(struct gfs2_jdesc *jd, unsigned int *blk,\n\t\t\tstruct gfs2_log_header_host *head)\n{\n\tunsigned int orig_blk = *blk;\n\tint error;\n\n\tfor (;;) {\n\t\terror = get_log_header(jd, *blk, head);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\n\t\tif (++*blk == jd->jd_blocks)\n\t\t\t*blk = 0;\n\n\t\tif (*blk == orig_blk) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "GFS2_I(jd->jd_inode)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_log_header",
          "args": [
            "jd",
            "*blk",
            "head"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "get_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "150-176",
          "snippet": "static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int find_good_lh(struct gfs2_jdesc *jd, unsigned int *blk,\n\t\t\tstruct gfs2_log_header_host *head)\n{\n\tunsigned int orig_blk = *blk;\n\tint error;\n\n\tfor (;;) {\n\t\terror = get_log_header(jd, *blk, head);\n\t\tif (error <= 0)\n\t\t\treturn error;\n\n\t\tif (++*blk == jd->jd_blocks)\n\t\t\t*blk = 0;\n\n\t\tif (*blk == orig_blk) {\n\t\t\tgfs2_consist_inode(GFS2_I(jd->jd_inode));\n\t\t\treturn -EIO;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_log_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "150-176",
    "snippet": "static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_header_in",
          "args": [
            "&lh",
            "bh->b_data"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_header_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "120-134",
          "snippet": "static int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)\n{\n\tconst struct gfs2_log_header *str = buf;\n\n\tif (str->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||\n\t    str->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH))\n\t\treturn 1;\n\n\tlh->lh_sequence = be64_to_cpu(str->lh_sequence);\n\tlh->lh_flags = be32_to_cpu(str->lh_flags);\n\tlh->lh_tail = be32_to_cpu(str->lh_tail);\n\tlh->lh_blkno = be32_to_cpu(str->lh_blkno);\n\tlh->lh_hash = be32_to_cpu(str->lh_hash);\n\treturn 0;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)\n{\n\tconst struct gfs2_log_header *str = buf;\n\n\tif (str->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||\n\t    str->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH))\n\t\treturn 1;\n\n\tlh->lh_sequence = be64_to_cpu(str->lh_sequence);\n\tlh->lh_flags = be32_to_cpu(str->lh_flags);\n\tlh->lh_tail = be32_to_cpu(str->lh_tail);\n\tlh->lh_blkno = be32_to_cpu(str->lh_blkno);\n\tlh->lh_hash = be32_to_cpu(str->lh_hash);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "hash",
            "(unsigned char const *)&nothing",
            "sizeof(nothing)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "(u32)~0",
            "bh->b_data",
            "sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_replay_read_block",
          "args": [
            "jd",
            "blk",
            "&bh"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_replay_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "32-53",
          "snippet": "int gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t  struct gfs2_log_header_host *head)\n{\n\tstruct buffer_head *bh;\n\tstruct gfs2_log_header_host uninitialized_var(lh);\n\tconst u32 nothing = 0;\n\tu32 hash;\n\tint error;\n\n\terror = gfs2_replay_read_block(jd, blk, &bh);\n\tif (error)\n\t\treturn error;\n\n\thash = crc32_le((u32)~0, bh->b_data, sizeof(struct gfs2_log_header) -\n\t\t\t\t\t     sizeof(u32));\n\thash = crc32_le(hash, (unsigned char const *)&nothing, sizeof(nothing));\n\thash ^= (u32)~0;\n\terror = gfs2_log_header_in(&lh, bh->b_data);\n\tbrelse(bh);\n\n\tif (error || lh.lh_blkno != blk || lh.lh_hash != hash)\n\t\treturn 1;\n\n\t*head = lh;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_log_header_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "120-134",
    "snippet": "static int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)\n{\n\tconst struct gfs2_log_header *str = buf;\n\n\tif (str->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||\n\t    str->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH))\n\t\treturn 1;\n\n\tlh->lh_sequence = be64_to_cpu(str->lh_sequence);\n\tlh->lh_flags = be32_to_cpu(str->lh_flags);\n\tlh->lh_tail = be32_to_cpu(str->lh_tail);\n\tlh->lh_blkno = be32_to_cpu(str->lh_blkno);\n\tlh->lh_hash = be32_to_cpu(str->lh_hash);\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->lh_hash"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->lh_blkno"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->lh_tail"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->lh_flags"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->lh_sequence"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_METATYPE_LH"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int gfs2_log_header_in(struct gfs2_log_header_host *lh, const void *buf)\n{\n\tconst struct gfs2_log_header *str = buf;\n\n\tif (str->lh_header.mh_magic != cpu_to_be32(GFS2_MAGIC) ||\n\t    str->lh_header.mh_type != cpu_to_be32(GFS2_METATYPE_LH))\n\t\treturn 1;\n\n\tlh->lh_sequence = be64_to_cpu(str->lh_sequence);\n\tlh->lh_flags = be32_to_cpu(str->lh_flags);\n\tlh->lh_tail = be32_to_cpu(str->lh_tail);\n\tlh->lh_blkno = be32_to_cpu(str->lh_blkno);\n\tlh->lh_hash = be32_to_cpu(str->lh_hash);\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_revoke_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "108-118",
    "snippet": "void gfs2_revoke_clean(struct gfs2_jdesc *jd)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr;\n\n\twhile (!list_empty(head)) {\n\t\trr = list_entry(head->next, struct gfs2_revoke_replay, rr_list);\n\t\tlist_del(&rr->rr_list);\n\t\tkfree(rr);\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rr"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rr->rr_list"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structgfs2_revoke_replay",
            "rr_list"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid gfs2_revoke_clean(struct gfs2_jdesc *jd)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr;\n\n\twhile (!list_empty(head)) {\n\t\trr = list_entry(head->next, struct gfs2_revoke_replay, rr_list);\n\t\tlist_del(&rr->rr_list);\n\t\tkfree(rr);\n\t}\n}"
  },
  {
    "function_name": "gfs2_revoke_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "84-106",
    "snippet": "int gfs2_revoke_check(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct gfs2_revoke_replay *rr;\n\tint wrap, a, b, revoke;\n\tint found = 0;\n\n\tlist_for_each_entry(rr, &jd->jd_revoke_list, rr_list) {\n\t\tif (rr->rr_blkno == blkno) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\twrap = (rr->rr_where < jd->jd_replay_tail);\n\ta = (jd->jd_replay_tail < where);\n\tb = (where < rr->rr_where);\n\trevoke = (wrap) ? (a || b) : (a && b);\n\n\treturn revoke;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rr",
            "&jd->jd_revoke_list",
            "rr_list"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_revoke_check(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct gfs2_revoke_replay *rr;\n\tint wrap, a, b, revoke;\n\tint found = 0;\n\n\tlist_for_each_entry(rr, &jd->jd_revoke_list, rr_list) {\n\t\tif (rr->rr_blkno == blkno) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\twrap = (rr->rr_where < jd->jd_replay_tail);\n\ta = (jd->jd_replay_tail < where);\n\tb = (where < rr->rr_where);\n\trevoke = (wrap) ? (a || b) : (a && b);\n\n\treturn revoke;\n}"
  },
  {
    "function_name": "gfs2_revoke_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "55-82",
    "snippet": "int gfs2_revoke_add(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr;\n\tint found = 0;\n\n\tlist_for_each_entry(rr, head, rr_list) {\n\t\tif (rr->rr_blkno == blkno) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\trr->rr_where = where;\n\t\treturn 0;\n\t}\n\n\trr = kmalloc(sizeof(struct gfs2_revoke_replay), GFP_NOFS);\n\tif (!rr)\n\t\treturn -ENOMEM;\n\n\trr->rr_blkno = blkno;\n\trr->rr_where = where;\n\tlist_add(&rr->rr_list, head);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rr->rr_list",
            "head"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segment_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/recovery.c",
          "lines": "403-414",
          "snippet": "static int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segment_list_add(struct list_head *head, __u64 segnum)\n{\n\tstruct nilfs_segment_entry *ent = kmalloc(sizeof(*ent), GFP_NOFS);\n\n\tif (unlikely(!ent))\n\t\treturn -ENOMEM;\n\n\tent->segnum = segnum;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct gfs2_revoke_replay)",
            "GFP_NOFS"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rr",
            "head",
            "rr_list"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_revoke_add(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)\n{\n\tstruct list_head *head = &jd->jd_revoke_list;\n\tstruct gfs2_revoke_replay *rr;\n\tint found = 0;\n\n\tlist_for_each_entry(rr, head, rr_list) {\n\t\tif (rr->rr_blkno == blkno) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\trr->rr_where = where;\n\t\treturn 0;\n\t}\n\n\trr = kmalloc(sizeof(struct gfs2_revoke_replay), GFP_NOFS);\n\tif (!rr)\n\t\treturn -ENOMEM;\n\n\trr->rr_blkno = blkno;\n\trr->rr_where = where;\n\tlist_add(&rr->rr_list, head);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "gfs2_replay_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
    "lines": "32-53",
    "snippet": "int gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"util.h\"",
      "#include \"super.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_meta_ra",
          "args": [
            "gl",
            "dblock",
            "extlen"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "363-402",
          "snippet": "struct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *first_bh, *bh;\n\tu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\n\t\t\t  sdp->sd_sb.sb_bsize_shift;\n\n\tBUG_ON(!extlen);\n\n\tif (max_ra < 1)\n\t\tmax_ra = 1;\n\tif (extlen > max_ra)\n\t\textlen = max_ra;\n\n\tfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\n\n\tif (buffer_uptodate(first_bh))\n\t\tgoto out;\n\tif (!buffer_locked(first_bh))\n\t\tll_rw_block(READ_SYNC | REQ_META, 1, &first_bh);\n\n\tdblock++;\n\textlen--;\n\n\twhile (extlen) {\n\t\tbh = gfs2_getbuf(gl, dblock, CREATE);\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh))\n\t\t\tll_rw_block(READA | REQ_META, 1, &bh);\n\t\tbrelse(bh);\n\t\tdblock++;\n\t\textlen--;\n\t\tif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\n\t\t\tgoto out;\n\t}\n\n\twait_on_buffer(first_bh);\nout:\n\treturn first_bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_extent_map",
          "args": [
            "&ip->i_inode",
            "blk",
            "&new",
            "&dblock",
            "&extlen"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/bmap.c",
          "lines": "682-701",
          "snippet": "int gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"log.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"dir.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"log.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_extent_map(struct inode *inode, u64 lblock, int *new, u64 *dblock, unsigned *extlen)\n{\n\tstruct buffer_head bh = { .b_state = 0, .b_blocknr = 0 };\n\tint ret;\n\tint create = *new;\n\n\tBUG_ON(!extlen);\n\tBUG_ON(!dblock);\n\tBUG_ON(!new);\n\n\tbh.b_size = 1 << (inode->i_blkbits + (create ? 0 : 5));\n\tret = gfs2_block_map(inode, lblock, &bh, create);\n\t*extlen = bh.b_size >> inode->i_blkbits;\n\t*dblock = bh.b_blocknr;\n\tif (buffer_new(&bh))\n\t\t*new = 1;\n\telse\n\t\t*new = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "jd->jd_inode"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_replay_read_block(struct gfs2_jdesc *jd, unsigned int blk,\n\t\t\t   struct buffer_head **bh)\n{\n\tstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tint new = 0;\n\tu64 dblock;\n\tu32 extlen;\n\tint error;\n\n\terror = gfs2_extent_map(&ip->i_inode, blk, &new, &dblock, &extlen);\n\tif (error)\n\t\treturn error;\n\tif (!dblock) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\t*bh = gfs2_meta_ra(gl, dblock, extlen);\n\n\treturn error;\n}"
  }
]