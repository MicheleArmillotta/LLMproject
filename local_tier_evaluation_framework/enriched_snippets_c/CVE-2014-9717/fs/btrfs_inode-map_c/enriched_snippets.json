[
  {
    "function_name": "btrfs_find_free_objectid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "546-568",
    "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->objectid_mutex"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_highest_objectid",
          "args": [
            "root",
            "&root->highest_objectid"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_highest_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "511-544",
          "snippet": "static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_key found_key;\n\tint slot;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = BTRFS_LAST_FREE_OBJECTID;\n\tsearch_key.type = -1;\n\tsearch_key.offset = (u64)-1;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\tBUG_ON(ret == 0); /* Corruption */\n\tif (path->slots[0] > 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\t\t*objectid = max_t(u64, found_key.objectid,\n\t\t\t\t  BTRFS_FIRST_FREE_OBJECTID - 1);\n\t} else {\n\t\t*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_key found_key;\n\tint slot;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = BTRFS_LAST_FREE_OBJECTID;\n\tsearch_key.type = -1;\n\tsearch_key.offset = (u64)-1;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\tBUG_ON(ret == 0); /* Corruption */\n\tif (path->slots[0] > 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\t\t*objectid = max_t(u64, found_key.objectid,\n\t\t\t\t  BTRFS_FIRST_FREE_OBJECTID - 1);\n\t} else {\n\t\t*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->objectid_mutex"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_find_highest_objectid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "511-544",
    "snippet": "static int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_key found_key;\n\tint slot;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = BTRFS_LAST_FREE_OBJECTID;\n\tsearch_key.type = -1;\n\tsearch_key.offset = (u64)-1;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\tBUG_ON(ret == 0); /* Corruption */\n\tif (path->slots[0] > 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\t\t*objectid = max_t(u64, found_key.objectid,\n\t\t\t\t  BTRFS_FIRST_FREE_OBJECTID - 1);\n\t} else {\n\t\t*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "found_key.objectid",
            "BTRFS_FIRST_FREE_OBJECTID - 1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&found_key",
            "slot"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 0"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&search_key",
            "path",
            "0",
            "0"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic int btrfs_find_highest_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_key found_key;\n\tint slot;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = BTRFS_LAST_FREE_OBJECTID;\n\tsearch_key.type = -1;\n\tsearch_key.offset = (u64)-1;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\tBUG_ON(ret == 0); /* Corruption */\n\tif (path->slots[0] > 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\t\t*objectid = max_t(u64, found_key.objectid,\n\t\t\t\t  BTRFS_FIRST_FREE_OBJECTID - 1);\n\t} else {\n\t\t*objectid = BTRFS_FIRST_FREE_OBJECTID - 1;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_save_ino_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "385-509",
    "snippet": "int btrfs_save_ino_cache(struct btrfs_root *root,\n\t\t\t struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tstruct btrfs_block_rsv *rsv;\n\tu64 num_bytes;\n\tu64 alloc_hint = 0;\n\tint ret;\n\tint prealloc;\n\tbool retry = false;\n\n\t/* only fs tree and subvol/snap needs ino cache */\n\tif (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&\n\t    (root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||\n\t     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))\n\t\treturn 0;\n\n\t/* Don't save inode cache if we are deleting this root */\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\treturn 0;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\tnum_bytes = trans->bytes_reserved;\n\t/*\n\t * 1 item for inode item insertion if need\n\t * 4 items for inode item update (in the worst case)\n\t * 1 items for slack space if we need do truncation\n\t * 1 item for free space object\n\t * 3 items for pre-allocation\n\t */\n\ttrans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);\n\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t  trans->bytes_reserved,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\tif (ret)\n\t\tgoto out;\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 1);\nagain:\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_release;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retry); /* Logic error */\n\t\tretry = true;\n\n\t\tret = create_free_ino_inode(root, trans, path);\n\t\tif (ret)\n\t\t\tgoto out_release;\n\t\tgoto again;\n\t}\n\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_FINISHED) {\n\t\tret = -1;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&root->ino_cache_lock);\n\n\tspin_lock(&ctl->tree_lock);\n\tprealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;\n\tprealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);\n\tprealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* Just to make sure we have enough space */\n\tprealloc += 8 * PAGE_CACHE_SIZE;\n\n\tret = btrfs_delalloc_reserve_space(inode, prealloc);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,\n\t\t\t\t\t      prealloc, prealloc, &alloc_hint);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_space(inode, prealloc);\n\t\tgoto out_put;\n\t}\n\tbtrfs_free_reserved_data_space(inode, prealloc);\n\n\tret = btrfs_write_out_ino_cache(root, trans, path, inode);\nout_put:\n\tiput(inode);\nout_release:\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\nout:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = num_bytes;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "trans->block_rsv",
            "trans->bytes_reserved"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"ino_cache\"",
            "trans->transid",
            "trans->bytes_reserved",
            "0"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_write_out_ino_cache",
          "args": [
            "root",
            "trans",
            "path",
            "inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_out_ino_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3342-3364",
          "snippet": "int btrfs_write_out_ino_cache(struct btrfs_root *root,\n\t\t\t      struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct inode *inode)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, NULL, trans, path, 0);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_metadata(inode, inode->i_size);\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\n#endif\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_write_out_ino_cache(struct btrfs_root *root,\n\t\t\t      struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct inode *inode)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tret = __btrfs_write_out_cache(root, inode, ctl, NULL, trans, path, 0);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_metadata(inode, inode->i_size);\n#ifdef DEBUG\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"failed to write free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\n#endif\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_reserved_data_space",
          "args": [
            "inode",
            "prealloc"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_reserved_data_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3750-3765",
          "snippet": "void btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_space",
          "args": [
            "inode",
            "prealloc"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5347-5351",
          "snippet": "void btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_prealloc_file_range_trans",
          "args": [
            "inode",
            "trans",
            "0",
            "0",
            "prealloc",
            "prealloc",
            "prealloc",
            "&alloc_hint"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prealloc_file_range_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9529-9536",
          "snippet": "int btrfs_prealloc_file_range_trans(struct inode *inode,\n\t\t\t\t    struct btrfs_trans_handle *trans, int mode,\n\t\t\t\t    u64 start, u64 num_bytes, u64 min_size,\n\t\t\t\t    loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint, trans);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_prealloc_file_range_trans(struct inode *inode,\n\t\t\t\t    struct btrfs_trans_handle *trans, int mode,\n\t\t\t\t    u64 start, u64 num_bytes, u64 min_size,\n\t\t\t\t    loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint, trans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_reserve_space",
          "args": [
            "inode",
            "prealloc"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_reserve_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5317-5332",
          "snippet": "int btrfs_delalloc_reserve_space(struct inode *inode, u64 num_bytes)\n{\n\tint ret;\n\n\tret = btrfs_check_data_free_space(inode, num_bytes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delalloc_reserve_metadata(inode, num_bytes);\n\tif (ret) {\n\t\tbtrfs_free_reserved_data_space(inode, num_bytes);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_delalloc_reserve_space(struct inode *inode, u64 num_bytes)\n{\n\tint ret;\n\n\tret = btrfs_check_data_free_space(inode, num_bytes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delalloc_reserve_metadata(inode, num_bytes);\n\tif (ret) {\n\t\tbtrfs_free_reserved_data_space(inode, num_bytes);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "prealloc",
            "PAGE_CACHE_SIZE"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_free_space_cache",
          "args": [
            "root",
            "trans",
            "inode"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "226-251",
          "snippet": "int btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_free_ino_inode",
          "args": [
            "root",
            "trans",
            "path"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "create_free_ino_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3292-3298",
          "snippet": "int create_free_ino_inode(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_path *path)\n{\n\treturn __create_free_space_inode(root, trans, path,\n\t\t\t\t\t BTRFS_FREE_INO_OBJECTID, 0);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint create_free_ino_inode(struct btrfs_root *root,\n\t\t\t  struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_path *path)\n{\n\treturn __create_free_space_inode(root, trans, path,\n\t\t\t\t\t BTRFS_FREE_INO_OBJECTID, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "retry"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_free_ino_inode",
          "args": [
            "root",
            "path"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_ino_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3268-3290",
          "snippet": "struct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_ino_inode(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_inode)\n\t\tinode = igrab(root->ino_cache_inode);\n\tspin_unlock(&root->ino_cache_lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path, 0);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (!btrfs_fs_closing(root->fs_info))\n\t\troot->ino_cache_inode = igrab(inode);\n\tspin_unlock(&root->ino_cache_lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"ino_cache\"",
            "trans->transid",
            "trans->bytes_reserved",
            "1"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "trans->block_rsv",
            "trans->bytes_reserved",
            "BTRFS_RESERVE_NO_FLUSH"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "10"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_save_ino_cache(struct btrfs_root *root,\n\t\t\t struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tstruct btrfs_block_rsv *rsv;\n\tu64 num_bytes;\n\tu64 alloc_hint = 0;\n\tint ret;\n\tint prealloc;\n\tbool retry = false;\n\n\t/* only fs tree and subvol/snap needs ino cache */\n\tif (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&\n\t    (root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||\n\t     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))\n\t\treturn 0;\n\n\t/* Don't save inode cache if we are deleting this root */\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\treturn 0;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\tnum_bytes = trans->bytes_reserved;\n\t/*\n\t * 1 item for inode item insertion if need\n\t * 4 items for inode item update (in the worst case)\n\t * 1 items for slack space if we need do truncation\n\t * 1 item for free space object\n\t * 3 items for pre-allocation\n\t */\n\ttrans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);\n\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t  trans->bytes_reserved,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\tif (ret)\n\t\tgoto out;\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 1);\nagain:\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_release;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retry); /* Logic error */\n\t\tretry = true;\n\n\t\tret = create_free_ino_inode(root, trans, path);\n\t\tif (ret)\n\t\t\tgoto out_release;\n\t\tgoto again;\n\t}\n\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_FINISHED) {\n\t\tret = -1;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&root->ino_cache_lock);\n\n\tspin_lock(&ctl->tree_lock);\n\tprealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;\n\tprealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);\n\tprealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* Just to make sure we have enough space */\n\tprealloc += 8 * PAGE_CACHE_SIZE;\n\n\tret = btrfs_delalloc_reserve_space(inode, prealloc);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,\n\t\t\t\t\t      prealloc, prealloc, &alloc_hint);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_space(inode, prealloc);\n\t\tgoto out_put;\n\t}\n\tbtrfs_free_reserved_data_space(inode, prealloc);\n\n\tret = btrfs_write_out_ino_cache(root, trans, path, inode);\nout_put:\n\tiput(inode);\nout_release:\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\nout:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = num_bytes;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_init_free_ino_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "357-383",
    "snippet": "void btrfs_init_free_ino_ctl(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = 1;\n\tctl->start = 0;\n\tctl->private = NULL;\n\tctl->op = &free_ino_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * Initially we allow to use 16K of ram to cache chunks of\n\t * inode numbers before we resort to bitmaps. This is somewhat\n\t * arbitrary, but it will be adjusted in runtime.\n\t */\n\tctl->extents_thresh = INIT_THRESHOLD;\n\n\tspin_lock_init(&pinned->tree_lock);\n\tpinned->unit = 1;\n\tpinned->start = 0;\n\tpinned->private = NULL;\n\tpinned->extents_thresh = 0;\n\tpinned->op = &pinned_free_ino_op;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))"
    ],
    "globals_used": [
      "static struct btrfs_free_space_op free_ino_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};",
      "static struct btrfs_free_space_op pinned_free_ino_op = {\n\t.recalc_thresholds\t= pinned_recalc_thresholds,\n\t.use_bitmap\t\t= pinned_use_bitmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pinned->tree_lock"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ctl->cache_writeout_mutex"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctl->trimming_ranges"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ctl->tree_lock"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))\n\nstatic struct btrfs_free_space_op free_ino_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\nstatic struct btrfs_free_space_op pinned_free_ino_op = {\n\t.recalc_thresholds\t= pinned_recalc_thresholds,\n\t.use_bitmap\t\t= pinned_use_bitmap,\n};\n\nvoid btrfs_init_free_ino_ctl(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = 1;\n\tctl->start = 0;\n\tctl->private = NULL;\n\tctl->op = &free_ino_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * Initially we allow to use 16K of ram to cache chunks of\n\t * inode numbers before we resort to bitmaps. This is somewhat\n\t * arbitrary, but it will be adjusted in runtime.\n\t */\n\tctl->extents_thresh = INIT_THRESHOLD;\n\n\tspin_lock_init(&pinned->tree_lock);\n\tpinned->unit = 1;\n\tpinned->start = 0;\n\tpinned->private = NULL;\n\tpinned->extents_thresh = 0;\n\tpinned->op = &pinned_free_ino_op;\n}"
  },
  {
    "function_name": "pinned_use_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "339-350",
    "snippet": "static bool pinned_use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t/*\n\t * We always use extents for two reasons:\n\t *\n\t * - The pinned tree is only used during the process of caching\n\t *   work.\n\t * - Make code simpler. See btrfs_unpin_free_ino().\n\t */\n\treturn false;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic bool pinned_use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info)\n{\n\t/*\n\t * We always use extents for two reasons:\n\t *\n\t * - The pinned tree is only used during the process of caching\n\t *   work.\n\t * - Make code simpler. See btrfs_unpin_free_ino().\n\t */\n\treturn false;\n}"
  },
  {
    "function_name": "pinned_recalc_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "335-337",
    "snippet": "static void pinned_recalc_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic void pinned_recalc_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n}"
  },
  {
    "function_name": "use_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "320-328",
    "snippet": "static bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t       struct btrfs_free_space *info)\n{\n\tif (ctl->free_extents < ctl->extents_thresh ||\n\t    info->bytes > INODES_PER_BITMAP / 10)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)\n\nstatic bool use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t       struct btrfs_free_space *info)\n{\n\tif (ctl->free_extents < ctl->extents_thresh ||\n\t    info->bytes > INODES_PER_BITMAP / 10)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "recalculate_thresholds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "285-314",
    "snippet": "static void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tint max_ino;\n\tint max_bitmaps;\n\n\tn = rb_last(&ctl->free_space_offset);\n\tif (!n) {\n\t\tctl->extents_thresh = INIT_THRESHOLD;\n\t\treturn;\n\t}\n\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\n\t/*\n\t * Find the maximum inode number in the filesystem. Note we\n\t * ignore the fact that this can be a bitmap, because we are\n\t * not doing precise calculation.\n\t */\n\tmax_ino = info->bytes - 1;\n\n\tmax_bitmaps = ALIGN(max_ino, INODES_PER_BITMAP) / INODES_PER_BITMAP;\n\tif (max_bitmaps <= ctl->total_bitmaps) {\n\t\tctl->extents_thresh = 0;\n\t\treturn;\n\t}\n\n\tctl->extents_thresh = (max_bitmaps - ctl->total_bitmaps) *\n\t\t\t\tPAGE_CACHE_SIZE / sizeof(*info);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [
      "#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)",
      "#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "max_ino",
            "INODES_PER_BITMAP"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "&ctl->free_space_offset"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n#define INODES_PER_BITMAP (PAGE_CACHE_SIZE * 8)\n#define INIT_THRESHOLD\t(((1024 * 32) / 2) / sizeof(struct btrfs_free_space))\n\nstatic void recalculate_thresholds(struct btrfs_free_space_ctl *ctl)\n{\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tint max_ino;\n\tint max_bitmaps;\n\n\tn = rb_last(&ctl->free_space_offset);\n\tif (!n) {\n\t\tctl->extents_thresh = INIT_THRESHOLD;\n\t\treturn;\n\t}\n\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\n\t/*\n\t * Find the maximum inode number in the filesystem. Note we\n\t * ignore the fact that this can be a bitmap, because we are\n\t * not doing precise calculation.\n\t */\n\tmax_ino = info->bytes - 1;\n\n\tmax_bitmaps = ALIGN(max_ino, INODES_PER_BITMAP) / INODES_PER_BITMAP;\n\tif (max_bitmaps <= ctl->total_bitmaps) {\n\t\tctl->extents_thresh = 0;\n\t\treturn;\n\t}\n\n\tctl->extents_thresh = (max_bitmaps - ctl->total_bitmaps) *\n\t\t\t\tPAGE_CACHE_SIZE / sizeof(*info);\n}"
  },
  {
    "function_name": "btrfs_unpin_free_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "245-276",
    "snippet": "void btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&info->offset_index",
            "rbroot"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "ctl",
            "info->offset",
            "count"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "info->bitmap"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_free_space",
            "offset_index"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "rbroot"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nvoid btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}"
  },
  {
    "function_name": "btrfs_return_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "210-235",
    "snippet": "void btrfs_return_ino(struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\nagain:\n\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\n\t\t__btrfs_add_free_space(pinned, objectid, 1);\n\t} else {\n\t\tdown_write(&root->fs_info->commit_root_sem);\n\t\tspin_lock(&root->ino_cache_lock);\n\t\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\n\t\t\tspin_unlock(&root->ino_cache_lock);\n\t\t\tup_write(&root->fs_info->commit_root_sem);\n\t\t\tgoto again;\n\t\t}\n\t\tspin_unlock(&root->ino_cache_lock);\n\n\t\tstart_caching(root);\n\n\t\t__btrfs_add_free_space(pinned, objectid, 1);\n\n\t\tup_write(&root->fs_info->commit_root_sem);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->commit_root_sem"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "pinned",
            "objectid",
            "1"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_caching",
          "args": [
            "root"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "start_caching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "137-184",
          "snippet": "static void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->commit_root_sem"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->commit_root_sem"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nvoid btrfs_return_ino(struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_free_space_ctl *pinned = root->free_ino_pinned;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\nagain:\n\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\n\t\t__btrfs_add_free_space(pinned, objectid, 1);\n\t} else {\n\t\tdown_write(&root->fs_info->commit_root_sem);\n\t\tspin_lock(&root->ino_cache_lock);\n\t\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED) {\n\t\t\tspin_unlock(&root->ino_cache_lock);\n\t\t\tup_write(&root->fs_info->commit_root_sem);\n\t\t\tgoto again;\n\t\t}\n\t\tspin_unlock(&root->ino_cache_lock);\n\n\t\tstart_caching(root);\n\n\t\t__btrfs_add_free_space(pinned, objectid, 1);\n\n\t\tup_write(&root->fs_info->commit_root_sem);\n\t}\n}"
  },
  {
    "function_name": "btrfs_find_free_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "186-208",
    "snippet": "int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)\n{\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn btrfs_find_free_objectid(root, objectid);\n\nagain:\n\t*objectid = btrfs_find_ino_for_alloc(root);\n\n\tif (*objectid != 0)\n\t\treturn 0;\n\n\tstart_caching(root);\n\n\twait_event(root->ino_cache_wait,\n\t\t   root->ino_cache_state == BTRFS_CACHE_FINISHED ||\n\t\t   root->free_ino_ctl->free_space > 0);\n\n\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED &&\n\t    root->free_ino_ctl->free_space == 0)\n\t\treturn -ENOSPC;\n\telse\n\t\tgoto again;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->ino_cache_wait",
            "root->ino_cache_state == BTRFS_CACHE_FINISHED ||\n\t\t   root->free_ino_ctl->free_space > 0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_caching",
          "args": [
            "root"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "start_caching",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "137-184",
          "snippet": "static void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_ino_for_alloc",
          "args": [
            "root"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_ino_for_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3224-3266",
          "snippet": "u64 btrfs_find_ino_for_alloc(struct btrfs_root *fs_root)\n{\n\tstruct btrfs_free_space_ctl *ctl = fs_root->free_ino_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 ino = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (RB_EMPTY_ROOT(&ctl->free_space_offset))\n\t\tgoto out;\n\n\tentry = rb_entry(rb_first(&ctl->free_space_offset),\n\t\t\t struct btrfs_free_space, offset_index);\n\n\tif (!entry->bitmap) {\n\t\tino = entry->offset;\n\n\t\tunlink_free_space(ctl, entry);\n\t\tentry->offset++;\n\t\tentry->bytes--;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t} else {\n\t\tu64 offset = 0;\n\t\tu64 count = 1;\n\t\tint ret;\n\n\t\tret = search_bitmap(ctl, entry, &offset, &count);\n\t\t/* Logic error; Should be empty if it can't find anything */\n\t\tASSERT(!ret);\n\n\t\tino = offset;\n\t\tbitmap_clear_bits(ctl, entry, offset, 1);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ino;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_find_ino_for_alloc(struct btrfs_root *fs_root)\n{\n\tstruct btrfs_free_space_ctl *ctl = fs_root->free_ino_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 ino = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (RB_EMPTY_ROOT(&ctl->free_space_offset))\n\t\tgoto out;\n\n\tentry = rb_entry(rb_first(&ctl->free_space_offset),\n\t\t\t struct btrfs_free_space, offset_index);\n\n\tif (!entry->bitmap) {\n\t\tino = entry->offset;\n\n\t\tunlink_free_space(ctl, entry);\n\t\tentry->offset++;\n\t\tentry->bytes--;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t} else {\n\t\tu64 offset = 0;\n\t\tu64 count = 1;\n\t\tint ret;\n\n\t\tret = search_bitmap(ctl, entry, &offset, &count);\n\t\t/* Logic error; Should be empty if it can't find anything */\n\t\tASSERT(!ret);\n\n\t\tino = offset;\n\t\tbitmap_clear_bits(ctl, entry, offset, 1);\n\t\tif (entry->bytes == 0)\n\t\t\tfree_bitmap(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "root",
            "objectid"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)\n{\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn btrfs_find_free_objectid(root, objectid);\n\nagain:\n\t*objectid = btrfs_find_ino_for_alloc(root);\n\n\tif (*objectid != 0)\n\t\treturn 0;\n\n\tstart_caching(root);\n\n\twait_event(root->ino_cache_wait,\n\t\t   root->ino_cache_state == BTRFS_CACHE_FINISHED ||\n\t\t   root->free_ino_ctl->free_space > 0);\n\n\tif (root->ino_cache_state == BTRFS_CACHE_FINISHED &&\n\t    root->free_ino_ctl->free_space == 0)\n\t\treturn -ENOSPC;\n\telse\n\t\tgoto again;\n}"
  },
  {
    "function_name": "start_caching",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "137-184",
    "snippet": "static void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_clear_pending_and_info",
          "args": [
            "root->fs_info",
            "INODE_MAP_CACHE",
            "\"disabling inode map caching\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"failed to start inode caching task\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsk"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "caching_kthread",
            "root",
            "\"btrfs-ino-cache-%llu\"",
            "root->root_key.objectid"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "ctl",
            "objectid",
            "BTRFS_LAST_FREE_OBJECTID - objectid + 1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "root",
            "&objectid"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_free_ino_cache",
          "args": [
            "root->fs_info",
            "root"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "load_free_ino_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3300-3340",
          "snippet": "int load_free_ino_cache(struct btrfs_fs_info *fs_info, struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tint ret = 0;\n\tu64 root_gen = btrfs_root_generation(&root->root_item);\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If we're unmounting then just return, since this does a search on the\n\t * normal root and not the commit root and we could deadlock.\n\t */\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (root_gen != BTRFS_I(inode)->generation)\n\t\tgoto out_put;\n\n\tret = __load_free_space_cache(root, inode, ctl, path, 0);\n\n\tif (ret < 0)\n\t\tbtrfs_err(fs_info,\n\t\t\t\"failed to load free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\nout_put:\n\tiput(inode);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint load_free_ino_cache(struct btrfs_fs_info *fs_info, struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tint ret = 0;\n\tu64 root_gen = btrfs_root_generation(&root->root_item);\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If we're unmounting then just return, since this does a search on the\n\t * normal root and not the commit root and we could deadlock.\n\t */\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn 0;\n\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\tif (root_gen != BTRFS_I(inode)->generation)\n\t\tgoto out_put;\n\n\tret = __load_free_space_cache(root, inode, ctl, path, 0);\n\n\tif (ret < 0)\n\t\tbtrfs_err(fs_info,\n\t\t\t\"failed to load free ino cache for root %llu\",\n\t\t\troot->root_key.objectid);\nout_put:\n\tiput(inode);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic void start_caching(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct task_struct *tsk;\n\tint ret;\n\tu64 objectid;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_NO) {\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\troot->ino_cache_state = BTRFS_CACHE_STARTED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\tret = load_free_ino_cache(root->fs_info, root);\n\tif (ret == 1) {\n\t\tspin_lock(&root->ino_cache_lock);\n\t\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\treturn;\n\t}\n\n\t/*\n\t * It can be quite time-consuming to fill the cache by searching\n\t * through the extent tree, and this can keep ino allocation path\n\t * waiting. Therefore at start we quickly find out the highest\n\t * inode number and we know we can use inode numbers which fall in\n\t * [highest_ino + 1, BTRFS_LAST_FREE_OBJECTID].\n\t */\n\tret = btrfs_find_free_objectid(root, &objectid);\n\tif (!ret && objectid <= BTRFS_LAST_FREE_OBJECTID) {\n\t\t__btrfs_add_free_space(ctl, objectid,\n\t\t\t\t       BTRFS_LAST_FREE_OBJECTID - objectid + 1);\n\t}\n\n\ttsk = kthread_run(caching_kthread, root, \"btrfs-ino-cache-%llu\",\n\t\t\t  root->root_key.objectid);\n\tif (IS_ERR(tsk)) {\n\t\tbtrfs_warn(root->fs_info, \"failed to start inode caching task\");\n\t\tbtrfs_clear_pending_and_info(root->fs_info, INODE_MAP_CACHE,\n\t\t\t\t\"disabling inode map caching\");\n\t}\n}"
  },
  {
    "function_name": "caching_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
    "lines": "29-135",
    "snippet": "static int caching_kthread(void *data)\n{\n\tstruct btrfs_root *root = data;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tu64 last = (u64)-1;\n\tint slot;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Since the commit root is read-only, we can safely skip locking. */\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\tpath->reada = 2;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\nagain:\n\t/* need to make sure the commit_root doesn't disappear */\n\tdown_read(&fs_info->commit_root_sem);\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (btrfs_fs_closing(fs_info))\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\n\t\t\tif (need_resched() ||\n\t\t\t    btrfs_transaction_in_commit(fs_info)) {\n\t\t\t\tleaf = path->nodes[0];\n\n\t\t\t\tif (WARN_ON(btrfs_header_nritems(leaf) == 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/*\n\t\t\t\t * Save the key so we can advances forward\n\t\t\t\t * in the next search.\n\t\t\t\t */\n\t\t\t\tbtrfs_item_key_to_cpu(leaf, &key, 0);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\troot->ino_cache_progress = last;\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tschedule_timeout(1);\n\t\t\t\tgoto again;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_INODE_ITEM_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.objectid >= root->highest_objectid)\n\t\t\tbreak;\n\n\t\tif (last != (u64)-1 && last + 1 != key.objectid) {\n\t\t\t__btrfs_add_free_space(ctl, last + 1,\n\t\t\t\t\t       key.objectid - last - 1);\n\t\t\twake_up(&root->ino_cache_wait);\n\t\t}\n\n\t\tlast = key.objectid;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\n\tif (last < root->highest_objectid - 1) {\n\t\t__btrfs_add_free_space(ctl, last + 1,\n\t\t\t\t       root->highest_objectid - last - 1);\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\troot->ino_cache_progress = (u64)-1;\n\tbtrfs_unpin_free_ino(root);\nout:\n\twake_up(&root->ino_cache_wait);\n\tup_read(&fs_info->commit_root_sem);\n\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&root->ino_cache_wait"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unpin_free_ino",
          "args": [
            "root"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unpin_free_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "245-276",
          "snippet": "void btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nvoid btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->ino_cache_lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "ctl",
            "last + 1",
            "root->highest_objectid - last - 1"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "1"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_nritems(leaf) == 0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_transaction_in_commit",
          "args": [
            "fs_info"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_transaction_in_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1547-1558",
          "snippet": "int btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "fs_info"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nstatic int caching_kthread(void *data)\n{\n\tstruct btrfs_root *root = data;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tu64 last = (u64)-1;\n\tint slot;\n\tint ret;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Since the commit root is read-only, we can safely skip locking. */\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\tpath->reada = 2;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\nagain:\n\t/* need to make sure the commit_root doesn't disappear */\n\tdown_read(&fs_info->commit_root_sem);\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tif (btrfs_fs_closing(fs_info))\n\t\t\tgoto out;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\n\t\t\tif (need_resched() ||\n\t\t\t    btrfs_transaction_in_commit(fs_info)) {\n\t\t\t\tleaf = path->nodes[0];\n\n\t\t\t\tif (WARN_ON(btrfs_header_nritems(leaf) == 0))\n\t\t\t\t\tbreak;\n\n\t\t\t\t/*\n\t\t\t\t * Save the key so we can advances forward\n\t\t\t\t * in the next search.\n\t\t\t\t */\n\t\t\t\tbtrfs_item_key_to_cpu(leaf, &key, 0);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\troot->ino_cache_progress = last;\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tschedule_timeout(1);\n\t\t\t\tgoto again;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_INODE_ITEM_KEY)\n\t\t\tgoto next;\n\n\t\tif (key.objectid >= root->highest_objectid)\n\t\t\tbreak;\n\n\t\tif (last != (u64)-1 && last + 1 != key.objectid) {\n\t\t\t__btrfs_add_free_space(ctl, last + 1,\n\t\t\t\t\t       key.objectid - last - 1);\n\t\t\twake_up(&root->ino_cache_wait);\n\t\t}\n\n\t\tlast = key.objectid;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\n\tif (last < root->highest_objectid - 1) {\n\t\t__btrfs_add_free_space(ctl, last + 1,\n\t\t\t\t       root->highest_objectid - last - 1);\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\troot->ino_cache_state = BTRFS_CACHE_FINISHED;\n\tspin_unlock(&root->ino_cache_lock);\n\n\troot->ino_cache_progress = (u64)-1;\n\tbtrfs_unpin_free_ino(root);\nout:\n\twake_up(&root->ino_cache_wait);\n\tup_read(&fs_info->commit_root_sem);\n\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}"
  }
]