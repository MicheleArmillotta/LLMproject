[
  {
    "function_name": "efs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/file.c",
    "lines": "36-56",
    "snippet": "int efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "efs_map_block",
          "args": [
            "inode",
            "block"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "efs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "197-309",
          "snippet": "efs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nefs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s(): block %d >= %ld (filesize %ld)\\n\"",
            "__func__",
            "block",
            "inode->i_blocks",
            "inode->i_size"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s(): block < 0\\n\"",
            "__func__"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/buffer_head.h>\n\nint efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}"
  },
  {
    "function_name": "efs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/file.c",
    "lines": "12-34",
    "snippet": "int efs_get_block(struct inode *inode, sector_t iblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\tint error = -EROFS;\n\tlong phys;\n\n\tif (create)\n\t\treturn error;\n\tif (iblock >= inode->i_blocks) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\tphys = efs_map_block(inode, iblock);\n\tif (phys)\n\t\tmap_bh(bh_result, inode->i_sb, phys);\n\treturn 0;\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "phys"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_map_block",
          "args": [
            "inode",
            "iblock"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "efs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "197-309",
          "snippet": "efs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nefs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s(): block %d >= %ld (filesize %ld)\\n\"",
            "__func__",
            "block",
            "inode->i_blocks",
            "inode->i_size"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/buffer_head.h>\n\nint efs_get_block(struct inode *inode, sector_t iblock,\n\t\t  struct buffer_head *bh_result, int create)\n{\n\tint error = -EROFS;\n\tlong phys;\n\n\tif (create)\n\t\treturn error;\n\tif (iblock >= inode->i_blocks) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\tphys = efs_map_block(inode, iblock);\n\tif (phys)\n\t\tmap_bh(bh_result, inode->i_sb, phys);\n\treturn 0;\n}"
  }
]