[
  {
    "function_name": "xfs_dir2_node_to_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1672-1819",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_to_leaf(\n\txfs_da_state_t\t\t*state)\t\t/* directory operation state */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*fbp;\t\t/* buffer for freespace block */\n\txfs_fileoff_t\t\tfo;\t\t/* freespace file offset */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\tstruct xfs_buf\t\t*lbp;\t\t/* buffer for leaf block */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* tail of leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\trval;\t\t/* successful free trim? */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t/*\n\t * There's more than a leaf level in the btree, so there must\n\t * be multiple leafn blocks.  Give up.\n\t */\n\tif (state->path.active > 1)\n\t\treturn 0;\n\targs = state->args;\n\n\ttrace_xfs_dir2_node_to_leaf(args);\n\n\tmp = state->mp;\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Get the last offset in the file.\n\t */\n\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\tfo -= args->geo->fsbcount;\n\t/*\n\t * If there are freespace blocks other than the first one,\n\t * take this opportunity to remove trailing empty freespace blocks\n\t * that may have been left behind during no-space-reservation\n\t * operations.\n\t */\n\twhile (fo > args->geo->freeblk) {\n\t\tif ((error = xfs_dir2_node_trim_free(args, fo, &rval))) {\n\t\t\treturn error;\n\t\t}\n\t\tif (rval)\n\t\t\tfo -= args->geo->fsbcount;\n\t\telse\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Now find the block just before the freespace block.\n\t */\n\tif ((error = xfs_bmap_last_before(tp, dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\t/*\n\t * If it's not the single leaf block, give up.\n\t */\n\tif (XFS_FSB_TO_B(mp, fo) > XFS_DIR2_LEAF_OFFSET + args->geo->blksize)\n\t\treturn 0;\n\tlbp = state->path.blk[0].bp;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_read(tp, dp,  args->geo->freeblk, &fbp);\n\tif (error)\n\t\treturn error;\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\tASSERT(!freehdr.firstdb);\n\n\t/*\n\t * Now see if the leafn and free data will fit in a leaf1.\n\t * If not, release the buffer and give up.\n\t */\n\tif (xfs_dir3_leaf_size(&leafhdr, freehdr.nvalid) > args->geo->blksize) {\n\t\txfs_trans_brelse(tp, fbp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the leaf has any stale entries in it, compress them out.\n\t */\n\tif (leafhdr.stale)\n\t\txfs_dir3_leaf_compact(args, &leafhdr, lbp);\n\n\tlbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAF1_BUF);\n\tleafhdr.magic = (leafhdr.magic == XFS_DIR2_LEAFN_MAGIC)\n\t\t\t\t\t? XFS_DIR2_LEAF1_MAGIC\n\t\t\t\t\t: XFS_DIR3_LEAF1_MAGIC;\n\n\t/*\n\t * Set up the leaf tail from the freespace block.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(freehdr.nvalid);\n\n\t/*\n\t * Set up the leaf bests table.\n\t */\n\tmemcpy(xfs_dir2_leaf_bests_p(ltp), dp->d_ops->free_bests_p(free),\n\t\tfreehdr.nvalid * sizeof(xfs_dir2_data_off_t));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\n\t/*\n\t * Get rid of the freespace block.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET),\n\t\t\tfbp);\n\tif (error) {\n\t\t/*\n\t\t * This can't fail here because it can only happen when\n\t\t * punching out the middle of an extent, and this is an\n\t\t * isolated block.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\treturn error;\n\t}\n\tfbp = NULL;\n\t/*\n\t * Now see if we can convert the single-leaf directory\n\t * down to a block form directory.\n\t * This routine always kills the dabuf for the leaf, so\n\t * eliminate it from the path.\n\t */\n\terror = xfs_dir2_leaf_to_block(args, lbp, NULL);\n\tstate->path.blk[0].bp = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);",
      "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_to_block",
          "args": [
            "args",
            "lbp",
            "NULL"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "897-1037",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET)",
            "fbp"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_tail",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1125-1141",
          "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_bests",
          "args": [
            "args",
            "lbp",
            "0",
            "be32_to_cpu(ltp->bestcount) - 1"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1051-1072",
          "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xfs_dir2_leaf_bests_p(ltp)",
            "dp->d_ops->free_bests_p(free)",
            "freehdr.nvalid * sizeof(xfs_dir2_data_off_t)"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "freehdr.nvalid"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "lbp",
            "XFS_BLFT_DIR_LEAF1_BUF"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_compact",
          "args": [
            "args",
            "&leafhdr",
            "lbp"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "907-952",
          "snippet": "void\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "fbp"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_size",
          "args": [
            "&leafhdr",
            "freehdr.nvalid"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1647-1665",
          "snippet": "static inline size_t\nxfs_dir3_leaf_size(\n\tstruct xfs_dir3_icleaf_hdr\t*hdr,\n\tint\t\t\t\tcounts)\n{\n\tint\tentries;\n\tint\thdrsize;\n\n\tentries = hdr->count - hdr->stale;\n\tif (hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t    hdr->magic == XFS_DIR2_LEAFN_MAGIC)\n\t\thdrsize = sizeof(struct xfs_dir2_leaf_hdr);\n\telse\n\t\thdrsize = sizeof(struct xfs_dir3_leaf_hdr);\n\n\treturn hdrsize + entries * sizeof(xfs_dir2_leaf_entry_t)\n\t               + counts * sizeof(xfs_dir2_data_off_t)\n\t\t       + sizeof(xfs_dir2_leaf_tail_t);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline size_t\nxfs_dir3_leaf_size(\n\tstruct xfs_dir3_icleaf_hdr\t*hdr,\n\tint\t\t\t\tcounts)\n{\n\tint\tentries;\n\tint\thdrsize;\n\n\tentries = hdr->count - hdr->stale;\n\tif (hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t    hdr->magic == XFS_DIR2_LEAFN_MAGIC)\n\t\thdrsize = sizeof(struct xfs_dir2_leaf_hdr);\n\telse\n\t\thdrsize = sizeof(struct xfs_dir3_leaf_hdr);\n\n\treturn hdrsize + entries * sizeof(xfs_dir2_leaf_entry_t)\n\t               + counts * sizeof(xfs_dir2_data_off_t)\n\t\t       + sizeof(xfs_dir2_leaf_tail_t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!freehdr.firstdb"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_read",
          "args": [
            "tp",
            "dp",
            "args->geo->freeblk",
            "&fbp"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "174-182",
          "snippet": "int\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "fo"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_before",
          "args": [
            "tp",
            "dp",
            "&fo",
            "XFS_DATA_FORK"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1555-1596",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_trim_free",
          "args": [
            "args",
            "fo",
            "&rval"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_trim_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "2212-2270",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_trim_free(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_fileoff_t\t\tfo,\t\t/* free block number */\n\tint\t\t\t*rvalp)\t\t/* out: did something */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* freespace buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * There can be holes in freespace.  If fo is a hole, there's\n\t * nothing to do.\n\t */\n\tif (!bp)\n\t\treturn 0;\n\tfree = bp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t/*\n\t * If there are used entries, there's nothing to do.\n\t */\n\tif (freehdr.nused > 0) {\n\t\txfs_trans_brelse(tp, bp);\n\t\t*rvalp = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Blow the block away.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo), bp);\n\tif (error) {\n\t\t/*\n\t\t * Can't fail with ENOSPC since that only happens with no\n\t\t * space reservation, when breaking up an extent into two\n\t\t * pieces.  This is the last block of an extent.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn error;\n\t}\n\t/*\n\t * Return that we succeeded.\n\t */\n\t*rvalp = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_trim_free(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_fileoff_t\t\tfo,\t\t/* free block number */\n\tint\t\t\t*rvalp)\t\t/* out: did something */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* freespace buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * There can be holes in freespace.  If fo is a hole, there's\n\t * nothing to do.\n\t */\n\tif (!bp)\n\t\treturn 0;\n\tfree = bp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t/*\n\t * If there are used entries, there's nothing to do.\n\t */\n\tif (freehdr.nused > 0) {\n\t\txfs_trans_brelse(tp, bp);\n\t\t*rvalp = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Blow the block away.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo), bp);\n\tif (error) {\n\t\t/*\n\t\t * Can't fail with ENOSPC since that only happens with no\n\t\t * space reservation, when breaking up an extent into two\n\t\t * pieces.  This is the last block of an extent.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn error;\n\t}\n\t/*\n\t * Return that we succeeded.\n\t */\n\t*rvalp = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_offset",
          "args": [
            "dp",
            "&fo",
            "XFS_DATA_FORK"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1671-1696",
          "snippet": "int\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_node_to_leaf",
          "args": [
            "args"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_to_leaf(\n\txfs_da_state_t\t\t*state)\t\t/* directory operation state */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*fbp;\t\t/* buffer for freespace block */\n\txfs_fileoff_t\t\tfo;\t\t/* freespace file offset */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\tstruct xfs_buf\t\t*lbp;\t\t/* buffer for leaf block */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* tail of leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\trval;\t\t/* successful free trim? */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t/*\n\t * There's more than a leaf level in the btree, so there must\n\t * be multiple leafn blocks.  Give up.\n\t */\n\tif (state->path.active > 1)\n\t\treturn 0;\n\targs = state->args;\n\n\ttrace_xfs_dir2_node_to_leaf(args);\n\n\tmp = state->mp;\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Get the last offset in the file.\n\t */\n\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\tfo -= args->geo->fsbcount;\n\t/*\n\t * If there are freespace blocks other than the first one,\n\t * take this opportunity to remove trailing empty freespace blocks\n\t * that may have been left behind during no-space-reservation\n\t * operations.\n\t */\n\twhile (fo > args->geo->freeblk) {\n\t\tif ((error = xfs_dir2_node_trim_free(args, fo, &rval))) {\n\t\t\treturn error;\n\t\t}\n\t\tif (rval)\n\t\t\tfo -= args->geo->fsbcount;\n\t\telse\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Now find the block just before the freespace block.\n\t */\n\tif ((error = xfs_bmap_last_before(tp, dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\t/*\n\t * If it's not the single leaf block, give up.\n\t */\n\tif (XFS_FSB_TO_B(mp, fo) > XFS_DIR2_LEAF_OFFSET + args->geo->blksize)\n\t\treturn 0;\n\tlbp = state->path.blk[0].bp;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_read(tp, dp,  args->geo->freeblk, &fbp);\n\tif (error)\n\t\treturn error;\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\tASSERT(!freehdr.firstdb);\n\n\t/*\n\t * Now see if the leafn and free data will fit in a leaf1.\n\t * If not, release the buffer and give up.\n\t */\n\tif (xfs_dir3_leaf_size(&leafhdr, freehdr.nvalid) > args->geo->blksize) {\n\t\txfs_trans_brelse(tp, fbp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the leaf has any stale entries in it, compress them out.\n\t */\n\tif (leafhdr.stale)\n\t\txfs_dir3_leaf_compact(args, &leafhdr, lbp);\n\n\tlbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAF1_BUF);\n\tleafhdr.magic = (leafhdr.magic == XFS_DIR2_LEAFN_MAGIC)\n\t\t\t\t\t? XFS_DIR2_LEAF1_MAGIC\n\t\t\t\t\t: XFS_DIR3_LEAF1_MAGIC;\n\n\t/*\n\t * Set up the leaf tail from the freespace block.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(freehdr.nvalid);\n\n\t/*\n\t * Set up the leaf bests table.\n\t */\n\tmemcpy(xfs_dir2_leaf_bests_p(ltp), dp->d_ops->free_bests_p(free),\n\t\tfreehdr.nvalid * sizeof(xfs_dir2_data_off_t));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\n\t/*\n\t * Get rid of the freespace block.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET),\n\t\t\tfbp);\n\tif (error) {\n\t\t/*\n\t\t * This can't fail here because it can only happen when\n\t\t * punching out the middle of an extent, and this is an\n\t\t * isolated block.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\treturn error;\n\t}\n\tfbp = NULL;\n\t/*\n\t * Now see if we can convert the single-leaf directory\n\t * down to a block form directory.\n\t * This routine always kills the dabuf for the leaf, so\n\t * eliminate it from the path.\n\t */\n\terror = xfs_dir2_leaf_to_block(args, lbp, NULL);\n\tstate->path.blk[0].bp = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1647-1665",
    "snippet": "static inline size_t\nxfs_dir3_leaf_size(\n\tstruct xfs_dir3_icleaf_hdr\t*hdr,\n\tint\t\t\t\tcounts)\n{\n\tint\tentries;\n\tint\thdrsize;\n\n\tentries = hdr->count - hdr->stale;\n\tif (hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t    hdr->magic == XFS_DIR2_LEAFN_MAGIC)\n\t\thdrsize = sizeof(struct xfs_dir2_leaf_hdr);\n\telse\n\t\thdrsize = sizeof(struct xfs_dir3_leaf_hdr);\n\n\treturn hdrsize + entries * sizeof(xfs_dir2_leaf_entry_t)\n\t               + counts * sizeof(xfs_dir2_data_off_t)\n\t\t       + sizeof(xfs_dir2_leaf_tail_t);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline size_t\nxfs_dir3_leaf_size(\n\tstruct xfs_dir3_icleaf_hdr\t*hdr,\n\tint\t\t\t\tcounts)\n{\n\tint\tentries;\n\tint\thdrsize;\n\n\tentries = hdr->count - hdr->stale;\n\tif (hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t    hdr->magic == XFS_DIR2_LEAFN_MAGIC)\n\t\thdrsize = sizeof(struct xfs_dir2_leaf_hdr);\n\telse\n\t\thdrsize = sizeof(struct xfs_dir3_leaf_hdr);\n\n\treturn hdrsize + entries * sizeof(xfs_dir2_leaf_entry_t)\n\t               + counts * sizeof(xfs_dir2_data_off_t)\n\t\t       + sizeof(xfs_dir2_leaf_tail_t);\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_trim_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1588-1645",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_trim_data(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\txfs_dir2_db_t\t\tdb)\t\t/* data block number */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the offending data block.  We need its buffer.\n\t */\n\terror = xfs_dir3_data_read(tp, dp, xfs_dir2_db_to_da(args->geo, db),\n\t\t\t\t   -1, &dbp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n#ifdef DEBUG\n{\n\tstruct xfs_dir2_data_hdr *hdr = dbp->b_addr;\n\tstruct xfs_dir2_data_free *bf = dp->d_ops->data_bestfree_p(hdr);\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\tASSERT(be16_to_cpu(bf[0].length) ==\n\t       args->geo->blksize - dp->d_ops->data_entry_offset);\n\tASSERT(db == be32_to_cpu(ltp->bestcount) - 1);\n}\n#endif\n\n\t/*\n\t * Get rid of the data block.\n\t */\n\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, dbp);\n\t\treturn error;\n\t}\n\t/*\n\t * Eliminate the last bests entry from the table.\n\t */\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbe32_add_cpu(&ltp->bestcount, -1);\n\tmemmove(&bestsp[1], &bestsp[0], be32_to_cpu(ltp->bestcount) * sizeof(*bestsp));\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_bests",
          "args": [
            "args",
            "lbp",
            "0",
            "be32_to_cpu(ltp->bestcount) - 1"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1051-1072",
          "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_tail",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1125-1141",
          "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&bestsp[1]",
            "&bestsp[0]",
            "be32_to_cpu(ltp->bestcount) * sizeof(*bestsp)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&ltp->bestcount",
            "-1"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "dbp"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "db",
            "dbp"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "db == be32_to_cpu(ltp->bestcount) - 1"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(bf[0].length) ==\n\t       args->geo->blksize - dp->d_ops->data_entry_offset"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, db)",
            "-1",
            "&dbp"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "db"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_trim_data(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\txfs_dir2_db_t\t\tdb)\t\t/* data block number */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the offending data block.  We need its buffer.\n\t */\n\terror = xfs_dir3_data_read(tp, dp, xfs_dir2_db_to_da(args->geo, db),\n\t\t\t\t   -1, &dbp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n#ifdef DEBUG\n{\n\tstruct xfs_dir2_data_hdr *hdr = dbp->b_addr;\n\tstruct xfs_dir2_data_free *bf = dp->d_ops->data_bestfree_p(hdr);\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\tASSERT(be16_to_cpu(bf[0].length) ==\n\t       args->geo->blksize - dp->d_ops->data_entry_offset);\n\tASSERT(db == be32_to_cpu(ltp->bestcount) - 1);\n}\n#endif\n\n\t/*\n\t * Get rid of the data block.\n\t */\n\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, dbp);\n\t\treturn error;\n\t}\n\t/*\n\t * Eliminate the last bests entry from the table.\n\t */\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbe32_add_cpu(&ltp->bestcount, -1);\n\tmemmove(&bestsp[1], &bestsp[0], be32_to_cpu(ltp->bestcount) * sizeof(*bestsp));\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_search_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1534-1582",
    "snippet": "int\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[mid - 1].hashval"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep[mid].hashval"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1480-1527",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index of leaf entry */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_replace(args);\n\n\t/*\n\t * Look up the entry.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, get data address from it.\n\t */\n\tlep = &ents[index];\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tASSERT(args->inumber != be64_to_cpu(dep->inumber));\n\t/*\n\t * Put the new inode number in, log it.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttp = args->trans;\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "lbp"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "dbp",
            "dep"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->inumber"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->inumber != be64_to_cpu(dep->inumber)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_lookup_int",
          "args": [
            "args",
            "&lbp",
            "&index",
            "&dbp"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1204-1331",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_replace",
          "args": [
            "args"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index of leaf entry */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_replace(args);\n\n\t/*\n\t * Look up the entry.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, get data address from it.\n\t */\n\tlep = &ents[index];\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tASSERT(args->inumber != be64_to_cpu(dep->inumber));\n\t/*\n\t * Put the new inode number in, log it.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttp = args->trans;\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1336-1475",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_removename(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf block best freespace */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry structure */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_db_t\t\ti;\t\t/* temporary data block # */\n\tint\t\t\tindex;\t\t/* index into leaf entries */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_dir2_data_off_t\toldbest;\t/* old value of best free */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_removename(args);\n\n\t/*\n\t * Lookup the leaf entry, get the leaf and data blocks read in.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, use that to point to the data entry.\n\t */\n\tlep = &ents[index];\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\txfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tneedscan = needlog = 0;\n\toldbest = be16_to_cpu(bf[0].length);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tASSERT(be16_to_cpu(bestsp[db]) == oldbest);\n\t/*\n\t * Mark the former data entry unused.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * We just mark the leaf entry stale by putting a null in it.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, lbp, index, index);\n\n\t/*\n\t * Scan the freespace in the data block again if necessary,\n\t * log the data block header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the longest freespace in the data block has changed,\n\t * put the new value in the bests table and log that.\n\t */\n\tif (be16_to_cpu(bf[0].length) != oldbest) {\n\t\tbestsp[db] = bf[0].length;\n\t\txfs_dir3_leaf_log_bests(args, lbp, db, db);\n\t}\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the data block is now empty then get rid of the data block.\n\t */\n\tif (be16_to_cpu(bf[0].length) ==\n\t\t\targs->geo->blksize - dp->d_ops->data_entry_offset) {\n\t\tASSERT(db != args->geo->datablk);\n\t\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\t\t/*\n\t\t\t * Nope, can't get rid of it because it caused\n\t\t\t * allocation of a bmap btree block to do so.\n\t\t\t * Just go on, returning success, leaving the\n\t\t\t * empty block in place.\n\t\t\t */\n\t\t\tif (error == -ENOSPC && args->total == 0)\n\t\t\t\terror = 0;\n\t\t\txfs_dir3_leaf_check(dp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\tdbp = NULL;\n\t\t/*\n\t\t * If this is the last data block then compact the\n\t\t * bests table by getting rid of entries.\n\t\t */\n\t\tif (db == be32_to_cpu(ltp->bestcount) - 1) {\n\t\t\t/*\n\t\t\t * Look for the last active entry (i).\n\t\t\t */\n\t\t\tfor (i = db - 1; i > 0; i--) {\n\t\t\t\tif (bestsp[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy the table down so inactive entries at the\n\t\t\t * end are removed.\n\t\t\t */\n\t\t\tmemmove(&bestsp[db - i], bestsp,\n\t\t\t\t(be32_to_cpu(ltp->bestcount) - (db - i)) * sizeof(*bestsp));\n\t\t\tbe32_add_cpu(&ltp->bestcount, -(db - i));\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t} else\n\t\t\tbestsp[db] = cpu_to_be16(NULLDATAOFF);\n\t}\n\t/*\n\t * If the data block was not the first one, drop it.\n\t */\n\telse if (db != args->geo->datablk)\n\t\tdbp = NULL;\n\n\txfs_dir3_leaf_check(dp, lbp);\n\t/*\n\t * See if we can convert to block form.\n\t */\n\treturn xfs_dir2_leaf_to_block(args, lbp, dbp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_to_block",
          "args": [
            "args",
            "lbp",
            "dbp"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "897-1037",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_bests",
          "args": [
            "args",
            "lbp",
            "0",
            "be32_to_cpu(ltp->bestcount) - 1"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1051-1072",
          "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_tail",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1125-1141",
          "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&ltp->bestcount",
            "-(db - i)"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&bestsp[db - i]",
            "bestsp",
            "(be32_to_cpu(ltp->bestcount) - (db - i)) * sizeof(*bestsp)"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "db",
            "dbp"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "db != args->geo->datablk"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "dbp"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "lbp",
            "index",
            "index"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_make_free",
          "args": [
            "args",
            "dbp",
            "(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr)",
            "dp->d_ops->data_entsize(dep->namelen)",
            "&needlog",
            "&needscan"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_make_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "714-894",
          "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(bestsp[db]) == oldbest"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bestsp[db]"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_lookup_int",
          "args": [
            "args",
            "&lbp",
            "&index",
            "&dbp"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1204-1331",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_removename",
          "args": [
            "args"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_removename(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf block best freespace */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry structure */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_db_t\t\ti;\t\t/* temporary data block # */\n\tint\t\t\tindex;\t\t/* index into leaf entries */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_dir2_data_off_t\toldbest;\t/* old value of best free */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_removename(args);\n\n\t/*\n\t * Lookup the leaf entry, get the leaf and data blocks read in.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Point to the leaf entry, use that to point to the data entry.\n\t */\n\tlep = &ents[index];\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\txfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\tneedscan = needlog = 0;\n\toldbest = be16_to_cpu(bf[0].length);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tASSERT(be16_to_cpu(bestsp[db]) == oldbest);\n\t/*\n\t * Mark the former data entry unused.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * We just mark the leaf entry stale by putting a null in it.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, lbp, index, index);\n\n\t/*\n\t * Scan the freespace in the data block again if necessary,\n\t * log the data block header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the longest freespace in the data block has changed,\n\t * put the new value in the bests table and log that.\n\t */\n\tif (be16_to_cpu(bf[0].length) != oldbest) {\n\t\tbestsp[db] = bf[0].length;\n\t\txfs_dir3_leaf_log_bests(args, lbp, db, db);\n\t}\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the data block is now empty then get rid of the data block.\n\t */\n\tif (be16_to_cpu(bf[0].length) ==\n\t\t\targs->geo->blksize - dp->d_ops->data_entry_offset) {\n\t\tASSERT(db != args->geo->datablk);\n\t\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\t\t/*\n\t\t\t * Nope, can't get rid of it because it caused\n\t\t\t * allocation of a bmap btree block to do so.\n\t\t\t * Just go on, returning success, leaving the\n\t\t\t * empty block in place.\n\t\t\t */\n\t\t\tif (error == -ENOSPC && args->total == 0)\n\t\t\t\terror = 0;\n\t\t\txfs_dir3_leaf_check(dp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\tdbp = NULL;\n\t\t/*\n\t\t * If this is the last data block then compact the\n\t\t * bests table by getting rid of entries.\n\t\t */\n\t\tif (db == be32_to_cpu(ltp->bestcount) - 1) {\n\t\t\t/*\n\t\t\t * Look for the last active entry (i).\n\t\t\t */\n\t\t\tfor (i = db - 1; i > 0; i--) {\n\t\t\t\tif (bestsp[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Copy the table down so inactive entries at the\n\t\t\t * end are removed.\n\t\t\t */\n\t\t\tmemmove(&bestsp[db - i], bestsp,\n\t\t\t\t(be32_to_cpu(ltp->bestcount) - (db - i)) * sizeof(*bestsp));\n\t\t\tbe32_add_cpu(&ltp->bestcount, -(db - i));\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t} else\n\t\t\tbestsp[db] = cpu_to_be16(NULLDATAOFF);\n\t}\n\t/*\n\t * If the data block was not the first one, drop it.\n\t */\n\telse if (db != args->geo->datablk)\n\t\tdbp = NULL;\n\n\txfs_dir3_leaf_check(dp, lbp);\n\t/*\n\t * See if we can convert to block form.\n\t */\n\treturn xfs_dir2_leaf_to_block(args, lbp, dbp);\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_lookup_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1204-1331",
    "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "lbp"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cidb == -1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, cidb)",
            "-1",
            "&dbp"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "cidb"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cidb != -1"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp->m_dirnameops->compname",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->hashval"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_search_hash",
          "args": [
            "args",
            "lbp"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_search_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1534-1582",
          "snippet": "int\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_read",
          "args": [
            "tp",
            "dp",
            "args->geo->leafblk",
            "-1",
            "&lbp"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "254-269",
          "snippet": "static int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\n\nstatic int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1148-1196",
    "snippet": "int\nxfs_dir2_leaf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* found entry index */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_lookup(args);\n\n\t/*\n\t * Look up name in the leaf block, returning both buffers and index.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\ttp = args->trans;\n\tdp = args->dp;\n\txfs_dir3_leaf_check(dp, lbp);\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Get to the leaf entry and contained data entry address.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\t/*\n\t * Return the found inode number & CI name if appropriate\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "lbp"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_cilookup_result",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_cilookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "327-346",
          "snippet": "int\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_lookup_int",
          "args": [
            "args",
            "&lbp",
            "&index",
            "&dbp"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1204-1331",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leaf_lookup_int(xfs_da_args_t *args, struct xfs_buf **lbpp,\n\t\t\t\t    int *indexp, struct xfs_buf **dbpp);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leaf_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t**lbpp,\t\t/* out: leaf buffer */\n\tint\t\t\t*indexp,\t/* out: index in leaf block */\n\tstruct xfs_buf\t\t**dbpp)\t\t/* out: data buffer */\n{\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\tstruct xfs_buf\t\t*dbp = NULL;\t/* data buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* index in leaf block */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tcidb = -1;\t/* case match data block no. */\n\tenum xfs_dacmp\t\tcmp;\t\t/* name compare result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t*lbpp = lbp;\n\tleaf = lbp->b_addr;\n\txfs_dir3_leaf_check(dp, lbp);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Look for the first leaf entry with our hash value.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\t/*\n\t * Loop over all the entries with the right hash value\n\t * looking to match the name.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip over stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the new data block number.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * If it's not the same as the old data block number,\n\t\t * need to pitch the old one and read the new one.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\tif (dbp)\n\t\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, newdb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)dbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*indexp = index;\n\t\t\t/* case exact match: return the current buffer. */\n\t\t\tif (cmp == XFS_CMP_EXACT) {\n\t\t\t\t*dbpp = dbp;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcidb = curdb;\n\t\t}\n\t}\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or remove).\n\t * If a case-insensitive match was found earlier, re-read the\n\t * appropriate data block if required and return it.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE) {\n\t\tASSERT(cidb != -1);\n\t\tif (cidb != curdb) {\n\t\t\txfs_trans_brelse(tp, dbp);\n\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, cidb),\n\t\t\t\t\t   -1, &dbp);\n\t\t\tif (error) {\n\t\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t\t*dbpp = dbp;\n\t\treturn 0;\n\t}\n\t/*\n\t * No match found, return -ENOENT.\n\t */\n\tASSERT(cidb == -1);\n\tif (dbp)\n\t\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_lookup",
          "args": [
            "args"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_leaf_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tint\t\t\tindex;\t\t/* found entry index */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leaf_lookup(args);\n\n\t/*\n\t * Look up name in the leaf block, returning both buffers and index.\n\t */\n\tif ((error = xfs_dir2_leaf_lookup_int(args, &lbp, &index, &dbp))) {\n\t\treturn error;\n\t}\n\ttp = args->trans;\n\tdp = args->dp;\n\txfs_dir3_leaf_check(dp, lbp);\n\tleaf = lbp->b_addr;\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\t/*\n\t * Get to the leaf entry and contained data entry address.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Point to the data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)\n\t      ((char *)dbp->b_addr +\n\t       xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));\n\t/*\n\t * Return the found inode number & CI name if appropriate\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(tp, dbp);\n\txfs_trans_brelse(tp, lbp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1125-1141",
    "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)ltp - (char *)leaf)",
            "(uint)(args->geo->blksize - 1)"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args->geo->blksize - 1"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)ltp - (char *)leaf"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_log_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1105-1120",
    "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)&leaf->hdr - (char *)leaf)",
            "args->dp->d_ops->leaf_hdr_size - 1"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&leaf->hdr - (char *)leaf"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_log_ents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1077-1100",
    "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)firstlep - (char *)leaf)",
            "(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)firstlep - (char *)leaf"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_log_bests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "1051-1072",
    "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)firstb - (char *)leaf)",
            "(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1)"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)lastb - (char *)leaf + sizeof(*lastb) - 1"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)firstb - (char *)leaf"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC)"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_compact_x1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "962-1046",
    "snippet": "void\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "from > to"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_find_stale",
          "args": [
            "leafhdr",
            "ents",
            "index",
            "&lowstale",
            "&highstale"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_find_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "477-506",
          "snippet": "STATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr->stale > 1"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nvoid\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "907-952",
    "snippet": "void\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "bp",
            "loglow",
            "to - 1"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "leafhdr"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr->stale == from - to"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "601-901",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "dbp"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "lbp",
            "lfloglow",
            "lfloghigh"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "lbp"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp))"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_dataptr",
          "args": [
            "args->geo",
            "use_block",
            "be16_to_cpu(*tagp)"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "277-282",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->hashval"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_find_entry",
          "args": [
            "&leafhdr",
            "ents",
            "index",
            "compact",
            "lowstale",
            "highstale",
            "&lfloglow",
            "&lfloghigh"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "508-596",
          "snippet": "struct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_bests",
          "args": [
            "args",
            "lbp",
            "use_block",
            "use_block"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1051-1072",
          "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bestsp[use_block]"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "dbp",
            "dep"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dep->name",
            "args->name",
            "dep->namelen"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->inumber"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_use_free",
          "args": [
            "args",
            "dbp",
            "dup",
            "(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr)",
            "length",
            "&needlog",
            "&needscan"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_use_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "899-1048",
          "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(dup->length) >= length"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].offset"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "lbp"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, use_block)",
            "-1",
            "&dbp"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "use_block"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_tail",
          "args": [
            "args",
            "lbp"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1125-1141",
          "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&ltp->bestcount",
            "1"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&bestsp[0]",
            "&bestsp[1]",
            "be32_to_cpu(ltp->bestcount) * sizeof(bestsp[0])"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_init",
          "args": [
            "args",
            "use_block",
            "&dbp"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "565-635",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_grow_inode",
          "args": [
            "args",
            "XFS_DIR2_DATA_SPACE",
            "&use_block"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "575-614",
          "snippet": "int\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_compact_x1",
          "args": [
            "&leafhdr",
            "ents",
            "&index",
            "&lowstale",
            "&highstale",
            "&lfloglow",
            "&lfloghigh"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_compact_x1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "962-1046",
          "snippet": "void\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nvoid\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_addname",
          "args": [
            "args"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1566-1630",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_to_node",
          "args": [
            "args",
            "lbp"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_to_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "284-366",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_node(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\txfs_dir2_db_t\t\tfdb;\t\t/* freespace block number */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*from;\t\t/* pointer to freespace entry */\n\tint\t\t\ti;\t\t/* leaf freespace index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tn;\t\t/* count of live freespc ents */\n\txfs_dir2_data_off_t\toff;\t\t/* freespace entry value */\n\t__be16\t\t\t*to;\t\t/* pointer to freespace entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\ttrace_xfs_dir2_leaf_to_node(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add a freespace block to the directory.\n\t */\n\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\n\t\treturn error;\n\t}\n\tASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\t/*\n\t * Get the buffer for the new freespace block.\n\t */\n\terror = xfs_dir3_free_get_buf(args, fdb, &fbp);\n\tif (error)\n\t\treturn error;\n\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tASSERT(be32_to_cpu(ltp->bestcount) <=\n\t\t\t\t(uint)dp->i_d.di_size / args->geo->blksize);\n\n\t/*\n\t * Copy freespace entries from the leaf block to the new block.\n\t * Count active entries.\n\t */\n\tfrom = xfs_dir2_leaf_bests_p(ltp);\n\tto = dp->d_ops->free_bests_p(free);\n\tfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\n\t\tif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\n\t\t\tn++;\n\t\t*to = cpu_to_be16(off);\n\t}\n\n\t/*\n\t * Now initialize the freespace block header.\n\t */\n\tfreehdr.nused = n;\n\tfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\n\n\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\txfs_dir2_free_log_bests(args, fbp, 0, freehdr.nvalid - 1);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * Converting the leaf to a leafnode is just a matter of changing the\n\t * magic number and the ops. Do the change directly to the buffer as\n\t * it's less work (and less code) than decoding the header to host\n\t * format and back again.\n\t */\n\tif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\n\telse\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\tlbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_node(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\txfs_dir2_db_t\t\tfdb;\t\t/* freespace block number */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*from;\t\t/* pointer to freespace entry */\n\tint\t\t\ti;\t\t/* leaf freespace index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tn;\t\t/* count of live freespc ents */\n\txfs_dir2_data_off_t\toff;\t\t/* freespace entry value */\n\t__be16\t\t\t*to;\t\t/* pointer to freespace entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\ttrace_xfs_dir2_leaf_to_node(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add a freespace block to the directory.\n\t */\n\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\n\t\treturn error;\n\t}\n\tASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\t/*\n\t * Get the buffer for the new freespace block.\n\t */\n\terror = xfs_dir3_free_get_buf(args, fdb, &fbp);\n\tif (error)\n\t\treturn error;\n\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tASSERT(be32_to_cpu(ltp->bestcount) <=\n\t\t\t\t(uint)dp->i_d.di_size / args->geo->blksize);\n\n\t/*\n\t * Copy freespace entries from the leaf block to the new block.\n\t * Count active entries.\n\t */\n\tfrom = xfs_dir2_leaf_bests_p(ltp);\n\tto = dp->d_ops->free_bests_p(free);\n\tfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\n\t\tif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\n\t\t\tn++;\n\t\t*to = cpu_to_be16(off);\n\t}\n\n\t/*\n\t * Now initialize the freespace block header.\n\t */\n\tfreehdr.nused = n;\n\tfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\n\n\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\txfs_dir2_free_log_bests(args, fbp, 0, freehdr.nvalid - 1);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * Converting the leaf to a leafnode is just a matter of changing the\n\t * magic number and the ops. Do the change directly to the buffer as\n\t * it's less work (and less code) than decoding the header to host\n\t * format and back again.\n\t */\n\tif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\n\telse\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\tlbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bestsp[i]"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bestsp[i]"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bestsp[i] != cpu_to_be16(NULLDATAOFF)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i < be32_to_cpu(ltp->bestcount)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->hashval"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_search_hash",
          "args": [
            "args",
            "lbp"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_search_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1534-1582",
          "snippet": "int\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_read",
          "args": [
            "tp",
            "dp",
            "args->geo->leafblk",
            "-1",
            "&lbp"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "254-269",
          "snippet": "static int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\n\nstatic int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_addname",
          "args": [
            "args"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "508-596",
    "snippet": "struct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "highstale",
            "*lfloghigh"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "index",
            "*lfloglow"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ents[index + 1]",
            "&ents[index]",
            "(highstale - index) * sizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "highstale - index >= 0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "index - 1",
            "*lfloghigh"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "lowstale",
            "*lfloglow"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ents[lowstale]",
            "&ents[lowstale + 1]",
            "(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "index - lowstale - 1 >= 0"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_find_stale",
          "args": [
            "leafhdr",
            "ents",
            "index",
            "&lowstale",
            "&highstale"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_find_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "477-506",
          "snippet": "STATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "lep + 1",
            "lep",
            "(leafhdr->count - index) * sizeof(*lep)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_find_stale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "477-506",
    "snippet": "STATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir3_leaf_find_stale(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\n\tint\t\t\t*lowstale,\n\tint\t\t\t*highstale)\n{\n\t/*\n\t * Find the first stale entry before our index, if any.\n\t */\n\tfor (*lowstale = index - 1; *lowstale >= 0; --*lowstale) {\n\t\tif (ents[*lowstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Find the first stale entry at or after our index, if any.\n\t * Stop if the result would require moving more entries than using\n\t * lowstale.\n\t */\n\tfor (*highstale = index; *highstale < leafhdr->count; ++*highstale) {\n\t\tif (ents[*highstale].address ==\n\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tbreak;\n\t\tif (*lowstale >= 0 && index - *lowstale <= *highstale - index)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_dir2_block_to_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "369-475",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_leaf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*dbp)\t\t/* input block's buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf's bestsp entries */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block's bno */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block's leaf entries */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block's tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf block's buffer */\n\txfs_dir2_db_t\t\tldb;\t\t/* leaf block's bno */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf's tail */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to rescan bestfree */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_block_to_leaf(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add the leaf block to the inode.\n\t * This interface will only put blocks in the leaf/node range.\n\t * Since that's empty now, we'll get the root (block 0 in range).\n\t */\n\tif ((error = xfs_da_grow_inode(args, &blkno))) {\n\t\treturn error;\n\t}\n\tldb = xfs_dir2_da_to_db(args->geo, blkno);\n\tASSERT(ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET));\n\t/*\n\t * Initialize the leaf block, get a buffer for it.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, ldb, &lbp, XFS_DIR2_LEAF1_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Set the counts in the leaf header.\n\t */\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tleafhdr.count = be32_to_cpu(btp->count);\n\tleafhdr.stale = be32_to_cpu(btp->stale);\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\t/*\n\t * Could compact these but I think we always do the conversion\n\t * after squeezing out stale entries.\n\t */\n\tmemcpy(ents, blp, be32_to_cpu(btp->count) * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, lbp, 0, leafhdr.count - 1);\n\tneedscan = 0;\n\tneedlog = 1;\n\t/*\n\t * Make the space formerly occupied by the leaf entries and block\n\t * tail be free.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp),\n\t\t&needlog, &needscan);\n\t/*\n\t * Fix up the block header, make it a data block.\n\t */\n\tdbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, dbp, XFS_BLFT_DIR_DATA_BUF);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\telse\n\t\thdr->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Set up leaf tail and bests table.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(1);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbestsp[0] =  bf[0].length;\n\t/*\n\t * Log the data header and leaf bests table.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_bests",
          "args": [
            "args",
            "lbp",
            "0",
            "0"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1051-1072",
          "snippet": "static void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\t__be16\t\t\t*firstb;\t/* pointer to first entry */\n\t__be16\t\t\t*lastb;\t\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tfirstb = xfs_dir2_leaf_bests_p(ltp) + first;\n\tlastb = xfs_dir2_leaf_bests_p(ltp) + last;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstb - (char *)leaf),\n\t\t(uint)((char *)lastb - (char *)leaf + sizeof(*lastb) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "dbp"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "dbp",
            "XFS_BLFT_DIR_DATA_BUF"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_make_free",
          "args": [
            "args",
            "dbp",
            "(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr)",
            "(xfs_dir2_data_aoff_t)((char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp)",
            "&needlog",
            "&needscan"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_make_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "714-894",
          "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)blp - (char *)hdr"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "lbp",
            "0",
            "leafhdr.count - 1"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ents",
            "blp",
            "be32_to_cpu(btp->count) * sizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "lbp"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_get_buf",
          "args": [
            "args",
            "ldb",
            "&lbp",
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "336-364",
          "snippet": "int\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nint\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_LEAF_OFFSET"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "args->geo",
            "blkno"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "args",
            "&blkno"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_to_leaf",
          "args": [
            "args"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_leaf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*dbp)\t\t/* input block's buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf's bestsp entries */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block's bno */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block's leaf entries */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block's tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf block's buffer */\n\txfs_dir2_db_t\t\tldb;\t\t/* leaf block's bno */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf's tail */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to rescan bestfree */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_block_to_leaf(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add the leaf block to the inode.\n\t * This interface will only put blocks in the leaf/node range.\n\t * Since that's empty now, we'll get the root (block 0 in range).\n\t */\n\tif ((error = xfs_da_grow_inode(args, &blkno))) {\n\t\treturn error;\n\t}\n\tldb = xfs_dir2_da_to_db(args->geo, blkno);\n\tASSERT(ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET));\n\t/*\n\t * Initialize the leaf block, get a buffer for it.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, ldb, &lbp, XFS_DIR2_LEAF1_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Set the counts in the leaf header.\n\t */\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tleafhdr.count = be32_to_cpu(btp->count);\n\tleafhdr.stale = be32_to_cpu(btp->stale);\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\t/*\n\t * Could compact these but I think we always do the conversion\n\t * after squeezing out stale entries.\n\t */\n\tmemcpy(ents, blp, be32_to_cpu(btp->count) * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, lbp, 0, leafhdr.count - 1);\n\tneedscan = 0;\n\tneedlog = 1;\n\t/*\n\t * Make the space formerly occupied by the leaf entries and block\n\t * tail be free.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp),\n\t\t&needlog, &needscan);\n\t/*\n\t * Fix up the block header, make it a data block.\n\t */\n\tdbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, dbp, XFS_BLFT_DIR_DATA_BUF);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\telse\n\t\thdr->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Set up leaf tail and bests table.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(1);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbestsp[0] =  bf[0].length;\n\t/*\n\t * Log the data header and leaf bests table.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_get_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "336-364",
    "snippet": "int\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_tail",
          "args": [
            "args",
            "bp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1125-1141",
          "snippet": "STATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC void\nxfs_dir3_leaf_log_tail(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)ltp - (char *)leaf),\n\t\t(uint)(args->geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_init",
          "args": [
            "mp",
            "tp",
            "bp",
            "dp->i_ino",
            "magic"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "291-334",
          "snippet": "static void\nxfs_dir3_leaf_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_ino_t\t\towner,\n\t__uint16_t\t\ttype)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(type == XFS_DIR2_LEAF1_MAGIC || type == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\n\t\tmemset(leaf3, 0, sizeof(*leaf3));\n\n\t\tleaf3->info.hdr.magic = (type == XFS_DIR2_LEAF1_MAGIC)\n\t\t\t\t\t ? cpu_to_be16(XFS_DIR3_LEAF1_MAGIC)\n\t\t\t\t\t : cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\t\tleaf3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\tleaf3->info.owner = cpu_to_be64(owner);\n\t\tuuid_copy(&leaf3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tmemset(leaf, 0, sizeof(*leaf));\n\t\tleaf->hdr.info.magic = cpu_to_be16(type);\n\t}\n\n\t/*\n\t * If it's a leaf-format directory initialize the tail.\n\t * Caller is responsible for initialising the bests table.\n\t */\n\tif (type == XFS_DIR2_LEAF1_MAGIC) {\n\t\tstruct xfs_dir2_leaf_tail *ltp;\n\n\t\tltp = xfs_dir2_leaf_tail_p(mp->m_dir_geo, leaf);\n\t\tltp->bestcount = 0;\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAF1_BUF);\n\t} else {\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);",
            "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};",
            "const struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\nconst struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};\n\nstatic void\nxfs_dir3_leaf_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_ino_t\t\towner,\n\t__uint16_t\t\ttype)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(type == XFS_DIR2_LEAF1_MAGIC || type == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\n\t\tmemset(leaf3, 0, sizeof(*leaf3));\n\n\t\tleaf3->info.hdr.magic = (type == XFS_DIR2_LEAF1_MAGIC)\n\t\t\t\t\t ? cpu_to_be16(XFS_DIR3_LEAF1_MAGIC)\n\t\t\t\t\t : cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\t\tleaf3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\tleaf3->info.owner = cpu_to_be64(owner);\n\t\tuuid_copy(&leaf3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tmemset(leaf, 0, sizeof(*leaf));\n\t\tleaf->hdr.info.magic = cpu_to_be16(type);\n\t}\n\n\t/*\n\t * If it's a leaf-format directory initialize the tail.\n\t * Caller is responsible for initialising the bests table.\n\t */\n\tif (type == XFS_DIR2_LEAF1_MAGIC) {\n\t\tstruct xfs_dir2_leaf_tail *ltp;\n\n\t\tltp = xfs_dir2_leaf_tail_p(mp->m_dir_geo, leaf);\n\t\tltp->bestcount = 0;\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAF1_BUF);\n\t} else {\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, bno)",
            "-1",
            "&bp",
            "XFS_DATA_FORK"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "bno"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nint\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "291-334",
    "snippet": "static void\nxfs_dir3_leaf_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_ino_t\t\towner,\n\t__uint16_t\t\ttype)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(type == XFS_DIR2_LEAF1_MAGIC || type == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\n\t\tmemset(leaf3, 0, sizeof(*leaf3));\n\n\t\tleaf3->info.hdr.magic = (type == XFS_DIR2_LEAF1_MAGIC)\n\t\t\t\t\t ? cpu_to_be16(XFS_DIR3_LEAF1_MAGIC)\n\t\t\t\t\t : cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\t\tleaf3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\tleaf3->info.owner = cpu_to_be64(owner);\n\t\tuuid_copy(&leaf3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tmemset(leaf, 0, sizeof(*leaf));\n\t\tleaf->hdr.info.magic = cpu_to_be16(type);\n\t}\n\n\t/*\n\t * If it's a leaf-format directory initialize the tail.\n\t * Caller is responsible for initialising the bests table.\n\t */\n\tif (type == XFS_DIR2_LEAF1_MAGIC) {\n\t\tstruct xfs_dir2_leaf_tail *ltp;\n\n\t\tltp = xfs_dir2_leaf_tail_p(mp->m_dir_geo, leaf);\n\t\tltp->bestcount = 0;\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAF1_BUF);\n\t} else {\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);",
      "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};",
      "const struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DIR_LEAFN_BUF"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "mp->m_dir_geo",
            "leaf"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "type"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "leaf",
            "0",
            "sizeof(*leaf)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&leaf3->info.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "owner"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "leaf3",
            "0",
            "sizeof(*leaf3)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type == XFS_DIR2_LEAF1_MAGIC || type == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\nconst struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};\n\nstatic void\nxfs_dir3_leaf_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\txfs_ino_t\t\towner,\n\t__uint16_t\t\ttype)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(type == XFS_DIR2_LEAF1_MAGIC || type == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\n\t\tmemset(leaf3, 0, sizeof(*leaf3));\n\n\t\tleaf3->info.hdr.magic = (type == XFS_DIR2_LEAF1_MAGIC)\n\t\t\t\t\t ? cpu_to_be16(XFS_DIR3_LEAF1_MAGIC)\n\t\t\t\t\t : cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\t\tleaf3->info.blkno = cpu_to_be64(bp->b_bn);\n\t\tleaf3->info.owner = cpu_to_be64(owner);\n\t\tuuid_copy(&leaf3->info.uuid, &mp->m_sb.sb_uuid);\n\t} else {\n\t\tmemset(leaf, 0, sizeof(*leaf));\n\t\tleaf->hdr.info.magic = cpu_to_be16(type);\n\t}\n\n\t/*\n\t * If it's a leaf-format directory initialize the tail.\n\t * Caller is responsible for initialising the bests table.\n\t */\n\tif (type == XFS_DIR2_LEAF1_MAGIC) {\n\t\tstruct xfs_dir2_leaf_tail *ltp;\n\n\t\tltp = xfs_dir2_leaf_tail_p(mp->m_dir_geo, leaf);\n\t\tltp->bestcount = 0;\n\t\tbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAF1_BUF);\n\t} else {\n\t\tbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_LEAFN_BUF);\n\t}\n}"
  },
  {
    "function_name": "xfs_dir3_leafn_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "271-286",
    "snippet": "int\nxfs_dir3_leafn_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leafn_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAFN_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_DIR_LEAFN_BUF"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "fbno",
            "mappedbno",
            "bpp",
            "XFS_DATA_FORK",
            "&xfs_dir3_leafn_buf_ops"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};\n\nint\nxfs_dir3_leafn_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leafn_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAFN_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "254-269",
    "snippet": "static int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_DIR_LEAF1_BUF"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "fbno",
            "mappedbno",
            "bpp",
            "XFS_DATA_FORK",
            "&xfs_dir3_leaf1_buf_ops"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\n\nstatic int\nxfs_dir3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leaf1_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAF1_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_dir3_leafn_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "237-242",
    "snippet": "static void\nxfs_dir3_leafn_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__write_verify(bp, XFS_DIR2_LEAFN_MAGIC);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__write_verify",
          "args": [
            "bp",
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__write_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "192-214",
          "snippet": "static void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leafn_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__write_verify(bp, XFS_DIR2_LEAFN_MAGIC);\n}"
  },
  {
    "function_name": "xfs_dir3_leafn_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "230-235",
    "snippet": "static void\nxfs_dir3_leafn_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__read_verify(bp, XFS_DIR2_LEAFN_MAGIC);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__read_verify",
          "args": [
            "bp",
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "__read_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "175-190",
          "snippet": "static void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leafn_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__read_verify(bp, XFS_DIR2_LEAFN_MAGIC);\n}"
  },
  {
    "function_name": "xfs_dir3_leaf1_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "223-228",
    "snippet": "static void\nxfs_dir3_leaf1_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__write_verify(bp, XFS_DIR2_LEAF1_MAGIC);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__write_verify",
          "args": [
            "bp",
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__write_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "192-214",
          "snippet": "static void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf1_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__write_verify(bp, XFS_DIR2_LEAF1_MAGIC);\n}"
  },
  {
    "function_name": "xfs_dir3_leaf1_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "216-221",
    "snippet": "static void\nxfs_dir3_leaf1_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__read_verify(bp, XFS_DIR2_LEAF1_MAGIC);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__read_verify",
          "args": [
            "bp",
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__read_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "175-190",
          "snippet": "static void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_leaf1_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\t__read_verify(bp, XFS_DIR2_LEAF1_MAGIC);\n}"
  },
  {
    "function_name": "__write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "192-214",
    "snippet": "static void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_DIR3_LEAF_CRC_OFF"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_verify",
          "args": [
            "bp",
            "magic"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "144-173",
          "snippet": "static bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__write_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_leaf_hdr *hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_leaf_verify(bp, magic)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_LEAF_CRC_OFF);\n}"
  },
  {
    "function_name": "__read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "175-190",
    "snippet": "static void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_verify",
          "args": [
            "bp",
            "magic"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "144-173",
          "snippet": "static bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_DIR3_LEAF_CRC_OFF"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic void\n__read_verify(\n\tstruct xfs_buf  *bp,\n\t__uint16_t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_LEAF_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_leaf_verify(bp, magic))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "144-173",
    "snippet": "static bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check_int",
          "args": [
            "mp",
            "NULL",
            "NULL",
            "leaf"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_check_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "81-137",
          "snippet": "bool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "magic"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "leaf3->info.blkno"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&leaf3->info.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "magic3"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_leaf_verify(\n\tstruct xfs_buf\t\t*bp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\t__uint16_t\t\tmagic3;\n\n\t\tmagic3 = (magic == XFS_DIR2_LEAF1_MAGIC) ? XFS_DIR3_LEAF1_MAGIC\n\t\t\t\t\t\t\t : XFS_DIR3_LEAFN_MAGIC;\n\n\t\tif (leaf3->info.hdr.magic != cpu_to_be16(magic3))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&leaf3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (leaf->hdr.info.magic != cpu_to_be16(magic))\n\t\t\treturn false;\n\t}\n\n\treturn xfs_dir3_leaf_check_int(mp, NULL, NULL, leaf);\n}"
  },
  {
    "function_name": "xfs_dir3_leaf_check_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "81-137",
    "snippet": "bool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[i + 1].hashval"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[i].hashval"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->leaf_max_ents",
          "args": [
            "geo"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "geo",
            "leaf"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir_get_ops",
          "args": [
            "mp",
            "dp"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_get_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.c",
          "lines": "880-894",
          "snippet": "const struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}",
          "includes": [
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};",
            "static const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_dir_ops xfs_dir2_ops = {\n\t.sf_entsize = xfs_dir2_sf_entsize,\n\t.sf_nextentry = xfs_dir2_sf_nextentry,\n\t.sf_get_ftype = xfs_dir2_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir2_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir2_sfe_get_ino,\n\t.sf_put_ino = xfs_dir2_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir2_data_entsize,\n\t.data_get_ftype = xfs_dir2_data_get_ftype,\n\t.data_put_ftype = xfs_dir2_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir2_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR2_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir2_ftype_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir2_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir2_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir2_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir2_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir2_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir2_ftype_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir2_ftype_data_first_entry_p,\n\t.data_entry_p = xfs_dir2_data_entry_p,\n\t.data_unused_p = xfs_dir2_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir2_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir2_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir2_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir2_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir2_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da_node_hdr),\n\t.node_hdr_to_disk = xfs_da2_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da2_node_hdr_from_disk,\n\t.node_tree_p = xfs_da2_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir2_free_hdr),\n\t.free_hdr_to_disk = xfs_dir2_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir2_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir2_free_max_bests,\n\t.free_bests_p = xfs_dir2_free_bests_p,\n\t.db_to_fdb = xfs_dir2_db_to_fdb,\n\t.db_to_fdindex = xfs_dir2_db_to_fdindex,\n};\nstatic const struct xfs_dir_ops xfs_dir3_ops = {\n\t.sf_entsize = xfs_dir3_sf_entsize,\n\t.sf_nextentry = xfs_dir3_sf_nextentry,\n\t.sf_get_ftype = xfs_dir3_sfe_get_ftype,\n\t.sf_put_ftype = xfs_dir3_sfe_put_ftype,\n\t.sf_get_ino = xfs_dir3_sfe_get_ino,\n\t.sf_put_ino = xfs_dir3_sfe_put_ino,\n\t.sf_get_parent_ino = xfs_dir2_sf_get_parent_ino,\n\t.sf_put_parent_ino = xfs_dir2_sf_put_parent_ino,\n\n\t.data_entsize = xfs_dir3_data_entsize,\n\t.data_get_ftype = xfs_dir3_data_get_ftype,\n\t.data_put_ftype = xfs_dir3_data_put_ftype,\n\t.data_entry_tag_p = xfs_dir3_data_entry_tag_p,\n\t.data_bestfree_p = xfs_dir3_data_bestfree_p,\n\n\t.data_dot_offset = sizeof(struct xfs_dir3_data_hdr),\n\t.data_dotdot_offset = sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1),\n\t.data_first_offset =  sizeof(struct xfs_dir3_data_hdr) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(1) +\n\t\t\t\tXFS_DIR3_DATA_ENTSIZE(2),\n\t.data_entry_offset = sizeof(struct xfs_dir3_data_hdr),\n\n\t.data_dot_entry_p = xfs_dir3_data_dot_entry_p,\n\t.data_dotdot_entry_p = xfs_dir3_data_dotdot_entry_p,\n\t.data_first_entry_p = xfs_dir3_data_first_entry_p,\n\t.data_entry_p = xfs_dir3_data_entry_p,\n\t.data_unused_p = xfs_dir3_data_unused_p,\n\n\t.leaf_hdr_size = sizeof(struct xfs_dir3_leaf_hdr),\n\t.leaf_hdr_to_disk = xfs_dir3_leaf_hdr_to_disk,\n\t.leaf_hdr_from_disk = xfs_dir3_leaf_hdr_from_disk,\n\t.leaf_max_ents = xfs_dir3_max_leaf_ents,\n\t.leaf_ents_p = xfs_dir3_leaf_ents_p,\n\n\t.node_hdr_size = sizeof(struct xfs_da3_node_hdr),\n\t.node_hdr_to_disk = xfs_da3_node_hdr_to_disk,\n\t.node_hdr_from_disk = xfs_da3_node_hdr_from_disk,\n\t.node_tree_p = xfs_da3_node_tree_p,\n\n\t.free_hdr_size = sizeof(struct xfs_dir3_free_hdr),\n\t.free_hdr_to_disk = xfs_dir3_free_hdr_to_disk,\n\t.free_hdr_from_disk = xfs_dir3_free_hdr_from_disk,\n\t.free_max_bests = xfs_dir3_free_max_bests,\n\t.free_bests_p = xfs_dir3_free_bests_p,\n\t.db_to_fdb = xfs_dir3_db_to_fdb,\n\t.db_to_fdindex = xfs_dir3_db_to_fdindex,\n};\n\nconst struct xfs_dir_ops *\nxfs_dir_get_ops(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp)\n{\n\tif (dp)\n\t\treturn dp->d_ops;\n\tif (mp->m_dir_inode_ops)\n\t\treturn mp->m_dir_inode_ops;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn &xfs_dir3_ops;\n\tif (xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn &xfs_dir2_ftype_ops;\n\treturn &xfs_dir2_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dir3_leaf1_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
    "lines": "58-76",
    "snippet": "STATIC bool\nxfs_dir3_leaf1_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tif (leafhdr.magic == XFS_DIR3_LEAF1_MAGIC) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else if (leafhdr.magic != XFS_DIR2_LEAF1_MAGIC)\n\t\treturn false;\n\n\treturn xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check_int",
          "args": [
            "dp->i_mount",
            "dp",
            "&leafhdr",
            "leaf"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_check_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "81-137",
          "snippet": "bool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "leaf3->info.blkno"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nSTATIC bool\nxfs_dir3_leaf1_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tif (leafhdr.magic == XFS_DIR3_LEAF1_MAGIC) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else if (leafhdr.magic != XFS_DIR2_LEAF1_MAGIC)\n\t\treturn false;\n\n\treturn xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);\n}"
  }
]