[
  {
    "function_name": "udf_truncate_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
    "lines": "203-287",
    "snippet": "void udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_alloc_ext_desc",
          "args": [
            "inode",
            "&epos",
            "lenalloc"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_alloc_ext_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "180-196",
          "snippet": "static void udf_update_alloc_ext_desc(struct inode *inode,\n\t\t\t\t      struct extent_position *epos,\n\t\t\t\t      u32 lenalloc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\n\tint len = sizeof(struct allocExtDesc);\n\n\taed->lengthAllocDescs =\tcpu_to_le32(lenalloc);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\n\t\tlen += lenalloc;\n\n\tudf_update_tag(epos->bh->b_data, len);\n\tmark_buffer_dirty_inode(epos->bh, inode);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void udf_update_alloc_ext_desc(struct inode *inode,\n\t\t\t\t      struct extent_position *epos,\n\t\t\t\t      u32 lenalloc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\n\tint len = sizeof(struct allocExtDesc);\n\n\taed->lengthAllocDescs =\tcpu_to_le32(lenalloc);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\n\t\tlen += lenalloc;\n\n\tudf_update_tag(epos->bh->b_data, len);\n\tmark_buffer_dirty_inode(epos->bh, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "sb",
            "NULL",
            "&epos.block",
            "0",
            "indirect_ext_len"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!epos.bh"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_trunc",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "etype",
            "elen",
            "0"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "extent_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "30-62",
          "snippet": "static void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "udf_get_lb_pblock(sb, &eloc, 0)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "&eloc",
            "0"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!epos.bh"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "&epos",
            "&neloc",
            "nelen",
            "0"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_current_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "&elen",
            "0"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "udf_current_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2079-2131",
          "snippet": "int8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "byte_offset"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "inode",
            "first_block",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}"
  },
  {
    "function_name": "udf_update_alloc_ext_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
    "lines": "180-196",
    "snippet": "static void udf_update_alloc_ext_desc(struct inode *inode,\n\t\t\t\t      struct extent_position *epos,\n\t\t\t\t      u32 lenalloc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\n\tint len = sizeof(struct allocExtDesc);\n\n\taed->lengthAllocDescs =\tcpu_to_le32(lenalloc);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\n\t\tlen += lenalloc;\n\n\tudf_update_tag(epos->bh->b_data, len);\n\tmark_buffer_dirty_inode(epos->bh, inode);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "epos->bh",
            "inode"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "epos->bh->b_data",
            "len"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lenalloc"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void udf_update_alloc_ext_desc(struct inode *inode,\n\t\t\t\t      struct extent_position *epos,\n\t\t\t\t      u32 lenalloc)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tstruct allocExtDesc *aed = (struct allocExtDesc *) (epos->bh->b_data);\n\tint len = sizeof(struct allocExtDesc);\n\n\taed->lengthAllocDescs =\tcpu_to_le32(lenalloc);\n\tif (!UDF_QUERY_FLAG(sb, UDF_FLAG_STRICT) || sbi->s_udfrev >= 0x0201)\n\t\tlen += lenalloc;\n\n\tudf_update_tag(epos->bh->b_data, len);\n\tmark_buffer_dirty_inode(epos->bh, inode);\n}"
  },
  {
    "function_name": "udf_discard_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
    "lines": "122-178",
    "snippet": "void udf_discard_prealloc(struct inode *inode)\n{\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\tepos.block = iinfo->i_location;\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t}\n\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\tepos.offset -= adsize;\n\t\tlbcount -= elen;\n\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\tif (!epos.bh) {\n\t\t\tiinfo->i_lenAlloc =\n\t\t\t\tepos.offset -\n\t\t\t\tudf_file_entry_alloc_offset(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->lengthAllocDescs =\n\t\t\t\tcpu_to_le32(epos.offset -\n\t\t\t\t\t    sizeof(struct allocExtDesc));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos.bh->b_data,\n\t\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = lbcount;\n\tbrelse(epos.bh);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "epos.bh",
            "inode"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "epos.bh->b_data",
            "sizeof(struct allocExtDesc)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "epos.offset -\n\t\t\t\t\t    sizeof(struct allocExtDesc)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_trunc",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "etype",
            "elen",
            "0"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "extent_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "30-62",
          "snippet": "static void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_discard_prealloc(struct inode *inode)\n{\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\tepos.block = iinfo->i_location;\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t}\n\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\tepos.offset -= adsize;\n\t\tlbcount -= elen;\n\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\tif (!epos.bh) {\n\t\t\tiinfo->i_lenAlloc =\n\t\t\t\tepos.offset -\n\t\t\t\tudf_file_entry_alloc_offset(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->lengthAllocDescs =\n\t\t\t\tcpu_to_le32(epos.offset -\n\t\t\t\t\t    sizeof(struct allocExtDesc));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos.bh->b_data,\n\t\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = lbcount;\n\tbrelse(epos.bh);\n}"
  },
  {
    "function_name": "udf_truncate_tail_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
    "lines": "68-120",
    "snippet": "void udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "inode->i_sb",
            "\"Extent after EOF in inode %u\\n\"",
            "(unsigned)inode->i_ino"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_trunc",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "etype",
            "elen",
            "nelen"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "extent_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "30-62",
          "snippet": "static void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "inode->i_sb",
            "\"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\"",
            "(unsigned)inode->i_ino",
            "(long long)inode->i_size",
            "(long long)lbcount",
            "(unsigned)eloc.logicalBlockNum",
            "(unsigned)elen"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2272-2286",
          "snippet": "void _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}"
  },
  {
    "function_name": "extent_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
    "lines": "30-62",
    "snippet": "static void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "inode->i_sb",
            "inode",
            "eloc",
            "first_block",
            "last_block - first_block"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "epos",
            "&neloc",
            "nelen",
            "0"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void extent_trunc(struct inode *inode, struct extent_position *epos,\n\t\t\t struct kernel_lb_addr *eloc, int8_t etype, uint32_t elen,\n\t\t\t uint32_t nelen)\n{\n\tstruct kernel_lb_addr neloc = {};\n\tint last_block = (elen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tint first_block = (nelen + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\n\tif (nelen) {\n\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, eloc, 0,\n\t\t\t\t\tlast_block);\n\t\t\tetype = (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30);\n\t\t} else\n\t\t\tneloc = *eloc;\n\t\tnelen = (etype << 30) | nelen;\n\t}\n\n\tif (elen != nelen) {\n\t\tudf_write_aext(inode, epos, &neloc, nelen, 0);\n\t\tif (last_block - first_block > 0) {\n\t\t\tif (etype == (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tmark_inode_dirty(inode);\n\n\t\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\t\tudf_free_blocks(inode->i_sb, inode, eloc,\n\t\t\t\t\t\tfirst_block,\n\t\t\t\t\t\tlast_block - first_block);\n\t\t}\n\t}\n}"
  }
]