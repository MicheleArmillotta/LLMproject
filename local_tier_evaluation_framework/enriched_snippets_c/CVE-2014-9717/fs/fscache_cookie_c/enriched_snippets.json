[
  {
    "function_name": "__fscache_check_consistency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "653-721",
    "snippet": "int __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ESTALE\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_wake_unused_cookie",
          "args": [
            "cookie"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_unuse_cookie",
          "args": [
            "cookie"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_put_operation",
          "args": [
            "op"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_put_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "398-455",
          "snippet": "void fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_put_operation(struct fscache_operation *op)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"{OBJ%x OP%x,%d}\",\n\t       op->object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tif (!atomic_dec_and_test(&op->usage))\n\t\treturn;\n\n\t_debug(\"PUT OP\");\n\tASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\n\t\t    op->state, ==, FSCACHE_OP_ST_CANCELLED);\n\top->state = FSCACHE_OP_ST_DEAD;\n\n\tfscache_stat(&fscache_n_op_release);\n\n\tif (op->release) {\n\t\top->release(op);\n\t\top->release = NULL;\n\t}\n\n\tobject = op->object;\n\n\tif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags))\n\t\tatomic_dec(&object->n_reads);\n\tif (test_bit(FSCACHE_OP_UNUSE_COOKIE, &op->flags))\n\t\tfscache_unuse_cookie(object);\n\n\t/* now... we may get called with the object spinlock held, so we\n\t * complete the cleanup here only if we can immediately acquire the\n\t * lock, and defer it otherwise */\n\tif (!spin_trylock(&object->lock)) {\n\t\t_debug(\"defer put\");\n\t\tfscache_stat(&fscache_n_op_deferred_release);\n\n\t\tcache = object->cache;\n\t\tspin_lock(&cache->op_gc_list_lock);\n\t\tlist_add_tail(&op->pend_link, &cache->op_gc_list);\n\t\tspin_unlock(&cache->op_gc_list_lock);\n\t\tschedule_work(&cache->op_gc);\n\t\t_leave(\" [defer]\");\n\t\treturn;\n\t}\n\n\tASSERTCMP(object->n_ops, >, 0);\n\tobject->n_ops--;\n\tif (object->n_ops == 0)\n\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\n\n\tspin_unlock(&object->lock);\n\n\tkfree(op);\n\t_leave(\" [done]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_op_complete",
          "args": [
            "op",
            "false"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_op_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "365-391",
          "snippet": "void fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "object->cache->ops->check_consistency",
          "args": [
            "op"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_operation_activation",
          "args": [
            "object",
            "op",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_operation_activation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "346-388",
          "snippet": "int fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_operation_activation(struct fscache_object *object,\n\t\t\t\t\t  struct fscache_operation *op,\n\t\t\t\t\t  atomic_t *stat_op_waits,\n\t\t\t\t\t  atomic_t *stat_object_dead,\n\t\t\t\t\t  void (*do_cancel)(struct fscache_operation *))\n{\n\tint ret;\n\n\tif (!test_bit(FSCACHE_OP_WAITING, &op->flags))\n\t\tgoto check_if_dead;\n\n\t_debug(\">>> WT\");\n\tif (stat_op_waits)\n\t\tfscache_stat(stat_op_waits);\n\tif (wait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tret = fscache_cancel_op(op, do_cancel);\n\t\tif (ret == 0)\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* it's been removed from the pending queue by another party,\n\t\t * so we should get to run shortly */\n\t\twait_on_bit(&op->flags, FSCACHE_OP_WAITING,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t}\n\t_debug(\"<<< GO\");\n\ncheck_if_dead:\n\tif (op->state == FSCACHE_OP_ST_CANCELLED) {\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\t_leave(\" = -ENOBUFS [cancelled]\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (unlikely(fscache_object_is_dead(object))) {\n\t\tpr_err(\"%s() = -ENOBUFS [obj dead %d]\\n\", __func__, op->state);\n\t\tfscache_cancel_op(op, do_cancel);\n\t\tif (stat_object_dead)\n\t\t\tfscache_stat(stat_object_dead);\n\t\treturn -ENOBUFS;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_submit_op",
          "args": [
            "object",
            "op"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_submit_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "186-248",
          "snippet": "int fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nint fscache_submit_op(struct fscache_object *object,\n\t\t      struct fscache_operation *op)\n{\n\tconst struct fscache_state *ostate;\n\tint ret;\n\n\t_enter(\"{OBJ%x OP%x},{%u}\",\n\t       object->debug_id, op->debug_id, atomic_read(&op->usage));\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\n\tASSERTCMP(atomic_read(&op->usage), >, 0);\n\n\tspin_lock(&object->lock);\n\tASSERTCMP(object->n_ops, >=, object->n_in_progress);\n\tASSERTCMP(object->n_ops, >=, object->n_exclusive);\n\tASSERT(list_empty(&op->pend_link));\n\n\tostate = object->state;\n\tsmp_rmb();\n\n\top->state = FSCACHE_OP_ST_PENDING;\n\tif (fscache_object_is_active(object)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\n\t\tif (object->n_exclusive > 0) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t} else if (!list_empty(&object->pending_ops)) {\n\t\t\tatomic_inc(&op->usage);\n\t\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\t\tfscache_stat(&fscache_n_op_pend);\n\t\t\tfscache_start_operations(object);\n\t\t} else {\n\t\t\tASSERTCMP(object->n_exclusive, ==, 0);\n\t\t\tfscache_run_op(object, op);\n\t\t}\n\t\tret = 0;\n\t} else if (test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags)) {\n\t\top->object = object;\n\t\tobject->n_ops++;\n\t\tatomic_inc(&op->usage);\n\t\tlist_add_tail(&op->pend_link, &object->pending_ops);\n\t\tfscache_stat(&fscache_n_op_pend);\n\t\tret = 0;\n\t} else if (fscache_object_is_dying(object)) {\n\t\tfscache_stat(&fscache_n_op_rejected);\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\n\t\tfscache_report_unexpected_submission(object, op, ostate);\n\t\tASSERT(!fscache_object_is_active(object));\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t} else {\n\t\top->state = FSCACHE_OP_ST_CANCELLED;\n\t\tret = -ENOBUFS;\n\t}\n\n\tspin_unlock(&object->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_use_cookie",
          "args": [
            "cookie"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&fscache_op_debug_id"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_IOERROR",
            "&object->cache->flags"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_operation_init",
          "args": [
            "op",
            "NULL",
            "NULL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*op)",
            "GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_wait_for_deferred_lookup",
          "args": [
            "cookie"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_wait_for_deferred_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "303-330",
          "snippet": "int fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint fscache_wait_for_deferred_lookup(struct fscache_cookie *cookie)\n{\n\tunsigned long jif;\n\n\t_enter(\"\");\n\n\tif (!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags)) {\n\t\t_leave(\" = 0 [imm]\");\n\t\treturn 0;\n\t}\n\n\tfscache_stat(&fscache_n_retrievals_wait);\n\n\tjif = jiffies;\n\tif (wait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\tTASK_INTERRUPTIBLE) != 0) {\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\t\t_leave(\" = -ERESTARTSYS\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tASSERT(!test_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags));\n\n\tsmp_rmb();\n\tfscache_hist(fscache_retrieval_delay_histogram, jif);\n\t_leave(\" = 0 [dly]\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "==,FSCACHE_COOKIE_TYPE_DATAFILE"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,\"",
            "cookie"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nint __fscache_check_consistency(struct fscache_cookie *cookie)\n{\n\tstruct fscache_operation *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,\", cookie);\n\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\treturn 0;\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\treturn -ENOMEM;\n\n\tfscache_operation_init(op, NULL, NULL);\n\top->flags = FSCACHE_OP_MYTHREAD |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto inconsistent;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto inconsistent;\n\n\top->debug_id = atomic_inc_return(&fscache_op_debug_id);\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, op) < 0)\n\t\tgoto submit_failed;\n\n\t/* the work queue now carries its own ref on the object */\n\tspin_unlock(&cookie->lock);\n\n\tret = fscache_wait_for_operation_activation(object, op,\n\t\t\t\t\t\t    NULL, NULL, NULL);\n\tif (ret == 0) {\n\t\t/* ask the cache to honour the operation */\n\t\tret = object->cache->ops->check_consistency(op);\n\t\tfscache_op_complete(op, false);\n\t} else if (ret == -ENOBUFS) {\n\t\tret = 0;\n\t}\n\n\tfscache_put_operation(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nsubmit_failed:\n\twake_cookie = __fscache_unuse_cookie(cookie);\ninconsistent:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\n\t_leave(\" = -ESTALE\");\n\treturn -ESTALE;\n}"
  },
  {
    "function_name": "__fscache_cookie_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "624-646",
    "snippet": "void __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *fscache_cookie_jar;",
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&cookie->usage"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&cookie->usage) <= 0"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->usage"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fscache_cookie_jar",
            "cookie"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_empty(&cookie->backing_objects)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"FREE COOKIE %p\"",
            "cookie"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "cookie"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_relinquish_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "581-618",
    "snippet": "void __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_cookie_put",
          "args": [
            "cookie"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_cookie_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "624-646",
          "snippet": "void __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&cookie->usage)",
            ">,0"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->usage"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cookie->parent->n_children"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&cookie->parent->n_children)",
            ">,0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->parent->n_children"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&cookie->parent->usage)",
            ">,0"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->parent->usage"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cookie->stores.rnode"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fscache_disable_cookie",
          "args": [
            "cookie",
            "retire"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_disable_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "511-572",
          "snippet": "void __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_RELINQUISHED",
            "&cookie->flags"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p{%s,%p,%d},%d\"",
            "cookie",
            "cookie->def->name",
            "cookie->netfs_data",
            "atomic_read(&cookie->n_active)",
            "retire"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->n_active"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_relinquishes_null"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\n{\n\tfscache_stat(&fscache_n_relinquishes);\n\tif (retire)\n\t\tfscache_stat(&fscache_n_relinquishes_retire);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_relinquishes_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"%p{%s,%p,%d},%d\",\n\t       cookie, cookie->def->name, cookie->netfs_data,\n\t       atomic_read(&cookie->n_active), retire);\n\n\t/* No further netfs-accessing operations on this cookie permitted */\n\tset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\n\n\t__fscache_disable_cookie(cookie, retire);\n\n\t/* Clear pointers back to the netfs */\n\tcookie->netfs_data\t= NULL;\n\tcookie->def\t\t= NULL;\n\tBUG_ON(cookie->stores.rnode);\n\n\tif (cookie->parent) {\n\t\tASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\n\t\tASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\n\t\tatomic_dec(&cookie->parent->n_children);\n\t}\n\n\t/* Dispose of the netfs's link to the cookie */\n\tASSERTCMP(atomic_read(&cookie->usage), >, 0);\n\tfscache_cookie_put(cookie);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_disable_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "511-572",
    "snippet": "void __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_ENABLEMENT_LOCK"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "FSCACHE_COOKIE_ENABLEMENT_LOCK",
            "&cookie->flags"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_NO_DATA_YET",
            "&cookie->flags"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cookie->n_active"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_RELINQUISHED",
            "&cookie->flags"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_atomic_t",
          "args": [
            "&cookie->n_active",
            "fscache_wait_atomic_t",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&cookie->n_active"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_INVALIDATING"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&cookie->flags"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_KILL"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "object",
            "&cookie->backing_objects",
            "cookie_link"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wait_on_invalidate",
          "args": [
            "cookie"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_wait_on_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "461-469",
          "snippet": "void __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_lock",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_ENABLEMENT_LOCK",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cookie '%s' still has children\\n\"",
            "cookie->def->name"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->n_children"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "atomic_read(&cookie->n_active)",
            ">,0"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cookie->n_active"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%u\"",
            "cookie",
            "invalidate"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\n{\n\tstruct fscache_object *object;\n\tbool awaken = false;\n\n\t_enter(\"%p,%u\", cookie, invalidate);\n\n\tASSERTCMP(atomic_read(&cookie->n_active), >, 0);\n\n\tif (atomic_read(&cookie->n_children) != 0) {\n\t\tpr_err(\"Cookie '%s' still has children\\n\",\n\t\t       cookie->def->name);\n\t\tBUG();\n\t}\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\tif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock_enable;\n\n\t/* If the cookie is being invalidated, wait for that to complete first\n\t * so that we can reuse the flag.\n\t */\n\t__fscache_wait_on_invalidate(cookie);\n\n\t/* Dispose of the backing objects */\n\tset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\n\n\tspin_lock(&cookie->lock);\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\thlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\n\t\t\tif (invalidate)\n\t\t\t\tset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\n\t\t}\n\t} else {\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\n\t\t\tawaken = true;\n\t}\n\tspin_unlock(&cookie->lock);\n\tif (awaken)\n\t\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\n\n\t/* Wait for cessation of activity requiring access to the netfs (when\n\t * n_active reaches 0).  This makes sure outstanding reads and writes\n\t * have completed.\n\t */\n\tif (!atomic_dec_and_test(&cookie->n_active))\n\t\twait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\n\t\t\t\t TASK_UNINTERRUPTIBLE);\n\n\t/* Reset the cookie state if it wasn't relinquished */\n\tif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\n\t\tatomic_inc(&cookie->n_active);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\t}\n\nout_unlock_enable:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_update_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "475-505",
    "snippet": "void __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_UPDATE"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "object",
            "&cookie->backing_objects",
            "cookie_link"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cookie->def->get_aux"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s}\"",
            "cookie->def->name"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_updates_null"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_update_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\tfscache_stat(&fscache_n_updates);\n\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_updates_null);\n\t\t_leave(\" [no cookie]\");\n\t\treturn;\n\t}\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tBUG_ON(!cookie->def->get_aux);\n\n\tspin_lock(&cookie->lock);\n\n\tif (fscache_cookie_enabled(cookie)) {\n\t\t/* update the index entry on disk in each cache backing this\n\t\t * cookie.\n\t\t */\n\t\thlist_for_each_entry(object,\n\t\t\t\t     &cookie->backing_objects, cookie_link) {\n\t\t\tfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\n\t\t}\n\t}\n\n\tspin_unlock(&cookie->lock);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_wait_on_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "461-469",
    "snippet": "void __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_INVALIDATING",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "cookie"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "__fscache_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "415-455",
    "snippet": "void __fscache_invalidate(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\t/* Only permit invalidation of data files.  Invalidating an index will\n\t * require the caller to release all its attachments to the tree rooted\n\t * there, and if it's doing that, it may as well just retire the\n\t * cookie.\n\t */\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\t/* We will be updating the cookie too. */\n\tBUG_ON(!cookie->def->get_aux);\n\n\t/* If there's an object, we tell the object state machine to handle the\n\t * invalidation on our behalf, otherwise there's nothing to do.\n\t */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tspin_lock(&cookie->lock);\n\n\t\tif (fscache_cookie_enabled(cookie) &&\n\t\t    !hlist_empty(&cookie->backing_objects) &&\n\t\t    !test_and_set_bit(FSCACHE_COOKIE_INVALIDATING,\n\t\t\t\t      &cookie->flags)) {\n\t\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t\t     struct fscache_object,\n\t\t\t\t\t     cookie_link);\n\t\t\tif (fscache_object_is_live(object))\n\t\t\t\tfscache_raise_event(\n\t\t\t\t\tobject, FSCACHE_OBJECT_EV_INVALIDATE);\n\t\t}\n\n\t\tspin_unlock(&cookie->lock);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_INVALIDATE"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_live",
          "args": [
            "object"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "FSCACHE_COOKIE_INVALIDATING",
            "&cookie->flags"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_cookie_enabled",
          "args": [
            "cookie"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cookie->def->get_aux"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "cookie->def->type",
            "==,FSCACHE_COOKIE_TYPE_DATAFILE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_invalidates"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s}\"",
            "cookie->def->name"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nvoid __fscache_invalidate(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\"{%s}\", cookie->def->name);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\t/* Only permit invalidation of data files.  Invalidating an index will\n\t * require the caller to release all its attachments to the tree rooted\n\t * there, and if it's doing that, it may as well just retire the\n\t * cookie.\n\t */\n\tASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\n\n\t/* We will be updating the cookie too. */\n\tBUG_ON(!cookie->def->get_aux);\n\n\t/* If there's an object, we tell the object state machine to handle the\n\t * invalidation on our behalf, otherwise there's nothing to do.\n\t */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tspin_lock(&cookie->lock);\n\n\t\tif (fscache_cookie_enabled(cookie) &&\n\t\t    !hlist_empty(&cookie->backing_objects) &&\n\t\t    !test_and_set_bit(FSCACHE_COOKIE_INVALIDATING,\n\t\t\t\t      &cookie->flags)) {\n\t\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t\t     struct fscache_object,\n\t\t\t\t\t     cookie_link);\n\t\t\tif (fscache_object_is_live(object))\n\t\t\t\tfscache_raise_event(\n\t\t\t\t\tobject, FSCACHE_OBJECT_EV_INVALIDATE);\n\t\t}\n\n\t\tspin_unlock(&cookie->lock);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "fscache_attach_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "350-410",
    "snippet": "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object)\n{\n\tstruct fscache_object *p;\n\tstruct fscache_cache *cache = object->cache;\n\tint ret;\n\n\t_enter(\"{%s},{OBJ%x}\", cookie->def->name, object->debug_id);\n\n\tspin_lock(&cookie->lock);\n\n\t/* there may be multiple initial creations of this object, but we only\n\t * want one */\n\tret = -EEXIST;\n\thlist_for_each_entry(p, &cookie->backing_objects, cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p))\n\t\t\t\tret = -ENOBUFS;\n\t\t\tgoto cant_attach_object;\n\t\t}\n\t}\n\n\t/* pin the parent object */\n\tspin_lock_nested(&cookie->parent->lock, 1);\n\thlist_for_each_entry(p, &cookie->parent->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p)) {\n\t\t\t\tret = -ENOBUFS;\n\t\t\t\tspin_unlock(&cookie->parent->lock);\n\t\t\t\tgoto cant_attach_object;\n\t\t\t}\n\t\t\tobject->parent = p;\n\t\t\tspin_lock(&p->lock);\n\t\t\tp->n_children++;\n\t\t\tspin_unlock(&p->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cookie->parent->lock);\n\n\t/* attach to the cache's object list */\n\tif (list_empty(&object->cache_link)) {\n\t\tspin_lock(&cache->object_list_lock);\n\t\tlist_add(&object->cache_link, &cache->object_list);\n\t\tspin_unlock(&cache->object_list_lock);\n\t}\n\n\t/* attach to the cookie */\n\tobject->cookie = cookie;\n\tatomic_inc(&cookie->usage);\n\thlist_add_head(&object->cookie_link, &cookie->backing_objects);\n\n\tfscache_objlist_add(object);\n\tret = 0;\n\ncant_attach_object:\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_objlist_add",
          "args": [
            "object"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_objlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object-list.c",
          "lines": "48-73",
          "snippet": "void fscache_objlist_add(struct fscache_object *obj)\n{\n\tstruct fscache_object *xobj;\n\tstruct rb_node **p = &fscache_object_list.rb_node, *parent = NULL;\n\n\tASSERT(RB_EMPTY_NODE(&obj->objlist_link));\n\n\twrite_lock(&fscache_object_list_lock);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txobj = rb_entry(parent, struct fscache_object, objlist_link);\n\n\t\tif (obj < xobj)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (obj > xobj)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&obj->objlist_link, parent, p);\n\trb_insert_color(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rb_root fscache_object_list;",
            "static DEFINE_RWLOCK(fscache_object_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic struct rb_root fscache_object_list;\nstatic DEFINE_RWLOCK(fscache_object_list_lock);\n\nvoid fscache_objlist_add(struct fscache_object *obj)\n{\n\tstruct fscache_object *xobj;\n\tstruct rb_node **p = &fscache_object_list.rb_node, *parent = NULL;\n\n\tASSERT(RB_EMPTY_NODE(&obj->objlist_link));\n\n\twrite_lock(&fscache_object_list_lock);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txobj = rb_entry(parent, struct fscache_object, objlist_link);\n\n\t\tif (obj < xobj)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (obj > xobj)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&obj->objlist_link, parent, p);\n\trb_insert_color(&obj->objlist_link, &fscache_object_list);\n\n\twrite_unlock(&fscache_object_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&object->cookie_link",
            "&cookie->backing_objects"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cookie->usage"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&object->cache_link",
            "&cache->object_list"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cache->object_list_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&object->cache_link"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "p"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "&cookie->parent->backing_objects",
            "cookie_link"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&cookie->parent->lock",
            "1"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dying",
          "args": [
            "p"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "&cookie->backing_objects",
            "cookie_link"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},{OBJ%x}\"",
            "cookie->def->name",
            "object->debug_id"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object)\n{\n\tstruct fscache_object *p;\n\tstruct fscache_cache *cache = object->cache;\n\tint ret;\n\n\t_enter(\"{%s},{OBJ%x}\", cookie->def->name, object->debug_id);\n\n\tspin_lock(&cookie->lock);\n\n\t/* there may be multiple initial creations of this object, but we only\n\t * want one */\n\tret = -EEXIST;\n\thlist_for_each_entry(p, &cookie->backing_objects, cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p))\n\t\t\t\tret = -ENOBUFS;\n\t\t\tgoto cant_attach_object;\n\t\t}\n\t}\n\n\t/* pin the parent object */\n\tspin_lock_nested(&cookie->parent->lock, 1);\n\thlist_for_each_entry(p, &cookie->parent->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p)) {\n\t\t\t\tret = -ENOBUFS;\n\t\t\t\tspin_unlock(&cookie->parent->lock);\n\t\t\t\tgoto cant_attach_object;\n\t\t\t}\n\t\t\tobject->parent = p;\n\t\t\tspin_lock(&p->lock);\n\t\t\tp->n_children++;\n\t\t\tspin_unlock(&p->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cookie->parent->lock);\n\n\t/* attach to the cache's object list */\n\tif (list_empty(&object->cache_link)) {\n\t\tspin_lock(&cache->object_list_lock);\n\t\tlist_add(&object->cache_link, &cache->object_list);\n\t\tspin_unlock(&cache->object_list_lock);\n\t}\n\n\t/* attach to the cookie */\n\tobject->cookie = cookie;\n\tatomic_inc(&cookie->usage);\n\thlist_add_head(&object->cookie_link, &cookie->backing_objects);\n\n\tfscache_objlist_add(object);\n\tret = 0;\n\ncant_attach_object:\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_alloc_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "278-345",
    "snippet": "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tint ret;\n\n\t_enter(\"%p,%p{%s}\", cache, cookie, cookie->def->name);\n\n\tspin_lock(&cookie->lock);\n\thlist_for_each_entry(object, &cookie->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (object->cache == cache)\n\t\t\tgoto object_already_extant;\n\t}\n\tspin_unlock(&cookie->lock);\n\n\t/* ask the cache to allocate an object (we may end up with duplicate\n\t * objects at this stage, but we sort that out later) */\n\tfscache_stat(&fscache_n_cop_alloc_object);\n\tobject = cache->ops->alloc_object(cache, cookie);\n\tfscache_stat_d(&fscache_n_cop_alloc_object);\n\tif (IS_ERR(object)) {\n\t\tfscache_stat(&fscache_n_object_no_alloc);\n\t\tret = PTR_ERR(object);\n\t\tgoto error;\n\t}\n\n\tfscache_stat(&fscache_n_object_alloc);\n\n\tobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\n\n\t_debug(\"ALLOC OBJ%x: %s {%lx}\",\n\t       object->debug_id, cookie->def->name, object->events);\n\n\tret = fscache_alloc_object(cache, cookie->parent);\n\tif (ret < 0)\n\t\tgoto error_put;\n\n\t/* only attach if we managed to allocate all we needed, otherwise\n\t * discard the object we just allocated and instead use the one\n\t * attached to the cookie */\n\tif (fscache_attach_object(cookie, object) < 0) {\n\t\tfscache_stat(&fscache_n_cop_put_object);\n\t\tcache->ops->put_object(object);\n\t\tfscache_stat_d(&fscache_n_cop_put_object);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nobject_already_extant:\n\tret = -ENOBUFS;\n\tif (fscache_object_is_dead(object)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto error;\n\t}\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = 0 [found]\");\n\treturn 0;\n\nerror_put:\n\tfscache_stat(&fscache_n_cop_put_object);\n\tcache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t fscache_object_debug_id = ATOMIC_INIT(0);",
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat_d",
          "args": [
            "&fscache_n_cop_put_object"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache->ops->put_object",
          "args": [
            "object"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [found]\""
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_is_dead",
          "args": [
            "object"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache->ops->put_object",
          "args": [
            "object"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_attach_object",
          "args": [
            "cookie",
            "object"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_attach_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "350-410",
          "snippet": "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object)\n{\n\tstruct fscache_object *p;\n\tstruct fscache_cache *cache = object->cache;\n\tint ret;\n\n\t_enter(\"{%s},{OBJ%x}\", cookie->def->name, object->debug_id);\n\n\tspin_lock(&cookie->lock);\n\n\t/* there may be multiple initial creations of this object, but we only\n\t * want one */\n\tret = -EEXIST;\n\thlist_for_each_entry(p, &cookie->backing_objects, cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p))\n\t\t\t\tret = -ENOBUFS;\n\t\t\tgoto cant_attach_object;\n\t\t}\n\t}\n\n\t/* pin the parent object */\n\tspin_lock_nested(&cookie->parent->lock, 1);\n\thlist_for_each_entry(p, &cookie->parent->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p)) {\n\t\t\t\tret = -ENOBUFS;\n\t\t\t\tspin_unlock(&cookie->parent->lock);\n\t\t\t\tgoto cant_attach_object;\n\t\t\t}\n\t\t\tobject->parent = p;\n\t\t\tspin_lock(&p->lock);\n\t\t\tp->n_children++;\n\t\t\tspin_unlock(&p->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cookie->parent->lock);\n\n\t/* attach to the cache's object list */\n\tif (list_empty(&object->cache_link)) {\n\t\tspin_lock(&cache->object_list_lock);\n\t\tlist_add(&object->cache_link, &cache->object_list);\n\t\tspin_unlock(&cache->object_list_lock);\n\t}\n\n\t/* attach to the cookie */\n\tobject->cookie = cookie;\n\tatomic_inc(&cookie->usage);\n\thlist_add_head(&object->cookie_link, &cookie->backing_objects);\n\n\tfscache_objlist_add(object);\n\tret = 0;\n\ncant_attach_object:\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object)\n{\n\tstruct fscache_object *p;\n\tstruct fscache_cache *cache = object->cache;\n\tint ret;\n\n\t_enter(\"{%s},{OBJ%x}\", cookie->def->name, object->debug_id);\n\n\tspin_lock(&cookie->lock);\n\n\t/* there may be multiple initial creations of this object, but we only\n\t * want one */\n\tret = -EEXIST;\n\thlist_for_each_entry(p, &cookie->backing_objects, cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p))\n\t\t\t\tret = -ENOBUFS;\n\t\t\tgoto cant_attach_object;\n\t\t}\n\t}\n\n\t/* pin the parent object */\n\tspin_lock_nested(&cookie->parent->lock, 1);\n\thlist_for_each_entry(p, &cookie->parent->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (p->cache == object->cache) {\n\t\t\tif (fscache_object_is_dying(p)) {\n\t\t\t\tret = -ENOBUFS;\n\t\t\t\tspin_unlock(&cookie->parent->lock);\n\t\t\t\tgoto cant_attach_object;\n\t\t\t}\n\t\t\tobject->parent = p;\n\t\t\tspin_lock(&p->lock);\n\t\t\tp->n_children++;\n\t\t\tspin_unlock(&p->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cookie->parent->lock);\n\n\t/* attach to the cache's object list */\n\tif (list_empty(&object->cache_link)) {\n\t\tspin_lock(&cache->object_list_lock);\n\t\tlist_add(&object->cache_link, &cache->object_list);\n\t\tspin_unlock(&cache->object_list_lock);\n\t}\n\n\t/* attach to the cookie */\n\tobject->cookie = cookie;\n\tatomic_inc(&cookie->usage);\n\thlist_add_head(&object->cookie_link, &cookie->backing_objects);\n\n\tfscache_objlist_add(object);\n\tret = 0;\n\ncant_attach_object:\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_alloc_object",
          "args": [
            "cache",
            "cookie->parent"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_alloc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "278-345",
          "snippet": "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tint ret;\n\n\t_enter(\"%p,%p{%s}\", cache, cookie, cookie->def->name);\n\n\tspin_lock(&cookie->lock);\n\thlist_for_each_entry(object, &cookie->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (object->cache == cache)\n\t\t\tgoto object_already_extant;\n\t}\n\tspin_unlock(&cookie->lock);\n\n\t/* ask the cache to allocate an object (we may end up with duplicate\n\t * objects at this stage, but we sort that out later) */\n\tfscache_stat(&fscache_n_cop_alloc_object);\n\tobject = cache->ops->alloc_object(cache, cookie);\n\tfscache_stat_d(&fscache_n_cop_alloc_object);\n\tif (IS_ERR(object)) {\n\t\tfscache_stat(&fscache_n_object_no_alloc);\n\t\tret = PTR_ERR(object);\n\t\tgoto error;\n\t}\n\n\tfscache_stat(&fscache_n_object_alloc);\n\n\tobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\n\n\t_debug(\"ALLOC OBJ%x: %s {%lx}\",\n\t       object->debug_id, cookie->def->name, object->events);\n\n\tret = fscache_alloc_object(cache, cookie->parent);\n\tif (ret < 0)\n\t\tgoto error_put;\n\n\t/* only attach if we managed to allocate all we needed, otherwise\n\t * discard the object we just allocated and instead use the one\n\t * attached to the cookie */\n\tif (fscache_attach_object(cookie, object) < 0) {\n\t\tfscache_stat(&fscache_n_cop_put_object);\n\t\tcache->ops->put_object(object);\n\t\tfscache_stat_d(&fscache_n_cop_put_object);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nobject_already_extant:\n\tret = -ENOBUFS;\n\tif (fscache_object_is_dead(object)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto error;\n\t}\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = 0 [found]\");\n\treturn 0;\n\nerror_put:\n\tfscache_stat(&fscache_n_cop_put_object);\n\tcache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"ALLOC OBJ%x: %s {%lx}\"",
            "object->debug_id",
            "cookie->def->name",
            "object->events"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&fscache_object_debug_id"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "object"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "object"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache->ops->alloc_object",
          "args": [
            "cache",
            "cookie"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "object",
            "&cookie->backing_objects",
            "cookie_link"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p{%s}\"",
            "cache",
            "cookie",
            "cookie->def->name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic atomic_t fscache_object_debug_id = ATOMIC_INIT(0);\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tint ret;\n\n\t_enter(\"%p,%p{%s}\", cache, cookie, cookie->def->name);\n\n\tspin_lock(&cookie->lock);\n\thlist_for_each_entry(object, &cookie->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (object->cache == cache)\n\t\t\tgoto object_already_extant;\n\t}\n\tspin_unlock(&cookie->lock);\n\n\t/* ask the cache to allocate an object (we may end up with duplicate\n\t * objects at this stage, but we sort that out later) */\n\tfscache_stat(&fscache_n_cop_alloc_object);\n\tobject = cache->ops->alloc_object(cache, cookie);\n\tfscache_stat_d(&fscache_n_cop_alloc_object);\n\tif (IS_ERR(object)) {\n\t\tfscache_stat(&fscache_n_object_no_alloc);\n\t\tret = PTR_ERR(object);\n\t\tgoto error;\n\t}\n\n\tfscache_stat(&fscache_n_object_alloc);\n\n\tobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\n\n\t_debug(\"ALLOC OBJ%x: %s {%lx}\",\n\t       object->debug_id, cookie->def->name, object->events);\n\n\tret = fscache_alloc_object(cache, cookie->parent);\n\tif (ret < 0)\n\t\tgoto error_put;\n\n\t/* only attach if we managed to allocate all we needed, otherwise\n\t * discard the object we just allocated and instead use the one\n\t * attached to the cookie */\n\tif (fscache_attach_object(cookie, object) < 0) {\n\t\tfscache_stat(&fscache_n_cop_put_object);\n\t\tcache->ops->put_object(object);\n\t\tfscache_stat_d(&fscache_n_cop_put_object);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nobject_already_extant:\n\tret = -ENOBUFS;\n\tif (fscache_object_is_dead(object)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto error;\n\t}\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = 0 [found]\");\n\treturn 0;\n\nerror_put:\n\tfscache_stat(&fscache_n_cop_put_object);\n\tcache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "fscache_acquire_non_index_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "191-272",
    "snippet": "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOBUFS\""
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_UNAVAILABLE",
            "&cookie->flags"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"complete\""
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_LOOKING_UP",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"non-deferred lookup %p\"",
            "&cookie->flags"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cookie->lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_raise_event",
          "args": [
            "object",
            "FSCACHE_OBJECT_EV_NEW_CHILD"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_raise_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "299-310",
          "snippet": "static inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void fscache_enqueue_object(struct fscache_object *);",
            "extern void fscache_cancel_all_ops(struct fscache_object *);",
            "extern void fscache_abort_object(struct fscache_object *);",
            "extern void fscache_start_operations(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern void fscache_enqueue_object(struct fscache_object *);\nextern void fscache_cancel_all_ops(struct fscache_object *);\nextern void fscache_abort_object(struct fscache_object *);\nextern void fscache_start_operations(struct fscache_object *);\n\nstatic inline void fscache_raise_event(struct fscache_object *object,\n\t\t\t\t       unsigned event)\n{\n\tBUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);\n#if 0\n\tprintk(\"*** fscache_raise_event(OBJ%d{%lx},%x)\\n\",\n\t       object->debug_id, object->event_mask, (1 << event));\n#endif\n\tif (!test_and_set_bit(event, &object->events) &&\n\t    test_bit(event, &object->event_mask))\n\t\tfscache_enqueue_object(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_set_store_limit",
          "args": [
            "object",
            "i_size"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "cookie->backing_objects.first",
            "structfscache_object",
            "cookie_link"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cookie->lock"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cookie->def->get_attr",
          "args": [
            "cookie->netfs_data",
            "&i_size"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_alloc_object",
          "args": [
            "cache",
            "cookie"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_alloc_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "278-345",
          "snippet": "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tint ret;\n\n\t_enter(\"%p,%p{%s}\", cache, cookie, cookie->def->name);\n\n\tspin_lock(&cookie->lock);\n\thlist_for_each_entry(object, &cookie->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (object->cache == cache)\n\t\t\tgoto object_already_extant;\n\t}\n\tspin_unlock(&cookie->lock);\n\n\t/* ask the cache to allocate an object (we may end up with duplicate\n\t * objects at this stage, but we sort that out later) */\n\tfscache_stat(&fscache_n_cop_alloc_object);\n\tobject = cache->ops->alloc_object(cache, cookie);\n\tfscache_stat_d(&fscache_n_cop_alloc_object);\n\tif (IS_ERR(object)) {\n\t\tfscache_stat(&fscache_n_object_no_alloc);\n\t\tret = PTR_ERR(object);\n\t\tgoto error;\n\t}\n\n\tfscache_stat(&fscache_n_object_alloc);\n\n\tobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\n\n\t_debug(\"ALLOC OBJ%x: %s {%lx}\",\n\t       object->debug_id, cookie->def->name, object->events);\n\n\tret = fscache_alloc_object(cache, cookie->parent);\n\tif (ret < 0)\n\t\tgoto error_put;\n\n\t/* only attach if we managed to allocate all we needed, otherwise\n\t * discard the object we just allocated and instead use the one\n\t * attached to the cookie */\n\tif (fscache_attach_object(cookie, object) < 0) {\n\t\tfscache_stat(&fscache_n_cop_put_object);\n\t\tcache->ops->put_object(object);\n\t\tfscache_stat_d(&fscache_n_cop_put_object);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nobject_already_extant:\n\tret = -ENOBUFS;\n\tif (fscache_object_is_dead(object)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto error;\n\t}\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = 0 [found]\");\n\treturn 0;\n\nerror_put:\n\tfscache_stat(&fscache_n_cop_put_object);\n\tcache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t fscache_object_debug_id = ATOMIC_INIT(0);",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic atomic_t fscache_object_debug_id = ATOMIC_INIT(0);\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tint ret;\n\n\t_enter(\"%p,%p{%s}\", cache, cookie, cookie->def->name);\n\n\tspin_lock(&cookie->lock);\n\thlist_for_each_entry(object, &cookie->backing_objects,\n\t\t\t     cookie_link) {\n\t\tif (object->cache == cache)\n\t\t\tgoto object_already_extant;\n\t}\n\tspin_unlock(&cookie->lock);\n\n\t/* ask the cache to allocate an object (we may end up with duplicate\n\t * objects at this stage, but we sort that out later) */\n\tfscache_stat(&fscache_n_cop_alloc_object);\n\tobject = cache->ops->alloc_object(cache, cookie);\n\tfscache_stat_d(&fscache_n_cop_alloc_object);\n\tif (IS_ERR(object)) {\n\t\tfscache_stat(&fscache_n_object_no_alloc);\n\t\tret = PTR_ERR(object);\n\t\tgoto error;\n\t}\n\n\tfscache_stat(&fscache_n_object_alloc);\n\n\tobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\n\n\t_debug(\"ALLOC OBJ%x: %s {%lx}\",\n\t       object->debug_id, cookie->def->name, object->events);\n\n\tret = fscache_alloc_object(cache, cookie->parent);\n\tif (ret < 0)\n\t\tgoto error_put;\n\n\t/* only attach if we managed to allocate all we needed, otherwise\n\t * discard the object we just allocated and instead use the one\n\t * attached to the cookie */\n\tif (fscache_attach_object(cookie, object) < 0) {\n\t\tfscache_stat(&fscache_n_cop_put_object);\n\t\tcache->ops->put_object(object);\n\t\tfscache_stat_d(&fscache_n_cop_put_object);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nobject_already_extant:\n\tret = -ENOBUFS;\n\tif (fscache_object_is_dead(object)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto error;\n\t}\n\tspin_unlock(&cookie->lock);\n\t_leave(\" = 0 [found]\");\n\treturn 0;\n\nerror_put:\n\tfscache_stat(&fscache_n_cop_put_object);\n\tcache->ops->put_object(object);\n\tfscache_stat_d(&fscache_n_cop_put_object);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_LOOKING_UP",
            "&cookie->flags"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_acquires_no_cache"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_select_cache_for_object",
          "args": [
            "cookie->parent"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_select_cache_for_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cache.c",
          "lines": "94-168",
          "snippet": "struct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_cache_tag *tag;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"\");\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\t_leave(\" = NULL [no cache]\");\n\t\treturn NULL;\n\t}\n\n\t/* we check the parent to determine the cache to use */\n\tspin_lock(&cookie->lock);\n\n\t/* the first in the parent's backing list should be the preferred\n\t * cache */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t     struct fscache_object, cookie_link);\n\n\t\tcache = object->cache;\n\t\tif (fscache_object_is_dying(object) ||\n\t\t    test_bit(FSCACHE_IOERROR, &cache->flags))\n\t\t\tcache = NULL;\n\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = %p [parent]\", cache);\n\t\treturn cache;\n\t}\n\n\t/* the parent is unbacked */\n\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* cookie not an index and is unbacked */\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = NULL [cookie ub,ni]\");\n\t\treturn NULL;\n\t}\n\n\tspin_unlock(&cookie->lock);\n\n\tif (!cookie->def->select_cache)\n\t\tgoto no_preference;\n\n\t/* ask the netfs for its preference */\n\ttag = cookie->def->select_cache(cookie->parent->netfs_data,\n\t\t\t\t\tcookie->netfs_data);\n\tif (!tag)\n\t\tgoto no_preference;\n\n\tif (tag == ERR_PTR(-ENOMEM)) {\n\t\t_leave(\" = NULL [nomem tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (!tag->cache) {\n\t\t_leave(\" = NULL [unbacked tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (test_bit(FSCACHE_IOERROR, &tag->cache->flags))\n\t\treturn NULL;\n\n\t_leave(\" = %p [specific]\", tag->cache);\n\treturn tag->cache;\n\nno_preference:\n\t/* netfs has no preference - just select first cache */\n\tcache = list_entry(fscache_cache_list.next,\n\t\t\t   struct fscache_cache, link);\n\t_leave(\" = %p [first]\", cache);\n\treturn cache;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct fscache_cache *fscache_select_cache_for_object(\n\tstruct fscache_cookie *cookie)\n{\n\tstruct fscache_cache_tag *tag;\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\n\t_enter(\"\");\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\t_leave(\" = NULL [no cache]\");\n\t\treturn NULL;\n\t}\n\n\t/* we check the parent to determine the cache to use */\n\tspin_lock(&cookie->lock);\n\n\t/* the first in the parent's backing list should be the preferred\n\t * cache */\n\tif (!hlist_empty(&cookie->backing_objects)) {\n\t\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t\t     struct fscache_object, cookie_link);\n\n\t\tcache = object->cache;\n\t\tif (fscache_object_is_dying(object) ||\n\t\t    test_bit(FSCACHE_IOERROR, &cache->flags))\n\t\t\tcache = NULL;\n\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = %p [parent]\", cache);\n\t\treturn cache;\n\t}\n\n\t/* the parent is unbacked */\n\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* cookie not an index and is unbacked */\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" = NULL [cookie ub,ni]\");\n\t\treturn NULL;\n\t}\n\n\tspin_unlock(&cookie->lock);\n\n\tif (!cookie->def->select_cache)\n\t\tgoto no_preference;\n\n\t/* ask the netfs for its preference */\n\ttag = cookie->def->select_cache(cookie->parent->netfs_data,\n\t\t\t\t\tcookie->netfs_data);\n\tif (!tag)\n\t\tgoto no_preference;\n\n\tif (tag == ERR_PTR(-ENOMEM)) {\n\t\t_leave(\" = NULL [nomem tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (!tag->cache) {\n\t\t_leave(\" = NULL [unbacked tag]\");\n\t\treturn NULL;\n\t}\n\n\tif (test_bit(FSCACHE_IOERROR, &tag->cache->flags))\n\t\treturn NULL;\n\n\t_leave(\" = %p [specific]\", tag->cache);\n\treturn tag->cache;\n\nno_preference:\n\t/* netfs has no preference - just select first cache */\n\tcache = list_entry(fscache_cache_list.next,\n\t\t\t   struct fscache_cache, link);\n\t_leave(\" = %p [first]\", cache);\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fscache_cache_list"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fscache_addremove_sem"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
  },
  {
    "function_name": "__fscache_enable_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "156-183",
    "snippet": "void __fscache_enable_cookie(struct fscache_cookie *cookie,\n\t\t\t     bool (*can_enable)(void *data),\n\t\t\t     void *data)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\n\tif (test_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock;\n\n\tif (can_enable && !can_enable(data)) {\n\t\t/* The netfs decided it didn't want to enable after all */\n\t} else if (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* Wait for outstanding disablement to complete */\n\t\t__fscache_wait_on_invalidate(cookie);\n\n\t\tif (fscache_acquire_non_index_cookie(cookie) == 0)\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t} else {\n\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t}\n\nout_unlock:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_ENABLEMENT_LOCK"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "FSCACHE_COOKIE_ENABLEMENT_LOCK",
            "&cookie->flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_ENABLED",
            "&cookie->flags"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_acquire_non_index_cookie",
          "args": [
            "cookie"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_acquire_non_index_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "191-272",
          "snippet": "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_wait_on_invalidate",
          "args": [
            "cookie"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_wait_on_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "461-469",
          "snippet": "void __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_enable",
          "args": [
            "data"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_can_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "207-212",
          "snippet": "static bool nfs_fscache_can_enable(void *data)\n{\n\tstruct inode *inode = data;\n\n\treturn !inode_is_open_for_write(inode);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic bool nfs_fscache_can_enable(void *data)\n{\n\tstruct inode *inode = data;\n\n\treturn !inode_is_open_for_write(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "FSCACHE_COOKIE_ENABLED",
            "&cookie->flags"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_lock",
          "args": [
            "&cookie->flags",
            "FSCACHE_COOKIE_ENABLEMENT_LOCK",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "cookie"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_enable_cookie(struct fscache_cookie *cookie,\n\t\t\t     bool (*can_enable)(void *data),\n\t\t\t     void *data)\n{\n\t_enter(\"%p\", cookie);\n\n\twait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n\n\tif (test_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\n\t\tgoto out_unlock;\n\n\tif (can_enable && !can_enable(data)) {\n\t\t/* The netfs decided it didn't want to enable after all */\n\t} else if (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* Wait for outstanding disablement to complete */\n\t\t__fscache_wait_on_invalidate(cookie);\n\n\t\tif (fscache_acquire_non_index_cookie(cookie) == 0)\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t} else {\n\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t}\n\nout_unlock:\n\tclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\n\twake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\n}"
  },
  {
    "function_name": "__fscache_acquire_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "58-150",
    "snippet": "struct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *fscache_cookie_jar;",
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
      "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p\"",
            "cookie"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_stat",
          "args": [
            "&fscache_n_acquires_ok"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_stat_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/internal.h",
          "lines": "279-282",
          "snippet": "static inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int fscache_wait_atomic_t(atomic_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/fscache-cache.h>\n\nextern int fscache_wait_atomic_t(atomic_t *);\n\nstatic inline void fscache_stat_d(atomic_t *stat)\n{\n\tatomic_dec(stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "FSCACHE_COOKIE_ENABLED",
            "&cookie->flags"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = NULL\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fscache_cookie_put",
          "args": [
            "cookie"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_cookie_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "624-646",
          "snippet": "void __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *fscache_cookie_jar;",
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\n{\n\tstruct fscache_cookie *parent;\n\n\t_enter(\"%p\", cookie);\n\n\tfor (;;) {\n\t\t_debug(\"FREE COOKIE %p\", cookie);\n\t\tparent = cookie->parent;\n\t\tBUG_ON(!hlist_empty(&cookie->backing_objects));\n\t\tkmem_cache_free(fscache_cookie_jar, cookie);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\n\t\tcookie = parent;\n\t\tBUG_ON(atomic_read(&cookie->usage) <= 0);\n\t\tif (!atomic_dec_and_test(&cookie->usage))\n\t\t\tbreak;\n\t}\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&parent->n_children"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_acquire_non_index_cookie",
          "args": [
            "cookie"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_acquire_non_index_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
          "lines": "191-272",
          "snippet": "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
            "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);",
            "static int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\n{\n\tstruct fscache_object *object;\n\tstruct fscache_cache *cache;\n\tuint64_t i_size;\n\tint ret;\n\n\t_enter(\"\");\n\n\tset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\n\n\t/* now we need to see whether the backing objects for this cookie yet\n\t * exist, if not there'll be nothing to search */\n\tdown_read(&fscache_addremove_sem);\n\n\tif (list_empty(&fscache_cache_list)) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = 0 [no caches]\");\n\t\treturn 0;\n\t}\n\n\t/* select a cache in which to store the object */\n\tcache = fscache_select_cache_for_object(cookie->parent);\n\tif (!cache) {\n\t\tup_read(&fscache_addremove_sem);\n\t\tfscache_stat(&fscache_n_acquires_no_cache);\n\t\t_leave(\" = -ENOMEDIUM [no cache]\");\n\t\treturn -ENOMEDIUM;\n\t}\n\n\t_debug(\"cache %s\", cache->tag->name);\n\n\tset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\n\n\t/* ask the cache to allocate objects for this cookie and its parent\n\t * chain */\n\tret = fscache_alloc_object(cache, cookie);\n\tif (ret < 0) {\n\t\tup_read(&fscache_addremove_sem);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* pass on how big the object we're caching is supposed to be */\n\tcookie->def->get_attr(cookie->netfs_data, &i_size);\n\n\tspin_lock(&cookie->lock);\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tspin_unlock(&cookie->lock);\n\t\tgoto unavailable;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tfscache_set_store_limit(object, i_size);\n\n\t/* initiate the process of looking up all the objects in the chain\n\t * (done by fscache_initialise_object()) */\n\tfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\n\n\tspin_unlock(&cookie->lock);\n\n\t/* we may be required to wait for lookup to complete at this point */\n\tif (!fscache_defer_lookup) {\n\t\t_debug(\"non-deferred lookup %p\", &cookie->flags);\n\t\twait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t_debug(\"complete\");\n\t\tif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\n\t\t\tgoto unavailable;\n\t}\n\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = 0 [deferred]\");\n\treturn 0;\n\nunavailable:\n\tup_read(&fscache_addremove_sem);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&cookie->stores",
            "GFP_NOFS & ~__GFP_WAIT"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&parent->n_children"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&parent->usage"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cookie->n_active",
            "1"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cookie->n_children",
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cookie->usage",
            "1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fscache_cookie_jar",
            "GFP_KERNEL"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!def->name[0]"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!def->get_key"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},{%s},%p,%u\"",
            "parent ? (char *) parent->def->name : \"<no-parent>\"",
            "def->name",
            "netfs_data",
            "enable"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!def"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstruct kmem_cache *fscache_cookie_jar;\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\n\t\t\t\t struct fscache_object *object);\n\nstruct fscache_cookie *__fscache_acquire_cookie(\n\tstruct fscache_cookie *parent,\n\tconst struct fscache_cookie_def *def,\n\tvoid *netfs_data,\n\tbool enable)\n{\n\tstruct fscache_cookie *cookie;\n\n\tBUG_ON(!def);\n\n\t_enter(\"{%s},{%s},%p,%u\",\n\t       parent ? (char *) parent->def->name : \"<no-parent>\",\n\t       def->name, netfs_data, enable);\n\n\tfscache_stat(&fscache_n_acquires);\n\n\t/* if there's no parent cookie, then we don't create one here either */\n\tif (!parent) {\n\t\tfscache_stat(&fscache_n_acquires_null);\n\t\t_leave(\" [no parent]\");\n\t\treturn NULL;\n\t}\n\n\t/* validate the definition */\n\tBUG_ON(!def->get_key);\n\tBUG_ON(!def->name[0]);\n\n\tBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\n\t       parent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\n\n\t/* allocate and initialise a cookie */\n\tcookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\n\tif (!cookie) {\n\t\tfscache_stat(&fscache_n_acquires_oom);\n\t\t_leave(\" [ENOMEM]\");\n\t\treturn NULL;\n\t}\n\n\tatomic_set(&cookie->usage, 1);\n\tatomic_set(&cookie->n_children, 0);\n\n\t/* We keep the active count elevated until relinquishment to prevent an\n\t * attempt to wake up every time the object operations queue quiesces.\n\t */\n\tatomic_set(&cookie->n_active, 1);\n\n\tatomic_inc(&parent->usage);\n\tatomic_inc(&parent->n_children);\n\n\tcookie->def\t\t= def;\n\tcookie->parent\t\t= parent;\n\tcookie->netfs_data\t= netfs_data;\n\tcookie->flags\t\t= (1 << FSCACHE_COOKIE_NO_DATA_YET);\n\n\t/* radix tree insertion won't use the preallocation pool unless it's\n\t * told it may not wait */\n\tINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\n\n\tswitch (cookie->def->type) {\n\tcase FSCACHE_COOKIE_TYPE_INDEX:\n\t\tfscache_stat(&fscache_n_cookie_index);\n\t\tbreak;\n\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\n\t\tfscache_stat(&fscache_n_cookie_data);\n\t\tbreak;\n\tdefault:\n\t\tfscache_stat(&fscache_n_cookie_special);\n\t\tbreak;\n\t}\n\n\tif (enable) {\n\t\t/* if the object is an index then we need do nothing more here\n\t\t * - we create indices on disk when we need them as an index\n\t\t * may exist in multiple caches */\n\t\tif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t\tif (fscache_acquire_non_index_cookie(cookie) == 0) {\n\t\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&parent->n_children);\n\t\t\t\t__fscache_cookie_put(cookie);\n\t\t\t\tfscache_stat(&fscache_n_acquires_nobufs);\n\t\t\t\t_leave(\" = NULL\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\n\t\t}\n\t}\n\n\tfscache_stat(&fscache_n_acquires_ok);\n\t_leave(\" = %p\", cookie);\n\treturn cookie;\n}"
  },
  {
    "function_name": "fscache_cookie_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/cookie.c",
    "lines": "33-41",
    "snippet": "void fscache_cookie_init_once(void *_cookie)\n{\n\tstruct fscache_cookie *cookie = _cookie;\n\n\tmemset(cookie, 0, sizeof(*cookie));\n\tspin_lock_init(&cookie->lock);\n\tspin_lock_init(&cookie->stores_lock);\n\tINIT_HLIST_HEAD(&cookie->backing_objects);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);",
      "static int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&cookie->backing_objects"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cookie->stores_lock"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cookie->lock"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cookie",
            "0",
            "sizeof(*cookie)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie);\nstatic int fscache_alloc_object(struct fscache_cache *cache,\n\t\t\t\tstruct fscache_cookie *cookie);\n\nvoid fscache_cookie_init_once(void *_cookie)\n{\n\tstruct fscache_cookie *cookie = _cookie;\n\n\tmemset(cookie, 0, sizeof(*cookie));\n\tspin_lock_init(&cookie->lock);\n\tspin_lock_init(&cookie->stores_lock);\n\tINIT_HLIST_HEAD(&cookie->backing_objects);\n}"
  }
]