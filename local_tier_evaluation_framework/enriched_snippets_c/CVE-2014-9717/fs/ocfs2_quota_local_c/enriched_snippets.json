[
  {
    "function_name": "ocfs2_local_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "1273-1302",
    "snippet": "int ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\n{\n\tint status;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint offset;\n\n\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\tINODE_CACHE(sb_dqopt(sb)->files[type]),\n\t\t\tod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\toffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\n\t\t\t\t\t     od->dq_local_off);\n\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t(od->dq_chunk->qc_headerbh->b_data);\n\t/* Mark structure as freed */\n\tlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, 1);\n\tunlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "od->dq_chunk->qc_headerbh"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "od->dq_chunk->qc_headerbh"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dchunk->dqc_free",
            "1"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_bit_unaligned",
          "args": [
            "offset",
            "dchunk->dqc_bitmap"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_dqblk_chunk_off",
          "args": [
            "sb",
            "od->dq_chunk->qc_num",
            "od->dq_local_off"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_chunk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "82-90",
          "snippet": "static int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ((off >> sb->s_blocksize_bits) -\n\t\t\tol_quota_chunk_block(sb, c) - 1) * epb\n\t       + ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\n\t\t sizeof(struct ocfs2_local_disk_dqblk);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ((off >> sb->s_blocksize_bits) -\n\t\t\tol_quota_chunk_block(sb, c) - 1) * epb\n\t       + ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\n\t\t sizeof(struct ocfs2_local_disk_dqblk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(sb_dqopt(sb)->files[type])",
            "od->dq_chunk->qc_headerbh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "sb_dqopt(sb)->files[type]"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_release_dquot(handle_t *handle, struct dquot *dquot)\n{\n\tint status;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint offset;\n\n\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\tINODE_CACHE(sb_dqopt(sb)->files[type]),\n\t\t\tod->dq_chunk->qc_headerbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\toffset = ol_dqblk_chunk_off(sb, od->dq_chunk->qc_num,\n\t\t\t\t\t     od->dq_local_off);\n\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t(od->dq_chunk->qc_headerbh->b_data);\n\t/* Mark structure as freed */\n\tlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_clear_bit_unaligned(offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, 1);\n\tunlock_buffer(od->dq_chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, od->dq_chunk->qc_headerbh);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_create_local_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "1219-1267",
    "snippet": "int ocfs2_create_local_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tint offset;\n\tint status;\n\tu64 pcount;\n\n\tdown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\tchunk = ocfs2_find_free_entry(sb, type, &offset);\n\tif (!chunk) {\n\t\tchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\n\t\tif (IS_ERR(chunk)) {\n\t\t\tstatus = PTR_ERR(chunk);\n\t\t\tgoto out;\n\t\t}\n\t} else if (IS_ERR(chunk)) {\n\t\tstatus = PTR_ERR(chunk);\n\t\tgoto out;\n\t}\n\tod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\n\tod->dq_chunk = chunk;\n\tstatus = ocfs2_extent_map_get_blocks(lqinode,\n\t\t\t\t     ol_dqblk_block(sb, chunk->qc_num, offset),\n\t\t\t\t     &od->dq_local_phys_blk,\n\t\t\t\t     &pcount,\n\t\t\t\t     NULL);\n\n\t/* Initialize dquot structure on disk */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Mark structure as allocated */\n\tstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\n\t\t\t\t &offset);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(lqinode)->ip_alloc_sem"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "lqinode"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_modify_bh",
          "args": [
            "lqinode",
            "chunk->qc_headerbh",
            "olq_alloc_dquot",
            "&offset"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_modify_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "93-125",
          "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_dquot",
          "args": [
            "dquot"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "896-918",
          "snippet": "int ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "lqinode",
            "ol_dqblk_block(sb, chunk->qc_num, offset)",
            "&od->dq_local_phys_blk",
            "&pcount",
            "NULL"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_dqblk_block",
          "args": [
            "sb",
            "chunk->qc_num",
            "offset"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "62-67",
          "snippet": "static unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_dqblk_off",
          "args": [
            "sb",
            "chunk->qc_num",
            "offset"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "70-74",
          "snippet": "static loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\n{\n\treturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\n\t       ol_dqblk_block_off(sb, c, off);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\n{\n\treturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\n\t       ol_dqblk_block_off(sb, c, off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "chunk"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "chunk"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "chunk"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "chunk"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_local_quota_file",
          "args": [
            "sb",
            "type",
            "&offset"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_local_quota_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "1094-1206",
          "snippet": "static struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\n\t\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint epb = ol_quota_entries_per_block(sb);\n\tunsigned int chunk_blocks;\n\tstruct buffer_head *bh;\n\tu64 p_blkno;\n\tint status;\n\thandle_t *handle;\n\n\tif (list_empty(&oinfo->dqi_chunk))\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\t/* Is the last chunk full? */\n\tchunk = list_entry(oinfo->dqi_chunk.prev,\n\t\t\tstruct ocfs2_quota_chunk, qc_chunk);\n\tchunk_blocks = oinfo->dqi_blocks -\n\t\t\tol_quota_chunk_block(sb, chunk->qc_num) - 1;\n\tif (ol_chunk_blocks(sb) == chunk_blocks)\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Get buffer from the just added block */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\n\t/* Local quota info, chunk header and the new block we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Zero created block */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Update chunk header */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t chunk->qc_headerbh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\n\tlock_buffer(chunk->qc_headerbh);\n\tle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\n\tunlock_buffer(chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, chunk->qc_headerbh);\n\n\t/* Update file header */\n\toinfo->dqi_blocks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t*offset = chunk_blocks * epb;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\treturn ERR_PTR(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\n\t\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint epb = ol_quota_entries_per_block(sb);\n\tunsigned int chunk_blocks;\n\tstruct buffer_head *bh;\n\tu64 p_blkno;\n\tint status;\n\thandle_t *handle;\n\n\tif (list_empty(&oinfo->dqi_chunk))\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\t/* Is the last chunk full? */\n\tchunk = list_entry(oinfo->dqi_chunk.prev,\n\t\t\tstruct ocfs2_quota_chunk, qc_chunk);\n\tchunk_blocks = oinfo->dqi_blocks -\n\t\t\tol_quota_chunk_block(sb, chunk->qc_num) - 1;\n\tif (ol_chunk_blocks(sb) == chunk_blocks)\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Get buffer from the just added block */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\n\t/* Local quota info, chunk header and the new block we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Zero created block */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Update chunk header */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t chunk->qc_headerbh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\n\tlock_buffer(chunk->qc_headerbh);\n\tle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\n\tunlock_buffer(chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, chunk->qc_headerbh);\n\n\t/* Update file header */\n\toinfo->dqi_blocks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t*offset = chunk_blocks * epb;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\treturn ERR_PTR(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_free_entry",
          "args": [
            "sb",
            "type",
            "&offset"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "921-960",
          "snippet": "static struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint found = 0, len;\n\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t\tchunk->qc_headerbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\n\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\tlen = ol_chunk_entries(sb);\n\t} else {\n\t\tlen = (oinfo->dqi_blocks -\n\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t      * ol_quota_entries_per_block(sb);\n\t}\n\n\tfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\n\t/* We failed? */\n\tif (found == len) {\n\t\tmlog(ML_ERROR, \"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\", chunk->qc_num,\n\t\t     le32_to_cpu(dchunk->dqc_free), type);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*offset = found;\n\treturn chunk;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint found = 0, len;\n\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t\tchunk->qc_headerbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\n\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\tlen = ol_chunk_entries(sb);\n\t} else {\n\t\tlen = (oinfo->dqi_blocks -\n\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t      * ol_quota_entries_per_block(sb);\n\t}\n\n\tfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\n\t/* We failed? */\n\tif (found == len) {\n\t\tmlog(ML_ERROR, \"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\", chunk->qc_num,\n\t\t     le32_to_cpu(dchunk->dqc_free), type);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*offset = found;\n\treturn chunk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(lqinode)->ip_alloc_sem"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_create_local_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tint offset;\n\tint status;\n\tu64 pcount;\n\n\tdown_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\tchunk = ocfs2_find_free_entry(sb, type, &offset);\n\tif (!chunk) {\n\t\tchunk = ocfs2_extend_local_quota_file(sb, type, &offset);\n\t\tif (IS_ERR(chunk)) {\n\t\t\tstatus = PTR_ERR(chunk);\n\t\t\tgoto out;\n\t\t}\n\t} else if (IS_ERR(chunk)) {\n\t\tstatus = PTR_ERR(chunk);\n\t\tgoto out;\n\t}\n\tod->dq_local_off = ol_dqblk_off(sb, chunk->qc_num, offset);\n\tod->dq_chunk = chunk;\n\tstatus = ocfs2_extent_map_get_blocks(lqinode,\n\t\t\t\t     ol_dqblk_block(sb, chunk->qc_num, offset),\n\t\t\t\t     &od->dq_local_phys_blk,\n\t\t\t\t     &pcount,\n\t\t\t\t     NULL);\n\n\t/* Initialize dquot structure on disk */\n\tstatus = ocfs2_local_write_dquot(dquot);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Mark structure as allocated */\n\tstatus = ocfs2_modify_bh(lqinode, chunk->qc_headerbh, olq_alloc_dquot,\n\t\t\t\t &offset);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tup_write(&OCFS2_I(lqinode)->ip_alloc_sem);\n\treturn status;\n}"
  },
  {
    "function_name": "olq_alloc_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "1208-1216",
    "snippet": "static void olq_alloc_dquot(struct buffer_head *bh, void *private)\n{\n\tint *offset = private;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_bit_unaligned(*offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, -1);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dchunk->dqc_free",
            "-1"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_bit_unaligned",
          "args": [
            "*offset",
            "dchunk->dqc_bitmap"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void olq_alloc_dquot(struct buffer_head *bh, void *private)\n{\n\tint *offset = private;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_bit_unaligned(*offset, dchunk->dqc_bitmap);\n\tle32_add_cpu(&dchunk->dqc_free, -1);\n}"
  },
  {
    "function_name": "ocfs2_extend_local_quota_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "1094-1206",
    "snippet": "static struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\n\t\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint epb = ol_quota_entries_per_block(sb);\n\tunsigned int chunk_blocks;\n\tstruct buffer_head *bh;\n\tu64 p_blkno;\n\tint status;\n\thandle_t *handle;\n\n\tif (list_empty(&oinfo->dqi_chunk))\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\t/* Is the last chunk full? */\n\tchunk = list_entry(oinfo->dqi_chunk.prev,\n\t\t\tstruct ocfs2_quota_chunk, qc_chunk);\n\tchunk_blocks = oinfo->dqi_blocks -\n\t\t\tol_quota_chunk_block(sb, chunk->qc_num) - 1;\n\tif (ol_chunk_blocks(sb) == chunk_blocks)\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Get buffer from the just added block */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\n\t/* Local quota info, chunk header and the new block we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Zero created block */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Update chunk header */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t chunk->qc_headerbh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\n\tlock_buffer(chunk->qc_headerbh);\n\tle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\n\tunlock_buffer(chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, chunk->qc_headerbh);\n\n\t/* Update file header */\n\toinfo->dqi_blocks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t*offset = chunk_blocks * epb;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\treturn ERR_PTR(status);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(sb)",
            "handle"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "795-810",
          "snippet": "static int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "chunk->qc_headerbh"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "chunk->qc_headerbh"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dchunk->dqc_free",
            "ol_quota_entries_per_block(sb)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(lqinode)",
            "chunk->qc_headerbh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "lqinode"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(sb)",
            "OCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(lqinode)",
            "bh"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "p_blkno"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "lqinode",
            "oinfo->dqi_blocks",
            "&p_blkno",
            "NULL",
            "NULL"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_size_update",
          "args": [
            "lqinode",
            "oinfo->dqi_lqi_bh",
            "i_size_read(lqinode) + sb->s_blocksize"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_size_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "319-343",
          "snippet": "int ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_no_holes",
          "args": [
            "lqinode",
            "NULL",
            "i_size_read(lqinode) + sb->s_blocksize",
            "i_size_read(lqinode)"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_no_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1018-1058",
          "snippet": "int ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_quota_add_chunk",
          "args": [
            "sb",
            "type",
            "offset"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_quota_add_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "963-1091",
          "snippet": "static struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\n\t\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\t\tint type,\n\t\t\t\t\t\t\tint *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk = NULL;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *bh = NULL, *dbh = NULL;\n\tu64 p_blkno;\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + 2 * sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + 2 * sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\tif (!chunk) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Local quota info and two new blocks we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Initialize chunk header */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tdchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\n\tmemset(dchunk->dqc_bitmap, 0,\n\t       sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Initialize new block with structures */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdbh = sb_getblk(sb, p_blkno);\n\tif (!dbh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(dbh);\n\tocfs2_journal_dirty(handle, dbh);\n\n\t/* Update local quotafile info */\n\toinfo->dqi_blocks += 2;\n\toinfo->dqi_chunks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\n\tchunk->qc_num = list_entry(chunk->qc_chunk.prev,\n\t\t\t\t   struct ocfs2_quota_chunk,\n\t\t\t\t   qc_chunk)->qc_num + 1;\n\tchunk->qc_headerbh = bh;\n\t*offset = 0;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\tbrelse(bh);\n\tbrelse(dbh);\n\tkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\n\treturn ERR_PTR(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\n\t\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\t\tint type,\n\t\t\t\t\t\t\tint *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk = NULL;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *bh = NULL, *dbh = NULL;\n\tu64 p_blkno;\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + 2 * sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + 2 * sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\tif (!chunk) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Local quota info and two new blocks we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Initialize chunk header */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tdchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\n\tmemset(dchunk->dqc_bitmap, 0,\n\t       sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Initialize new block with structures */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdbh = sb_getblk(sb, p_blkno);\n\tif (!dbh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(dbh);\n\tocfs2_journal_dirty(handle, dbh);\n\n\t/* Update local quotafile info */\n\toinfo->dqi_blocks += 2;\n\toinfo->dqi_chunks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\n\tchunk->qc_num = list_entry(chunk->qc_chunk.prev,\n\t\t\t\t   struct ocfs2_quota_chunk,\n\t\t\t\t   qc_chunk)->qc_num + 1;\n\tchunk->qc_headerbh = bh;\n\t*offset = 0;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\tbrelse(bh);\n\tbrelse(dbh);\n\tkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\n\treturn ERR_PTR(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_chunk_blocks",
          "args": [
            "sb"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "35-40",
          "snippet": "static inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "chunk->qc_num"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "oinfo->dqi_chunk.prev",
            "structocfs2_quota_chunk",
            "qc_chunk"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&oinfo->dqi_chunk"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_extend_local_quota_file(\n\t\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint epb = ol_quota_entries_per_block(sb);\n\tunsigned int chunk_blocks;\n\tstruct buffer_head *bh;\n\tu64 p_blkno;\n\tint status;\n\thandle_t *handle;\n\n\tif (list_empty(&oinfo->dqi_chunk))\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\t/* Is the last chunk full? */\n\tchunk = list_entry(oinfo->dqi_chunk.prev,\n\t\t\tstruct ocfs2_quota_chunk, qc_chunk);\n\tchunk_blocks = oinfo->dqi_blocks -\n\t\t\tol_quota_chunk_block(sb, chunk->qc_num) - 1;\n\tif (ol_chunk_blocks(sb) == chunk_blocks)\n\t\treturn ocfs2_local_quota_add_chunk(sb, type, offset);\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Get buffer from the just added block */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\n\t/* Local quota info, chunk header and the new block we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Zero created block */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, sb->s_blocksize);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Update chunk header */\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t chunk->qc_headerbh,\n\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tdchunk = (struct ocfs2_local_disk_chunk *)chunk->qc_headerbh->b_data;\n\tlock_buffer(chunk->qc_headerbh);\n\tle32_add_cpu(&dchunk->dqc_free, ol_quota_entries_per_block(sb));\n\tunlock_buffer(chunk->qc_headerbh);\n\tocfs2_journal_dirty(handle, chunk->qc_headerbh);\n\n\t/* Update file header */\n\toinfo->dqi_blocks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t*offset = chunk_blocks * epb;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\treturn ERR_PTR(status);\n}"
  },
  {
    "function_name": "ocfs2_local_quota_add_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "963-1091",
    "snippet": "static struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\n\t\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\t\tint type,\n\t\t\t\t\t\t\tint *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk = NULL;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *bh = NULL, *dbh = NULL;\n\tu64 p_blkno;\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + 2 * sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + 2 * sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\tif (!chunk) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Local quota info and two new blocks we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Initialize chunk header */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tdchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\n\tmemset(dchunk->dqc_bitmap, 0,\n\t       sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Initialize new block with structures */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdbh = sb_getblk(sb, p_blkno);\n\tif (!dbh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(dbh);\n\tocfs2_journal_dirty(handle, dbh);\n\n\t/* Update local quotafile info */\n\toinfo->dqi_blocks += 2;\n\toinfo->dqi_chunks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\n\tchunk->qc_num = list_entry(chunk->qc_chunk.prev,\n\t\t\t\t   struct ocfs2_quota_chunk,\n\t\t\t\t   qc_chunk)->qc_num + 1;\n\tchunk->qc_headerbh = bh;\n\t*offset = 0;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\tbrelse(bh);\n\tbrelse(dbh);\n\tkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\n\treturn ERR_PTR(status);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ocfs2_qf_chunk_cachep",
            "chunk"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dbh"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(sb)",
            "handle"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "chunk->qc_chunk.prev",
            "structocfs2_quota_chunk",
            "qc_chunk"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&chunk->qc_chunk",
            "&oinfo->dqi_chunk"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_write_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_write_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "795-810",
          "snippet": "static int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "dbh"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "dbh"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dbh->b_data",
            "0",
            "sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(lqinode)",
            "dbh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "lqinode"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(lqinode)",
            "dbh"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "p_blkno"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "lqinode",
            "oinfo->dqi_blocks + 1",
            "&p_blkno",
            "NULL",
            "NULL"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dchunk->dqc_bitmap",
            "0",
            "sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ol_quota_entries_per_block(sb)"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "p_blkno"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(sb)",
            "OCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ocfs2_qf_chunk_cachep",
            "GFP_NOFS"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_size_update",
          "args": [
            "lqinode",
            "oinfo->dqi_lqi_bh",
            "i_size_read(lqinode) + 2 * sb->s_blocksize"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_size_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "319-343",
          "snippet": "int ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_no_holes",
          "args": [
            "lqinode",
            "NULL",
            "i_size_read(lqinode) + 2 * sb->s_blocksize",
            "i_size_read(lqinode)"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_no_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1018-1058",
          "snippet": "int ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lqinode"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_local_quota_add_chunk(\n\t\t\t\t\t\t\tstruct super_block *sb,\n\t\t\t\t\t\t\tint type,\n\t\t\t\t\t\t\tint *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tstruct ocfs2_quota_chunk *chunk = NULL;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *bh = NULL, *dbh = NULL;\n\tu64 p_blkno;\n\n\t/* We are protected by dqio_sem so no locking needed */\n\tstatus = ocfs2_extend_no_holes(lqinode, NULL,\n\t\t\t\t       i_size_read(lqinode) + 2 * sb->s_blocksize,\n\t\t\t\t       i_size_read(lqinode));\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_simple_size_update(lqinode, oinfo->dqi_lqi_bh,\n\t\t\t\t\t  i_size_read(lqinode) + 2 * sb->s_blocksize);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\tif (!chunk) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\t/* Local quota info and two new blocks we initialize */\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\tOCFS2_LOCAL_QINFO_WRITE_CREDITS +\n\t\t\t2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Initialize chunk header */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tbh = sb_getblk(sb, p_blkno);\n\tif (!bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdchunk = (struct ocfs2_local_disk_chunk *)bh->b_data;\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), bh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(bh);\n\tdchunk->dqc_free = cpu_to_le32(ol_quota_entries_per_block(sb));\n\tmemset(dchunk->dqc_bitmap, 0,\n\t       sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t       OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\t/* Initialize new block with structures */\n\tstatus = ocfs2_extent_map_get_blocks(lqinode, oinfo->dqi_blocks + 1,\n\t\t\t\t\t     &p_blkno, NULL, NULL);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tdbh = sb_getblk(sb, p_blkno);\n\tif (!dbh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(lqinode), dbh);\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode), dbh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0, sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE);\n\tunlock_buffer(dbh);\n\tocfs2_journal_dirty(handle, dbh);\n\n\t/* Update local quotafile info */\n\toinfo->dqi_blocks += 2;\n\toinfo->dqi_chunks++;\n\tstatus = ocfs2_local_write_info(sb, type);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_trans;\n\t}\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&chunk->qc_chunk, &oinfo->dqi_chunk);\n\tchunk->qc_num = list_entry(chunk->qc_chunk.prev,\n\t\t\t\t   struct ocfs2_quota_chunk,\n\t\t\t\t   qc_chunk)->qc_num + 1;\n\tchunk->qc_headerbh = bh;\n\t*offset = 0;\n\treturn chunk;\nout_trans:\n\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout:\n\tbrelse(bh);\n\tbrelse(dbh);\n\tkmem_cache_free(ocfs2_qf_chunk_cachep, chunk);\n\treturn ERR_PTR(status);\n}"
  },
  {
    "function_name": "ocfs2_find_free_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "921-960",
    "snippet": "static struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint found = 0, len;\n\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t\tchunk->qc_headerbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\n\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\tlen = ol_chunk_entries(sb);\n\t} else {\n\t\tlen = (oinfo->dqi_blocks -\n\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t      * ol_quota_entries_per_block(sb);\n\t}\n\n\tfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\n\t/* We failed? */\n\tif (found == len) {\n\t\tmlog(ML_ERROR, \"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\", chunk->qc_num,\n\t\t     le32_to_cpu(dchunk->dqc_free), type);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*offset = found;\n\treturn chunk;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\"",
            "chunk->qc_num",
            "le32_to_cpu(dchunk->dqc_free)",
            "type"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dchunk->dqc_free"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit_unaligned",
          "args": [
            "dchunk->dqc_bitmap",
            "len",
            "0"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "chunk->qc_num"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_chunk_entries",
          "args": [
            "sb"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "43-46",
          "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&oinfo->dqi_chunk",
            "qc_chunk"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_chunk *ocfs2_find_free_entry(struct super_block *sb,\n\t\t\t\t\t\t       int type,\n\t\t\t\t\t\t       int *offset)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint found = 0, len;\n\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t\tchunk->qc_headerbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) > 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\n\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\tlen = ol_chunk_entries(sb);\n\t} else {\n\t\tlen = (oinfo->dqi_blocks -\n\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t      * ol_quota_entries_per_block(sb);\n\t}\n\n\tfound = ocfs2_find_next_zero_bit_unaligned(dchunk->dqc_bitmap, len, 0);\n\t/* We failed? */\n\tif (found == len) {\n\t\tmlog(ML_ERROR, \"Did not find empty entry in chunk %d with %u\"\n\t\t     \" entries free (type=%d)\\n\", chunk->qc_num,\n\t\t     le32_to_cpu(dchunk->dqc_free), type);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\t*offset = found;\n\treturn chunk;\n}"
  },
  {
    "function_name": "ocfs2_local_write_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "896-918",
    "snippet": "int ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_modify_bh",
          "args": [
            "lqinode",
            "bh",
            "olq_set_dquot",
            "od"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_modify_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "93-125",
          "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_phys_block",
          "args": [
            "lqinode",
            "od->dq_local_phys_blk",
            "&bh"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_phys_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "149-160",
          "snippet": "int ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_read_quota_phys_block(struct inode *inode, u64 p_block,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tint rc;\n\n\t*bhp = NULL;\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, 1, bhp, 0,\n\t\t\t       ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_DQUOT",
          "args": [
            "dquot"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_DQUOT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "71-74",
          "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_local_write_dquot(struct dquot *dquot)\n{\n\tstruct super_block *sb = dquot->dq_sb;\n\tstruct ocfs2_dquot *od = OCFS2_DQUOT(dquot);\n\tstruct buffer_head *bh;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[dquot->dq_id.type];\n\tint status;\n\n\tstatus = ocfs2_read_quota_phys_block(lqinode, od->dq_local_phys_blk,\n\t\t\t\t\t     &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_set_dquot, od);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\nout:\n\tbrelse(bh);\n\treturn status;\n}"
  },
  {
    "function_name": "olq_set_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "872-893",
    "snippet": "static void olq_set_dquot(struct buffer_head *bh, void *private)\n{\n\tstruct ocfs2_dquot *od = private;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct super_block *sb = od->dq_dquot.dq_sb;\n\n\tdqblk = (struct ocfs2_local_disk_dqblk *)(bh->b_data\n\t\t+ ol_dqblk_block_offset(sb, od->dq_local_off));\n\n\tdqblk->dqb_id = cpu_to_le64(from_kqid(&init_user_ns,\n\t\t\t\t\t      od->dq_dquot.dq_id));\n\tspin_lock(&dq_data_lock);\n\tdqblk->dqb_spacemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curspace -\n\t\t\t\t\t  od->dq_origspace);\n\tdqblk->dqb_inodemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curinodes -\n\t\t\t\t\t  od->dq_originodes);\n\tspin_unlock(&dq_data_lock);\n\ttrace_olq_set_dquot(\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_spacemod),\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_inodemod),\n\t\tfrom_kqid(&init_user_ns, od->dq_dquot.dq_id));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_olq_set_dquot",
          "args": [
            "(unsigned long long)le64_to_cpu(dqblk->dqb_spacemod)",
            "(unsigned long long)le64_to_cpu(dqblk->dqb_inodemod)",
            "from_kqid(&init_user_ns, od->dq_dquot.dq_id)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "od->dq_dquot.dq_id"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dqblk->dqb_inodemod"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "od->dq_dquot.dq_dqb.dqb_curinodes -\n\t\t\t\t\t  od->dq_originodes"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "od->dq_dquot.dq_dqb.dqb_curspace -\n\t\t\t\t\t  od->dq_origspace"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "from_kqid(&init_user_ns,\n\t\t\t\t\t      od->dq_dquot.dq_id)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_dqblk_block_offset",
          "args": [
            "sb",
            "od->dq_local_off"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_block_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "76-79",
          "snippet": "static inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\n{\n\treturn off & ((1 << sb->s_blocksize_bits) - 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\n{\n\treturn off & ((1 << sb->s_blocksize_bits) - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void olq_set_dquot(struct buffer_head *bh, void *private)\n{\n\tstruct ocfs2_dquot *od = private;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct super_block *sb = od->dq_dquot.dq_sb;\n\n\tdqblk = (struct ocfs2_local_disk_dqblk *)(bh->b_data\n\t\t+ ol_dqblk_block_offset(sb, od->dq_local_off));\n\n\tdqblk->dqb_id = cpu_to_le64(from_kqid(&init_user_ns,\n\t\t\t\t\t      od->dq_dquot.dq_id));\n\tspin_lock(&dq_data_lock);\n\tdqblk->dqb_spacemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curspace -\n\t\t\t\t\t  od->dq_origspace);\n\tdqblk->dqb_inodemod = cpu_to_le64(od->dq_dquot.dq_dqb.dqb_curinodes -\n\t\t\t\t\t  od->dq_originodes);\n\tspin_unlock(&dq_data_lock);\n\ttrace_olq_set_dquot(\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_spacemod),\n\t\t(unsigned long long)le64_to_cpu(dqblk->dqb_inodemod),\n\t\tfrom_kqid(&init_user_ns, od->dq_dquot.dq_id));\n}"
  },
  {
    "function_name": "ocfs2_local_free_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "813-870",
    "snippet": "static int ocfs2_local_free_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint mark_clean = 1, len;\n\tint status;\n\n\tiput(oinfo->dqi_gqinode);\n\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t(chunk->qc_headerbh->b_data);\n\t\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\t\tlen = ol_chunk_entries(sb);\n\t\t} else {\n\t\t\tlen = (oinfo->dqi_blocks -\n\t\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t\t      * ol_quota_entries_per_block(sb);\n\t\t}\n\t\t/* Not all entries free? Bug! */\n\t\tif (le32_to_cpu(dchunk->dqc_free) != len) {\n\t\t\tmlog(ML_ERROR, \"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\", type);\n\t\t\tmark_clean = 0;\n\t\t}\n\t}\n\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\n\t/* dqonoff_mutex protects us against racing with recovery thread... */\n\tif (oinfo->dqi_rec) {\n\t\tocfs2_free_quota_recovery(oinfo->dqi_rec);\n\t\tmark_clean = 0;\n\t}\n\n\tif (!mark_clean)\n\t\tgoto out;\n\n\t/* Mark local file as clean */\n\toinfo->dqi_flags |= OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\n\t\t\t\t oinfo->dqi_libh,\n\t\t\t\t olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\n\tbrelse(oinfo->dqi_libh);\n\tbrelse(oinfo->dqi_lqi_bh);\n\tkfree(oinfo);\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oinfo"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "oinfo->dqi_lqi_bh"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "sb_dqopt(sb)->files[type]",
            "1"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_modify_bh",
          "args": [
            "sb_dqopt(sb)->files[type]",
            "oinfo->dqi_libh",
            "olq_update_info",
            "info"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_modify_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "93-125",
          "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_quota_recovery",
          "args": [
            "oinfo->dqi_rec"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "329-336",
          "snippet": "void ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_release_local_quota_bitmaps",
          "args": [
            "&oinfo->dqi_chunk"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_local_quota_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "238-247",
          "snippet": "static void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\"",
            "type"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dchunk->dqc_free"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "chunk->qc_num"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_chunk_entries",
          "args": [
            "sb"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "43-46",
          "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "chunk",
            "&oinfo->dqi_chunk",
            "qc_chunk"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&oinfo->dqi_gqlock"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "OCFS2_SB(sb)",
            "&oinfo->dqi_gqlock"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "oinfo->dqi_gqinode"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_free_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_quota_chunk *chunk;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint mark_clean = 1, len;\n\tint status;\n\n\tiput(oinfo->dqi_gqinode);\n\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\tlist_for_each_entry(chunk, &oinfo->dqi_chunk, qc_chunk) {\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)\n\t\t\t\t\t(chunk->qc_headerbh->b_data);\n\t\tif (chunk->qc_num < oinfo->dqi_chunks - 1) {\n\t\t\tlen = ol_chunk_entries(sb);\n\t\t} else {\n\t\t\tlen = (oinfo->dqi_blocks -\n\t\t\t       ol_quota_chunk_block(sb, chunk->qc_num) - 1)\n\t\t\t      * ol_quota_entries_per_block(sb);\n\t\t}\n\t\t/* Not all entries free? Bug! */\n\t\tif (le32_to_cpu(dchunk->dqc_free) != len) {\n\t\t\tmlog(ML_ERROR, \"releasing quota file with used \"\n\t\t\t\t\t\"entries (type=%d)\\n\", type);\n\t\t\tmark_clean = 0;\n\t\t}\n\t}\n\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\n\t/* dqonoff_mutex protects us against racing with recovery thread... */\n\tif (oinfo->dqi_rec) {\n\t\tocfs2_free_quota_recovery(oinfo->dqi_rec);\n\t\tmark_clean = 0;\n\t}\n\n\tif (!mark_clean)\n\t\tgoto out;\n\n\t/* Mark local file as clean */\n\toinfo->dqi_flags |= OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type],\n\t\t\t\t oinfo->dqi_libh,\n\t\t\t\t olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\nout:\n\tocfs2_inode_unlock(sb_dqopt(sb)->files[type], 1);\n\tbrelse(oinfo->dqi_libh);\n\tbrelse(oinfo->dqi_lqi_bh);\n\tkfree(oinfo);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_local_write_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "795-810",
    "snippet": "static int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_modify_bh",
          "args": [
            "sb_dqopt(sb)->files[type]",
            "bh",
            "olq_update_info",
            "info"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_modify_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "93-125",
          "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_write_info(struct super_block *sb, int type)\n{\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct buffer_head *bh = ((struct ocfs2_mem_dqinfo *)info->dqi_priv)\n\t\t\t\t\t\t->dqi_libh;\n\tint status;\n\n\tstatus = ocfs2_modify_bh(sb_dqopt(sb)->files[type], bh, olq_update_info,\n\t\t\t\t info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_local_read_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "684-792",
    "snippet": "static int ocfs2_local_read_info(struct super_block *sb, int type)\n{\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_quota_recovery *rec;\n\tint locked = 0;\n\n\t/* We don't need the lock and we have to acquire quota file locks\n\t * which will later depend on this lock */\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tinfo->dqi_max_spc_limit = 0x7fffffffffffffffLL;\n\tinfo->dqi_max_ino_limit = 0x7fffffffffffffffLL;\n\toinfo = kmalloc(sizeof(struct ocfs2_mem_dqinfo), GFP_NOFS);\n\tif (!oinfo) {\n\t\tmlog(ML_ERROR, \"failed to allocate memory for ocfs2 quota\"\n\t\t\t       \" info.\");\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_priv = oinfo;\n\toinfo->dqi_type = type;\n\tINIT_LIST_HEAD(&oinfo->dqi_chunk);\n\toinfo->dqi_rec = NULL;\n\toinfo->dqi_lqi_bh = NULL;\n\toinfo->dqi_libh = NULL;\n\n\tstatus = ocfs2_global_read_info(sb, type);\n\tif (status < 0)\n\t\tgoto out_err;\n\n\tstatus = ocfs2_inode_lock(lqinode, &oinfo->dqi_lqi_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tlocked = 1;\n\n\t/* Now read local header */\n\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\toinfo->dqi_flags = le32_to_cpu(ldinfo->dqi_flags);\n\toinfo->dqi_chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\toinfo->dqi_blocks = le32_to_cpu(ldinfo->dqi_blocks);\n\toinfo->dqi_libh = bh;\n\n\t/* We crashed when using local quota file? */\n\tif (!(oinfo->dqi_flags & OLQF_CLEAN)) {\n\t\trec = OCFS2_SB(sb)->quota_rec;\n\t\tif (!rec) {\n\t\t\trec = ocfs2_alloc_quota_recovery();\n\t\t\tif (!rec) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tOCFS2_SB(sb)->quota_rec = rec;\n\t\t}\n\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n                                                   &rec->r_list[type]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tstatus = ocfs2_load_local_quota_bitmaps(lqinode,\n\t\t\t\t\t\tldinfo,\n\t\t\t\t\t\t&oinfo->dqi_chunk);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\t/* Now mark quota file as used */\n\toinfo->dqi_flags &= ~OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_update_info, info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\treturn 0;\nout_err:\n\tif (oinfo) {\n\t\tiput(oinfo->dqi_gqinode);\n\t\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\t\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\t\tbrelse(oinfo->dqi_lqi_bh);\n\t\tif (locked)\n\t\t\tocfs2_inode_unlock(lqinode, 1);\n\t\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\t\tkfree(oinfo);\n\t}\n\tbrelse(bh);\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\treturn -1;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oinfo"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_release_local_quota_bitmaps",
          "args": [
            "&oinfo->dqi_chunk"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_local_quota_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "238-247",
          "snippet": "static void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "lqinode",
            "1"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&oinfo->dqi_gqlock"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "OCFS2_SB(sb)",
            "&oinfo->dqi_gqlock"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "oinfo->dqi_gqinode"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_modify_bh",
          "args": [
            "lqinode",
            "bh",
            "olq_update_info",
            "info"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_modify_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "93-125",
          "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_load_local_quota_bitmaps",
          "args": [
            "lqinode",
            "ldinfo",
            "&oinfo->dqi_chunk"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_load_local_quota_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "250-278",
          "snippet": "static int ocfs2_load_local_quota_bitmaps(struct inode *inode,\n\t\t\tstruct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\tstruct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *newchunk;\n\tint i, status;\n\n\tINIT_LIST_HEAD(head);\n\tfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\n\t\tnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\t\tif (!newchunk) {\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnewchunk->qc_num = i;\n\t\tnewchunk->qc_headerbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(inode,\n\t\t\t\tol_quota_chunk_block(inode->i_sb, i),\n\t\t\t\t&newchunk->qc_headerbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn status;\n\t\t}\n\t\tlist_add_tail(&newchunk->qc_chunk, head);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_load_local_quota_bitmaps(struct inode *inode,\n\t\t\tstruct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\tstruct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *newchunk;\n\tint i, status;\n\n\tINIT_LIST_HEAD(head);\n\tfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\n\t\tnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\t\tif (!newchunk) {\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnewchunk->qc_num = i;\n\t\tnewchunk->qc_headerbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(inode,\n\t\t\t\tol_quota_chunk_block(inode->i_sb, i),\n\t\t\t\t&newchunk->qc_headerbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn status;\n\t\t}\n\t\tlist_add_tail(&newchunk->qc_chunk, head);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_load_quota",
          "args": [
            "lqinode",
            "ldinfo",
            "type",
            "&rec->r_list[type]"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_load_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "339-369",
          "snippet": "static int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_quota_recovery",
          "args": [],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "371-382",
          "snippet": "static struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldinfo->dqi_blocks"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to read quota file info header \"\n\t\t\t\"(type=%d)\\n\"",
            "type"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "lqinode",
            "0",
            "&bh"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "lqinode",
            "&oinfo->dqi_lqi_bh",
            "1"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_global_read_info",
          "args": [
            "sb",
            "type"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_read_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "336-411",
          "snippet": "int ocfs2_global_read_info(struct super_block *sb, int type)\n{\n\tstruct inode *gqinode = NULL;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tu64 pcount;\n\tint status;\n\n\t/* Read global header */\n\tgqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\tOCFS2_INVALID_SLOT);\n\tif (!gqinode) {\n\t\tmlog(ML_ERROR, \"failed to get global quota inode (type=%d)\\n\",\n\t\t\ttype);\n\t\tstatus = -EINVAL;\n\t\tgoto out_err;\n\t}\n\toinfo->dqi_gi.dqi_sb = sb;\n\toinfo->dqi_gi.dqi_type = type;\n\tocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\n\toinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\n\toinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\n\toinfo->dqi_gqi_bh = NULL;\n\toinfo->dqi_gqi_count = 0;\n\toinfo->dqi_gqinode = gqinode;\n\tstatus = ocfs2_lock_global_qf(oinfo, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(gqinode, 0, &oinfo->dqi_giblk,\n\t\t\t\t\t     &pcount, NULL);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\n\tstatus = ocfs2_qinfo_lock(oinfo, 0);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\tstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t\t\t\t      sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t      OCFS2_GLOBAL_INFO_OFF);\n\tocfs2_qinfo_unlock(oinfo, 0);\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot read global quota info (%d).\\n\",\n\t\t     status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\toinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\n\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\toinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\toinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\n\toinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\n\t\t\t\t\t\tOCFS2_QBLK_RESERVED_SPACE;\n\toinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\n\tINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n\nout_err:\n\treturn status;\nout_unlock:\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tmlog_errno(status);\n\tgoto out_err;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct qtree_fmt_operations ocfs2_global_ops = {\n\t.mem2disk_dqblk = ocfs2_global_mem2diskdqb,\n\t.disk2mem_dqblk = ocfs2_global_disk2memdqb,\n\t.is_id = ocfs2_global_is_id,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nstruct qtree_fmt_operations ocfs2_global_ops = {\n\t.mem2disk_dqblk = ocfs2_global_mem2diskdqb,\n\t.disk2mem_dqblk = ocfs2_global_disk2memdqb,\n\t.is_id = ocfs2_global_is_id,\n};\n\nint ocfs2_global_read_info(struct super_block *sb, int type)\n{\n\tstruct inode *gqinode = NULL;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct ocfs2_global_disk_dqinfo dinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tu64 pcount;\n\tint status;\n\n\t/* Read global header */\n\tgqinode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\tOCFS2_INVALID_SLOT);\n\tif (!gqinode) {\n\t\tmlog(ML_ERROR, \"failed to get global quota inode (type=%d)\\n\",\n\t\t\ttype);\n\t\tstatus = -EINVAL;\n\t\tgoto out_err;\n\t}\n\toinfo->dqi_gi.dqi_sb = sb;\n\toinfo->dqi_gi.dqi_type = type;\n\tocfs2_qinfo_lock_res_init(&oinfo->dqi_gqlock, oinfo);\n\toinfo->dqi_gi.dqi_entry_size = sizeof(struct ocfs2_global_disk_dqblk);\n\toinfo->dqi_gi.dqi_ops = &ocfs2_global_ops;\n\toinfo->dqi_gqi_bh = NULL;\n\toinfo->dqi_gqi_count = 0;\n\toinfo->dqi_gqinode = gqinode;\n\tstatus = ocfs2_lock_global_qf(oinfo, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tstatus = ocfs2_extent_map_get_blocks(gqinode, 0, &oinfo->dqi_giblk,\n\t\t\t\t\t     &pcount, NULL);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\n\tstatus = ocfs2_qinfo_lock(oinfo, 0);\n\tif (status < 0)\n\t\tgoto out_unlock;\n\tstatus = sb->s_op->quota_read(sb, type, (char *)&dinfo,\n\t\t\t\t      sizeof(struct ocfs2_global_disk_dqinfo),\n\t\t\t\t      OCFS2_GLOBAL_INFO_OFF);\n\tocfs2_qinfo_unlock(oinfo, 0);\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tif (status != sizeof(struct ocfs2_global_disk_dqinfo)) {\n\t\tmlog(ML_ERROR, \"Cannot read global quota info (%d).\\n\",\n\t\t     status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\n\tinfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\n\toinfo->dqi_syncms = le32_to_cpu(dinfo.dqi_syncms);\n\toinfo->dqi_gi.dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\n\toinfo->dqi_gi.dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\n\toinfo->dqi_gi.dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\n\toinfo->dqi_gi.dqi_blocksize_bits = sb->s_blocksize_bits;\n\toinfo->dqi_gi.dqi_usable_bs = sb->s_blocksize -\n\t\t\t\t\t\tOCFS2_QBLK_RESERVED_SPACE;\n\toinfo->dqi_gi.dqi_qtree_depth = qtree_depth(&oinfo->dqi_gi);\n\tINIT_DELAYED_WORK(&oinfo->dqi_sync_work, qsync_work_fn);\n\tschedule_delayed_work(&oinfo->dqi_sync_work,\n\t\t\t      msecs_to_jiffies(oinfo->dqi_syncms));\n\nout_err:\n\treturn status;\nout_unlock:\n\tocfs2_unlock_global_qf(oinfo, 0);\n\tmlog_errno(status);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oinfo->dqi_chunk"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to allocate memory for ocfs2 quota\"\n\t\t\t       \" info.\""
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ocfs2_mem_dqinfo)",
            "GFP_NOFS"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_read_info(struct super_block *sb, int type)\n{\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct mem_dqinfo *info = sb_dqinfo(sb, type);\n\tstruct ocfs2_mem_dqinfo *oinfo;\n\tstruct inode *lqinode = sb_dqopt(sb)->files[type];\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_quota_recovery *rec;\n\tint locked = 0;\n\n\t/* We don't need the lock and we have to acquire quota file locks\n\t * which will later depend on this lock */\n\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\tinfo->dqi_max_spc_limit = 0x7fffffffffffffffLL;\n\tinfo->dqi_max_ino_limit = 0x7fffffffffffffffLL;\n\toinfo = kmalloc(sizeof(struct ocfs2_mem_dqinfo), GFP_NOFS);\n\tif (!oinfo) {\n\t\tmlog(ML_ERROR, \"failed to allocate memory for ocfs2 quota\"\n\t\t\t       \" info.\");\n\t\tgoto out_err;\n\t}\n\tinfo->dqi_priv = oinfo;\n\toinfo->dqi_type = type;\n\tINIT_LIST_HEAD(&oinfo->dqi_chunk);\n\toinfo->dqi_rec = NULL;\n\toinfo->dqi_lqi_bh = NULL;\n\toinfo->dqi_libh = NULL;\n\n\tstatus = ocfs2_global_read_info(sb, type);\n\tif (status < 0)\n\t\tgoto out_err;\n\n\tstatus = ocfs2_inode_lock(lqinode, &oinfo->dqi_lqi_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\tlocked = 1;\n\n\t/* Now read local header */\n\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\toinfo->dqi_flags = le32_to_cpu(ldinfo->dqi_flags);\n\toinfo->dqi_chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\toinfo->dqi_blocks = le32_to_cpu(ldinfo->dqi_blocks);\n\toinfo->dqi_libh = bh;\n\n\t/* We crashed when using local quota file? */\n\tif (!(oinfo->dqi_flags & OLQF_CLEAN)) {\n\t\trec = OCFS2_SB(sb)->quota_rec;\n\t\tif (!rec) {\n\t\t\trec = ocfs2_alloc_quota_recovery();\n\t\t\tif (!rec) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tOCFS2_SB(sb)->quota_rec = rec;\n\t\t}\n\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n                                                   &rec->r_list[type]);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tstatus = ocfs2_load_local_quota_bitmaps(lqinode,\n\t\t\t\t\t\tldinfo,\n\t\t\t\t\t\t&oinfo->dqi_chunk);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\t/* Now mark quota file as used */\n\toinfo->dqi_flags &= ~OLQF_CLEAN;\n\tstatus = ocfs2_modify_bh(lqinode, bh, olq_update_info, info);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_err;\n\t}\n\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\treturn 0;\nout_err:\n\tif (oinfo) {\n\t\tiput(oinfo->dqi_gqinode);\n\t\tocfs2_simple_drop_lockres(OCFS2_SB(sb), &oinfo->dqi_gqlock);\n\t\tocfs2_lock_res_free(&oinfo->dqi_gqlock);\n\t\tbrelse(oinfo->dqi_lqi_bh);\n\t\tif (locked)\n\t\t\tocfs2_inode_unlock(lqinode, 1);\n\t\tocfs2_release_local_quota_bitmaps(&oinfo->dqi_chunk);\n\t\tkfree(oinfo);\n\t}\n\tbrelse(bh);\n\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\treturn -1;\n}"
  },
  {
    "function_name": "ocfs2_finish_quota_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "583-681",
    "snippet": "int ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_quota_recovery *rec,\n\t\t\t\tint slot_num)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\tint type;\n\tint status = 0;\n\tstruct inode *lqinode;\n\tunsigned int flags;\n\n\tprintk(KERN_NOTICE \"ocfs2: Finishing quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (list_empty(&(rec->r_list[type])))\n\t\t\tcontinue;\n\t\ttrace_ocfs2_finish_quota_recovery(slot_num);\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t\t       OCFS2_META_LOCK_NOQUEUE);\n\t\t/* Someone else is holding the lock? Then he must be\n\t\t * doing the recovery. Just skip the file... */\n\t\tif (status == -EAGAIN) {\n\t\t\tprintk(KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\", osb->dev_str, slot_num);\n\t\t\tstatus = 0;\n\t\t\tgoto out_put;\n\t\t} else if (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\t/* Is recovery still needed? */\n\t\tflags = le32_to_cpu(ldinfo->dqi_flags);\n\t\tif (!(flags & OLQF_CLEAN))\n\t\t\tstatus = ocfs2_recover_local_quota_file(lqinode,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\trec);\n\t\t/* We don't want to mark file as clean when it is actually\n\t\t * active */\n\t\tif (slot_num == osb->slot_num)\n\t\t\tgoto out_bh;\n\t\t/* Mark quota file as clean if we are recovering quota file of\n\t\t * some other node. */\n\t\thandle = ocfs2_start_trans(osb,\n\t\t\t\t\t   OCFS2_LOCAL_QINFO_WRITE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_bh;\n\t\t}\n\t\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t\t bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_trans;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\n\t\tunlock_buffer(bh);\n\t\tocfs2_journal_dirty(handle, bh);\nout_trans:\n\t\tocfs2_commit_trans(osb, handle);\nout_bh:\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\tkfree(rec);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rec"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(sb)->dqonoff_mutex"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "lqinode"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "lqinode",
            "1"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags | OLQF_CLEAN"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(lqinode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "lqinode"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_LOCAL_QINFO_WRITE_CREDITS"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_local_quota_file",
          "args": [
            "lqinode",
            "type",
            "rec"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_local_quota_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "459-580",
          "snippet": "static int ocfs2_recover_local_quota_file(struct inode *lqinode,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  struct ocfs2_quota_recovery *rec)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct dquot *dquot;\n\thandle_t *handle;\n\tstruct buffer_head *hbh = NULL, *qbh = NULL;\n\tint status = 0;\n\tint bit, chunk;\n\tstruct ocfs2_recovery_chunk *rchunk, *next;\n\tqsize_t spacechange, inodechange;\n\n\ttrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\n\n\tlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\n\t\tchunk = rchunk->rc_chunk;\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, chunk),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\n\t\t\tqbh = NULL;\n\t\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_dqblk_block(sb, chunk, bit),\n\t\t\t\t\t\t&qbh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\n\t\t\t\tol_dqblk_block_off(sb, chunk, bit));\n\t\t\tdquot = dqget(sb,\n\t\t\t\t      make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id)));\n\t\t\tif (!dquot) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog(ML_ERROR, \"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\",\n\t\t\t\t     (unsigned)le64_to_cpu(dqblk->dqb_id),\n\t\t\t\t     type);\n\t\t\t\tgoto out_put_bh;\n\t\t\t}\n\t\t\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_put_dquot;\n\t\t\t}\n\n\t\t\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t\t\t   OCFS2_QSYNC_CREDITS);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tstatus = PTR_ERR(handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_drop_lock;\n\t\t\t}\n\t\t\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tspin_lock(&dq_data_lock);\n\t\t\t/* Add usage from quota entry into quota changes\n\t\t\t * of our node. Auxiliary variables are important\n\t\t\t * due to signedness */\n\t\t\tspacechange = le64_to_cpu(dqblk->dqb_spacemod);\n\t\t\tinodechange = le64_to_cpu(dqblk->dqb_inodemod);\n\t\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\t\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t\t\tspin_unlock(&dq_data_lock);\n\t\t\t/* We want to drop reference held by the crashed\n\t\t\t * node. Since we have our own reference we know\n\t\t\t * global structure actually won't be freed. */\n\t\t\tstatus = ocfs2_global_release_dquot(dquot);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\t/* Release local quota file entry */\n\t\t\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\t\t\tINODE_CACHE(lqinode),\n\t\t\t\t\tqbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tlock_buffer(qbh);\n\t\t\tWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\n\t\t\tocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\n\t\t\tle32_add_cpu(&dchunk->dqc_free, 1);\n\t\t\tunlock_buffer(qbh);\n\t\t\tocfs2_journal_dirty(handle, qbh);\nout_commit:\n\t\t\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_drop_lock:\n\t\t\tocfs2_unlock_global_qf(oinfo, 1);\nout_put_dquot:\n\t\t\tdqput(dquot);\nout_put_bh:\n\t\t\tbrelse(qbh);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(hbh);\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_local_quota_file(struct inode *lqinode,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  struct ocfs2_quota_recovery *rec)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct dquot *dquot;\n\thandle_t *handle;\n\tstruct buffer_head *hbh = NULL, *qbh = NULL;\n\tint status = 0;\n\tint bit, chunk;\n\tstruct ocfs2_recovery_chunk *rchunk, *next;\n\tqsize_t spacechange, inodechange;\n\n\ttrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\n\n\tlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\n\t\tchunk = rchunk->rc_chunk;\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, chunk),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\n\t\t\tqbh = NULL;\n\t\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_dqblk_block(sb, chunk, bit),\n\t\t\t\t\t\t&qbh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\n\t\t\t\tol_dqblk_block_off(sb, chunk, bit));\n\t\t\tdquot = dqget(sb,\n\t\t\t\t      make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id)));\n\t\t\tif (!dquot) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog(ML_ERROR, \"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\",\n\t\t\t\t     (unsigned)le64_to_cpu(dqblk->dqb_id),\n\t\t\t\t     type);\n\t\t\t\tgoto out_put_bh;\n\t\t\t}\n\t\t\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_put_dquot;\n\t\t\t}\n\n\t\t\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t\t\t   OCFS2_QSYNC_CREDITS);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tstatus = PTR_ERR(handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_drop_lock;\n\t\t\t}\n\t\t\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tspin_lock(&dq_data_lock);\n\t\t\t/* Add usage from quota entry into quota changes\n\t\t\t * of our node. Auxiliary variables are important\n\t\t\t * due to signedness */\n\t\t\tspacechange = le64_to_cpu(dqblk->dqb_spacemod);\n\t\t\tinodechange = le64_to_cpu(dqblk->dqb_inodemod);\n\t\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\t\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t\t\tspin_unlock(&dq_data_lock);\n\t\t\t/* We want to drop reference held by the crashed\n\t\t\t * node. Since we have our own reference we know\n\t\t\t * global structure actually won't be freed. */\n\t\t\tstatus = ocfs2_global_release_dquot(dquot);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\t/* Release local quota file entry */\n\t\t\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\t\t\tINODE_CACHE(lqinode),\n\t\t\t\t\tqbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tlock_buffer(qbh);\n\t\t\tWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\n\t\t\tocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\n\t\t\tle32_add_cpu(&dchunk->dqc_free, 1);\n\t\t\tunlock_buffer(qbh);\n\t\t\tocfs2_journal_dirty(handle, qbh);\nout_commit:\n\t\t\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_drop_lock:\n\t\t\tocfs2_unlock_global_qf(oinfo, 1);\nout_put_dquot:\n\t\t\tdqput(dquot);\nout_put_bh:\n\t\t\tbrelse(qbh);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(hbh);\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldinfo->dqi_flags"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\"",
            "slot_num",
            "type"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "lqinode",
            "0",
            "&bh"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\"",
            "osb->dev_str",
            "slot_num"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "lqinode",
            "NULL",
            "1",
            "OCFS2_META_LOCK_NOQUEUE"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ino[type]",
            "slot_num"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_finish_quota_recovery",
          "args": [
            "slot_num"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&(rec->r_list[type])"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqonoff_mutex"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_quota_recovery *rec,\n\t\t\t\tint slot_num)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\tint type;\n\tint status = 0;\n\tstruct inode *lqinode;\n\tunsigned int flags;\n\n\tprintk(KERN_NOTICE \"ocfs2: Finishing quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (list_empty(&(rec->r_list[type])))\n\t\t\tcontinue;\n\t\ttrace_ocfs2_finish_quota_recovery(slot_num);\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t\t       OCFS2_META_LOCK_NOQUEUE);\n\t\t/* Someone else is holding the lock? Then he must be\n\t\t * doing the recovery. Just skip the file... */\n\t\tif (status == -EAGAIN) {\n\t\t\tprintk(KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\", osb->dev_str, slot_num);\n\t\t\tstatus = 0;\n\t\t\tgoto out_put;\n\t\t} else if (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\t/* Is recovery still needed? */\n\t\tflags = le32_to_cpu(ldinfo->dqi_flags);\n\t\tif (!(flags & OLQF_CLEAN))\n\t\t\tstatus = ocfs2_recover_local_quota_file(lqinode,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\trec);\n\t\t/* We don't want to mark file as clean when it is actually\n\t\t * active */\n\t\tif (slot_num == osb->slot_num)\n\t\t\tgoto out_bh;\n\t\t/* Mark quota file as clean if we are recovering quota file of\n\t\t * some other node. */\n\t\thandle = ocfs2_start_trans(osb,\n\t\t\t\t\t   OCFS2_LOCAL_QINFO_WRITE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_bh;\n\t\t}\n\t\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t\t bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_trans;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\n\t\tunlock_buffer(bh);\n\t\tocfs2_journal_dirty(handle, bh);\nout_trans:\n\t\tocfs2_commit_trans(osb, handle);\nout_bh:\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\tkfree(rec);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_recover_local_quota_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "459-580",
    "snippet": "static int ocfs2_recover_local_quota_file(struct inode *lqinode,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  struct ocfs2_quota_recovery *rec)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct dquot *dquot;\n\thandle_t *handle;\n\tstruct buffer_head *hbh = NULL, *qbh = NULL;\n\tint status = 0;\n\tint bit, chunk;\n\tstruct ocfs2_recovery_chunk *rchunk, *next;\n\tqsize_t spacechange, inodechange;\n\n\ttrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\n\n\tlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\n\t\tchunk = rchunk->rc_chunk;\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, chunk),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\n\t\t\tqbh = NULL;\n\t\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_dqblk_block(sb, chunk, bit),\n\t\t\t\t\t\t&qbh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\n\t\t\t\tol_dqblk_block_off(sb, chunk, bit));\n\t\t\tdquot = dqget(sb,\n\t\t\t\t      make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id)));\n\t\t\tif (!dquot) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog(ML_ERROR, \"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\",\n\t\t\t\t     (unsigned)le64_to_cpu(dqblk->dqb_id),\n\t\t\t\t     type);\n\t\t\t\tgoto out_put_bh;\n\t\t\t}\n\t\t\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_put_dquot;\n\t\t\t}\n\n\t\t\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t\t\t   OCFS2_QSYNC_CREDITS);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tstatus = PTR_ERR(handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_drop_lock;\n\t\t\t}\n\t\t\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tspin_lock(&dq_data_lock);\n\t\t\t/* Add usage from quota entry into quota changes\n\t\t\t * of our node. Auxiliary variables are important\n\t\t\t * due to signedness */\n\t\t\tspacechange = le64_to_cpu(dqblk->dqb_spacemod);\n\t\t\tinodechange = le64_to_cpu(dqblk->dqb_inodemod);\n\t\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\t\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t\t\tspin_unlock(&dq_data_lock);\n\t\t\t/* We want to drop reference held by the crashed\n\t\t\t * node. Since we have our own reference we know\n\t\t\t * global structure actually won't be freed. */\n\t\t\tstatus = ocfs2_global_release_dquot(dquot);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\t/* Release local quota file entry */\n\t\t\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\t\t\tINODE_CACHE(lqinode),\n\t\t\t\t\tqbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tlock_buffer(qbh);\n\t\t\tWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\n\t\t\tocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\n\t\t\tle32_add_cpu(&dchunk->dqc_free, 1);\n\t\t\tunlock_buffer(qbh);\n\t\t\tocfs2_journal_dirty(handle, qbh);\nout_commit:\n\t\t\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_drop_lock:\n\t\t\tocfs2_unlock_global_qf(oinfo, 1);\nout_put_dquot:\n\t\t\tdqput(dquot);\nout_put_bh:\n\t\t\tbrelse(qbh);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(hbh);\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_recovery_list",
          "args": [
            "&(rec->r_list[type])"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "free_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "317-327",
          "snippet": "static void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rchunk"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rchunk->rc_bitmap"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rchunk->rc_list"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "hbh"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dqput",
          "args": [
            "dquot"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "734-794",
          "snippet": "void dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "319-333",
          "snippet": "void ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nvoid ocfs2_unlock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tif (ex) {\n\t\tup_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t\tmutex_unlock(&oinfo->dqi_gqinode->i_mutex);\n\t} else {\n\t\tup_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\tocfs2_inode_unlock(oinfo->dqi_gqinode, ex);\n\tbrelse(oinfo->dqi_gqi_bh);\n\tspin_lock(&dq_data_lock);\n\tif (!--oinfo->dqi_gqi_count)\n\t\toinfo->dqi_gqi_bh = NULL;\n\tspin_unlock(&dq_data_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(sb)",
            "handle"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "qbh"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "qbh"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dchunk->dqc_free",
            "1"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_bit_unaligned",
          "args": [
            "bit",
            "dchunk->dqc_bitmap"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit_unaligned",
          "args": [
            "bit",
            "dchunk->dqc_bitmap"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(lqinode)",
            "qbh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "lqinode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_global_release_dquot",
          "args": [
            "dquot"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_global_release_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
          "lines": "105-108",
          "snippet": "static inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}",
          "includes": [
            "#include \"ocfs2.h\"",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/list.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dqblk->dqb_inodemod"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb_dqopt(sb)->dqio_mutex"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(sb)",
            "OCFS2_QSYNC_CREDITS"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_global_qf",
          "args": [
            "oinfo",
            "1"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_global_qf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "296-317",
          "snippet": "int ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint ocfs2_lock_global_qf(struct ocfs2_mem_dqinfo *oinfo, int ex)\n{\n\tint status;\n\tstruct buffer_head *bh = NULL;\n\n\tstatus = ocfs2_inode_lock(oinfo->dqi_gqinode, &bh, ex);\n\tif (status < 0)\n\t\treturn status;\n\tspin_lock(&dq_data_lock);\n\tif (!oinfo->dqi_gqi_count++)\n\t\toinfo->dqi_gqi_bh = bh;\n\telse\n\t\tWARN_ON(bh != oinfo->dqi_gqi_bh);\n\tspin_unlock(&dq_data_lock);\n\tif (ex) {\n\t\tmutex_lock(&oinfo->dqi_gqinode->i_mutex);\n\t\tdown_write(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t} else {\n\t\tdown_read(&OCFS2_I(oinfo->dqi_gqinode)->ip_alloc_sem);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\"",
            "(unsigned)le64_to_cpu(dqblk->dqb_id)",
            "type"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dqget",
          "args": [
            "sb",
            "make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id))"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "832-893",
          "snippet": "struct dquot *dqget(struct super_block *sb, struct kqid qid)\n{\n\tunsigned int hashent = hashfn(sb, qid);\n\tstruct dquot *dquot = NULL, *empty = NULL;\n\n        if (!sb_has_quota_active(sb, qid.type))\n\t\treturn NULL;\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tspin_lock(&dq_state_lock);\n\tif (!sb_has_quota_active(sb, qid.type)) {\n\t\tspin_unlock(&dq_state_lock);\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&dq_state_lock);\n\n\tdquot = find_dquot(hashent, sb, qid);\n\tif (!dquot) {\n\t\tif (!empty) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tempty = get_empty_dquot(sb, qid.type);\n\t\t\tif (!empty)\n\t\t\t\tschedule();\t/* Try to wait for a moment... */\n\t\t\tgoto we_slept;\n\t\t}\n\t\tdquot = empty;\n\t\tempty = NULL;\n\t\tdquot->dq_id = qid;\n\t\t/* all dquots go on the inuse_list */\n\t\tput_inuse(dquot);\n\t\t/* hash it first so it can be found */\n\t\tinsert_dquot_hash(dquot);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t} else {\n\t\tif (!atomic_read(&dquot->dq_count))\n\t\t\tremove_free_dquot(dquot);\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_CACHE_HITS);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t}\n\t/* Wait for dq_lock - after this we know that either dquot_release() is\n\t * already finished or it will be canceled due to dq_count > 1 test */\n\twait_on_dquot(dquot);\n\t/* Read the dquot / allocate space in quota file */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) &&\n\t    sb->dq_op->acquire_dquot(dquot) < 0) {\n\t\tdqput(dquot);\n\t\tdquot = NULL;\n\t\tgoto out;\n\t}\n#ifdef CONFIG_QUOTA_DEBUG\n\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */\n#endif\nout:\n\tif (empty)\n\t\tdo_destroy_dquot(empty);\n\n\treturn dquot;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static LIST_HEAD(inuse_list);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic LIST_HEAD(inuse_list);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nstruct dquot *dqget(struct super_block *sb, struct kqid qid)\n{\n\tunsigned int hashent = hashfn(sb, qid);\n\tstruct dquot *dquot = NULL, *empty = NULL;\n\n        if (!sb_has_quota_active(sb, qid.type))\n\t\treturn NULL;\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tspin_lock(&dq_state_lock);\n\tif (!sb_has_quota_active(sb, qid.type)) {\n\t\tspin_unlock(&dq_state_lock);\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&dq_state_lock);\n\n\tdquot = find_dquot(hashent, sb, qid);\n\tif (!dquot) {\n\t\tif (!empty) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tempty = get_empty_dquot(sb, qid.type);\n\t\t\tif (!empty)\n\t\t\t\tschedule();\t/* Try to wait for a moment... */\n\t\t\tgoto we_slept;\n\t\t}\n\t\tdquot = empty;\n\t\tempty = NULL;\n\t\tdquot->dq_id = qid;\n\t\t/* all dquots go on the inuse_list */\n\t\tput_inuse(dquot);\n\t\t/* hash it first so it can be found */\n\t\tinsert_dquot_hash(dquot);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t} else {\n\t\tif (!atomic_read(&dquot->dq_count))\n\t\t\tremove_free_dquot(dquot);\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_CACHE_HITS);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t}\n\t/* Wait for dq_lock - after this we know that either dquot_release() is\n\t * already finished or it will be canceled due to dq_count > 1 test */\n\twait_on_dquot(dquot);\n\t/* Read the dquot / allocate space in quota file */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) &&\n\t    sb->dq_op->acquire_dquot(dquot) < 0) {\n\t\tdqput(dquot);\n\t\tdquot = NULL;\n\t\tgoto out;\n\t}\n#ifdef CONFIG_QUOTA_DEBUG\n\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */\n#endif\nout:\n\tif (empty)\n\t\tdo_destroy_dquot(empty);\n\n\treturn dquot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid",
          "args": [
            "&init_user_ns",
            "type",
            "le64_to_cpu(dqblk->dqb_id)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_dqblk_block_off",
          "args": [
            "sb",
            "chunk",
            "bit"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "62-67",
          "snippet": "static unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "lqinode",
            "ol_dqblk_block(sb, chunk, bit)",
            "&qbh"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "rchunk->rc_bitmap",
            "ol_chunk_entries(sb)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_chunk_entries",
          "args": [
            "sb"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "43-46",
          "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "chunk"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rchunk",
            "next",
            "&(rec->r_list[type])",
            "rc_list"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recover_local_quota_file",
          "args": [
            "(unsigned long)lqinode->i_ino",
            "type"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqinfo",
          "args": [
            "sb",
            "type"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_local_quota_file(struct inode *lqinode,\n\t\t\t\t\t  int type,\n\t\t\t\t\t  struct ocfs2_quota_recovery *rec)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct ocfs2_mem_dqinfo *oinfo = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tstruct ocfs2_local_disk_dqblk *dqblk;\n\tstruct dquot *dquot;\n\thandle_t *handle;\n\tstruct buffer_head *hbh = NULL, *qbh = NULL;\n\tint status = 0;\n\tint bit, chunk;\n\tstruct ocfs2_recovery_chunk *rchunk, *next;\n\tqsize_t spacechange, inodechange;\n\n\ttrace_ocfs2_recover_local_quota_file((unsigned long)lqinode->i_ino, type);\n\n\tlist_for_each_entry_safe(rchunk, next, &(rec->r_list[type]), rc_list) {\n\t\tchunk = rchunk->rc_chunk;\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, chunk),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tfor_each_set_bit(bit, rchunk->rc_bitmap, ol_chunk_entries(sb)) {\n\t\t\tqbh = NULL;\n\t\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_dqblk_block(sb, chunk, bit),\n\t\t\t\t\t\t&qbh);\n\t\t\tif (status) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdqblk = (struct ocfs2_local_disk_dqblk *)(qbh->b_data +\n\t\t\t\tol_dqblk_block_off(sb, chunk, bit));\n\t\t\tdquot = dqget(sb,\n\t\t\t\t      make_kqid(&init_user_ns, type,\n\t\t\t\t\t\tle64_to_cpu(dqblk->dqb_id)));\n\t\t\tif (!dquot) {\n\t\t\t\tstatus = -EIO;\n\t\t\t\tmlog(ML_ERROR, \"Failed to get quota structure \"\n\t\t\t\t     \"for id %u, type %d. Cannot finish quota \"\n\t\t\t\t     \"file recovery.\\n\",\n\t\t\t\t     (unsigned)le64_to_cpu(dqblk->dqb_id),\n\t\t\t\t     type);\n\t\t\t\tgoto out_put_bh;\n\t\t\t}\n\t\t\tstatus = ocfs2_lock_global_qf(oinfo, 1);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_put_dquot;\n\t\t\t}\n\n\t\t\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t\t\t   OCFS2_QSYNC_CREDITS);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tstatus = PTR_ERR(handle);\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_drop_lock;\n\t\t\t}\n\t\t\tmutex_lock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tspin_lock(&dq_data_lock);\n\t\t\t/* Add usage from quota entry into quota changes\n\t\t\t * of our node. Auxiliary variables are important\n\t\t\t * due to signedness */\n\t\t\tspacechange = le64_to_cpu(dqblk->dqb_spacemod);\n\t\t\tinodechange = le64_to_cpu(dqblk->dqb_inodemod);\n\t\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\t\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t\t\tspin_unlock(&dq_data_lock);\n\t\t\t/* We want to drop reference held by the crashed\n\t\t\t * node. Since we have our own reference we know\n\t\t\t * global structure actually won't be freed. */\n\t\t\tstatus = ocfs2_global_release_dquot(dquot);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\t/* Release local quota file entry */\n\t\t\tstatus = ocfs2_journal_access_dq(handle,\n\t\t\t\t\tINODE_CACHE(lqinode),\n\t\t\t\t\tqbh, OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tlock_buffer(qbh);\n\t\t\tWARN_ON(!ocfs2_test_bit_unaligned(bit, dchunk->dqc_bitmap));\n\t\t\tocfs2_clear_bit_unaligned(bit, dchunk->dqc_bitmap);\n\t\t\tle32_add_cpu(&dchunk->dqc_free, 1);\n\t\t\tunlock_buffer(qbh);\n\t\t\tocfs2_journal_dirty(handle, qbh);\nout_commit:\n\t\t\tmutex_unlock(&sb_dqopt(sb)->dqio_mutex);\n\t\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\nout_drop_lock:\n\t\t\tocfs2_unlock_global_qf(oinfo, 1);\nout_put_dquot:\n\t\t\tdqput(dquot);\nout_put_bh:\n\t\t\tbrelse(qbh);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbrelse(hbh);\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_begin_quota_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "385-453",
    "snippet": "struct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\n\t\t\t\t\t\tstruct ocfs2_super *osb,\n\t\t\t\t\t\tint slot_num)\n{\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct inode *lqinode;\n\tstruct buffer_head *bh;\n\tint type;\n\tint status = 0;\n\tstruct ocfs2_quota_recovery *rec;\n\n\tprintk(KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\trec = ocfs2_alloc_quota_recovery();\n\tif (!rec)\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* First init... */\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\t/* At this point, journal of the slot is already replayed so\n\t\t * we can trust metadata and data of the quota file */\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t       OCFS2_META_LOCK_RECOVERY);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n\t\t\t\t\t\t   &rec->r_list[type]);\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tif (status < 0) {\n\t\tocfs2_free_quota_recovery(rec);\n\t\trec = ERR_PTR(status);\n\t}\n\treturn rec;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_quota_recovery",
          "args": [
            "rec"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "329-336",
          "snippet": "void ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "lqinode"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "lqinode",
            "1"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_load_quota",
          "args": [
            "lqinode",
            "ldinfo",
            "type",
            "&rec->r_list[type]"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_load_quota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "339-369",
          "snippet": "static int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\"",
            "slot_num",
            "type"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "lqinode",
            "0",
            "&bh"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "lqinode",
            "NULL",
            "1",
            "OCFS2_META_LOCK_RECOVERY"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ino[type]",
            "slot_num"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "feature[type]"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_alloc_quota_recovery",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_alloc_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "371-382",
          "snippet": "static struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\"",
            "osb->dev_str",
            "slot_num"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\n\t\t\t\t\t\tstruct ocfs2_super *osb,\n\t\t\t\t\t\tint slot_num)\n{\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct inode *lqinode;\n\tstruct buffer_head *bh;\n\tint type;\n\tint status = 0;\n\tstruct ocfs2_quota_recovery *rec;\n\n\tprintk(KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\trec = ocfs2_alloc_quota_recovery();\n\tif (!rec)\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* First init... */\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\t/* At this point, journal of the slot is already replayed so\n\t\t * we can trust metadata and data of the quota file */\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t       OCFS2_META_LOCK_RECOVERY);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n\t\t\t\t\t\t   &rec->r_list[type]);\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tif (status < 0) {\n\t\tocfs2_free_quota_recovery(rec);\n\t\trec = ERR_PTR(status);\n\t}\n\treturn rec;\n}"
  },
  {
    "function_name": "ocfs2_alloc_quota_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "371-382",
    "snippet": "static struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&(rec->r_list[type])"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ocfs2_quota_recovery)",
            "GFP_NOFS"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_quota_recovery *ocfs2_alloc_quota_recovery(void)\n{\n\tint type;\n\tstruct ocfs2_quota_recovery *rec;\n\n\trec = kmalloc(sizeof(struct ocfs2_quota_recovery), GFP_NOFS);\n\tif (!rec)\n\t\treturn NULL;\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tINIT_LIST_HEAD(&(rec->r_list[type]));\n\treturn rec;\n}"
  },
  {
    "function_name": "ocfs2_recovery_load_quota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "339-369",
    "snippet": "static int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_recovery_list",
          "args": [
            "head"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "free_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "317-327",
          "snippet": "static void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "hbh"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_add_recovery_chunk",
          "args": [
            "sb",
            "dchunk",
            "i",
            "head"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_recovery_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "295-315",
          "snippet": "static int ocfs2_add_recovery_chunk(struct super_block *sb,\n\t\t\t\t    struct ocfs2_local_disk_chunk *dchunk,\n\t\t\t\t    int chunk,\n\t\t\t\t    struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *rc;\n\n\trc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\trc->rc_chunk = chunk;\n\trc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!rc->rc_bitmap) {\n\t\tkfree(rc);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\n\t       (ol_chunk_entries(sb) + 7) >> 3);\n\tlist_add_tail(&rc->rc_list, head);\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_add_recovery_chunk(struct super_block *sb,\n\t\t\t\t    struct ocfs2_local_disk_chunk *dchunk,\n\t\t\t\t    int chunk,\n\t\t\t\t    struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *rc;\n\n\trc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\trc->rc_chunk = chunk;\n\trc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!rc->rc_bitmap) {\n\t\tkfree(rc);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\n\t       (ol_chunk_entries(sb) + 7) >> 3);\n\tlist_add_tail(&rc->rc_list, head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_chunk_entries",
          "args": [
            "sb"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "43-46",
          "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dchunk->dqc_free"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "lqinode",
            "ol_quota_chunk_block(sb, i)",
            "&hbh"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "i"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recovery_load_quota(struct inode *lqinode,\n\t\t\t\t     struct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\t\t     int type,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct super_block *sb = lqinode->i_sb;\n\tstruct buffer_head *hbh;\n\tstruct ocfs2_local_disk_chunk *dchunk;\n\tint i, chunks = le32_to_cpu(ldinfo->dqi_chunks);\n\tint status = 0;\n\n\tfor (i = 0; i < chunks; i++) {\n\t\thbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode,\n\t\t\t\t\t\tol_quota_chunk_block(sb, i),\n\t\t\t\t\t\t&hbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tbreak;\n\t\t}\n\t\tdchunk = (struct ocfs2_local_disk_chunk *)hbh->b_data;\n\t\tif (le32_to_cpu(dchunk->dqc_free) < ol_chunk_entries(sb))\n\t\t\tstatus = ocfs2_add_recovery_chunk(sb, dchunk, i, head);\n\t\tbrelse(hbh);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\tif (status < 0)\n\t\tfree_recovery_list(head);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_free_quota_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "329-336",
    "snippet": "void ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rec"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_recovery_list",
          "args": [
            "&(rec->r_list[type])"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "free_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "317-327",
          "snippet": "static void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}"
  },
  {
    "function_name": "free_recovery_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "317-327",
    "snippet": "static void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rchunk"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rchunk->rc_bitmap"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rchunk->rc_list"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rchunk",
            "next",
            "head",
            "rc_list"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void free_recovery_list(struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *next;\n\tstruct ocfs2_recovery_chunk *rchunk;\n\n\tlist_for_each_entry_safe(rchunk, next, head, rc_list) {\n\t\tlist_del(&rchunk->rc_list);\n\t\tkfree(rchunk->rc_bitmap);\n\t\tkfree(rchunk);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_add_recovery_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "295-315",
    "snippet": "static int ocfs2_add_recovery_chunk(struct super_block *sb,\n\t\t\t\t    struct ocfs2_local_disk_chunk *dchunk,\n\t\t\t\t    int chunk,\n\t\t\t\t    struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *rc;\n\n\trc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\trc->rc_chunk = chunk;\n\trc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!rc->rc_bitmap) {\n\t\tkfree(rc);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\n\t       (ol_chunk_entries(sb) + 7) >> 3);\n\tlist_add_tail(&rc->rc_list, head);\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rc->rc_list",
            "head"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rc->rc_bitmap",
            "dchunk->dqc_bitmap",
            "(ol_chunk_entries(sb) + 7) >> 3"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ol_chunk_entries",
          "args": [
            "sb"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "43-46",
          "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rc"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_add_recovery_chunk(struct super_block *sb,\n\t\t\t\t    struct ocfs2_local_disk_chunk *dchunk,\n\t\t\t\t    int chunk,\n\t\t\t\t    struct list_head *head)\n{\n\tstruct ocfs2_recovery_chunk *rc;\n\n\trc = kmalloc(sizeof(struct ocfs2_recovery_chunk), GFP_NOFS);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\trc->rc_chunk = chunk;\n\trc->rc_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!rc->rc_bitmap) {\n\t\tkfree(rc);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(rc->rc_bitmap, dchunk->dqc_bitmap,\n\t       (ol_chunk_entries(sb) + 7) >> 3);\n\tlist_add_tail(&rc->rc_list, head);\n\treturn 0;\n}"
  },
  {
    "function_name": "olq_update_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "280-293",
    "snippet": "static void olq_update_info(struct buffer_head *bh, void *private)\n{\n\tstruct mem_dqinfo *info = private;\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\tspin_lock(&dq_data_lock);\n\tldinfo->dqi_flags = cpu_to_le32(oinfo->dqi_flags);\n\tldinfo->dqi_chunks = cpu_to_le32(oinfo->dqi_chunks);\n\tldinfo->dqi_blocks = cpu_to_le32(oinfo->dqi_blocks);\n\tspin_unlock(&dq_data_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_blocks"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_chunks"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "oinfo->dqi_flags"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dq_data_lock"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void olq_update_info(struct buffer_head *bh, void *private)\n{\n\tstruct mem_dqinfo *info = private;\n\tstruct ocfs2_mem_dqinfo *oinfo = info->dqi_priv;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\n\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\tspin_lock(&dq_data_lock);\n\tldinfo->dqi_flags = cpu_to_le32(oinfo->dqi_flags);\n\tldinfo->dqi_chunks = cpu_to_le32(oinfo->dqi_chunks);\n\tldinfo->dqi_blocks = cpu_to_le32(oinfo->dqi_blocks);\n\tspin_unlock(&dq_data_lock);\n}"
  },
  {
    "function_name": "ocfs2_load_local_quota_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "250-278",
    "snippet": "static int ocfs2_load_local_quota_bitmaps(struct inode *inode,\n\t\t\tstruct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\tstruct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *newchunk;\n\tint i, status;\n\n\tINIT_LIST_HEAD(head);\n\tfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\n\t\tnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\t\tif (!newchunk) {\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnewchunk->qc_num = i;\n\t\tnewchunk->qc_headerbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(inode,\n\t\t\t\tol_quota_chunk_block(inode->i_sb, i),\n\t\t\t\t&newchunk->qc_headerbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn status;\n\t\t}\n\t\tlist_add_tail(&newchunk->qc_chunk, head);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&newchunk->qc_chunk",
            "head"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_release_local_quota_bitmaps",
          "args": [
            "head"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_local_quota_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "238-247",
          "snippet": "static void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ocfs2_qf_chunk_cachep",
            "newchunk"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "inode",
            "ol_quota_chunk_block(inode->i_sb, i)",
            "&newchunk->qc_headerbh"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "inode->i_sb",
            "i"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ocfs2_qf_chunk_cachep",
            "GFP_NOFS"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldinfo->dqi_chunks"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_load_local_quota_bitmaps(struct inode *inode,\n\t\t\tstruct ocfs2_local_disk_dqinfo *ldinfo,\n\t\t\tstruct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *newchunk;\n\tint i, status;\n\n\tINIT_LIST_HEAD(head);\n\tfor (i = 0; i < le32_to_cpu(ldinfo->dqi_chunks); i++) {\n\t\tnewchunk = kmem_cache_alloc(ocfs2_qf_chunk_cachep, GFP_NOFS);\n\t\tif (!newchunk) {\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnewchunk->qc_num = i;\n\t\tnewchunk->qc_headerbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(inode,\n\t\t\t\tol_quota_chunk_block(inode->i_sb, i),\n\t\t\t\t&newchunk->qc_headerbh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, newchunk);\n\t\t\tocfs2_release_local_quota_bitmaps(head);\n\t\t\treturn status;\n\t\t}\n\t\tlist_add_tail(&newchunk->qc_chunk, head);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_release_local_quota_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "238-247",
    "snippet": "static void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ocfs2_qf_chunk_cachep",
            "pos"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "pos->qc_headerbh"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pos->qc_chunk"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pos",
            "next",
            "head",
            "qc_chunk"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_release_local_quota_bitmaps(struct list_head *head)\n{\n\tstruct ocfs2_quota_chunk *pos, *next;\n\n\tlist_for_each_entry_safe(pos, next, head, qc_chunk) {\n\t\tlist_del(&pos->qc_chunk);\n\t\tbrelse(pos->qc_headerbh);\n\t\tkmem_cache_free(ocfs2_qf_chunk_cachep, pos);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_local_check_quota_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "161-235",
    "snippet": "static int ocfs2_local_check_quota_file(struct super_block *sb, int type)\n{\n\tunsigned int lmagics[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QMAGICS;\n\tunsigned int lversions[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QVERSIONS;\n\tunsigned int gmagics[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QMAGICS;\n\tunsigned int gversions[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QVERSIONS;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *linode = sb_dqopt(sb)->files[type];\n\tstruct inode *ginode = NULL;\n\tstruct ocfs2_disk_dqheader *dqhead;\n\tint status, ret = 0;\n\n\t/* First check whether we understand local quota file */\n\tstatus = ocfs2_read_quota_block(linode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file header (type=%d)\\n\",\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != lmagics[type]) {\n\t\tmlog(ML_ERROR, \"quota file magic does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_magic),\n\t\t\tlmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != lversions[type]) {\n\t\tmlog(ML_ERROR, \"quota file version does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_version),\n\t\t\tlversions[type], type);\n\t\tgoto out_err;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/* Next check whether we understand global quota file */\n\tginode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\tif (!ginode) {\n\t\tmlog(ML_ERROR, \"cannot get global quota file inode \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\t/* Since the header is read only, we don't care about locking */\n\tstatus = ocfs2_read_quota_block(ginode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read global quota file header \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != gmagics[type]) {\n\t\tmlog(ML_ERROR, \"global quota file magic does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_magic), gmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != gversions[type]) {\n\t\tmlog(ML_ERROR, \"global quota file version does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_version), gversions[type],\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\n\tret = 1;\nout_err:\n\tbrelse(bh);\n\tiput(ginode);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ginode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"global quota file version does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\"",
            "le32_to_cpu(dqhead->dqh_version)",
            "gversions[type]",
            "type"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dqhead->dqh_version"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"global quota file magic does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\"",
            "le32_to_cpu(dqhead->dqh_magic)",
            "gmagics[type]",
            "type"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"failed to read global quota file header \"\n\t\t\t\t\"(type=%d)\\n\"",
            "type"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_quota_block",
          "args": [
            "ginode",
            "0",
            "&bh"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_quota_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "133-158",
          "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "OCFS2_SB(sb)",
            "ino[type]",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"quota file version does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\"",
            "le32_to_cpu(dqhead->dqh_version)",
            "lversions[type]",
            "type"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"quota file magic does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\"",
            "le32_to_cpu(dqhead->dqh_magic)",
            "lmagics[type]",
            "type"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_check_quota_file(struct super_block *sb, int type)\n{\n\tunsigned int lmagics[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QMAGICS;\n\tunsigned int lversions[OCFS2_MAXQUOTAS] = OCFS2_LOCAL_QVERSIONS;\n\tunsigned int gmagics[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QMAGICS;\n\tunsigned int gversions[OCFS2_MAXQUOTAS] = OCFS2_GLOBAL_QVERSIONS;\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      GROUP_QUOTA_SYSTEM_INODE };\n\tstruct buffer_head *bh = NULL;\n\tstruct inode *linode = sb_dqopt(sb)->files[type];\n\tstruct inode *ginode = NULL;\n\tstruct ocfs2_disk_dqheader *dqhead;\n\tint status, ret = 0;\n\n\t/* First check whether we understand local quota file */\n\tstatus = ocfs2_read_quota_block(linode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read quota file header (type=%d)\\n\",\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != lmagics[type]) {\n\t\tmlog(ML_ERROR, \"quota file magic does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_magic),\n\t\t\tlmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != lversions[type]) {\n\t\tmlog(ML_ERROR, \"quota file version does not match (%u != %u),\"\n\t\t\t\" type=%d\\n\", le32_to_cpu(dqhead->dqh_version),\n\t\t\tlversions[type], type);\n\t\tgoto out_err;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/* Next check whether we understand global quota file */\n\tginode = ocfs2_get_system_file_inode(OCFS2_SB(sb), ino[type],\n\t\t\t\t\t\tOCFS2_INVALID_SLOT);\n\tif (!ginode) {\n\t\tmlog(ML_ERROR, \"cannot get global quota file inode \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\t/* Since the header is read only, we don't care about locking */\n\tstatus = ocfs2_read_quota_block(ginode, 0, &bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tmlog(ML_ERROR, \"failed to read global quota file header \"\n\t\t\t\t\"(type=%d)\\n\", type);\n\t\tgoto out_err;\n\t}\n\tdqhead = (struct ocfs2_disk_dqheader *)(bh->b_data);\n\tif (le32_to_cpu(dqhead->dqh_magic) != gmagics[type]) {\n\t\tmlog(ML_ERROR, \"global quota file magic does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_magic), gmagics[type], type);\n\t\tgoto out_err;\n\t}\n\tif (le32_to_cpu(dqhead->dqh_version) != gversions[type]) {\n\t\tmlog(ML_ERROR, \"global quota file version does not match \"\n\t\t\t\"(%u != %u), type=%d\\n\",\n\t\t\tle32_to_cpu(dqhead->dqh_version), gversions[type],\n\t\t\ttype);\n\t\tgoto out_err;\n\t}\n\n\tret = 1;\nout_err:\n\tbrelse(bh);\n\tiput(ginode);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_read_quota_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "133-158",
    "snippet": "static int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_virt_blocks",
          "args": [
            "inode",
            "v_block",
            "1",
            "&tmp",
            "0",
            "ocfs2_validate_quota_block"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_virt_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "927-992",
          "snippet": "int ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_read_virt_blocks(struct inode *inode, u64 v_block, int nr,\n\t\t\t   struct buffer_head *bhs[], int flags,\n\t\t\t   int (*validate)(struct super_block *sb,\n\t\t\t\t\t   struct buffer_head *bh))\n{\n\tint rc = 0;\n\tu64 p_block, p_count;\n\tint i, count, done = 0;\n\n\ttrace_ocfs2_read_virt_blocks(\n\t     inode, (unsigned long long)v_block, nr, bhs, flags,\n\t     validate);\n\n\tif (((v_block + nr - 1) << inode->i_sb->s_blocksize_bits) >=\n\t    i_size_read(inode)) {\n\t\tBUG_ON(!(flags & OCFS2_BH_READAHEAD));\n\t\tgoto out;\n\t}\n\n\twhile (done < nr) {\n\t\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\trc = ocfs2_extent_map_get_blocks(inode, v_block + done,\n\t\t\t\t\t\t &p_block, &p_count, NULL);\n\t\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!p_block) {\n\t\t\trc = -EIO;\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Inode #%llu contains a hole at offset %llu\\n\",\n\t\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t     (unsigned long long)(v_block + done) <<\n\t\t\t     inode->i_sb->s_blocksize_bits);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = nr - done;\n\t\tif (p_count < count)\n\t\t\tcount = p_count;\n\n\t\t/*\n\t\t * If the caller passed us bhs, they should have come\n\t\t * from a previous readahead call to this function.  Thus,\n\t\t * they should have the right b_blocknr.\n\t\t */\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (!bhs[done + i])\n\t\t\t\tcontinue;\n\t\t\tBUG_ON(bhs[done + i]->b_blocknr != (p_block + i));\n\t\t}\n\n\t\trc = ocfs2_read_blocks(INODE_CACHE(inode), p_block, count,\n\t\t\t\t       bhs + done, flags, validate);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tdone += count;\n\t}\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)v_block",
            "(unsigned long long)i_size_read(inode)"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_quota_block(struct inode *inode, u64 v_block,\n\t\t\t\t  struct buffer_head **bh)\n{\n\tint rc = 0;\n\tstruct buffer_head *tmp = *bh;\n\n\tif (i_size_read(inode) >> inode->i_sb->s_blocksize_bits <= v_block) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Quota file %llu is probably corrupted! Requested \"\n\t\t\t    \"to read block %Lu but file has size only %Lu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)v_block,\n\t\t\t    (unsigned long long)i_size_read(inode));\n\t\treturn -EIO;\n\t}\n\trc = ocfs2_read_virt_blocks(inode, v_block, 1, &tmp, 0,\n\t\t\t\t    ocfs2_validate_quota_block);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\t/* If ocfs2_read_virt_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_modify_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "93-125",
    "snippet": "static int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(sb)",
            "handle"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify",
          "args": [
            "bh",
            "private"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_dq",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_dq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "747-751",
          "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(sb)",
            "OCFS2_QUOTA_BLOCK_UPDATE_CREDITS"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_modify_bh(struct inode *inode, struct buffer_head *bh,\n\t\tvoid (*modify)(struct buffer_head *, void *), void *private)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tint status;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(sb),\n\t\t\t\t   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tocfs2_commit_trans(OCFS2_SB(sb), handle);\n\t\treturn status;\n\t}\n\tlock_buffer(bh);\n\tmodify(bh, private);\n\tunlock_buffer(bh);\n\tocfs2_journal_dirty(handle, bh);\n\n\tstatus = ocfs2_commit_trans(OCFS2_SB(sb), handle);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ol_dqblk_chunk_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "82-90",
    "snippet": "static int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ((off >> sb->s_blocksize_bits) -\n\t\t\tol_quota_chunk_block(sb, c) - 1) * epb\n\t       + ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\n\t\t sizeof(struct ocfs2_local_disk_dqblk);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "c"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ol_dqblk_chunk_off(struct super_block *sb, int c, loff_t off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ((off >> sb->s_blocksize_bits) -\n\t\t\tol_quota_chunk_block(sb, c) - 1) * epb\n\t       + ((unsigned int)(off & ((1 << sb->s_blocksize_bits) - 1))) /\n\t\t sizeof(struct ocfs2_local_disk_dqblk);\n}"
  },
  {
    "function_name": "ol_dqblk_block_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "76-79",
    "snippet": "static inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\n{\n\treturn off & ((1 << sb->s_blocksize_bits) - 1);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)\n{\n\treturn off & ((1 << sb->s_blocksize_bits) - 1);\n}"
  },
  {
    "function_name": "ol_dqblk_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "70-74",
    "snippet": "static loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\n{\n\treturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\n\t       ol_dqblk_block_off(sb, c, off);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_dqblk_block_off",
          "args": [
            "sb",
            "c",
            "off"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ol_dqblk_block_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "62-67",
          "snippet": "static unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic loff_t ol_dqblk_off(struct super_block *sb, int c, int off)\n{\n\treturn (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +\n\t       ol_dqblk_block_off(sb, c, off);\n}"
  },
  {
    "function_name": "ol_dqblk_block_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "62-67",
    "snippet": "static unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_dqblk_block_off(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn (off % epb) * sizeof(struct ocfs2_local_disk_dqblk);\n}"
  },
  {
    "function_name": "ol_dqblk_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "55-60",
    "snippet": "static unsigned int ol_dqblk_block(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ol_quota_chunk_block(sb, c) + 1 + off / epb;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_quota_chunk_block",
          "args": [
            "sb",
            "c"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_chunk_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "49-53",
          "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_dqblk_block(struct super_block *sb, int c, int off)\n{\n\tint epb = ol_quota_entries_per_block(sb);\n\n\treturn ol_quota_chunk_block(sb, c) + 1 + off / epb;\n}"
  },
  {
    "function_name": "ol_quota_chunk_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "49-53",
    "snippet": "static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_chunk_blocks",
          "args": [
            "sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "35-40",
          "snippet": "static inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_quota_chunk_block(struct super_block *sb, int c)\n{\n\t/* 1 block for local quota file info, 1 block per chunk for chunk info */\n\treturn 1 + (ol_chunk_blocks(sb) + 1) * c;\n}"
  },
  {
    "function_name": "ol_chunk_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "43-46",
    "snippet": "static unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ol_chunk_blocks",
          "args": [
            "sb"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ol_chunk_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "35-40",
          "snippet": "static inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int ol_chunk_entries(struct super_block *sb)\n{\n\treturn ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);\n}"
  },
  {
    "function_name": "ol_chunk_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "35-40",
    "snippet": "static inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ol_quota_entries_per_block",
          "args": [
            "sb"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ol_quota_entries_per_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "28-32",
          "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_chunk_blocks(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -\n\t\t OCFS2_QBLK_RESERVED_SPACE) << 3) /\n\t       ol_quota_entries_per_block(sb);\n}"
  },
  {
    "function_name": "ol_quota_entries_per_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
    "lines": "28-32",
    "snippet": "static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"quota.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"journal.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"file.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include \"ocfs2_fs.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/module.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int ol_quota_entries_per_block(struct super_block *sb)\n{\n\treturn ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /\n\t\tsizeof(struct ocfs2_local_disk_dqblk));\n}"
  }
]