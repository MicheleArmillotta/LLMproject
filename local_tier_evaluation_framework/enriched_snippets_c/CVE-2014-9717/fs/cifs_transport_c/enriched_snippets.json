[
  {
    "function_name": "SendReceiveBlockingLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "969-1113",
    "snippet": "int\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_delete_mid",
          "args": [
            "midQ"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_delete_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "114-122",
          "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_check_receive",
          "args": [
            "midQ",
            "ses->server",
            "0"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_check_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "658-685",
          "snippet": "int\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out_buf",
            "midQ->resp_buf",
            "*pbytes_returned + 4"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "midQ->resp_buf"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Bad MID state?\\n\""
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sync_mid_result",
          "args": [
            "midQ",
            "ses->server"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sync_mid_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "617-649",
          "snippet": "static int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cancel",
          "args": [
            "ses->server",
            "in_buf",
            "midQ"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "651-656",
          "snippet": "static inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_response",
          "args": [
            "ses->server",
            "midQ"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "495-506",
          "snippet": "static int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_lock_cancel",
          "args": [
            "xid",
            "tcon",
            "in_buf",
            "out_buf"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "send_lock_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "947-967",
          "snippet": "static int\nsend_lock_cancel(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf)\n{\n\tint bytes_returned;\n\tstruct cifs_ses *ses = tcon->ses;\n\tLOCK_REQ *pSMB = (LOCK_REQ *)in_buf;\n\n\t/* We just modify the current in_buf to change\n\t   the type of lock from LOCKING_ANDX_SHARED_LOCK\n\t   or LOCKING_ANDX_EXCLUSIVE_LOCK to\n\t   LOCKING_ANDX_CANCEL_LOCK. */\n\n\tpSMB->LockType = LOCKING_ANDX_CANCEL_LOCK|LOCKING_ANDX_LARGE_FILES;\n\tpSMB->Timeout = 0;\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\treturn SendReceive(xid, ses, in_buf, out_buf,\n\t\t\t&bytes_returned, 0);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsend_lock_cancel(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf)\n{\n\tint bytes_returned;\n\tstruct cifs_ses *ses = tcon->ses;\n\tLOCK_REQ *pSMB = (LOCK_REQ *)in_buf;\n\n\t/* We just modify the current in_buf to change\n\t   the type of lock from LOCKING_ANDX_SHARED_LOCK\n\t   or LOCKING_ANDX_EXCLUSIVE_LOCK to\n\t   LOCKING_ANDX_CANCEL_LOCK. */\n\n\tpSMB->LockType = LOCKING_ANDX_CANCEL_LOCK|LOCKING_ANDX_LARGE_FILES;\n\tpSMB->Timeout = 0;\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\treturn SendReceive(xid, ses, in_buf, out_buf,\n\t\t\t&bytes_returned, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ses->server->response_q",
            "(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew))"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_save_when_sent",
          "args": [
            "midQ"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_when_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1321-1323",
          "snippet": "static inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_dec",
          "args": [
            "ses->server"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1309-1311",
          "snippet": "static inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_send",
          "args": [
            "ses->server",
            "in_buf",
            "be32_to_cpu(in_buf->smb_buf_length)"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "378-388",
          "snippet": "int\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_in_send_inc",
          "args": [
            "ses->server"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1306-1308",
          "snippet": "static inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sign_smb",
          "args": [
            "in_buf",
            "ses->server",
            "&midQ->sequence_number"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "194-204",
          "snippet": "int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_mid",
          "args": [
            "ses",
            "in_buf",
            "&midQ"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "460-493",
          "snippet": "static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_free_request",
          "args": [
            "ses->server",
            "CIFS_BLOCKING_OP",
            "0"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_free_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "438-449",
          "snippet": "static int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal length, greater than maximum frame, %d\\n\"",
            "be32_to_cpu(in_buf->smb_buf_length)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null tcp session\\n\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null smb session\\n\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveBlockingLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned)\n{\n\tint rc = 0;\n\tint rstart = 0;\n\tstruct mid_q_entry *midQ;\n\tstruct cifs_ses *ses;\n\n\tif (tcon == NULL || tcon->ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tses = tcon->ses;\n\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, CIFS_BLOCKING_OP, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(midQ);\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_delete_mid(midQ);\n\t\treturn rc;\n\t}\n\n\t/* Wait for a reply - allow signals to interrupt. */\n\trc = wait_event_interruptible(ses->server->response_q,\n\t\t(!(midQ->mid_state == MID_REQUEST_SUBMITTED)) ||\n\t\t((ses->server->tcpStatus != CifsGood) &&\n\t\t (ses->server->tcpStatus != CifsNew)));\n\n\t/* Were we interrupted by a signal ? */\n\tif ((rc == -ERESTARTSYS) &&\n\t\t(midQ->mid_state == MID_REQUEST_SUBMITTED) &&\n\t\t((ses->server->tcpStatus == CifsGood) ||\n\t\t (ses->server->tcpStatus == CifsNew))) {\n\n\t\tif (in_buf->Command == SMB_COM_TRANSACTION2) {\n\t\t\t/* POSIX lock. We send a NT_CANCEL SMB to cause the\n\t\t\t   blocking lock to return. */\n\t\t\trc = send_cancel(ses->server, in_buf, midQ);\n\t\t\tif (rc) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Windows lock. We send a LOCKINGX_CANCEL_LOCK\n\t\t\t   to cause the blocking lock to return. */\n\n\t\t\trc = send_lock_cancel(xid, tcon, in_buf, out_buf);\n\n\t\t\t/* If we get -ENOLCK back the lock may have\n\t\t\t   already been removed. Don't exit in this case. */\n\t\t\tif (rc && rc != -ENOLCK) {\n\t\t\t\tcifs_delete_mid(midQ);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\trc = wait_for_response(ses->server, midQ);\n\t\tif (rc) {\n\t\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\n\t\t/* We got the response - restart system call. */\n\t\trstart = 1;\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* rcvd frame is ok */\n\tif (out_buf == NULL || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tif (rstart && rc == -EACCES)\n\t\treturn -ERESTARTSYS;\n\treturn rc;\n}"
  },
  {
    "function_name": "send_lock_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "947-967",
    "snippet": "static int\nsend_lock_cancel(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf)\n{\n\tint bytes_returned;\n\tstruct cifs_ses *ses = tcon->ses;\n\tLOCK_REQ *pSMB = (LOCK_REQ *)in_buf;\n\n\t/* We just modify the current in_buf to change\n\t   the type of lock from LOCKING_ANDX_SHARED_LOCK\n\t   or LOCKING_ANDX_EXCLUSIVE_LOCK to\n\t   LOCKING_ANDX_CANCEL_LOCK. */\n\n\tpSMB->LockType = LOCKING_ANDX_CANCEL_LOCK|LOCKING_ANDX_LARGE_FILES;\n\tpSMB->Timeout = 0;\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\treturn SendReceive(xid, ses, in_buf, out_buf,\n\t\t\t&bytes_returned, 0);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendReceive",
          "args": [
            "xid",
            "ses",
            "in_buf",
            "out_buf",
            "&bytes_returned",
            "0"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "834-942",
          "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_mid",
          "args": [
            "ses->server"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_next_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "169-234",
          "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsend_lock_cancel(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct smb_hdr *in_buf,\n\t\t\tstruct smb_hdr *out_buf)\n{\n\tint bytes_returned;\n\tstruct cifs_ses *ses = tcon->ses;\n\tLOCK_REQ *pSMB = (LOCK_REQ *)in_buf;\n\n\t/* We just modify the current in_buf to change\n\t   the type of lock from LOCKING_ANDX_SHARED_LOCK\n\t   or LOCKING_ANDX_EXCLUSIVE_LOCK to\n\t   LOCKING_ANDX_CANCEL_LOCK. */\n\n\tpSMB->LockType = LOCKING_ANDX_CANCEL_LOCK|LOCKING_ANDX_LARGE_FILES;\n\tpSMB->Timeout = 0;\n\tpSMB->hdr.Mid = get_next_mid(ses->server);\n\n\treturn SendReceive(xid, ses, in_buf, out_buf,\n\t\t\t&bytes_returned, 0);\n}"
  },
  {
    "function_name": "SendReceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "834-942",
    "snippet": "int\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "ses->server",
            "1",
            "0"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_delete_mid",
          "args": [
            "midQ"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_delete_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "114-122",
          "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_check_receive",
          "args": [
            "midQ",
            "ses->server",
            "0"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_check_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "658-685",
          "snippet": "int\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out_buf",
            "midQ->resp_buf",
            "*pbytes_returned + 4"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "midQ->resp_buf"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Bad MID state?\\n\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sync_mid_result",
          "args": [
            "midQ",
            "ses->server"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sync_mid_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "617-649",
          "snippet": "static int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cancel",
          "args": [
            "ses->server",
            "in_buf",
            "midQ"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "651-656",
          "snippet": "static inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_response",
          "args": [
            "ses->server",
            "midQ"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "495-506",
          "snippet": "static int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_save_when_sent",
          "args": [
            "midQ"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_when_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1321-1323",
          "snippet": "static inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_dec",
          "args": [
            "ses->server"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1309-1311",
          "snippet": "static inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_send",
          "args": [
            "ses->server",
            "in_buf",
            "be32_to_cpu(in_buf->smb_buf_length)"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "378-388",
          "snippet": "int\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_in_send_inc",
          "args": [
            "ses->server"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1306-1308",
          "snippet": "static inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sign_smb",
          "args": [
            "in_buf",
            "ses->server",
            "&midQ->sequence_number"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "194-204",
          "snippet": "int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_mid",
          "args": [
            "ses",
            "in_buf",
            "&midQ"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "460-493",
          "snippet": "static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_free_request",
          "args": [
            "ses->server",
            "timeout",
            "0"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_free_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "438-449",
          "snippet": "static int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal length, greater than maximum frame, %d\\n\"",
            "be32_to_cpu(in_buf->smb_buf_length)"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null tcp session\\n\""
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null smb session\\n\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive(const unsigned int xid, struct cifs_ses *ses,\n\t    struct smb_hdr *in_buf, struct smb_hdr *out_buf,\n\t    int *pbytes_returned, const int timeout)\n{\n\tint rc = 0;\n\tstruct mid_q_entry *midQ;\n\n\tif (ses == NULL) {\n\t\tcifs_dbg(VFS, \"Null smb session\\n\");\n\t\treturn -EIO;\n\t}\n\tif (ses->server == NULL) {\n\t\tcifs_dbg(VFS, \"Null tcp session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting)\n\t\treturn -ENOENT;\n\n\t/* Ensure that we do not send more than 50 overlapping requests\n\t   to the same server. We may make this configurable later or\n\t   use ses->maxReq */\n\n\tif (be32_to_cpu(in_buf->smb_buf_length) > CIFSMaxBufSize +\n\t\t\tMAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"Illegal length, greater than maximum frame, %d\\n\",\n\t\t\t be32_to_cpu(in_buf->smb_buf_length));\n\t\treturn -EIO;\n\t}\n\n\trc = wait_for_free_request(ses->server, timeout, 0);\n\tif (rc)\n\t\treturn rc;\n\n\t/* make sure that we sign in the same order that we send on this socket\n\t   and avoid races inside tcp sendmsg code that could cause corruption\n\t   of smb data */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\trc = allocate_mid(ses, in_buf, &midQ);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\trc = cifs_sign_smb(in_buf, ses->server, &midQ->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tgoto out;\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\n\tcifs_in_send_inc(ses->server);\n\trc = smb_send(ses->server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (timeout == CIFS_ASYNC_OP)\n\t\tgoto out;\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, in_buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t/* no longer considered to be \"in-flight\" */\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tadd_credits(ses->server, 1, 0);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, 0);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || !out_buf ||\n\t    midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\t*pbytes_returned = get_rfc1002_length(midQ->resp_buf);\n\tmemcpy(out_buf, midQ->resp_buf, *pbytes_returned + 4);\n\trc = cifs_check_receive(midQ, ses->server, 0);\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, 1, 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "SendReceive2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "705-832",
    "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits",
          "args": [
            "ses->server",
            "credits",
            "optype"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "116-125",
          "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_delete_mid",
          "args": [
            "midQ"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_delete_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "114-122",
          "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ses->server->ops->check_receive",
          "args": [
            "midQ",
            "ses->server",
            "flags & CIFS_LOG_ERROR"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ses->server->ops->get_credits",
          "args": [
            "midQ"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "buf"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Bad MID state?\\n\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sync_mid_result",
          "args": [
            "midQ",
            "ses->server"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sync_mid_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "617-649",
          "snippet": "static int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "buf"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cancel",
          "args": [
            "ses->server",
            "buf",
            "midQ"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "651-656",
          "snippet": "static inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_response",
          "args": [
            "ses->server",
            "midQ"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "495-506",
          "snippet": "static int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_save_when_sent",
          "args": [
            "midQ"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_when_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1321-1323",
          "snippet": "static inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_dec",
          "args": [
            "ses->server"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1309-1311",
          "snippet": "static inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_sendv",
          "args": [
            "ses->server",
            "iov",
            "n_vec"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "smb_sendv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "369-376",
          "snippet": "static int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_inc",
          "args": [
            "ses->server"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1306-1308",
          "snippet": "static inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "midQ"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "midQ"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ses->server->ops->setup_request",
          "args": [
            "ses",
            "&rqst"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ses->server->srv_mutex"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_free_request",
          "args": [
            "ses->server",
            "timeout",
            "optype"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_free_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "438-449",
          "snippet": "static int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null session\\n\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_setup_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "687-703",
    "snippet": "struct mid_q_entry *\ncifs_setup_request(struct cifs_ses *ses, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\trc = allocate_mid(ses, hdr, &mid);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\trc = cifs_sign_rqst(rqst, ses->server, &mid->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn mid;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_delete_mid",
          "args": [
            "mid"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_delete_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "114-122",
          "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sign_rqst",
          "args": [
            "rqst",
            "ses->server",
            "&mid->sequence_number"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "149-182",
          "snippet": "int cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_mid",
          "args": [
            "ses",
            "hdr",
            "&mid"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "460-493",
          "snippet": "static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstruct mid_q_entry *\ncifs_setup_request(struct cifs_ses *ses, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\trc = allocate_mid(ses, hdr, &mid);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\trc = cifs_sign_rqst(rqst, ses->server, &mid->sequence_number);\n\tif (rc) {\n\t\tcifs_delete_mid(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn mid;\n}"
  },
  {
    "function_name": "cifs_check_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "658-685",
    "snippet": "int\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_smb_to_linux_error",
          "args": [
            "mid->resp_buf",
            "log_error"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "map_smb_to_linux_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "827-899",
          "snippet": "int\nmap_smb_to_linux_error(char *buf, bool logErr)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\tunsigned int i;\n\tint rc = -EIO;\t/* if transport error smb error may not be set */\n\t__u8 smberrclass;\n\t__u16 smberrcode;\n\n\t/* BB if NT Status codes - map NT BB */\n\n\t/* old style smb error codes */\n\tif (smb->Status.CifsError == 0)\n\t\treturn 0;\n\n\tif (smb->Flags2 & SMBFLG2_ERR_STATUS) {\n\t\t/* translate the newer STATUS codes to old style SMB errors\n\t\t * and then to POSIX errors */\n\t\t__u32 err = le32_to_cpu(smb->Status.CifsError);\n\t\tif (logErr && (err != (NT_STATUS_MORE_PROCESSING_REQUIRED)))\n\t\t\tcifs_print_status(err);\n\t\telse if (cifsFYI & CIFS_RC)\n\t\t\tcifs_print_status(err);\n\t\tntstatus_to_dos(err, &smberrclass, &smberrcode);\n\t} else {\n\t\tsmberrclass = smb->Status.DosError.ErrorClass;\n\t\tsmberrcode = le16_to_cpu(smb->Status.DosError.Error);\n\t}\n\n\t/* old style errors */\n\n\t/* DOS class smb error codes - map DOS */\n\tif (smberrclass == ERRDOS) {\n\t\t/* 1 byte field no need to byte reverse */\n\t\tfor (i = 0;\n\t\t     i <\n\t\t     sizeof(mapping_table_ERRDOS) /\n\t\t     sizeof(struct smb_to_posix_error); i++) {\n\t\t\tif (mapping_table_ERRDOS[i].smb_err == 0)\n\t\t\t\tbreak;\n\t\t\telse if (mapping_table_ERRDOS[i].smb_err ==\n\t\t\t\t\t\t\t\tsmberrcode) {\n\t\t\t\trc = mapping_table_ERRDOS[i].posix_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else try next error mapping one to see if match */\n\t\t}\n\t} else if (smberrclass == ERRSRV) {\n\t\t/* server class of error codes */\n\t\tfor (i = 0;\n\t\t     i <\n\t\t     sizeof(mapping_table_ERRSRV) /\n\t\t     sizeof(struct smb_to_posix_error); i++) {\n\t\t\tif (mapping_table_ERRSRV[i].smb_err == 0)\n\t\t\t\tbreak;\n\t\t\telse if (mapping_table_ERRSRV[i].smb_err ==\n\t\t\t\t\t\t\t\tsmberrcode) {\n\t\t\t\trc = mapping_table_ERRSRV[i].posix_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else try next error mapping to see if match */\n\t\t}\n\t}\n\t/* else ERRHRD class errors or junk  - return EIO */\n\n\tcifs_dbg(FYI, \"Mapping smb error code 0x%x to POSIX err %d\\n\",\n\t\t le32_to_cpu(smb->Status.CifsError), rc);\n\n\t/* generic corrective action e.g. reconnect SMB session on\n\t * ERRbaduid could be added */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct smb_to_posix_error mapping_table_ERRDOS[] = {\n\t{ERRbadfunc, -EINVAL},\n\t{ERRbadfile, -ENOENT},\n\t{ERRbadpath, -ENOTDIR},\n\t{ERRnofids, -EMFILE},\n\t{ERRnoaccess, -EACCES},\n\t{ERRbadfid, -EBADF},\n\t{ERRbadmcb, -EIO},\n\t{ERRnomem, -EREMOTEIO},\n\t{ERRbadmem, -EFAULT},\n\t{ERRbadenv, -EFAULT},\n\t{ERRbadformat, -EINVAL},\n\t{ERRbadaccess, -EACCES},\n\t{ERRbaddata, -EIO},\n\t{ERRbaddrive, -ENXIO},\n\t{ERRremcd, -EACCES},\n\t{ERRdiffdevice, -EXDEV},\n\t{ERRnofiles, -ENOENT},\n\t{ERRwriteprot, -EROFS},\n\t{ERRbadshare, -EBUSY},\n\t{ERRlock, -EACCES},\n\t{ERRunsup, -EINVAL},\n\t{ERRnosuchshare, -ENXIO},\n\t{ERRfilexists, -EEXIST},\n\t{ERRinvparm, -EINVAL},\n\t{ERRdiskfull, -ENOSPC},\n\t{ERRinvname, -ENOENT},\n\t{ERRinvlevel, -EOPNOTSUPP},\n\t{ERRdirnotempty, -ENOTEMPTY},\n\t{ERRnotlocked, -ENOLCK},\n\t{ERRcancelviolation, -ENOLCK},\n\t{ERRalreadyexists, -EEXIST},\n\t{ERRmoredata, -EOVERFLOW},\n\t{ERReasnotsupported, -EOPNOTSUPP},\n\t{ErrQuota, -EDQUOT},\n\t{ErrNotALink, -ENOLINK},\n\t{ERRnetlogonNotStarted, -ENOPROTOOPT},\n\t{ERRsymlink, -EOPNOTSUPP},\n\t{ErrTooManyLinks, -EMLINK},\n\t{0, 0}\n};",
            "static const struct smb_to_posix_error mapping_table_ERRSRV[] = {\n\t{ERRerror, -EIO},\n\t{ERRbadpw, -EACCES},  /* was EPERM */\n\t{ERRbadtype, -EREMOTE},\n\t{ERRaccess, -EACCES},\n\t{ERRinvtid, -ENXIO},\n\t{ERRinvnetname, -ENXIO},\n\t{ERRinvdevice, -ENXIO},\n\t{ERRqfull, -ENOSPC},\n\t{ERRqtoobig, -ENOSPC},\n\t{ERRqeof, -EIO},\n\t{ERRinvpfid, -EBADF},\n\t{ERRsmbcmd, -EBADRQC},\n\t{ERRsrverror, -EIO},\n\t{ERRbadBID, -EIO},\n\t{ERRfilespecs, -EINVAL},\n\t{ERRbadLink, -EIO},\n\t{ERRbadpermits, -EINVAL},\n\t{ERRbadPID, -ESRCH},\n\t{ERRsetattrmode, -EINVAL},\n\t{ERRpaused, -EHOSTDOWN},\n\t{ERRmsgoff, -EHOSTDOWN},\n\t{ERRnoroom, -ENOSPC},\n\t{ERRrmuns, -EUSERS},\n\t{ERRtimeout, -ETIME},\n\t{ERRnoresource, -EREMOTEIO},\n\t{ERRtoomanyuids, -EUSERS},\n\t{ERRbaduid, -EACCES},\n\t{ERRusempx, -EIO},\n\t{ERRusestd, -EIO},\n\t{ERR_NOTIFY_ENUM_DIR, -ENOBUFS},\n\t{ERRnoSuchUser, -EACCES},\n/*\t{ERRaccountexpired, -EACCES},\n\t{ERRbadclient, -EACCES},\n\t{ERRbadLogonTime, -EACCES},\n\t{ERRpasswordExpired, -EACCES},*/\n\t{ERRaccountexpired, -EKEYEXPIRED},\n\t{ERRbadclient, -EACCES},\n\t{ERRbadLogonTime, -EACCES},\n\t{ERRpasswordExpired, -EKEYEXPIRED},\n\n\t{ERRnosupport, -EINVAL},\n\t{0, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\nstatic const struct smb_to_posix_error mapping_table_ERRDOS[] = {\n\t{ERRbadfunc, -EINVAL},\n\t{ERRbadfile, -ENOENT},\n\t{ERRbadpath, -ENOTDIR},\n\t{ERRnofids, -EMFILE},\n\t{ERRnoaccess, -EACCES},\n\t{ERRbadfid, -EBADF},\n\t{ERRbadmcb, -EIO},\n\t{ERRnomem, -EREMOTEIO},\n\t{ERRbadmem, -EFAULT},\n\t{ERRbadenv, -EFAULT},\n\t{ERRbadformat, -EINVAL},\n\t{ERRbadaccess, -EACCES},\n\t{ERRbaddata, -EIO},\n\t{ERRbaddrive, -ENXIO},\n\t{ERRremcd, -EACCES},\n\t{ERRdiffdevice, -EXDEV},\n\t{ERRnofiles, -ENOENT},\n\t{ERRwriteprot, -EROFS},\n\t{ERRbadshare, -EBUSY},\n\t{ERRlock, -EACCES},\n\t{ERRunsup, -EINVAL},\n\t{ERRnosuchshare, -ENXIO},\n\t{ERRfilexists, -EEXIST},\n\t{ERRinvparm, -EINVAL},\n\t{ERRdiskfull, -ENOSPC},\n\t{ERRinvname, -ENOENT},\n\t{ERRinvlevel, -EOPNOTSUPP},\n\t{ERRdirnotempty, -ENOTEMPTY},\n\t{ERRnotlocked, -ENOLCK},\n\t{ERRcancelviolation, -ENOLCK},\n\t{ERRalreadyexists, -EEXIST},\n\t{ERRmoredata, -EOVERFLOW},\n\t{ERReasnotsupported, -EOPNOTSUPP},\n\t{ErrQuota, -EDQUOT},\n\t{ErrNotALink, -ENOLINK},\n\t{ERRnetlogonNotStarted, -ENOPROTOOPT},\n\t{ERRsymlink, -EOPNOTSUPP},\n\t{ErrTooManyLinks, -EMLINK},\n\t{0, 0}\n};\nstatic const struct smb_to_posix_error mapping_table_ERRSRV[] = {\n\t{ERRerror, -EIO},\n\t{ERRbadpw, -EACCES},  /* was EPERM */\n\t{ERRbadtype, -EREMOTE},\n\t{ERRaccess, -EACCES},\n\t{ERRinvtid, -ENXIO},\n\t{ERRinvnetname, -ENXIO},\n\t{ERRinvdevice, -ENXIO},\n\t{ERRqfull, -ENOSPC},\n\t{ERRqtoobig, -ENOSPC},\n\t{ERRqeof, -EIO},\n\t{ERRinvpfid, -EBADF},\n\t{ERRsmbcmd, -EBADRQC},\n\t{ERRsrverror, -EIO},\n\t{ERRbadBID, -EIO},\n\t{ERRfilespecs, -EINVAL},\n\t{ERRbadLink, -EIO},\n\t{ERRbadpermits, -EINVAL},\n\t{ERRbadPID, -ESRCH},\n\t{ERRsetattrmode, -EINVAL},\n\t{ERRpaused, -EHOSTDOWN},\n\t{ERRmsgoff, -EHOSTDOWN},\n\t{ERRnoroom, -ENOSPC},\n\t{ERRrmuns, -EUSERS},\n\t{ERRtimeout, -ETIME},\n\t{ERRnoresource, -EREMOTEIO},\n\t{ERRtoomanyuids, -EUSERS},\n\t{ERRbaduid, -EACCES},\n\t{ERRusempx, -EIO},\n\t{ERRusestd, -EIO},\n\t{ERR_NOTIFY_ENUM_DIR, -ENOBUFS},\n\t{ERRnoSuchUser, -EACCES},\n/*\t{ERRaccountexpired, -EACCES},\n\t{ERRbadclient, -EACCES},\n\t{ERRbadLogonTime, -EACCES},\n\t{ERRpasswordExpired, -EACCES},*/\n\t{ERRaccountexpired, -EKEYEXPIRED},\n\t{ERRbadclient, -EACCES},\n\t{ERRbadLogonTime, -EACCES},\n\t{ERRpasswordExpired, -EKEYEXPIRED},\n\n\t{ERRnosupport, -EINVAL},\n\t{0, 0}\n};\n\nint\nmap_smb_to_linux_error(char *buf, bool logErr)\n{\n\tstruct smb_hdr *smb = (struct smb_hdr *)buf;\n\tunsigned int i;\n\tint rc = -EIO;\t/* if transport error smb error may not be set */\n\t__u8 smberrclass;\n\t__u16 smberrcode;\n\n\t/* BB if NT Status codes - map NT BB */\n\n\t/* old style smb error codes */\n\tif (smb->Status.CifsError == 0)\n\t\treturn 0;\n\n\tif (smb->Flags2 & SMBFLG2_ERR_STATUS) {\n\t\t/* translate the newer STATUS codes to old style SMB errors\n\t\t * and then to POSIX errors */\n\t\t__u32 err = le32_to_cpu(smb->Status.CifsError);\n\t\tif (logErr && (err != (NT_STATUS_MORE_PROCESSING_REQUIRED)))\n\t\t\tcifs_print_status(err);\n\t\telse if (cifsFYI & CIFS_RC)\n\t\t\tcifs_print_status(err);\n\t\tntstatus_to_dos(err, &smberrclass, &smberrcode);\n\t} else {\n\t\tsmberrclass = smb->Status.DosError.ErrorClass;\n\t\tsmberrcode = le16_to_cpu(smb->Status.DosError.Error);\n\t}\n\n\t/* old style errors */\n\n\t/* DOS class smb error codes - map DOS */\n\tif (smberrclass == ERRDOS) {\n\t\t/* 1 byte field no need to byte reverse */\n\t\tfor (i = 0;\n\t\t     i <\n\t\t     sizeof(mapping_table_ERRDOS) /\n\t\t     sizeof(struct smb_to_posix_error); i++) {\n\t\t\tif (mapping_table_ERRDOS[i].smb_err == 0)\n\t\t\t\tbreak;\n\t\t\telse if (mapping_table_ERRDOS[i].smb_err ==\n\t\t\t\t\t\t\t\tsmberrcode) {\n\t\t\t\trc = mapping_table_ERRDOS[i].posix_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else try next error mapping one to see if match */\n\t\t}\n\t} else if (smberrclass == ERRSRV) {\n\t\t/* server class of error codes */\n\t\tfor (i = 0;\n\t\t     i <\n\t\t     sizeof(mapping_table_ERRSRV) /\n\t\t     sizeof(struct smb_to_posix_error); i++) {\n\t\t\tif (mapping_table_ERRSRV[i].smb_err == 0)\n\t\t\t\tbreak;\n\t\t\telse if (mapping_table_ERRSRV[i].smb_err ==\n\t\t\t\t\t\t\t\tsmberrcode) {\n\t\t\t\trc = mapping_table_ERRSRV[i].posix_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* else try next error mapping to see if match */\n\t\t}\n\t}\n\t/* else ERRHRD class errors or junk  - return EIO */\n\n\tcifs_dbg(FYI, \"Mapping smb error code 0x%x to POSIX err %d\\n\",\n\t\t le32_to_cpu(smb->Status.CifsError), rc);\n\n\t/* generic corrective action e.g. reconnect SMB session on\n\t * ERRbaduid could be added */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB signature verification returned error = %d\\n\"",
            "rc"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_verify_signature",
          "args": [
            "&rqst",
            "server",
            "mid->sequence_number"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_verify_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "206-259",
          "snippet": "int cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_smb",
          "args": [
            "mid->resp_buf",
            "min_t(u32, 92, len)"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "dump_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "513-521",
          "snippet": "void\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "92",
            "len"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "mid->resp_buf"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t   bool log_error)\n{\n\tunsigned int len = get_rfc1002_length(mid->resp_buf) + 4;\n\n\tdump_smb(mid->resp_buf, min_t(u32, 92, len));\n\n\t/* convert the length into a more usable form */\n\tif (server->sign) {\n\t\tstruct kvec iov;\n\t\tint rc = 0;\n\t\tstruct smb_rqst rqst = { .rq_iov = &iov,\n\t\t\t\t\t .rq_nvec = 1 };\n\n\t\tiov.iov_base = mid->resp_buf;\n\t\tiov.iov_len = len;\n\t\t/* FIXME: add code to kill session */\n\t\trc = cifs_verify_signature(&rqst, server,\n\t\t\t\t\t   mid->sequence_number);\n\t\tif (rc)\n\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\t/* BB special case reconnect tid and uid here? */\n\treturn map_smb_to_linux_error(mid->resp_buf, log_error);\n}"
  },
  {
    "function_name": "send_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "651-656",
    "snippet": "static inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "server->ops->send_cancel",
          "args": [
            "server",
            "buf",
            "mid"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "send_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "651-656",
          "snippet": "static inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic inline int\nsend_cancel(struct TCP_Server_Info *server, void *buf, struct mid_q_entry *mid)\n{\n\treturn server->ops->send_cancel ?\n\t\t\t\tserver->ops->send_cancel(server, buf, mid) : 0;\n}"
  },
  {
    "function_name": "cifs_sync_mid_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "617-649",
    "snippet": "static int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: invalid mid state mid=%llu state=%d\\n\"",
            "__func__",
            "mid->mid",
            "mid->mid_state"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mid->qhead"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: cmd=%d mid=%llu state=%d\\n\"",
            "__func__",
            "le16_to_cpu(mid->command)",
            "mid->mid",
            "mid->mid_state"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "mid->command"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_sync_mid_result(struct mid_q_entry *mid, struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\n\tcifs_dbg(FYI, \"%s: cmd=%d mid=%llu state=%d\\n\",\n\t\t __func__, le16_to_cpu(mid->command), mid->mid, mid->mid_state);\n\n\tspin_lock(&GlobalMid_Lock);\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\tcase MID_RETRY_NEEDED:\n\t\trc = -EAGAIN;\n\t\tbreak;\n\tcase MID_RESPONSE_MALFORMED:\n\t\trc = -EIO;\n\t\tbreak;\n\tcase MID_SHUTDOWN:\n\t\trc = -EHOSTDOWN;\n\t\tbreak;\n\tdefault:\n\t\tlist_del_init(&mid->qhead);\n\t\tcifs_dbg(VFS, \"%s: invalid mid state mid=%llu state=%d\\n\",\n\t\t\t __func__, mid->mid, mid->mid_state);\n\t\trc = -EIO;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n\treturn rc;\n}"
  },
  {
    "function_name": "SendReceiveNoRsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "600-615",
    "snippet": "int\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "NOISY",
            "\"SendRcvNoRsp flags %d rc %d\\n\"",
            "flags",
            "rc"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendReceive2",
          "args": [
            "xid",
            "ses",
            "iov",
            "1",
            "&resp_buf_type",
            "flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "SendReceive2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "705-832",
          "snippet": "int\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceive2(const unsigned int xid, struct cifs_ses *ses,\n\t     struct kvec *iov, int n_vec, int *resp_buf_type /* ret */,\n\t     const int flags)\n{\n\tint rc = 0;\n\tint timeout, optype;\n\tstruct mid_q_entry *midQ;\n\tchar *buf = iov[0].iov_base;\n\tunsigned int credits = 1;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\t*resp_buf_type = CIFS_NO_BUFFER;  /* no response buf yet */\n\n\tif ((ses == NULL) || (ses->server == NULL)) {\n\t\tcifs_small_buf_release(buf);\n\t\tcifs_dbg(VFS, \"Null session\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Ensure that we do not send more than 50 overlapping requests\n\t * to the same server. We may make this configurable later or\n\t * use ses->maxReq.\n\t */\n\n\trc = wait_for_free_request(ses->server, timeout, optype);\n\tif (rc) {\n\t\tcifs_small_buf_release(buf);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Make sure that we sign in the same order that we send on this socket\n\t * and avoid races inside tcp sendmsg code that could cause corruption\n\t * of smb data.\n\t */\n\n\tmutex_lock(&ses->server->srv_mutex);\n\n\tmidQ = ses->server->ops->setup_request(ses, &rqst);\n\tif (IS_ERR(midQ)) {\n\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\tcifs_small_buf_release(buf);\n\t\t/* Update # of requests on wire to server */\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn PTR_ERR(midQ);\n\t}\n\n\tmidQ->mid_state = MID_REQUEST_SUBMITTED;\n\tcifs_in_send_inc(ses->server);\n\trc = smb_sendv(ses->server, iov, n_vec);\n\tcifs_in_send_dec(ses->server);\n\tcifs_save_when_sent(midQ);\n\n\tif (rc < 0)\n\t\tses->server->sequence_number -= 2;\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tif (rc < 0) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\tcifs_small_buf_release(buf);\n\t\tgoto out;\n\t}\n\n\trc = wait_for_response(ses->server, midQ);\n\tif (rc != 0) {\n\t\tsend_cancel(ses->server, buf, midQ);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (midQ->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\tmidQ->callback = DeleteMidQEntry;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\tcifs_small_buf_release(buf);\n\t\t\tadd_credits(ses->server, 1, optype);\n\t\t\treturn rc;\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tcifs_small_buf_release(buf);\n\n\trc = cifs_sync_mid_result(midQ, ses->server);\n\tif (rc != 0) {\n\t\tadd_credits(ses->server, 1, optype);\n\t\treturn rc;\n\t}\n\n\tif (!midQ->resp_buf || midQ->mid_state != MID_RESPONSE_RECEIVED) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Bad MID state?\\n\");\n\t\tgoto out;\n\t}\n\n\tbuf = (char *)midQ->resp_buf;\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = get_rfc1002_length(buf) + 4;\n\tif (midQ->large_buf)\n\t\t*resp_buf_type = CIFS_LARGE_BUFFER;\n\telse\n\t\t*resp_buf_type = CIFS_SMALL_BUFFER;\n\n\tcredits = ses->server->ops->get_credits(midQ);\n\n\trc = ses->server->ops->check_receive(midQ, ses->server,\n\t\t\t\t\t     flags & CIFS_LOG_ERROR);\n\n\t/* mark it so buf will not be freed by cifs_delete_mid */\n\tif ((flags & CIFS_NO_RESP) == 0)\n\t\tmidQ->resp_buf = NULL;\nout:\n\tcifs_delete_mid(midQ);\n\tadd_credits(ses->server, credits, optype);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "in_buf"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nSendReceiveNoRsp(const unsigned int xid, struct cifs_ses *ses,\n\t\t char *in_buf, int flags)\n{\n\tint rc;\n\tstruct kvec iov[1];\n\tint resp_buf_type;\n\n\tiov[0].iov_base = in_buf;\n\tiov[0].iov_len = get_rfc1002_length(in_buf) + 4;\n\tflags |= CIFS_NO_RESP;\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buf_type, flags);\n\tcifs_dbg(NOISY, \"SendRcvNoRsp flags %d rc %d\\n\", flags, rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_call_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "536-589",
    "snippet": "int\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_credits_and_wake_if",
          "args": [
            "server",
            "credits",
            "optype"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "add_credits_and_wake_if",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "648-656",
          "snippet": "static inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nadd_credits_and_wake_if(struct TCP_Server_Info *server, const unsigned int add,\n\t\t\tconst int optype)\n{\n\tif (add) {\n\t\tserver->ops->add_credits(server, add, optype);\n\t\twake_up(&server->request_q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_delete_mid",
          "args": [
            "mid"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_delete_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "114-122",
          "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_save_when_sent",
          "args": [
            "mid"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_save_when_sent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1321-1323",
          "snippet": "static inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_save_when_sent(struct mid_q_entry *mid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_dec",
          "args": [
            "server"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1309-1311",
          "snippet": "static inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb_send_rqst",
          "args": [
            "server",
            "rqst"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "293-367",
          "snippet": "static int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_in_send_inc",
          "args": [
            "server"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_in_send_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1306-1308",
          "snippet": "static inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_in_send_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mid->qhead",
            "&server->pending_mid_q"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mid"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mid"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->setup_async_request",
          "args": [
            "server",
            "rqst"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_free_request",
          "args": [
            "server",
            "timeout",
            "optype"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_free_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "438-449",
          "snippet": "static int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,\n\t\tmid_receive_t *receive, mid_callback_t *callback,\n\t\tvoid *cbdata, const int flags)\n{\n\tint rc, timeout, optype;\n\tstruct mid_q_entry *mid;\n\tunsigned int credits = 0;\n\n\ttimeout = flags & CIFS_TIMEOUT_MASK;\n\toptype = flags & CIFS_OP_MASK;\n\n\tif ((flags & CIFS_HAS_CREDITS) == 0) {\n\t\trc = wait_for_free_request(server, timeout, optype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tcredits = 1;\n\t}\n\n\tmutex_lock(&server->srv_mutex);\n\tmid = server->ops->setup_async_request(server, rqst);\n\tif (IS_ERR(mid)) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\tadd_credits_and_wake_if(server, credits, optype);\n\t\treturn PTR_ERR(mid);\n\t}\n\n\tmid->receive = receive;\n\tmid->callback = callback;\n\tmid->callback_data = cbdata;\n\tmid->mid_state = MID_REQUEST_SUBMITTED;\n\n\t/* put it on the pending_mid_q */\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&mid->qhead, &server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\n\n\tcifs_in_send_inc(server);\n\trc = smb_send_rqst(server, rqst);\n\tcifs_in_send_dec(server);\n\tcifs_save_when_sent(mid);\n\n\tif (rc < 0)\n\t\tserver->sequence_number -= 2;\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc == 0)\n\t\treturn 0;\n\n\tcifs_delete_mid(mid);\n\tadd_credits_and_wake_if(server, credits, optype);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_setup_async_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "508-530",
    "snippet": "struct mid_q_entry *\ncifs_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\t/* enable signing if server requires it */\n\tif (server->sign)\n\t\thdr->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tmid = AllocMidQEntry(hdr, server);\n\tif (mid == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_sign_rqst(rqst, server, &mid->sequence_number);\n\tif (rc) {\n\t\tDeleteMidQEntry(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn mid;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sign_rqst",
          "args": [
            "rqst",
            "server",
            "&mid->sequence_number"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "149-182",
          "snippet": "int cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocMidQEntry",
          "args": [
            "hdr",
            "server"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "AllocMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "46-81",
          "snippet": "struct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstruct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstruct mid_q_entry *\ncifs_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct smb_hdr *hdr = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\tstruct mid_q_entry *mid;\n\n\t/* enable signing if server requires it */\n\tif (server->sign)\n\t\thdr->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tmid = AllocMidQEntry(hdr, server);\n\tif (mid == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_sign_rqst(rqst, server, &mid->sequence_number);\n\tif (rc) {\n\t\tDeleteMidQEntry(mid);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn mid;\n}"
  },
  {
    "function_name": "wait_for_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "495-506",
    "snippet": "static int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_freezekillable_unsafe",
          "args": [
            "server->response_q",
            "midQ->mid_state != MID_REQUEST_SUBMITTED"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_response(struct TCP_Server_Info *server, struct mid_q_entry *midQ)\n{\n\tint error;\n\n\terror = wait_event_freezekillable_unsafe(server->response_q,\n\t\t\t\t    midQ->mid_state != MID_REQUEST_SUBMITTED);\n\tif (error < 0)\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "allocate_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "460-493",
    "snippet": "static int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&(*ppmidQ)->qhead",
            "&ses->server->pending_mid_q"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocMidQEntry",
          "args": [
            "in_buf",
            "ses->server"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "AllocMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "46-81",
          "snippet": "struct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstruct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"tcp session dead - return to caller to retry\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int allocate_mid(struct cifs_ses *ses, struct smb_hdr *in_buf,\n\t\t\tstruct mid_q_entry **ppmidQ)\n{\n\tif (ses->server->tcpStatus == CifsExiting) {\n\t\treturn -ENOENT;\n\t}\n\n\tif (ses->server->tcpStatus == CifsNeedReconnect) {\n\t\tcifs_dbg(FYI, \"tcp session dead - return to caller to retry\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ses->status == CifsNew) {\n\t\tif ((in_buf->Command != SMB_COM_SESSION_SETUP_ANDX) &&\n\t\t\t(in_buf->Command != SMB_COM_NEGOTIATE))\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are setting up session */\n\t}\n\n\tif (ses->status == CifsExiting) {\n\t\t/* check if SMB session is bad because we are setting it up */\n\t\tif (in_buf->Command != SMB_COM_LOGOFF_ANDX)\n\t\t\treturn -EAGAIN;\n\t\t/* else ok - we are shutting down session */\n\t}\n\n\t*ppmidQ = AllocMidQEntry(in_buf, ses->server);\n\tif (*ppmidQ == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&GlobalMid_Lock);\n\tlist_add_tail(&(*ppmidQ)->qhead, &ses->server->pending_mid_q);\n\tspin_unlock(&GlobalMid_Lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_wait_mtu_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "451-458",
    "snippet": "int\ncifs_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, unsigned int *credits)\n{\n\t*num = size;\n\t*credits = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\ncifs_wait_mtu_credits(struct TCP_Server_Info *server, unsigned int size,\n\t\t      unsigned int *num, unsigned int *credits)\n{\n\t*num = size;\n\t*credits = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_for_free_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "438-449",
    "snippet": "static int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_free_credits",
          "args": [
            "server",
            "timeout",
            "val"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_free_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "390-436",
          "snippet": "static int\nwait_for_free_credits(struct TCP_Server_Info *server, const int timeout,\n\t\t      int *credits)\n{\n\tint rc;\n\n\tspin_lock(&server->req_lock);\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\t/* oplock breaks must not be held up */\n\t\tserver->in_flight++;\n\t\t*credits -= 1;\n\t\tspin_unlock(&server->req_lock);\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (*credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\t\t has_credits(server, credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Can not count locking commands against total\n\t\t\t * as they are allowed to block on server.\n\t\t\t */\n\n\t\t\t/* update # of requests on the wire to server */\n\t\t\tif (timeout != CIFS_BLOCKING_OP) {\n\t\t\t\t*credits -= 1;\n\t\t\t\tserver->in_flight++;\n\t\t\t}\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_credits(struct TCP_Server_Info *server, const int timeout,\n\t\t      int *credits)\n{\n\tint rc;\n\n\tspin_lock(&server->req_lock);\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\t/* oplock breaks must not be held up */\n\t\tserver->in_flight++;\n\t\t*credits -= 1;\n\t\tspin_unlock(&server->req_lock);\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (*credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\t\t has_credits(server, credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Can not count locking commands against total\n\t\t\t * as they are allowed to block on server.\n\t\t\t */\n\n\t\t\t/* update # of requests on the wire to server */\n\t\t\tif (timeout != CIFS_BLOCKING_OP) {\n\t\t\t\t*credits -= 1;\n\t\t\t\tserver->in_flight++;\n\t\t\t}\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->get_credits_field",
          "args": [
            "server",
            "optype"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_request(struct TCP_Server_Info *server, const int timeout,\n\t\t      const int optype)\n{\n\tint *val;\n\n\tval = server->ops->get_credits_field(server, optype);\n\t/* Since an echo is already inflight, no need to wait to send another */\n\tif (*val <= 0 && optype == CIFS_ECHO_OP)\n\t\treturn -EAGAIN;\n\treturn wait_for_free_credits(server, timeout, val);\n}"
  },
  {
    "function_name": "wait_for_free_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "390-436",
    "snippet": "static int\nwait_for_free_credits(struct TCP_Server_Info *server, const int timeout,\n\t\t      int *credits)\n{\n\tint rc;\n\n\tspin_lock(&server->req_lock);\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\t/* oplock breaks must not be held up */\n\t\tserver->in_flight++;\n\t\t*credits -= 1;\n\t\tspin_unlock(&server->req_lock);\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (*credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\t\t has_credits(server, credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Can not count locking commands against total\n\t\t\t * as they are allowed to block on server.\n\t\t\t */\n\n\t\t\t/* update # of requests on the wire to server */\n\t\t\tif (timeout != CIFS_BLOCKING_OP) {\n\t\t\t\t*credits -= 1;\n\t\t\t\tserver->in_flight++;\n\t\t\t}\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_num_waiters_dec",
          "args": [
            "server"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_num_waiters_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1317-1319",
          "snippet": "static inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_num_waiters_dec(struct TCP_Server_Info *server)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_killable",
          "args": [
            "server->request_q",
            "has_credits(server, credits)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_credits",
          "args": [
            "server",
            "credits"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "has_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "631-639",
          "snippet": "static inline bool\nhas_credits(struct TCP_Server_Info *server, int *credits)\n{\n\tint num;\n\tspin_lock(&server->req_lock);\n\tnum = *credits;\n\tspin_unlock(&server->req_lock);\n\treturn num > 0;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\nhas_credits(struct TCP_Server_Info *server, int *credits)\n{\n\tint num;\n\tspin_lock(&server->req_lock);\n\tnum = *credits;\n\tspin_unlock(&server->req_lock);\n\treturn num > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_num_waiters_inc",
          "args": [
            "server"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_num_waiters_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1313-1315",
          "snippet": "static inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)\n{\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void cifs_num_waiters_inc(struct TCP_Server_Info *server)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nwait_for_free_credits(struct TCP_Server_Info *server, const int timeout,\n\t\t      int *credits)\n{\n\tint rc;\n\n\tspin_lock(&server->req_lock);\n\tif (timeout == CIFS_ASYNC_OP) {\n\t\t/* oplock breaks must not be held up */\n\t\tserver->in_flight++;\n\t\t*credits -= 1;\n\t\tspin_unlock(&server->req_lock);\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tif (*credits <= 0) {\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tcifs_num_waiters_inc(server);\n\t\t\trc = wait_event_killable(server->request_q,\n\t\t\t\t\t\t has_credits(server, credits));\n\t\t\tcifs_num_waiters_dec(server);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tspin_lock(&server->req_lock);\n\t\t} else {\n\t\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\t\tspin_unlock(&server->req_lock);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Can not count locking commands against total\n\t\t\t * as they are allowed to block on server.\n\t\t\t */\n\n\t\t\t/* update # of requests on the wire to server */\n\t\t\tif (timeout != CIFS_BLOCKING_OP) {\n\t\t\t\t*credits -= 1;\n\t\t\t\tserver->in_flight++;\n\t\t\t}\n\t\t\tspin_unlock(&server->req_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "smb_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "378-388",
    "snippet": "int\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb_sendv",
          "args": [
            "server",
            "&iov",
            "1"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "smb_sendv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "369-376",
          "snippet": "static int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}"
  },
  {
    "function_name": "smb_sendv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "369-376",
    "snippet": "static int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smb_send_rqst",
          "args": [
            "server",
            "&rqst"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "293-367",
          "snippet": "static int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_sendv(struct TCP_Server_Info *server, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn smb_send_rqst(server, &rqst);\n}"
  },
  {
    "function_name": "smb_send_rqst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "293-367",
    "snippet": "static int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Error %d sending data on socket to server\\n\"",
            "rc"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"partial send (wanted=%u sent=%zu): terminating session\\n\"",
            "smb_buf_length + 4",
            "total_len"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "ssocket",
            "SOL_TCP",
            "TCP_CORK",
            "(char *)&val",
            "sizeof(val)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "rqst->rq_pages[i]"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_send_kvec",
          "args": [
            "server",
            "&p_iov",
            "1",
            "&sent"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send_kvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "134-239",
          "snippet": "static int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -EAGAIN) {\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcifs_dbg(VFS, \"sends on sock %p stuck for 15 seconds\\n\",\n\t\t\t\t\t ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcifs_dbg(VFS, \"sent %d requested %d\\n\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcifs_dbg(VFS, \"tcp sent no data\\n\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -EAGAIN) {\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcifs_dbg(VFS, \"sends on sock %p stuck for 15 seconds\\n\",\n\t\t\t\t\t ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcifs_dbg(VFS, \"sent %d requested %d\\n\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcifs_dbg(VFS, \"tcp sent no data\\n\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_rqst_page_to_kvec",
          "args": [
            "rqst",
            "i",
            "&p_iov"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_rqst_page_to_kvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "251-271",
          "snippet": "void\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_setsockopt",
          "args": [
            "ssocket",
            "SOL_TCP",
            "TCP_CORK",
            "(char *)&val",
            "sizeof(val)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_smb",
          "args": [
            "iov[0].iov_base",
            "iov[0].iov_len"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "dump_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "513-521",
          "snippet": "void\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ndump_smb(void *buf, int smb_buf_length)\n{\n\tif (traceSMB == 0)\n\t\treturn;\n\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_NONE, 8, 2, buf,\n\t\t       smb_buf_length, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Sending smb: smb_len=%u\\n\"",
            "smb_buf_length"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\"",
            "send_length",
            "smb_buf_length"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_len",
          "args": [
            "rqst"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "273-291",
          "snippet": "static unsigned long\nrqst_len(struct smb_rqst *rqst)\n{\n\tunsigned int i;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned long buflen = 0;\n\n\t/* total up iov array first */\n\tfor (i = 0; i < rqst->rq_nvec; i++)\n\t\tbuflen += iov[i].iov_len;\n\n\t/* add in the page array if there is one */\n\tif (rqst->rq_npages) {\n\t\tbuflen += rqst->rq_pagesz * (rqst->rq_npages - 1);\n\t\tbuflen += rqst->rq_tailsz;\n\t}\n\n\treturn buflen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic unsigned long\nrqst_len(struct smb_rqst *rqst)\n{\n\tunsigned int i;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned long buflen = 0;\n\n\t/* total up iov array first */\n\tfor (i = 0; i < rqst->rq_nvec; i++)\n\t\tbuflen += iov[i].iov_len;\n\n\t/* add in the page array if there is one */\n\tif (rqst->rq_npages) {\n\t\tbuflen += rqst->rq_pagesz * (rqst->rq_npages - 1);\n\t\tbuflen += rqst->rq_tailsz;\n\t}\n\n\treturn buflen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "iov[0].iov_base"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned long send_length;\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\n\t/* sanity check send length */\n\tsend_length = rqst_len(rqst);\n\tif (send_length != smb_buf_length + 4) {\n\t\tWARN(1, \"Send length mismatch(send_length=%lu smb_buf_length=%u)\\n\",\n\t\t\tsend_length, smb_buf_length);\n\t\treturn -EIO;\n\t}\n\n\tcifs_dbg(FYI, \"Sending smb: smb_len=%u\\n\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\n\t/* cork the socket */\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\n\ttotal_len += sent;\n\n\t/* now walk the page array and send each page in it */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttotal_len += sent;\n\t}\n\nuncork:\n\t/* uncork it */\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcifs_dbg(FYI, \"partial send (wanted=%u sent=%zu): terminating session\\n\",\n\t\t\t smb_buf_length + 4, total_len);\n\t\t/*\n\t\t * If we have only sent part of an SMB then the next SMB could\n\t\t * be taken as the remainder of this one. We need to kill the\n\t\t * socket so the server throws away the partial SMB\n\t\t */\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\n\tif (rc < 0 && rc != -EINTR)\n\t\tcifs_dbg(VFS, \"Error %d sending data on socket to server\\n\",\n\t\t\t rc);\n\telse\n\t\trc = 0;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "rqst_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "273-291",
    "snippet": "static unsigned long\nrqst_len(struct smb_rqst *rqst)\n{\n\tunsigned int i;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned long buflen = 0;\n\n\t/* total up iov array first */\n\tfor (i = 0; i < rqst->rq_nvec; i++)\n\t\tbuflen += iov[i].iov_len;\n\n\t/* add in the page array if there is one */\n\tif (rqst->rq_npages) {\n\t\tbuflen += rqst->rq_pagesz * (rqst->rq_npages - 1);\n\t\tbuflen += rqst->rq_tailsz;\n\t}\n\n\treturn buflen;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic unsigned long\nrqst_len(struct smb_rqst *rqst)\n{\n\tunsigned int i;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned long buflen = 0;\n\n\t/* total up iov array first */\n\tfor (i = 0; i < rqst->rq_nvec; i++)\n\t\tbuflen += iov[i].iov_len;\n\n\t/* add in the page array if there is one */\n\tif (rqst->rq_npages) {\n\t\tbuflen += rqst->rq_pagesz * (rqst->rq_npages - 1);\n\t\tbuflen += rqst->rq_tailsz;\n\t}\n\n\treturn buflen;\n}"
  },
  {
    "function_name": "cifs_rqst_page_to_kvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "251-271",
    "snippet": "void\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "rqst->rq_pages[idx]"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}"
  },
  {
    "function_name": "smb_send_kvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "134-239",
    "snippet": "static int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -EAGAIN) {\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcifs_dbg(VFS, \"sends on sock %p stuck for 15 seconds\\n\",\n\t\t\t\t\t ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcifs_dbg(VFS, \"sent %d requested %d\\n\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcifs_dbg(VFS, \"tcp sent no data\\n\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "500"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"tcp sent no data\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"sent %d requested %d\\n\"",
            "rc",
            "remaining"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1 << i"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"sends on sock %p stuck for 15 seconds\\n\"",
            "ssocket"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_sendmsg",
          "args": [
            "ssocket",
            "&smb_msg",
            "&iov[first_vec]",
            "n_vec - first_vec",
            "remaining"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstatic int\nsmb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n\n\t*sent = 0;\n\n\tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n\tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -EAGAIN) {\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcifs_dbg(VFS, \"sends on sock %p stuck for 15 seconds\\n\",\n\t\t\t\t\t ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcifs_dbg(VFS, \"sent %d requested %d\\n\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcifs_dbg(VFS, \"tcp sent no data\\n\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_delete_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "114-122",
    "snippet": "void\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DeleteMidQEntry",
          "args": [
            "mid"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteMidQEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "83-112",
          "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mid->qhead"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_delete_mid(struct mid_q_entry *mid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\tlist_del(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n\n\tDeleteMidQEntry(mid);\n}"
  },
  {
    "function_name": "DeleteMidQEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "83-112",
    "snippet": "void\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "midEntry",
            "cifs_mid_poolp"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\"",
            "now - midEntry->when_alloc",
            "now - midEntry->when_sent",
            "now - midEntry->when_received"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\" CIFS slow rsp: cmd %d mid %llu\"",
            "midEntry->command",
            "midEntry->mid"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_small_buf_release",
          "args": [
            "midEntry->resp_buf"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_small_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "215-227",
          "snippet": "void\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_sm_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_sm_req_poolp;\n\nvoid\ncifs_small_buf_release(void *buf_to_free)\n{\n\n\tif (buf_to_free == NULL) {\n\t\tcifs_dbg(FYI, \"Null buffer passed to cifs_small_buf_release\\n\");\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_sm_req_poolp);\n\n\tatomic_dec(&smBufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_buf_release",
          "args": [
            "midEntry->resp_buf"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_buf_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "180-191",
          "snippet": "void\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern mempool_t *cifs_req_poolp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nextern mempool_t *cifs_req_poolp;\n\nvoid\ncifs_buf_release(void *buf_to_free)\n{\n\tif (buf_to_free == NULL) {\n\t\t/* cifs_dbg(FYI, \"Null buffer passed to cifs_buf_release\\n\");*/\n\t\treturn;\n\t}\n\tmempool_free(buf_to_free, cifs_req_poolp);\n\n\tatomic_dec(&bufAllocCount);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&midCount"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\nDeleteMidQEntry(struct mid_q_entry *midEntry)\n{\n#ifdef CONFIG_CIFS_STATS2\n\t__le16 command = midEntry->server->vals->lock_cmd;\n\tunsigned long now;\n#endif\n\tmidEntry->mid_state = MID_FREE;\n\tatomic_dec(&midCount);\n\tif (midEntry->large_buf)\n\t\tcifs_buf_release(midEntry->resp_buf);\n\telse\n\t\tcifs_small_buf_release(midEntry->resp_buf);\n#ifdef CONFIG_CIFS_STATS2\n\tnow = jiffies;\n\t/* commands taking longer than one second are indications that\n\t   something is wrong, unless it is quite a slow link or server */\n\tif ((now - midEntry->when_alloc) > HZ) {\n\t\tif ((cifsFYI & CIFS_TIMER) && (midEntry->command != command)) {\n\t\t\tpr_debug(\" CIFS slow rsp: cmd %d mid %llu\",\n\t\t\t       midEntry->command, midEntry->mid);\n\t\t\tpr_info(\" A: 0x%lx S: 0x%lx R: 0x%lx\\n\",\n\t\t\t       now - midEntry->when_alloc,\n\t\t\t       now - midEntry->when_sent,\n\t\t\t       now - midEntry->when_received);\n\t\t}\n\t}\n#endif\n\tmempool_free(midEntry, cifs_mid_poolp);\n}"
  },
  {
    "function_name": "AllocMidQEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "46-81",
    "snippet": "struct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&midCount"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"For smb_command %d\\n\"",
            "smb_buffer->Command"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "smb_buffer->Command"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mid",
          "args": [
            "smb_buffer"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "get_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "681-685",
          "snippet": "static inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "temp",
            "0",
            "sizeof(struct mid_q_entry)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "cifs_mid_poolp",
            "GFP_NOFS"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Null TCP session in AllocMidQEntry\\n\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nstruct mid_q_entry *\nAllocMidQEntry(const struct smb_hdr *smb_buffer, struct TCP_Server_Info *server)\n{\n\tstruct mid_q_entry *temp;\n\n\tif (server == NULL) {\n\t\tcifs_dbg(VFS, \"Null TCP session in AllocMidQEntry\\n\");\n\t\treturn NULL;\n\t}\n\n\ttemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\n\tif (temp == NULL)\n\t\treturn temp;\n\telse {\n\t\tmemset(temp, 0, sizeof(struct mid_q_entry));\n\t\ttemp->mid = get_mid(smb_buffer);\n\t\ttemp->pid = current->pid;\n\t\ttemp->command = cpu_to_le16(smb_buffer->Command);\n\t\tcifs_dbg(FYI, \"For smb_command %d\\n\", smb_buffer->Command);\n\t/*\tdo_gettimeofday(&temp->when_sent);*/ /* easier to use jiffies */\n\t\t/* when mid allocated can be before when sent */\n\t\ttemp->when_alloc = jiffies;\n\t\ttemp->server = server;\n\n\t\t/*\n\t\t * The default is for the mid to be synchronous, so the\n\t\t * default callback just wakes up the current task.\n\t\t */\n\t\ttemp->callback = cifs_wake_up_task;\n\t\ttemp->callback_data = current;\n\t}\n\n\tatomic_inc(&midCount);\n\ttemp->mid_state = MID_REQUEST_ALLOCATED;\n\treturn temp;\n}"
  },
  {
    "function_name": "cifs_wake_up_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
    "lines": "40-44",
    "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/mempool.h>",
      "#include <asm/processor.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/highmem.h>",
      "#include <linux/tcp.h>",
      "#include <linux/freezer.h>",
      "#include <linux/delay.h>",
      "#include <linux/net.h>",
      "#include <linux/wait.h>",
      "#include <linux/gfp.h>",
      "#include <linux/list.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "mid->callback_data"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
  }
]