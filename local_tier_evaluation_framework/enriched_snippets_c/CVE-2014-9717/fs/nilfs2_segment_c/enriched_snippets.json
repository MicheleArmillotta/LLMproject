[
  {
    "function_name": "nilfs_detach_log_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2737-2759",
    "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_dispose_list",
          "args": [
            "nilfs",
            "&garbage_list",
            "1"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "713-744",
          "snippet": "static void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */"
          ],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sb",
            "__func__",
            "\"Hit dirty file after stopped log writer\\n\""
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&nilfs->ns_dirty_files",
            "&garbage_list"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nilfs->ns_dirty_files"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_destroy",
          "args": [
            "nilfs->ns_writer"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2649-2689",
          "snippet": "static void nilfs_segctor_destroy(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint flag;\n\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tspin_lock(&sci->sc_state_lock);\n\tnilfs_segctor_kill_thread(sci);\n\tflag = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) || sci->sc_flush_request\n\t\t|| sci->sc_seq_request != sci->sc_seq_done);\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (flush_work(&sci->sc_iput_work))\n\t\tflag = true;\n\n\tif (flag || !nilfs_segctor_confirm(sci))\n\t\tnilfs_segctor_write_out(sci);\n\n\tif (!list_empty(&sci->sc_dirty_files)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"dirty file(s) after the final construction\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_dirty_files, 1);\n\t}\n\n\tif (!list_empty(&sci->sc_iput_queue)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"iput queue is not empty\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 1);\n\t}\n\n\tWARN_ON(!list_empty(&sci->sc_segbufs));\n\tWARN_ON(!list_empty(&sci->sc_write_logs));\n\n\tnilfs_put_root(sci->sc_root);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tdel_timer_sync(&sci->sc_timer);\n\tkfree(sci);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_destroy(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint flag;\n\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tspin_lock(&sci->sc_state_lock);\n\tnilfs_segctor_kill_thread(sci);\n\tflag = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) || sci->sc_flush_request\n\t\t|| sci->sc_seq_request != sci->sc_seq_done);\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (flush_work(&sci->sc_iput_work))\n\t\tflag = true;\n\n\tif (flag || !nilfs_segctor_confirm(sci))\n\t\tnilfs_segctor_write_out(sci);\n\n\tif (!list_empty(&sci->sc_dirty_files)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"dirty file(s) after the final construction\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_dirty_files, 1);\n\t}\n\n\tif (!list_empty(&sci->sc_iput_queue)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"iput queue is not empty\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 1);\n\t}\n\n\tWARN_ON(!list_empty(&sci->sc_segbufs));\n\tWARN_ON(!list_empty(&sci->sc_write_logs));\n\n\tnilfs_put_root(sci->sc_root);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tdel_timer_sync(&sci->sc_timer);\n\tkfree(sci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "garbage_list"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
  },
  {
    "function_name": "nilfs_attach_log_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2704-2728",
    "snippet": "int nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nilfs->ns_writer"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_start_thread",
          "args": [
            "nilfs->ns_writer"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_start_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2552-2566",
          "snippet": "static int nilfs_segctor_start_thread(struct nilfs_sc_info *sci)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(nilfs_segctor_thread, sci, \"segctord\");\n\tif (IS_ERR(t)) {\n\t\tint err = PTR_ERR(t);\n\n\t\tprintk(KERN_ERR \"NILFS: error %d creating segctord thread\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n\twait_event(sci->sc_wait_task, sci->sc_task != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_start_thread(struct nilfs_sc_info *sci)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(nilfs_segctor_thread, sci, \"segctord\");\n\tif (IS_ERR(t)) {\n\t\tint err = PTR_ERR(t);\n\n\t\tprintk(KERN_ERR \"NILFS: error %d creating segctord thread\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n\twait_event(sci->sc_wait_task, sci->sc_task != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_new",
          "args": [
            "sb",
            "root"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2585-2621",
          "snippet": "static struct nilfs_sc_info *nilfs_segctor_new(struct super_block *sb,\n\t\t\t\t\t       struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci;\n\n\tsci = kzalloc(sizeof(*sci), GFP_KERNEL);\n\tif (!sci)\n\t\treturn NULL;\n\n\tsci->sc_super = sb;\n\n\tnilfs_get_root(root);\n\tsci->sc_root = root;\n\n\tinit_waitqueue_head(&sci->sc_wait_request);\n\tinit_waitqueue_head(&sci->sc_wait_daemon);\n\tinit_waitqueue_head(&sci->sc_wait_task);\n\tspin_lock_init(&sci->sc_state_lock);\n\tINIT_LIST_HEAD(&sci->sc_dirty_files);\n\tINIT_LIST_HEAD(&sci->sc_segbufs);\n\tINIT_LIST_HEAD(&sci->sc_write_logs);\n\tINIT_LIST_HEAD(&sci->sc_gc_inodes);\n\tINIT_LIST_HEAD(&sci->sc_iput_queue);\n\tINIT_WORK(&sci->sc_iput_work, nilfs_iput_work_func);\n\tinit_timer(&sci->sc_timer);\n\n\tsci->sc_interval = HZ * NILFS_SC_DEFAULT_TIMEOUT;\n\tsci->sc_mjcp_freq = HZ * NILFS_SC_DEFAULT_SR_FREQ;\n\tsci->sc_watermark = NILFS_SC_DEFAULT_WATERMARK;\n\n\tif (nilfs->ns_interval)\n\t\tsci->sc_interval = HZ * nilfs->ns_interval;\n\tif (nilfs->ns_watermark)\n\t\tsci->sc_watermark = nilfs->ns_watermark;\n\treturn sci;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic struct nilfs_sc_info *nilfs_segctor_new(struct super_block *sb,\n\t\t\t\t\t       struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci;\n\n\tsci = kzalloc(sizeof(*sci), GFP_KERNEL);\n\tif (!sci)\n\t\treturn NULL;\n\n\tsci->sc_super = sb;\n\n\tnilfs_get_root(root);\n\tsci->sc_root = root;\n\n\tinit_waitqueue_head(&sci->sc_wait_request);\n\tinit_waitqueue_head(&sci->sc_wait_daemon);\n\tinit_waitqueue_head(&sci->sc_wait_task);\n\tspin_lock_init(&sci->sc_state_lock);\n\tINIT_LIST_HEAD(&sci->sc_dirty_files);\n\tINIT_LIST_HEAD(&sci->sc_segbufs);\n\tINIT_LIST_HEAD(&sci->sc_write_logs);\n\tINIT_LIST_HEAD(&sci->sc_gc_inodes);\n\tINIT_LIST_HEAD(&sci->sc_iput_queue);\n\tINIT_WORK(&sci->sc_iput_work, nilfs_iput_work_func);\n\tinit_timer(&sci->sc_timer);\n\n\tsci->sc_interval = HZ * NILFS_SC_DEFAULT_TIMEOUT;\n\tsci->sc_mjcp_freq = HZ * NILFS_SC_DEFAULT_SR_FREQ;\n\tsci->sc_watermark = NILFS_SC_DEFAULT_WATERMARK;\n\n\tif (nilfs->ns_interval)\n\t\tsci->sc_interval = HZ * nilfs->ns_interval;\n\tif (nilfs->ns_watermark)\n\t\tsci->sc_watermark = nilfs->ns_watermark;\n\treturn sci;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_detach_log_writer",
          "args": [
            "sb"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_detach_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2737-2759",
          "snippet": "void nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_detach_log_writer(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tLIST_HEAD(garbage_list);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (nilfs->ns_writer) {\n\t\tnilfs_segctor_destroy(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\n\t/* Force to free the list of dirty files */\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!list_empty(&nilfs->ns_dirty_files)) {\n\t\tlist_splice_init(&nilfs->ns_dirty_files, &garbage_list);\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"Hit dirty file after stopped log writer\\n\");\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tnilfs_dispose_list(nilfs, &garbage_list, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_attach_log_writer(struct super_block *sb, struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err;\n\n\tif (nilfs->ns_writer) {\n\t\t/*\n\t\t * This happens if the filesystem was remounted\n\t\t * read/write after nilfs_error degenerated it into a\n\t\t * read-only mount.\n\t\t */\n\t\tnilfs_detach_log_writer(sb);\n\t}\n\n\tnilfs->ns_writer = nilfs_segctor_new(sb, root);\n\tif (!nilfs->ns_writer)\n\t\treturn -ENOMEM;\n\n\terr = nilfs_segctor_start_thread(nilfs->ns_writer);\n\tif (err) {\n\t\tkfree(nilfs->ns_writer);\n\t\tnilfs->ns_writer = NULL;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2649-2689",
    "snippet": "static void nilfs_segctor_destroy(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint flag;\n\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tspin_lock(&sci->sc_state_lock);\n\tnilfs_segctor_kill_thread(sci);\n\tflag = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) || sci->sc_flush_request\n\t\t|| sci->sc_seq_request != sci->sc_seq_done);\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (flush_work(&sci->sc_iput_work))\n\t\tflag = true;\n\n\tif (flag || !nilfs_segctor_confirm(sci))\n\t\tnilfs_segctor_write_out(sci);\n\n\tif (!list_empty(&sci->sc_dirty_files)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"dirty file(s) after the final construction\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_dirty_files, 1);\n\t}\n\n\tif (!list_empty(&sci->sc_iput_queue)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"iput queue is not empty\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 1);\n\t}\n\n\tWARN_ON(!list_empty(&sci->sc_segbufs));\n\tWARN_ON(!list_empty(&sci->sc_write_logs));\n\n\tnilfs_put_root(sci->sc_root);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tdel_timer_sync(&sci->sc_timer);\n\tkfree(sci);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sci"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sci->sc_timer"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_put_root",
          "args": [
            "sci->sc_root"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_put_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "801-815",
          "snippet": "void nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_put_root(struct nilfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->count)) {\n\t\tstruct the_nilfs *nilfs = root->nilfs;\n\n\t\tnilfs_sysfs_delete_snapshot_group(root);\n\n\t\tspin_lock(&nilfs->ns_cptree_lock);\n\t\trb_erase(&root->rb_node, &nilfs->ns_cptree);\n\t\tspin_unlock(&nilfs->ns_cptree_lock);\n\t\tiput(root->ifile);\n\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&sci->sc_write_logs)"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&sci->sc_segbufs)"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_dispose_list",
          "args": [
            "nilfs",
            "&sci->sc_iput_queue",
            "1"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "713-744",
          "snippet": "static void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */"
          ],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sci->sc_super",
            "__func__",
            "\"iput queue is not empty\\n\""
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_write_out",
          "args": [
            "sci"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_write_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2623-2639",
          "snippet": "static void nilfs_segctor_write_out(struct nilfs_sc_info *sci)\n{\n\tint ret, retrycount = NILFS_SC_CLEANUP_RETRY;\n\n\t/* The segctord thread was stopped and its timer was removed.\n\t   But some tasks remain. */\n\tdo {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\t\tret = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_transaction_unlock(sci->sc_super);\n\n\t\tflush_work(&sci->sc_iput_work);\n\n\t} while (ret && retrycount-- > 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_write_out(struct nilfs_sc_info *sci)\n{\n\tint ret, retrycount = NILFS_SC_CLEANUP_RETRY;\n\n\t/* The segctord thread was stopped and its timer was removed.\n\t   But some tasks remain. */\n\tdo {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\t\tret = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_transaction_unlock(sci->sc_super);\n\n\t\tflush_work(&sci->sc_iput_work);\n\n\t} while (ret && retrycount-- > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_confirm",
          "args": [
            "sci"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "779-793",
          "snippet": "static int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&sci->sc_iput_work"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_kill_thread",
          "args": [
            "sci"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2568-2580",
          "snippet": "static void nilfs_segctor_kill_thread(struct nilfs_sc_info *sci)\n\t__acquires(&sci->sc_state_lock)\n\t__releases(&sci->sc_state_lock)\n{\n\tsci->sc_state |= NILFS_SEGCTOR_QUIT;\n\n\twhile (sci->sc_task) {\n\t\twake_up(&sci->sc_wait_daemon);\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\twait_event(sci->sc_wait_task, sci->sc_task == NULL);\n\t\tspin_lock(&sci->sc_state_lock);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_kill_thread(struct nilfs_sc_info *sci)\n\t__acquires(&sci->sc_state_lock)\n\t__releases(&sci->sc_state_lock)\n{\n\tsci->sc_state |= NILFS_SEGCTOR_QUIT;\n\n\twhile (sci->sc_task) {\n\t\twake_up(&sci->sc_wait_daemon);\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\twait_event(sci->sc_wait_task, sci->sc_task == NULL);\n\t\tspin_lock(&sci->sc_state_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_destroy(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint flag;\n\n\tup_write(&nilfs->ns_segctor_sem);\n\n\tspin_lock(&sci->sc_state_lock);\n\tnilfs_segctor_kill_thread(sci);\n\tflag = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) || sci->sc_flush_request\n\t\t|| sci->sc_seq_request != sci->sc_seq_done);\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (flush_work(&sci->sc_iput_work))\n\t\tflag = true;\n\n\tif (flag || !nilfs_segctor_confirm(sci))\n\t\tnilfs_segctor_write_out(sci);\n\n\tif (!list_empty(&sci->sc_dirty_files)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"dirty file(s) after the final construction\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_dirty_files, 1);\n\t}\n\n\tif (!list_empty(&sci->sc_iput_queue)) {\n\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t      \"iput queue is not empty\\n\");\n\t\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 1);\n\t}\n\n\tWARN_ON(!list_empty(&sci->sc_segbufs));\n\tWARN_ON(!list_empty(&sci->sc_write_logs));\n\n\tnilfs_put_root(sci->sc_root);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\n\tdel_timer_sync(&sci->sc_timer);\n\tkfree(sci);\n}"
  },
  {
    "function_name": "nilfs_segctor_write_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2623-2639",
    "snippet": "static void nilfs_segctor_write_out(struct nilfs_sc_info *sci)\n{\n\tint ret, retrycount = NILFS_SC_CLEANUP_RETRY;\n\n\t/* The segctord thread was stopped and its timer was removed.\n\t   But some tasks remain. */\n\tdo {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\t\tret = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_transaction_unlock(sci->sc_super);\n\n\t\tflush_work(&sci->sc_iput_work);\n\n\t} while (ret && retrycount-- > 0);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&sci->sc_iput_work"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_unlock",
          "args": [
            "sci->sc_super"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "324-334",
          "snippet": "static void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_construct",
          "args": [
            "sci",
            "SC_LSEG_SR"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2299-2332",
          "snippet": "static int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_lock",
          "args": [
            "sci->sc_super",
            "&ti",
            "0"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "295-322",
          "snippet": "static void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_write_out(struct nilfs_sc_info *sci)\n{\n\tint ret, retrycount = NILFS_SC_CLEANUP_RETRY;\n\n\t/* The segctord thread was stopped and its timer was removed.\n\t   But some tasks remain. */\n\tdo {\n\t\tstruct nilfs_transaction_info ti;\n\n\t\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\t\tret = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_transaction_unlock(sci->sc_super);\n\n\t\tflush_work(&sci->sc_iput_work);\n\n\t} while (ret && retrycount-- > 0);\n}"
  },
  {
    "function_name": "nilfs_segctor_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2585-2621",
    "snippet": "static struct nilfs_sc_info *nilfs_segctor_new(struct super_block *sb,\n\t\t\t\t\t       struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci;\n\n\tsci = kzalloc(sizeof(*sci), GFP_KERNEL);\n\tif (!sci)\n\t\treturn NULL;\n\n\tsci->sc_super = sb;\n\n\tnilfs_get_root(root);\n\tsci->sc_root = root;\n\n\tinit_waitqueue_head(&sci->sc_wait_request);\n\tinit_waitqueue_head(&sci->sc_wait_daemon);\n\tinit_waitqueue_head(&sci->sc_wait_task);\n\tspin_lock_init(&sci->sc_state_lock);\n\tINIT_LIST_HEAD(&sci->sc_dirty_files);\n\tINIT_LIST_HEAD(&sci->sc_segbufs);\n\tINIT_LIST_HEAD(&sci->sc_write_logs);\n\tINIT_LIST_HEAD(&sci->sc_gc_inodes);\n\tINIT_LIST_HEAD(&sci->sc_iput_queue);\n\tINIT_WORK(&sci->sc_iput_work, nilfs_iput_work_func);\n\tinit_timer(&sci->sc_timer);\n\n\tsci->sc_interval = HZ * NILFS_SC_DEFAULT_TIMEOUT;\n\tsci->sc_mjcp_freq = HZ * NILFS_SC_DEFAULT_SR_FREQ;\n\tsci->sc_watermark = NILFS_SC_DEFAULT_WATERMARK;\n\n\tif (nilfs->ns_interval)\n\t\tsci->sc_interval = HZ * nilfs->ns_interval;\n\tif (nilfs->ns_watermark)\n\t\tsci->sc_watermark = nilfs->ns_watermark;\n\treturn sci;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_timer",
          "args": [
            "&sci->sc_timer"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sci->sc_iput_work",
            "nilfs_iput_work_func"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sci->sc_iput_queue"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sci->sc_gc_inodes"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sci->sc_dirty_files"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sci->sc_wait_task"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sci->sc_wait_daemon"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&sci->sc_wait_request"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_get_root",
          "args": [
            "root"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_get_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "304-307",
          "snippet": "static inline void nilfs_get_root(struct nilfs_root *root)\n{\n\tatomic_inc(&root->count);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void nilfs_get_root(struct nilfs_root *root)\n{\n\tatomic_inc(&root->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sci)",
            "GFP_KERNEL"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic struct nilfs_sc_info *nilfs_segctor_new(struct super_block *sb,\n\t\t\t\t\t       struct nilfs_root *root)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci;\n\n\tsci = kzalloc(sizeof(*sci), GFP_KERNEL);\n\tif (!sci)\n\t\treturn NULL;\n\n\tsci->sc_super = sb;\n\n\tnilfs_get_root(root);\n\tsci->sc_root = root;\n\n\tinit_waitqueue_head(&sci->sc_wait_request);\n\tinit_waitqueue_head(&sci->sc_wait_daemon);\n\tinit_waitqueue_head(&sci->sc_wait_task);\n\tspin_lock_init(&sci->sc_state_lock);\n\tINIT_LIST_HEAD(&sci->sc_dirty_files);\n\tINIT_LIST_HEAD(&sci->sc_segbufs);\n\tINIT_LIST_HEAD(&sci->sc_write_logs);\n\tINIT_LIST_HEAD(&sci->sc_gc_inodes);\n\tINIT_LIST_HEAD(&sci->sc_iput_queue);\n\tINIT_WORK(&sci->sc_iput_work, nilfs_iput_work_func);\n\tinit_timer(&sci->sc_timer);\n\n\tsci->sc_interval = HZ * NILFS_SC_DEFAULT_TIMEOUT;\n\tsci->sc_mjcp_freq = HZ * NILFS_SC_DEFAULT_SR_FREQ;\n\tsci->sc_watermark = NILFS_SC_DEFAULT_WATERMARK;\n\n\tif (nilfs->ns_interval)\n\t\tsci->sc_interval = HZ * nilfs->ns_interval;\n\tif (nilfs->ns_watermark)\n\t\tsci->sc_watermark = nilfs->ns_watermark;\n\treturn sci;\n}"
  },
  {
    "function_name": "nilfs_segctor_kill_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2568-2580",
    "snippet": "static void nilfs_segctor_kill_thread(struct nilfs_sc_info *sci)\n\t__acquires(&sci->sc_state_lock)\n\t__releases(&sci->sc_state_lock)\n{\n\tsci->sc_state |= NILFS_SEGCTOR_QUIT;\n\n\twhile (sci->sc_task) {\n\t\twake_up(&sci->sc_wait_daemon);\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\twait_event(sci->sc_wait_task, sci->sc_task == NULL);\n\t\tspin_lock(&sci->sc_state_lock);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sci->sc_wait_task",
            "sci->sc_task == NULL"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sci->sc_wait_daemon"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_kill_thread(struct nilfs_sc_info *sci)\n\t__acquires(&sci->sc_state_lock)\n\t__releases(&sci->sc_state_lock)\n{\n\tsci->sc_state |= NILFS_SEGCTOR_QUIT;\n\n\twhile (sci->sc_task) {\n\t\twake_up(&sci->sc_wait_daemon);\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\twait_event(sci->sc_wait_task, sci->sc_task == NULL);\n\t\tspin_lock(&sci->sc_state_lock);\n\t}\n}"
  },
  {
    "function_name": "nilfs_segctor_start_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2552-2566",
    "snippet": "static int nilfs_segctor_start_thread(struct nilfs_sc_info *sci)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(nilfs_segctor_thread, sci, \"segctord\");\n\tif (IS_ERR(t)) {\n\t\tint err = PTR_ERR(t);\n\n\t\tprintk(KERN_ERR \"NILFS: error %d creating segctord thread\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n\twait_event(sci->sc_wait_task, sci->sc_task != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "sci->sc_wait_task",
            "sci->sc_task != NULL"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NILFS: error %d creating segctord thread\\n\"",
            "err"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "nilfs_segctor_thread",
            "sci",
            "\"segctord\""
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_start_thread(struct nilfs_sc_info *sci)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(nilfs_segctor_thread, sci, \"segctord\");\n\tif (IS_ERR(t)) {\n\t\tint err = PTR_ERR(t);\n\n\t\tprintk(KERN_ERR \"NILFS: error %d creating segctord thread\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n\twait_event(sci->sc_wait_task, sci->sc_task != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2471-2550",
    "snippet": "static int nilfs_segctor_thread(void *arg)\n{\n\tstruct nilfs_sc_info *sci = (struct nilfs_sc_info *)arg;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint timeout = 0;\n\n\tsci->sc_timer.data = (unsigned long)current;\n\tsci->sc_timer.function = nilfs_construction_timeout;\n\n\t/* start sync. */\n\tsci->sc_task = current;\n\twake_up(&sci->sc_wait_task); /* for nilfs_segctor_start_thread() */\n\tprintk(KERN_INFO\n\t       \"segctord starting. Construction interval = %lu seconds, \"\n\t       \"CP frequency < %lu seconds\\n\",\n\t       sci->sc_interval / HZ, sci->sc_mjcp_freq / HZ);\n\n\tspin_lock(&sci->sc_state_lock);\n loop:\n\tfor (;;) {\n\t\tint mode;\n\n\t\tif (sci->sc_state & NILFS_SEGCTOR_QUIT)\n\t\t\tgoto end_thread;\n\n\t\tif (timeout || sci->sc_seq_request != sci->sc_seq_done)\n\t\t\tmode = SC_LSEG_SR;\n\t\telse if (!sci->sc_flush_request)\n\t\t\tbreak;\n\t\telse\n\t\t\tmode = nilfs_segctor_flush_mode(sci);\n\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\tnilfs_segctor_thread_construct(sci, mode);\n\t\tspin_lock(&sci->sc_state_lock);\n\t\ttimeout = 0;\n\t}\n\n\n\tif (freezing(current)) {\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\ttry_to_freeze();\n\t\tspin_lock(&sci->sc_state_lock);\n\t} else {\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&sci->sc_wait_daemon, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\tif (sci->sc_seq_request != sci->sc_seq_done)\n\t\t\tshould_sleep = 0;\n\t\telse if (sci->sc_flush_request)\n\t\t\tshould_sleep = 0;\n\t\telse if (sci->sc_state & NILFS_SEGCTOR_COMMIT)\n\t\t\tshould_sleep = time_before(jiffies,\n\t\t\t\t\tsci->sc_timer.expires);\n\n\t\tif (should_sleep) {\n\t\t\tspin_unlock(&sci->sc_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&sci->sc_state_lock);\n\t\t}\n\t\tfinish_wait(&sci->sc_wait_daemon, &wait);\n\t\ttimeout = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t\t   time_after_eq(jiffies, sci->sc_timer.expires));\n\n\t\tif (nilfs_sb_dirty(nilfs) && nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\tgoto loop;\n\n end_thread:\n\tspin_unlock(&sci->sc_state_lock);\n\n\t/* end sync. */\n\tsci->sc_task = NULL;\n\twake_up(&sci->sc_wait_task); /* for nilfs_segctor_kill_thread() */\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sci->sc_wait_task"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sb_need_update",
          "args": [
            "nilfs"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb_need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "273-278",
          "snippet": "static inline int nilfs_sb_need_update(struct the_nilfs *nilfs)\n{\n\tu64 t = get_seconds();\n\treturn t < nilfs->ns_sbwtime ||\n\t\tt > nilfs->ns_sbwtime + nilfs->ns_sb_update_freq;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_sb_need_update(struct the_nilfs *nilfs)\n{\n\tu64 t = get_seconds();\n\treturn t < nilfs->ns_sbwtime ||\n\t\tt > nilfs->ns_sbwtime + nilfs->ns_sb_update_freq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sb_dirty",
          "args": [
            "nilfs"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "sci->sc_timer.expires"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&sci->sc_wait_daemon",
            "&wait"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sci->sc_timer.expires"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&sci->sc_wait_daemon",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_thread_construct",
          "args": [
            "sci",
            "mode"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_thread_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2413-2429",
          "snippet": "static void nilfs_segctor_thread_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_transaction_info ti;\n\n\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\tnilfs_segctor_construct(sci, mode);\n\n\t/*\n\t * Unclosed segment should be retried.  We do this using sc_timer.\n\t * Timeout of sc_timer will invoke complete construction which leads\n\t * to close the current logical segment.\n\t */\n\tif (test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags))\n\t\tnilfs_segctor_start_timer(sci);\n\n\tnilfs_transaction_unlock(sci->sc_super);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_thread_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_transaction_info ti;\n\n\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\tnilfs_segctor_construct(sci, mode);\n\n\t/*\n\t * Unclosed segment should be retried.  We do this using sc_timer.\n\t * Timeout of sc_timer will invoke complete construction which leads\n\t * to close the current logical segment.\n\t */\n\tif (test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags))\n\t\tnilfs_segctor_start_timer(sci);\n\n\tnilfs_transaction_unlock(sci->sc_super);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_flush_mode",
          "args": [
            "sci"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_flush_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2452-2462",
          "snippet": "static int nilfs_segctor_flush_mode(struct nilfs_sc_info *sci)\n{\n\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    time_before(jiffies, sci->sc_lseg_stime + sci->sc_mjcp_freq)) {\n\t\tif (!(sci->sc_flush_request & ~FLUSH_FILE_BIT))\n\t\t\treturn SC_FLUSH_FILE;\n\t\telse if (!(sci->sc_flush_request & ~FLUSH_DAT_BIT))\n\t\t\treturn SC_FLUSH_DAT;\n\t}\n\treturn SC_LSEG_SR;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
            "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_flush_mode(struct nilfs_sc_info *sci)\n{\n\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    time_before(jiffies, sci->sc_lseg_stime + sci->sc_mjcp_freq)) {\n\t\tif (!(sci->sc_flush_request & ~FLUSH_FILE_BIT))\n\t\t\treturn SC_FLUSH_FILE;\n\t\telse if (!(sci->sc_flush_request & ~FLUSH_DAT_BIT))\n\t\t\treturn SC_FLUSH_DAT;\n\t}\n\treturn SC_LSEG_SR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t       \"segctord starting. Construction interval = %lu seconds, \"\n\t       \"CP frequency < %lu seconds\\n\"",
            "sci->sc_interval / HZ",
            "sci->sc_mjcp_freq / HZ"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_thread(void *arg)\n{\n\tstruct nilfs_sc_info *sci = (struct nilfs_sc_info *)arg;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint timeout = 0;\n\n\tsci->sc_timer.data = (unsigned long)current;\n\tsci->sc_timer.function = nilfs_construction_timeout;\n\n\t/* start sync. */\n\tsci->sc_task = current;\n\twake_up(&sci->sc_wait_task); /* for nilfs_segctor_start_thread() */\n\tprintk(KERN_INFO\n\t       \"segctord starting. Construction interval = %lu seconds, \"\n\t       \"CP frequency < %lu seconds\\n\",\n\t       sci->sc_interval / HZ, sci->sc_mjcp_freq / HZ);\n\n\tspin_lock(&sci->sc_state_lock);\n loop:\n\tfor (;;) {\n\t\tint mode;\n\n\t\tif (sci->sc_state & NILFS_SEGCTOR_QUIT)\n\t\t\tgoto end_thread;\n\n\t\tif (timeout || sci->sc_seq_request != sci->sc_seq_done)\n\t\t\tmode = SC_LSEG_SR;\n\t\telse if (!sci->sc_flush_request)\n\t\t\tbreak;\n\t\telse\n\t\t\tmode = nilfs_segctor_flush_mode(sci);\n\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\tnilfs_segctor_thread_construct(sci, mode);\n\t\tspin_lock(&sci->sc_state_lock);\n\t\ttimeout = 0;\n\t}\n\n\n\tif (freezing(current)) {\n\t\tspin_unlock(&sci->sc_state_lock);\n\t\ttry_to_freeze();\n\t\tspin_lock(&sci->sc_state_lock);\n\t} else {\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&sci->sc_wait_daemon, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\n\t\tif (sci->sc_seq_request != sci->sc_seq_done)\n\t\t\tshould_sleep = 0;\n\t\telse if (sci->sc_flush_request)\n\t\t\tshould_sleep = 0;\n\t\telse if (sci->sc_state & NILFS_SEGCTOR_COMMIT)\n\t\t\tshould_sleep = time_before(jiffies,\n\t\t\t\t\tsci->sc_timer.expires);\n\n\t\tif (should_sleep) {\n\t\t\tspin_unlock(&sci->sc_state_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&sci->sc_state_lock);\n\t\t}\n\t\tfinish_wait(&sci->sc_wait_daemon, &wait);\n\t\ttimeout = ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t\t   time_after_eq(jiffies, sci->sc_timer.expires));\n\n\t\tif (nilfs_sb_dirty(nilfs) && nilfs_sb_need_update(nilfs))\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\tgoto loop;\n\n end_thread:\n\tspin_unlock(&sci->sc_state_lock);\n\n\t/* end sync. */\n\tsci->sc_task = NULL;\n\twake_up(&sci->sc_wait_task); /* for nilfs_segctor_kill_thread() */\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_flush_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2452-2462",
    "snippet": "static int nilfs_segctor_flush_mode(struct nilfs_sc_info *sci)\n{\n\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    time_before(jiffies, sci->sc_lseg_stime + sci->sc_mjcp_freq)) {\n\t\tif (!(sci->sc_flush_request & ~FLUSH_FILE_BIT))\n\t\t\treturn SC_FLUSH_FILE;\n\t\telse if (!(sci->sc_flush_request & ~FLUSH_DAT_BIT))\n\t\t\treturn SC_FLUSH_DAT;\n\t}\n\treturn SC_LSEG_SR;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
      "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sci->sc_lseg_stime + sci->sc_mjcp_freq"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_UNCLOSED",
            "&sci->sc_flags"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_flush_mode(struct nilfs_sc_info *sci)\n{\n\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    time_before(jiffies, sci->sc_lseg_stime + sci->sc_mjcp_freq)) {\n\t\tif (!(sci->sc_flush_request & ~FLUSH_FILE_BIT))\n\t\t\treturn SC_FLUSH_FILE;\n\t\telse if (!(sci->sc_flush_request & ~FLUSH_DAT_BIT))\n\t\t\treturn SC_FLUSH_DAT;\n\t}\n\treturn SC_LSEG_SR;\n}"
  },
  {
    "function_name": "nilfs_segctor_do_immediate_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2431-2450",
    "snippet": "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
      "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_SC_PRIOR_FLUSH",
            "&sci->sc_flags"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_construct",
          "args": [
            "sci",
            "mode"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1945-2039",
          "snippet": "static int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)",
            "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}"
  },
  {
    "function_name": "nilfs_segctor_thread_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2413-2429",
    "snippet": "static void nilfs_segctor_thread_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_transaction_info ti;\n\n\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\tnilfs_segctor_construct(sci, mode);\n\n\t/*\n\t * Unclosed segment should be retried.  We do this using sc_timer.\n\t * Timeout of sc_timer will invoke complete construction which leads\n\t * to close the current logical segment.\n\t */\n\tif (test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags))\n\t\tnilfs_segctor_start_timer(sci);\n\n\tnilfs_transaction_unlock(sci->sc_super);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_unlock",
          "args": [
            "sci->sc_super"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "324-334",
          "snippet": "static void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_start_timer",
          "args": [
            "sci"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_start_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2049-2058",
          "snippet": "static void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_UNCLOSED",
            "&sci->sc_flags"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_construct",
          "args": [
            "sci",
            "mode"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2299-2332",
          "snippet": "static int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_lock",
          "args": [
            "sci->sc_super",
            "&ti",
            "0"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "295-322",
          "snippet": "static void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_thread_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_transaction_info ti;\n\n\tnilfs_transaction_lock(sci->sc_super, &ti, 0);\n\tnilfs_segctor_construct(sci, mode);\n\n\t/*\n\t * Unclosed segment should be retried.  We do this using sc_timer.\n\t * Timeout of sc_timer will invoke complete construction which leads\n\t * to close the current logical segment.\n\t */\n\tif (test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags))\n\t\tnilfs_segctor_start_timer(sci);\n\n\tnilfs_transaction_unlock(sci->sc_super);\n}"
  },
  {
    "function_name": "nilfs_clean_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2355-2411",
    "snippet": "int nilfs_clean_segments(struct super_block *sb, struct nilfs_argv *argv,\n\t\t\t void **kbufs)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\tif (unlikely(!sci))\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 1);\n\n\terr = nilfs_mdt_save_to_shadow_map(nilfs->ns_dat);\n\tif (unlikely(err))\n\t\tgoto out_unlock;\n\n\terr = nilfs_ioctl_prepare_clean_segments(nilfs, argv, kbufs);\n\tif (unlikely(err)) {\n\t\tnilfs_mdt_restore_from_shadow_map(nilfs->ns_dat);\n\t\tgoto out_unlock;\n\t}\n\n\tsci->sc_freesegs = kbufs[4];\n\tsci->sc_nfreesegs = argv[4].v_nmembs;\n\tlist_splice_tail_init(&nilfs->ns_gc_inodes, &sci->sc_gc_inodes);\n\n\tfor (;;) {\n\t\terr = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_remove_written_gcinodes(nilfs, &sci->sc_gc_inodes);\n\n\t\tif (likely(!err))\n\t\t\tbreak;\n\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"segment construction failed. (err=%d)\", err);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(sci->sc_interval);\n\t}\n\tif (nilfs_test_opt(nilfs, DISCARD)) {\n\t\tint ret = nilfs_discard_segments(nilfs, sci->sc_freesegs,\n\t\t\t\t\t\t sci->sc_nfreesegs);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: error %d on discard request, \"\n\t\t\t       \"turning discards off for the device\\n\", ret);\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t}\n\t}\n\n out_unlock:\n\tsci->sc_freesegs = NULL;\n\tsci->sc_nfreesegs = 0;\n\tnilfs_mdt_clear_shadow_map(nilfs->ns_dat);\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_unlock",
          "args": [
            "sb"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "324-334",
          "snippet": "static void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_clear_shadow_map",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_clear_shadow_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "588-598",
          "snippet": "void nilfs_mdt_clear_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\tnilfs_release_frozen_buffers(shadow);\n\ttruncate_inode_pages(&shadow->frozen_data, 0);\n\ttruncate_inode_pages(&shadow->frozen_btnodes, 0);\n\tup_write(&mi->mi_sem);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_clear_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\tnilfs_release_frozen_buffers(shadow);\n\ttruncate_inode_pages(&shadow->frozen_data, 0);\n\ttruncate_inode_pages(&shadow->frozen_btnodes, 0);\n\tup_write(&mi->mi_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_opt",
          "args": [
            "nilfs",
            "DISCARD"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t       \"NILFS warning: error %d on discard request, \"\n\t\t\t       \"turning discards off for the device\\n\"",
            "ret"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_discard_segments",
          "args": [
            "nilfs",
            "sci->sc_freesegs",
            "sci->sc_nfreesegs"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_discard_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "660-695",
          "snippet": "int nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\n\t\t\t    size_t nsegs)\n{\n\tsector_t seg_start, seg_end;\n\tsector_t start = 0, nblocks = 0;\n\tunsigned int sects_per_block;\n\t__u64 *sn;\n\tint ret = 0;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tfor (sn = segnump; sn < segnump + nsegs; sn++) {\n\t\tnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\n\n\t\tif (!nblocks) {\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t} else if (start + nblocks == seg_start) {\n\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t} else {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t\t   GFP_NOFS, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tnblocks = 0;\n\t\t}\n\t}\n\tif (nblocks)\n\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t   GFP_NOFS, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_discard_segments(struct the_nilfs *nilfs, __u64 *segnump,\n\t\t\t    size_t nsegs)\n{\n\tsector_t seg_start, seg_end;\n\tsector_t start = 0, nblocks = 0;\n\tunsigned int sects_per_block;\n\t__u64 *sn;\n\tint ret = 0;\n\n\tsects_per_block = (1 << nilfs->ns_blocksize_bits) /\n\t\tbdev_logical_block_size(nilfs->ns_bdev);\n\tfor (sn = segnump; sn < segnump + nsegs; sn++) {\n\t\tnilfs_get_segment_range(nilfs, *sn, &seg_start, &seg_end);\n\n\t\tif (!nblocks) {\n\t\t\tstart = seg_start;\n\t\t\tnblocks = seg_end - seg_start + 1;\n\t\t} else if (start + nblocks == seg_start) {\n\t\t\tnblocks += seg_end - seg_start + 1;\n\t\t} else {\n\t\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t\t   GFP_NOFS, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tnblocks = 0;\n\t\t}\n\t}\n\tif (nblocks)\n\t\tret = blkdev_issue_discard(nilfs->ns_bdev,\n\t\t\t\t\t   start * sects_per_block,\n\t\t\t\t\t   nblocks * sects_per_block,\n\t\t\t\t\t   GFP_NOFS, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "DISCARD"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "sci->sc_interval"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sb",
            "__func__",
            "\"segment construction failed. (err=%d)\"",
            "err"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_remove_written_gcinodes",
          "args": [
            "nilfs",
            "&sci->sc_gc_inodes"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_remove_written_gcinodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2340-2353",
          "snippet": "static void\nnilfs_remove_written_gcinodes(struct the_nilfs *nilfs, struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\n\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\tif (!test_bit(NILFS_I_UPDATED, &ii->i_state))\n\t\t\tcontinue;\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void\nnilfs_remove_written_gcinodes(struct the_nilfs *nilfs, struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\n\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\tif (!test_bit(NILFS_I_UPDATED, &ii->i_state))\n\t\t\tcontinue;\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_construct",
          "args": [
            "sci",
            "SC_LSEG_SR"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2299-2332",
          "snippet": "static int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&nilfs->ns_gc_inodes",
            "&sci->sc_gc_inodes"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_restore_from_shadow_map",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_restore_from_shadow_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "562-582",
          "snippet": "void nilfs_mdt_restore_from_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\n\tif (mi->mi_palloc_cache)\n\t\tnilfs_palloc_clear_cache(inode);\n\n\tnilfs_clear_dirty_pages(inode->i_mapping, true);\n\tnilfs_copy_back_pages(inode->i_mapping, &shadow->frozen_data);\n\n\tnilfs_clear_dirty_pages(&ii->i_btnode_cache, true);\n\tnilfs_copy_back_pages(&ii->i_btnode_cache, &shadow->frozen_btnodes);\n\n\tnilfs_bmap_restore(ii->i_bmap, &shadow->bmap_store);\n\n\tup_write(&mi->mi_sem);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_mdt_restore_from_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\n\tdown_write(&mi->mi_sem);\n\n\tif (mi->mi_palloc_cache)\n\t\tnilfs_palloc_clear_cache(inode);\n\n\tnilfs_clear_dirty_pages(inode->i_mapping, true);\n\tnilfs_copy_back_pages(inode->i_mapping, &shadow->frozen_data);\n\n\tnilfs_clear_dirty_pages(&ii->i_btnode_cache, true);\n\tnilfs_copy_back_pages(&ii->i_btnode_cache, &shadow->frozen_btnodes);\n\n\tnilfs_bmap_restore(ii->i_bmap, &shadow->bmap_store);\n\n\tup_write(&mi->mi_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ioctl_prepare_clean_segments",
          "args": [
            "nilfs",
            "argv",
            "kbufs"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_prepare_clean_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "821-859",
          "snippet": "int nilfs_ioctl_prepare_clean_segments(struct the_nilfs *nilfs,\n\t\t\t\t       struct nilfs_argv *argv, void **kbufs)\n{\n\tconst char *msg;\n\tint ret;\n\n\tret = nilfs_ioctl_delete_checkpoints(nilfs, &argv[1], kbufs[1]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because checkpoints can be removed\n\t\t * independently.\n\t\t */\n\t\tmsg = \"cannot delete checkpoints\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_free_vblocknrs(nilfs, &argv[2], kbufs[2]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because DAT file is updated atomically\n\t\t * using a copy-on-write technique.\n\t\t */\n\t\tmsg = \"cannot delete virtual blocks from DAT file\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_mark_blocks_dirty(nilfs, &argv[3], kbufs[3]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because the operation is nondestructive.\n\t\t */\n\t\tmsg = \"cannot mark copying blocks dirty\";\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tprintk(KERN_ERR \"NILFS: GC failed during preparation: %s: err=%d\\n\",\n\t       msg, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nint nilfs_ioctl_prepare_clean_segments(struct the_nilfs *nilfs,\n\t\t\t\t       struct nilfs_argv *argv, void **kbufs)\n{\n\tconst char *msg;\n\tint ret;\n\n\tret = nilfs_ioctl_delete_checkpoints(nilfs, &argv[1], kbufs[1]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because checkpoints can be removed\n\t\t * independently.\n\t\t */\n\t\tmsg = \"cannot delete checkpoints\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_free_vblocknrs(nilfs, &argv[2], kbufs[2]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because DAT file is updated atomically\n\t\t * using a copy-on-write technique.\n\t\t */\n\t\tmsg = \"cannot delete virtual blocks from DAT file\";\n\t\tgoto failed;\n\t}\n\tret = nilfs_ioctl_mark_blocks_dirty(nilfs, &argv[3], kbufs[3]);\n\tif (ret < 0) {\n\t\t/*\n\t\t * can safely abort because the operation is nondestructive.\n\t\t */\n\t\tmsg = \"cannot mark copying blocks dirty\";\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tprintk(KERN_ERR \"NILFS: GC failed during preparation: %s: err=%d\\n\",\n\t       msg, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_save_to_shadow_map",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_save_to_shadow_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "473-492",
          "snippet": "int nilfs_mdt_save_to_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\tint ret;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_data, inode->i_mapping);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_btnodes,\n\t\t\t\t     &ii->i_btnode_cache);\n\tif (ret)\n\t\tgoto out;\n\n\tnilfs_bmap_save(ii->i_bmap, &shadow->bmap_store);\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_save_to_shadow_map(struct inode *inode)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct nilfs_shadow_map *shadow = mi->mi_shadow;\n\tint ret;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_data, inode->i_mapping);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nilfs_copy_dirty_pages(&shadow->frozen_btnodes,\n\t\t\t\t     &ii->i_btnode_cache);\n\tif (ret)\n\t\tgoto out;\n\n\tnilfs_bmap_save(ii->i_bmap, &shadow->bmap_store);\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_lock",
          "args": [
            "sb",
            "&ti",
            "1"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "295-322",
          "snippet": "static void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sci"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_clean_segments(struct super_block *sb, struct nilfs_argv *argv,\n\t\t\t void **kbufs)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info ti;\n\tint err;\n\n\tif (unlikely(!sci))\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 1);\n\n\terr = nilfs_mdt_save_to_shadow_map(nilfs->ns_dat);\n\tif (unlikely(err))\n\t\tgoto out_unlock;\n\n\terr = nilfs_ioctl_prepare_clean_segments(nilfs, argv, kbufs);\n\tif (unlikely(err)) {\n\t\tnilfs_mdt_restore_from_shadow_map(nilfs->ns_dat);\n\t\tgoto out_unlock;\n\t}\n\n\tsci->sc_freesegs = kbufs[4];\n\tsci->sc_nfreesegs = argv[4].v_nmembs;\n\tlist_splice_tail_init(&nilfs->ns_gc_inodes, &sci->sc_gc_inodes);\n\n\tfor (;;) {\n\t\terr = nilfs_segctor_construct(sci, SC_LSEG_SR);\n\t\tnilfs_remove_written_gcinodes(nilfs, &sci->sc_gc_inodes);\n\n\t\tif (likely(!err))\n\t\t\tbreak;\n\n\t\tnilfs_warning(sb, __func__,\n\t\t\t      \"segment construction failed. (err=%d)\", err);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(sci->sc_interval);\n\t}\n\tif (nilfs_test_opt(nilfs, DISCARD)) {\n\t\tint ret = nilfs_discard_segments(nilfs, sci->sc_freesegs,\n\t\t\t\t\t\t sci->sc_nfreesegs);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: error %d on discard request, \"\n\t\t\t       \"turning discards off for the device\\n\", ret);\n\t\t\tnilfs_clear_opt(nilfs, DISCARD);\n\t\t}\n\t}\n\n out_unlock:\n\tsci->sc_freesegs = NULL;\n\tsci->sc_nfreesegs = 0;\n\tnilfs_mdt_clear_shadow_map(nilfs->ns_dat);\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_remove_written_gcinodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2340-2353",
    "snippet": "static void\nnilfs_remove_written_gcinodes(struct the_nilfs *nilfs, struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\n\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\tif (!test_bit(NILFS_I_UPDATED, &ii->i_state))\n\t\t\tcontinue;\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&ii->vfs_inode"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_btnode_cache_clear",
          "args": [
            "&ii->i_btnode_cache"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_btnode_cache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/btnode.c",
          "lines": "37-41",
          "snippet": "void nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}",
          "includes": [
            "#include \"btnode.h\"",
            "#include \"page.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btnode.h\"\n#include \"page.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_btnode_cache_clear(struct address_space *btnc)\n{\n\tinvalidate_mapping_pages(btnc, 0, -1);\n\ttruncate_inode_pages(btnc, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "&ii->vfs_inode.i_data",
            "0"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_UPDATED",
            "&ii->i_state"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ii",
            "n",
            "head",
            "i_dirty"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void\nnilfs_remove_written_gcinodes(struct the_nilfs *nilfs, struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\n\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\tif (!test_bit(NILFS_I_UPDATED, &ii->i_state))\n\t\t\tcontinue;\n\t\tlist_del_init(&ii->i_dirty);\n\t\ttruncate_inode_pages(&ii->vfs_inode.i_data, 0);\n\t\tnilfs_btnode_cache_clear(&ii->i_btnode_cache);\n\t\tiput(&ii->vfs_inode);\n\t}\n}"
  },
  {
    "function_name": "nilfs_construction_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2334-2338",
    "snippet": "static void nilfs_construction_timeout(unsigned long data)\n{\n\tstruct task_struct *p = (struct task_struct *)data;\n\twake_up_process(p);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_construction_timeout(unsigned long data)\n{\n\tstruct task_struct *p = (struct task_struct *)data;\n\twake_up_process(p);\n}"
  },
  {
    "function_name": "nilfs_segctor_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2299-2332",
    "snippet": "static int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_notify",
          "args": [
            "sci",
            "mode",
            "err"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2270-2292",
          "snippet": "static void nilfs_segctor_notify(struct nilfs_sc_info *sci, int mode, int err)\n{\n\t/* Clear requests (even when the construction failed) */\n\tspin_lock(&sci->sc_state_lock);\n\n\tif (mode == SC_LSEG_SR) {\n\t\tsci->sc_state &= ~NILFS_SEGCTOR_COMMIT;\n\t\tsci->sc_seq_done = sci->sc_seq_accepted;\n\t\tnilfs_segctor_wakeup(sci, err);\n\t\tsci->sc_flush_request = 0;\n\t} else {\n\t\tif (mode == SC_FLUSH_FILE)\n\t\t\tsci->sc_flush_request &= ~FLUSH_FILE_BIT;\n\t\telse if (mode == SC_FLUSH_DAT)\n\t\t\tsci->sc_flush_request &= ~FLUSH_DAT_BIT;\n\n\t\t/* re-enable timer if checkpoint creation was not done */\n\t\tif ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t    time_before(jiffies, sci->sc_timer.expires))\n\t\t\tadd_timer(&sci->sc_timer);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
            "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_notify(struct nilfs_sc_info *sci, int mode, int err)\n{\n\t/* Clear requests (even when the construction failed) */\n\tspin_lock(&sci->sc_state_lock);\n\n\tif (mode == SC_LSEG_SR) {\n\t\tsci->sc_state &= ~NILFS_SEGCTOR_COMMIT;\n\t\tsci->sc_seq_done = sci->sc_seq_accepted;\n\t\tnilfs_segctor_wakeup(sci, err);\n\t\tsci->sc_flush_request = 0;\n\t} else {\n\t\tif (mode == SC_FLUSH_FILE)\n\t\t\tsci->sc_flush_request &= ~FLUSH_FILE_BIT;\n\t\telse if (mode == SC_FLUSH_DAT)\n\t\t\tsci->sc_flush_request &= ~FLUSH_DAT_BIT;\n\n\t\t/* re-enable timer if checkpoint creation was not done */\n\t\tif ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t    time_before(jiffies, sci->sc_timer.expires))\n\t\t\tadd_timer(&sci->sc_timer);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_commit_super",
          "args": [
            "sci->sc_super",
            "NILFS_SB_COMMIT"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "291-317",
          "snippet": "int nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nint nilfs_commit_super(struct super_block *sb, int flag)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\ttime_t t;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tt = get_seconds();\n\tnilfs->ns_sbwtime = t;\n\tsbp[0]->s_wtime = cpu_to_le64(t);\n\tsbp[0]->s_sum = 0;\n\tsbp[0]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t     (unsigned char *)sbp[0],\n\t\t\t\t\t     nilfs->ns_sbsize));\n\tif (flag == NILFS_SB_COMMIT_ALL && sbp[1]) {\n\t\tsbp[1]->s_wtime = sbp[0]->s_wtime;\n\t\tsbp[1]->s_sum = 0;\n\t\tsbp[1]->s_sum = cpu_to_le32(crc32_le(nilfs->ns_crc_seed,\n\t\t\t\t\t    (unsigned char *)sbp[1],\n\t\t\t\t\t    nilfs->ns_sbsize));\n\t}\n\tclear_nilfs_sb_dirty(nilfs);\n\tnilfs->ns_flushed_device = 1;\n\t/* make sure store to ns_flushed_device cannot be reordered */\n\tsmp_wmb();\n\treturn nilfs_sync_super(sb, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_log_cursor",
          "args": [
            "sbp[0]",
            "nilfs"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_log_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "248-262",
          "snippet": "void nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_set_log_cursor(struct nilfs_super_block *sbp,\n\t\t\t  struct the_nilfs *nilfs)\n{\n\tsector_t nfreeblocks;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tnilfs_count_free_blocks(nilfs, &nfreeblocks);\n\tsbp->s_free_blocks_count = cpu_to_le64(nfreeblocks);\n\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tsbp->s_last_seq = cpu_to_le64(nilfs->ns_last_seq);\n\tsbp->s_last_pseg = cpu_to_le64(nilfs->ns_last_pseg);\n\tsbp->s_last_cno = cpu_to_le64(nilfs->ns_last_cno);\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sbp"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_super",
          "args": [
            "sci->sc_super",
            "nilfs_sb_will_flip(nilfs)"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "264-289",
          "snippet": "struct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstruct nilfs_super_block **nilfs_prepare_super(struct super_block *sb,\n\t\t\t\t\t       int flip)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_super_block **sbp = nilfs->ns_sbp;\n\n\t/* nilfs->ns_sem must be locked by the caller. */\n\tif (sbp[0]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\tif (sbp[1] &&\n\t\t    sbp[1]->s_magic == cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[0], sbp[1], nilfs->ns_sbsize);\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"NILFS: superblock broke on dev %s\\n\",\n\t\t\t       sb->s_id);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (sbp[1] &&\n\t\t   sbp[1]->s_magic != cpu_to_le16(NILFS_SUPER_MAGIC)) {\n\t\t\tmemcpy(sbp[1], sbp[0], nilfs->ns_sbsize);\n\t}\n\n\tif (flip && sbp[1])\n\t\tnilfs_swap_super_block(nilfs);\n\n\treturn sbp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sb_will_flip",
          "args": [
            "nilfs"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb_will_flip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "280-284",
          "snippet": "static inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_sem"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_SUPER_ROOT",
            "&sci->sc_flags"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nilfs->ns_ndirtyblks",
            "0"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_construct",
          "args": [
            "sci",
            "mode"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1945-2039",
          "snippet": "static int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)",
            "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_confirm",
          "args": [
            "sci"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "779-793",
          "snippet": "static int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_accept",
          "args": [
            "sci"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2256-2262",
          "snippet": "static void nilfs_segctor_accept(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tsci->sc_seq_accepted = sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\tdel_timer_sync(&sci->sc_timer);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_accept(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tsci->sc_seq_accepted = sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\tdel_timer_sync(&sci->sc_timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct nilfs_super_block **sbp;\n\tint err = 0;\n\n\tnilfs_segctor_accept(sci);\n\n\tif (nilfs_discontinued(nilfs))\n\t\tmode = SC_LSEG_SR;\n\tif (!nilfs_segctor_confirm(sci))\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\tif (likely(!err)) {\n\t\tif (mode != SC_FLUSH_DAT)\n\t\t\tatomic_set(&nilfs->ns_ndirtyblks, 0);\n\t\tif (test_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags) &&\n\t\t    nilfs_discontinued(nilfs)) {\n\t\t\tdown_write(&nilfs->ns_sem);\n\t\t\terr = -EIO;\n\t\t\tsbp = nilfs_prepare_super(sci->sc_super,\n\t\t\t\t\t\t  nilfs_sb_will_flip(nilfs));\n\t\t\tif (likely(sbp)) {\n\t\t\t\tnilfs_set_log_cursor(sbp[0], nilfs);\n\t\t\t\terr = nilfs_commit_super(sci->sc_super,\n\t\t\t\t\t\t\t NILFS_SB_COMMIT);\n\t\t\t}\n\t\t\tup_write(&nilfs->ns_sem);\n\t\t}\n\t}\n\n\tnilfs_segctor_notify(sci, mode, err);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2270-2292",
    "snippet": "static void nilfs_segctor_notify(struct nilfs_sc_info *sci, int mode, int err)\n{\n\t/* Clear requests (even when the construction failed) */\n\tspin_lock(&sci->sc_state_lock);\n\n\tif (mode == SC_LSEG_SR) {\n\t\tsci->sc_state &= ~NILFS_SEGCTOR_COMMIT;\n\t\tsci->sc_seq_done = sci->sc_seq_accepted;\n\t\tnilfs_segctor_wakeup(sci, err);\n\t\tsci->sc_flush_request = 0;\n\t} else {\n\t\tif (mode == SC_FLUSH_FILE)\n\t\t\tsci->sc_flush_request &= ~FLUSH_FILE_BIT;\n\t\telse if (mode == SC_FLUSH_DAT)\n\t\t\tsci->sc_flush_request &= ~FLUSH_DAT_BIT;\n\n\t\t/* re-enable timer if checkpoint creation was not done */\n\t\tif ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t    time_before(jiffies, sci->sc_timer.expires))\n\t\t\tadd_timer(&sci->sc_timer);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
      "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "&sci->sc_timer"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sci->sc_timer.expires"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_wakeup",
          "args": [
            "sci",
            "err"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2129-2149",
          "snippet": "static void nilfs_segctor_wakeup(struct nilfs_sc_info *sci, int err)\n{\n\tstruct nilfs_segctor_wait_request *wrq, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sci->sc_wait_request.lock, flags);\n\tlist_for_each_entry_safe(wrq, n, &sci->sc_wait_request.task_list,\n\t\t\t\t wq.task_list) {\n\t\tif (!atomic_read(&wrq->done) &&\n\t\t    nilfs_cnt32_ge(sci->sc_seq_done, wrq->seq)) {\n\t\t\twrq->err = err;\n\t\t\tatomic_set(&wrq->done, 1);\n\t\t}\n\t\tif (atomic_read(&wrq->done)) {\n\t\t\twrq->wq.func(&wrq->wq,\n\t\t\t\t     TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,\n\t\t\t\t     0, NULL);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sci->sc_wait_request.lock, flags);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_wakeup(struct nilfs_sc_info *sci, int err)\n{\n\tstruct nilfs_segctor_wait_request *wrq, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sci->sc_wait_request.lock, flags);\n\tlist_for_each_entry_safe(wrq, n, &sci->sc_wait_request.task_list,\n\t\t\t\t wq.task_list) {\n\t\tif (!atomic_read(&wrq->done) &&\n\t\t    nilfs_cnt32_ge(sci->sc_seq_done, wrq->seq)) {\n\t\t\twrq->err = err;\n\t\t\tatomic_set(&wrq->done, 1);\n\t\t}\n\t\tif (atomic_read(&wrq->done)) {\n\t\t\twrq->wq.func(&wrq->wq,\n\t\t\t\t     TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,\n\t\t\t\t     0, NULL);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sci->sc_wait_request.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_notify(struct nilfs_sc_info *sci, int mode, int err)\n{\n\t/* Clear requests (even when the construction failed) */\n\tspin_lock(&sci->sc_state_lock);\n\n\tif (mode == SC_LSEG_SR) {\n\t\tsci->sc_state &= ~NILFS_SEGCTOR_COMMIT;\n\t\tsci->sc_seq_done = sci->sc_seq_accepted;\n\t\tnilfs_segctor_wakeup(sci, err);\n\t\tsci->sc_flush_request = 0;\n\t} else {\n\t\tif (mode == SC_FLUSH_FILE)\n\t\t\tsci->sc_flush_request &= ~FLUSH_FILE_BIT;\n\t\telse if (mode == SC_FLUSH_DAT)\n\t\t\tsci->sc_flush_request &= ~FLUSH_DAT_BIT;\n\n\t\t/* re-enable timer if checkpoint creation was not done */\n\t\tif ((sci->sc_state & NILFS_SEGCTOR_COMMIT) &&\n\t\t    time_before(jiffies, sci->sc_timer.expires))\n\t\t\tadd_timer(&sci->sc_timer);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
  },
  {
    "function_name": "nilfs_segctor_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2256-2262",
    "snippet": "static void nilfs_segctor_accept(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tsci->sc_seq_accepted = sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\tdel_timer_sync(&sci->sc_timer);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sci->sc_timer"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_accept(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tsci->sc_seq_accepted = sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\tdel_timer_sync(&sci->sc_timer);\n}"
  },
  {
    "function_name": "nilfs_construct_dsync_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2205-2247",
    "snippet": "int nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_transaction_unlock",
          "args": [
            "sb"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "324-334",
          "snippet": "static void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_construct",
          "args": [
            "sci",
            "SC_LSEG_DSYNC"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1945-2039",
          "snippet": "static int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)",
            "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_sync",
          "args": [
            "sci"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2096-2127",
          "snippet": "static int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_test_opt",
          "args": [
            "nilfs",
            "STRICT_ORDER"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_transaction_lock",
          "args": [
            "sb",
            "&ti",
            "0"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_transaction_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "295-322",
          "snippet": "static void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_dsync_segment(struct super_block *sb, struct inode *inode,\n\t\t\t\t  loff_t start, loff_t end)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_transaction_info ti;\n\tint err = 0;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\tnilfs_transaction_lock(sb, &ti, 0);\n\n\tii = NILFS_I(inode);\n\tif (test_bit(NILFS_I_INODE_SYNC, &ii->i_state) ||\n\t    nilfs_test_opt(nilfs, STRICT_ORDER) ||\n\t    test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags) ||\n\t    nilfs_discontinued(nilfs)) {\n\t\tnilfs_transaction_unlock(sb);\n\t\terr = nilfs_segctor_sync(sci);\n\t\treturn err;\n\t}\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (!test_bit(NILFS_I_QUEUED, &ii->i_state) &&\n\t    !test_bit(NILFS_I_BUSY, &ii->i_state)) {\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\tnilfs_transaction_unlock(sb);\n\t\treturn 0;\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\tsci->sc_dsync_inode = ii;\n\tsci->sc_dsync_start = start;\n\tsci->sc_dsync_end = end;\n\n\terr = nilfs_segctor_do_construct(sci, SC_LSEG_DSYNC);\n\tif (!err)\n\t\tnilfs->ns_flushed_device = 0;\n\n\tnilfs_transaction_unlock(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_construct_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2168-2183",
    "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_sync",
          "args": [
            "sci"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2096-2127",
          "snippet": "static int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2129-2149",
    "snippet": "static void nilfs_segctor_wakeup(struct nilfs_sc_info *sci, int err)\n{\n\tstruct nilfs_segctor_wait_request *wrq, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sci->sc_wait_request.lock, flags);\n\tlist_for_each_entry_safe(wrq, n, &sci->sc_wait_request.task_list,\n\t\t\t\t wq.task_list) {\n\t\tif (!atomic_read(&wrq->done) &&\n\t\t    nilfs_cnt32_ge(sci->sc_seq_done, wrq->seq)) {\n\t\t\twrq->err = err;\n\t\t\tatomic_set(&wrq->done, 1);\n\t\t}\n\t\tif (atomic_read(&wrq->done)) {\n\t\t\twrq->wq.func(&wrq->wq,\n\t\t\t\t     TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,\n\t\t\t\t     0, NULL);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sci->sc_wait_request.lock, flags);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sci->sc_wait_request.lock",
            "flags"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrq->wq.func",
          "args": [
            "&wrq->wq",
            "TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE",
            "0",
            "NULL"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wrq->done"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wrq->done",
            "1"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cnt32_ge",
          "args": [
            "sci->sc_seq_done",
            "wrq->seq"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wrq->done"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "wrq",
            "n",
            "&sci->sc_wait_request.task_list",
            "wq.task_list"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sci->sc_wait_request.lock",
            "flags"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_wakeup(struct nilfs_sc_info *sci, int err)\n{\n\tstruct nilfs_segctor_wait_request *wrq, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sci->sc_wait_request.lock, flags);\n\tlist_for_each_entry_safe(wrq, n, &sci->sc_wait_request.task_list,\n\t\t\t\t wq.task_list) {\n\t\tif (!atomic_read(&wrq->done) &&\n\t\t    nilfs_cnt32_ge(sci->sc_seq_done, wrq->seq)) {\n\t\t\twrq->err = err;\n\t\t\tatomic_set(&wrq->done, 1);\n\t\t}\n\t\tif (atomic_read(&wrq->done)) {\n\t\t\twrq->wq.func(&wrq->wq,\n\t\t\t\t     TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,\n\t\t\t\t     0, NULL);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sci->sc_wait_request.lock, flags);\n}"
  },
  {
    "function_name": "nilfs_segctor_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2096-2127",
    "snippet": "static int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&sci->sc_wait_request",
            "&wait_req.wq"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wait_req.done"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sci->sc_wait_daemon"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&sci->sc_wait_request",
            "&wait_req.wq"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_entry",
          "args": [
            "&wait_req.wq",
            "current"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wait_req.done",
            "0"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&wait_req.wq"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_sync(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segctor_wait_request wait_req;\n\tint err = 0;\n\n\tspin_lock(&sci->sc_state_lock);\n\tinit_wait(&wait_req.wq);\n\twait_req.err = 0;\n\tatomic_set(&wait_req.done, 0);\n\twait_req.seq = ++sci->sc_seq_request;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tinit_waitqueue_entry(&wait_req.wq, current);\n\tadd_wait_queue(&sci->sc_wait_request, &wait_req.wq);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twake_up(&sci->sc_wait_daemon);\n\n\tfor (;;) {\n\t\tif (atomic_read(&wait_req.done)) {\n\t\t\terr = wait_req.err;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(&sci->sc_wait_request, &wait_req.wq);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_flush_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2078-2087",
    "snippet": "void nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_do_flush",
          "args": [
            "sci",
            "NILFS_MDT_INODE(sb, ino) ? ino : 0"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2060-2071",
          "snippet": "static void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_MDT_INODE",
          "args": [
            "sb",
            "ino"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_doing_construction",
          "args": [],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_construction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "192-195",
          "snippet": "static inline int nilfs_doing_construction(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_WRITER);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_WRITER\t\t0x0010\t/* Constructor context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_WRITER\t\t0x0010\t/* Constructor context */\n\nstatic inline int nilfs_doing_construction(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_WRITER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nvoid nilfs_flush_segment(struct super_block *sb, ino_t ino)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || nilfs_doing_construction())\n\t\treturn;\n\tnilfs_segctor_do_flush(sci, NILFS_MDT_INODE(sb, ino) ? ino : 0);\n\t\t\t\t\t/* assign bit 0 to data files */\n}"
  },
  {
    "function_name": "nilfs_segctor_do_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2060-2071",
    "snippet": "static void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sci->sc_wait_daemon"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
  },
  {
    "function_name": "nilfs_segctor_start_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "2049-2058",
    "snippet": "static void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "&sci->sc_timer"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sci->sc_state_lock"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
  },
  {
    "function_name": "nilfs_segctor_do_construct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1945-2039",
    "snippet": "static int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)",
      "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_abort_construction",
          "args": [
            "sci",
            "nilfs",
            "err"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_abort_construction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1721-1744",
          "snippet": "static void nilfs_segctor_abort_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs, int err)\n{\n\tLIST_HEAD(logs);\n\tint ret;\n\n\tlist_splice_tail_init(&sci->sc_write_logs, &logs);\n\tret = nilfs_wait_on_logs(&logs);\n\tnilfs_abort_logs(&logs, ret ? : err);\n\n\tlist_splice_tail_init(&sci->sc_segbufs, &logs);\n\tnilfs_cancel_segusage(&logs, nilfs->ns_sufile);\n\tnilfs_free_incomplete_logs(&logs, nilfs);\n\n\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\tret = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\tNULL);\n\t\tWARN_ON(ret); /* do not happen */\n\t}\n\n\tnilfs_destroy_logs(&logs);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_abort_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs, int err)\n{\n\tLIST_HEAD(logs);\n\tint ret;\n\n\tlist_splice_tail_init(&sci->sc_write_logs, &logs);\n\tret = nilfs_wait_on_logs(&logs);\n\tnilfs_abort_logs(&logs, ret ? : err);\n\n\tlist_splice_tail_init(&sci->sc_segbufs, &logs);\n\tnilfs_cancel_segusage(&logs, nilfs->ns_sufile);\n\tnilfs_free_incomplete_logs(&logs, nilfs);\n\n\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\tret = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\tNULL);\n\t\tWARN_ON(ret); /* do not happen */\n\t}\n\n\tnilfs_destroy_logs(&logs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_redirty_inodes",
          "args": [
            "&sci->sc_gc_inodes"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_redirty_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "921-929",
          "snippet": "static void nilfs_redirty_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (test_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tclear_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_redirty_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (test_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tclear_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_drop_written_files",
          "args": [
            "sci",
            "nilfs"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_drop_written_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1906-1940",
          "snippet": "static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tint during_mount = !(sci->sc_super->s_flags & MS_ACTIVE);\n\tint defer_iput = false;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tlist_for_each_entry_safe(ii, n, &sci->sc_dirty_files, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_UPDATED, &ii->i_state) ||\n\t\t    test_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tbrelse(ii->i_bh);\n\t\tii->i_bh = NULL;\n\t\tlist_del_init(&ii->i_dirty);\n\t\tif (!ii->vfs_inode.i_nlink || during_mount) {\n\t\t\t/*\n\t\t\t * Defer calling iput() to avoid deadlocks if\n\t\t\t * i_nlink == 0 or mount is not yet finished.\n\t\t\t */\n\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);\n\t\t\tdefer_iput = true;\n\t\t} else {\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\tiput(&ii->vfs_inode);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\tif (defer_iput)\n\t\tschedule_work(&sci->sc_iput_work);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tint during_mount = !(sci->sc_super->s_flags & MS_ACTIVE);\n\tint defer_iput = false;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tlist_for_each_entry_safe(ii, n, &sci->sc_dirty_files, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_UPDATED, &ii->i_state) ||\n\t\t    test_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tbrelse(ii->i_bh);\n\t\tii->i_bh = NULL;\n\t\tlist_del_init(&ii->i_dirty);\n\t\tif (!ii->vfs_inode.i_nlink || during_mount) {\n\t\t\t/*\n\t\t\t * Defer calling iput() to avoid deadlocks if\n\t\t\t * i_nlink == 0 or mount is not yet finished.\n\t\t\t */\n\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);\n\t\t\tdefer_iput = true;\n\t\t} else {\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\tiput(&ii->vfs_inode);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\tif (defer_iput)\n\t\tschedule_work(&sci->sc_iput_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_wait",
          "args": [
            "sci"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1854-1864",
          "snippet": "static int nilfs_segctor_wait(struct nilfs_sc_info *sci)\n{\n\tint ret;\n\n\tret = nilfs_wait_on_logs(&sci->sc_write_logs);\n\tif (!ret) {\n\t\tnilfs_segctor_complete_write(sci);\n\t\tnilfs_destroy_logs(&sci->sc_write_logs);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_wait(struct nilfs_sc_info *sci)\n{\n\tint ret;\n\n\tret = nilfs_wait_on_logs(&sci->sc_write_logs);\n\tif (!ret) {\n\t\tnilfs_segctor_complete_write(sci);\n\t\tnilfs_destroy_logs(&sci->sc_write_logs);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_write",
          "args": [
            "sci",
            "nilfs"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1631-1639",
          "snippet": "static int nilfs_segctor_write(struct nilfs_sc_info *sci,\n\t\t\t       struct the_nilfs *nilfs)\n{\n\tint ret;\n\n\tret = nilfs_write_logs(&sci->sc_segbufs, nilfs);\n\tlist_splice_tail_init(&sci->sc_segbufs, &sci->sc_write_logs);\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_write(struct nilfs_sc_info *sci,\n\t\t\t       struct the_nilfs *nilfs)\n{\n\tint ret;\n\n\tret = nilfs_write_logs(&sci->sc_segbufs, nilfs);\n\tlist_splice_tail_init(&sci->sc_segbufs, &sci->sc_write_logs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_add_checksums_on_logs",
          "args": [
            "&sci->sc_segbufs",
            "nilfs->ns_crc_seed"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_add_checksums_on_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "326-336",
          "snippet": "void nilfs_add_checksums_on_logs(struct list_head *logs, u32 seed)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tif (segbuf->sb_super_root)\n\t\t\tnilfs_segbuf_fill_in_super_root_crc(segbuf, seed);\n\t\tnilfs_segbuf_fill_in_segsum_crc(segbuf, seed);\n\t\tnilfs_segbuf_fill_in_data_crc(segbuf, seed);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_add_checksums_on_logs(struct list_head *logs, u32 seed)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tif (segbuf->sb_super_root)\n\t\t\tnilfs_segbuf_fill_in_super_root_crc(segbuf, seed);\n\t\tnilfs_segbuf_fill_in_segsum_crc(segbuf, seed);\n\t\tnilfs_segbuf_fill_in_data_crc(segbuf, seed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_prepare_write",
          "args": [
            "sci"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_prepare_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1581-1629",
          "snippet": "static void nilfs_segctor_prepare_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t}\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_begin_page_io(fs_page);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page) {\n\t\tlock_page(bd_page);\n\t\tclear_page_dirty_for_io(bd_page);\n\t\tset_page_writeback(bd_page);\n\t\tunlock_page(bd_page);\n\t}\n\tnilfs_begin_page_io(fs_page);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_prepare_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t}\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_begin_page_io(fs_page);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page) {\n\t\tlock_page(bd_page);\n\t\tclear_page_dirty_for_io(bd_page);\n\t\tset_page_writeback(bd_page);\n\t\tunlock_page(bd_page);\n\t}\n\tnilfs_begin_page_io(fs_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_update_segusage",
          "args": [
            "sci",
            "nilfs->ns_sufile"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_update_segusage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1369-1384",
          "snippet": "static void nilfs_segctor_update_segusage(struct nilfs_sc_info *sci,\n\t\t\t\t\t  struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tunsigned long live_blocks;\n\tint ret;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tlive_blocks = segbuf->sb_sum.nblocks +\n\t\t\t(segbuf->sb_pseg_start - segbuf->sb_fseg_start);\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     live_blocks,\n\t\t\t\t\t\t     sci->sc_seg_ctime);\n\t\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_update_segusage(struct nilfs_sc_info *sci,\n\t\t\t\t\t  struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tunsigned long live_blocks;\n\tint ret;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tlive_blocks = segbuf->sb_sum.nblocks +\n\t\t\t(segbuf->sb_pseg_start - segbuf->sb_fseg_start);\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     live_blocks,\n\t\t\t\t\t\t     sci->sc_seg_ctime);\n\t\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_fill_in_super_root",
          "args": [
            "sci",
            "nilfs"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_fill_in_super_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "894-919",
          "snippet": "static void nilfs_segctor_fill_in_super_root(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tunsigned isz, srsz;\n\n\tbh_sr = NILFS_LAST_SEGBUF(&sci->sc_segbufs)->sb_super_root;\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tisz = nilfs->ns_inode_size;\n\tsrsz = NILFS_SR_BYTES(isz);\n\n\traw_sr->sr_bytes = cpu_to_le16(srsz);\n\traw_sr->sr_nongc_ctime\n\t\t= cpu_to_le64(nilfs_doing_gc() ?\n\t\t\t      nilfs->ns_nongc_ctime : sci->sc_seg_ctime);\n\traw_sr->sr_flags = 0;\n\n\tnilfs_write_inode_common(nilfs->ns_dat, (void *)raw_sr +\n\t\t\t\t NILFS_SR_DAT_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_cpfile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_CPFILE_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_sufile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_SUFILE_OFFSET(isz), 1);\n\tmemset((void *)raw_sr + srsz, 0, nilfs->ns_blocksize - srsz);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_fill_in_super_root(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tunsigned isz, srsz;\n\n\tbh_sr = NILFS_LAST_SEGBUF(&sci->sc_segbufs)->sb_super_root;\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tisz = nilfs->ns_inode_size;\n\tsrsz = NILFS_SR_BYTES(isz);\n\n\traw_sr->sr_bytes = cpu_to_le16(srsz);\n\traw_sr->sr_nongc_ctime\n\t\t= cpu_to_le64(nilfs_doing_gc() ?\n\t\t\t      nilfs->ns_nongc_ctime : sci->sc_seg_ctime);\n\traw_sr->sr_flags = 0;\n\n\tnilfs_write_inode_common(nilfs->ns_dat, (void *)raw_sr +\n\t\t\t\t NILFS_SR_DAT_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_cpfile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_CPFILE_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_sufile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_SUFILE_OFFSET(isz), 1);\n\tmemset((void *)raw_sr + srsz, 0, nilfs->ns_blocksize - srsz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_fill_in_checkpoint",
          "args": [
            "sci"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_fill_in_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "829-865",
          "snippet": "static int nilfs_segctor_fill_in_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 0,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (unlikely(err)) {\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\t\tgoto failed_ibh;\n\t}\n\traw_cp->cp_snapshot_list.ssl_next = 0;\n\traw_cp->cp_snapshot_list.ssl_prev = 0;\n\traw_cp->cp_inodes_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->inodes_count));\n\traw_cp->cp_blocks_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->blocks_count));\n\traw_cp->cp_nblk_inc =\n\t\tcpu_to_le64(sci->sc_nblk_inc + sci->sc_nblk_this_inc);\n\traw_cp->cp_create = cpu_to_le64(sci->sc_seg_ctime);\n\traw_cp->cp_cno = cpu_to_le64(nilfs->ns_cno);\n\n\tif (test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tnilfs_checkpoint_clear_minor(raw_cp);\n\telse\n\t\tnilfs_checkpoint_set_minor(raw_cp);\n\n\tnilfs_write_inode_common(sci->sc_root->ifile,\n\t\t\t\t &raw_cp->cp_ifile_inode, 1);\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\treturn 0;\n\n failed_ibh:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_fill_in_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 0,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (unlikely(err)) {\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\t\tgoto failed_ibh;\n\t}\n\traw_cp->cp_snapshot_list.ssl_next = 0;\n\traw_cp->cp_snapshot_list.ssl_prev = 0;\n\traw_cp->cp_inodes_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->inodes_count));\n\traw_cp->cp_blocks_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->blocks_count));\n\traw_cp->cp_nblk_inc =\n\t\tcpu_to_le64(sci->sc_nblk_inc + sci->sc_nblk_this_inc);\n\traw_cp->cp_create = cpu_to_le64(sci->sc_seg_ctime);\n\traw_cp->cp_cno = cpu_to_le64(nilfs->ns_cno);\n\n\tif (test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tnilfs_checkpoint_clear_minor(raw_cp);\n\telse\n\t\tnilfs_checkpoint_set_minor(raw_cp);\n\n\tnilfs_write_inode_common(sci->sc_root->ifile,\n\t\t\t\t &raw_cp->cp_ifile_inode, 1);\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\treturn 0;\n\n failed_ibh:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_fill_in_file_bmap",
          "args": [
            "sci"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_fill_in_file_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "884-892",
          "snippet": "static void nilfs_segctor_fill_in_file_bmap(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, &sci->sc_dirty_files, i_dirty) {\n\t\tnilfs_fill_in_file_bmap(sci->sc_root->ifile, ii);\n\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_fill_in_file_bmap(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, &sci->sc_dirty_files, i_dirty) {\n\t\tnilfs_fill_in_file_bmap(sci->sc_root->ifile, ii);\n\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_assign",
          "args": [
            "sci",
            "mode"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1554-1566",
          "snippet": "static int nilfs_segctor_assign(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\terr = nilfs_segctor_update_payload_blocknr(sci, segbuf, mode);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tnilfs_segbuf_fill_in_segsum(segbuf);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_assign(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\terr = nilfs_segctor_update_payload_blocknr(sci, segbuf, mode);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tnilfs_segbuf_fill_in_segsum(segbuf);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_empty",
          "args": [
            "sci->sc_curseg"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "141-144",
          "snippet": "static inline int nilfs_segbuf_empty(struct nilfs_segment_buffer *segbuf)\n{\n\treturn segbuf->sb_sum.nblocks == segbuf->sb_sum.nsumblk;\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_segbuf_empty(struct nilfs_segment_buffer *segbuf)\n{\n\treturn segbuf->sb_sum.nblocks == segbuf->sb_sum.nsumblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_collect",
          "args": [
            "sci",
            "nilfs",
            "mode"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1420-1470",
          "snippet": "static int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */",
            "#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_begin_construction",
          "args": [
            "sci",
            "nilfs"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_begin_construction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1216-1274",
          "snippet": "static int nilfs_segctor_begin_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\t__u64 nextnum;\n\tint err, alloc = 0;\n\n\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\tif (unlikely(!segbuf))\n\t\treturn -ENOMEM;\n\n\tif (list_empty(&sci->sc_write_logs)) {\n\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum,\n\t\t\t\t nilfs->ns_pseg_offset, nilfs);\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_shift_to_next_segment(nilfs);\n\t\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum, 0, nilfs);\n\t\t}\n\n\t\tsegbuf->sb_sum.seg_seq = nilfs->ns_seg_seq;\n\t\tnextnum = nilfs->ns_nextnum;\n\n\t\tif (nilfs->ns_segnum == nilfs->ns_nextnum)\n\t\t\t/* Start from the head of a new full segment */\n\t\t\talloc++;\n\t} else {\n\t\t/* Continue logs */\n\t\tprev = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\t\tnilfs_segbuf_map_cont(segbuf, prev);\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq;\n\t\tnextnum = prev->sb_nextnum;\n\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\t\tsegbuf->sb_sum.seg_seq++;\n\t\t\talloc++;\n\t\t}\n\t}\n\n\terr = nilfs_sufile_mark_dirty(nilfs->ns_sufile, segbuf->sb_segnum);\n\tif (err)\n\t\tgoto failed;\n\n\tif (alloc) {\n\t\terr = nilfs_sufile_alloc(nilfs->ns_sufile, &nextnum);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\tnilfs_segbuf_set_next_segnum(segbuf, nextnum, nilfs);\n\n\tBUG_ON(!list_empty(&sci->sc_segbufs));\n\tlist_add_tail(&segbuf->sb_list, &sci->sc_segbufs);\n\tsci->sc_segbuf_nblocks = segbuf->sb_rest_blocks;\n\treturn 0;\n\n failed:\n\tnilfs_segbuf_free(segbuf);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_begin_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\t__u64 nextnum;\n\tint err, alloc = 0;\n\n\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\tif (unlikely(!segbuf))\n\t\treturn -ENOMEM;\n\n\tif (list_empty(&sci->sc_write_logs)) {\n\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum,\n\t\t\t\t nilfs->ns_pseg_offset, nilfs);\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_shift_to_next_segment(nilfs);\n\t\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum, 0, nilfs);\n\t\t}\n\n\t\tsegbuf->sb_sum.seg_seq = nilfs->ns_seg_seq;\n\t\tnextnum = nilfs->ns_nextnum;\n\n\t\tif (nilfs->ns_segnum == nilfs->ns_nextnum)\n\t\t\t/* Start from the head of a new full segment */\n\t\t\talloc++;\n\t} else {\n\t\t/* Continue logs */\n\t\tprev = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\t\tnilfs_segbuf_map_cont(segbuf, prev);\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq;\n\t\tnextnum = prev->sb_nextnum;\n\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\t\tsegbuf->sb_sum.seg_seq++;\n\t\t\talloc++;\n\t\t}\n\t}\n\n\terr = nilfs_sufile_mark_dirty(nilfs->ns_sufile, segbuf->sb_segnum);\n\tif (err)\n\t\tgoto failed;\n\n\tif (alloc) {\n\t\terr = nilfs_sufile_alloc(nilfs->ns_sufile, &nextnum);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\tnilfs_segbuf_set_next_segnum(segbuf, nextnum, nilfs);\n\n\tBUG_ON(!list_empty(&sci->sc_segbufs));\n\tlist_add_tail(&segbuf->sb_list, &sci->sc_segbufs);\n\tsci->sc_segbuf_nblocks = segbuf->sb_rest_blocks;\n\treturn 0;\n\n failed:\n\tnilfs_segbuf_free(segbuf);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_clean",
          "args": [
            "sci"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "771-777",
          "snippet": "static int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_SC_DIRTY",
            "&sci->sc_flags"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_metadata_dirty",
          "args": [
            "nilfs",
            "sci->sc_root"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_test_metadata_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "755-769",
          "snippet": "static int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_collect_dirty_files",
          "args": [
            "sci",
            "nilfs"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_collect_dirty_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1866-1904",
          "snippet": "static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct inode *ifile = sci->sc_root->ifile;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n retry:\n\tlist_for_each_entry_safe(ii, n, &nilfs->ns_dirty_files, i_dirty) {\n\t\tif (!ii->i_bh) {\n\t\t\tstruct buffer_head *ibh;\n\t\t\tint err;\n\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\terr = nilfs_ifile_get_inode_block(\n\t\t\t\tifile, ii->vfs_inode.i_ino, &ibh);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t\t\t      \"failed to get inode block.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmark_buffer_dirty(ibh);\n\t\t\tnilfs_mdt_mark_dirty(ifile);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t\tif (likely(!ii->i_bh))\n\t\t\t\tii->i_bh = ibh;\n\t\t\telse\n\t\t\t\tbrelse(ibh);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tclear_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\tset_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tlist_move_tail(&ii->i_dirty, &sci->sc_dirty_files);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct inode *ifile = sci->sc_root->ifile;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n retry:\n\tlist_for_each_entry_safe(ii, n, &nilfs->ns_dirty_files, i_dirty) {\n\t\tif (!ii->i_bh) {\n\t\t\tstruct buffer_head *ibh;\n\t\t\tint err;\n\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\terr = nilfs_ifile_get_inode_block(\n\t\t\t\tifile, ii->vfs_inode.i_ino, &ibh);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t\t\t      \"failed to get inode block.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmark_buffer_dirty(ibh);\n\t\t\tnilfs_mdt_mark_dirty(ifile);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t\tif (likely(!ii->i_bh))\n\t\t\t\tii->i_bh = ibh;\n\t\t\telse\n\t\t\t\tbrelse(ibh);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tclear_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\tset_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tlist_move_tail(&ii->i_dirty, &sci->sc_dirty_files);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_HISTORY_MASK\t(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_do_construct(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint err;\n\n\tsci->sc_stage.scnt = NILFS_ST_INIT;\n\tsci->sc_cno = nilfs->ns_cno;\n\n\terr = nilfs_segctor_collect_dirty_files(sci, nilfs);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tif (nilfs_segctor_clean(sci))\n\t\tgoto out;\n\n\tdo {\n\t\tsci->sc_stage.flags &= ~NILFS_CF_HISTORY_MASK;\n\n\t\terr = nilfs_segctor_begin_construction(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\t\t/* Update time stamp */\n\t\tsci->sc_seg_ctime = get_seconds();\n\n\t\terr = nilfs_segctor_collect(sci, nilfs, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\t/* Avoid empty segment */\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE &&\n\t\t    nilfs_segbuf_empty(sci->sc_curseg)) {\n\t\t\tnilfs_segctor_abort_construction(sci, nilfs, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nilfs_segctor_assign(sci, mode);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\t\tnilfs_segctor_fill_in_file_bmap(sci);\n\n\t\tif (mode == SC_LSEG_SR &&\n\t\t    sci->sc_stage.scnt >= NILFS_ST_CPFILE) {\n\t\t\terr = nilfs_segctor_fill_in_checkpoint(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto failed_to_write;\n\n\t\t\tnilfs_segctor_fill_in_super_root(sci, nilfs);\n\t\t}\n\t\tnilfs_segctor_update_segusage(sci, nilfs->ns_sufile);\n\n\t\t/* Write partial segments */\n\t\tnilfs_segctor_prepare_write(sci);\n\n\t\tnilfs_add_checksums_on_logs(&sci->sc_segbufs,\n\t\t\t\t\t    nilfs->ns_crc_seed);\n\n\t\terr = nilfs_segctor_write(sci, nilfs);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_to_write;\n\n\t\tif (sci->sc_stage.scnt == NILFS_ST_DONE ||\n\t\t    nilfs->ns_blocksize_bits != PAGE_CACHE_SHIFT) {\n\t\t\t/*\n\t\t\t * At this point, we avoid double buffering\n\t\t\t * for blocksize < pagesize because page dirty\n\t\t\t * flag is turned off during write and dirty\n\t\t\t * buffers are not properly collected for\n\t\t\t * pages crossing over segments.\n\t\t\t */\n\t\t\terr = nilfs_segctor_wait(sci);\n\t\t\tif (err)\n\t\t\t\tgoto failed_to_write;\n\t\t}\n\t} while (sci->sc_stage.scnt != NILFS_ST_DONE);\n\n out:\n\tnilfs_segctor_drop_written_files(sci, nilfs);\n\treturn err;\n\n failed_to_write:\n\tif (sci->sc_stage.flags & NILFS_CF_IFILE_STARTED)\n\t\tnilfs_redirty_inodes(&sci->sc_dirty_files);\n\n failed:\n\tif (nilfs_doing_gc())\n\t\tnilfs_redirty_inodes(&sci->sc_gc_inodes);\n\tnilfs_segctor_abort_construction(sci, nilfs, err);\n\tgoto out;\n}"
  },
  {
    "function_name": "nilfs_segctor_drop_written_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1906-1940",
    "snippet": "static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tint during_mount = !(sci->sc_super->s_flags & MS_ACTIVE);\n\tint defer_iput = false;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tlist_for_each_entry_safe(ii, n, &sci->sc_dirty_files, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_UPDATED, &ii->i_state) ||\n\t\t    test_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tbrelse(ii->i_bh);\n\t\tii->i_bh = NULL;\n\t\tlist_del_init(&ii->i_dirty);\n\t\tif (!ii->vfs_inode.i_nlink || during_mount) {\n\t\t\t/*\n\t\t\t * Defer calling iput() to avoid deadlocks if\n\t\t\t * i_nlink == 0 or mount is not yet finished.\n\t\t\t */\n\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);\n\t\t\tdefer_iput = true;\n\t\t} else {\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\tiput(&ii->vfs_inode);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\tif (defer_iput)\n\t\tschedule_work(&sci->sc_iput_work);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sci->sc_iput_work"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&ii->vfs_inode"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ii->i_dirty",
            "&sci->sc_iput_queue"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ii->i_bh"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NILFS_I_UPDATED",
            "&ii->i_state"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ii",
            "n",
            "&sci->sc_dirty_files",
            "i_dirty"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tint during_mount = !(sci->sc_super->s_flags & MS_ACTIVE);\n\tint defer_iput = false;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tlist_for_each_entry_safe(ii, n, &sci->sc_dirty_files, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_UPDATED, &ii->i_state) ||\n\t\t    test_bit(NILFS_I_DIRTY, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tbrelse(ii->i_bh);\n\t\tii->i_bh = NULL;\n\t\tlist_del_init(&ii->i_dirty);\n\t\tif (!ii->vfs_inode.i_nlink || during_mount) {\n\t\t\t/*\n\t\t\t * Defer calling iput() to avoid deadlocks if\n\t\t\t * i_nlink == 0 or mount is not yet finished.\n\t\t\t */\n\t\t\tlist_add_tail(&ii->i_dirty, &sci->sc_iput_queue);\n\t\t\tdefer_iput = true;\n\t\t} else {\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\tiput(&ii->vfs_inode);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t}\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\tif (defer_iput)\n\t\tschedule_work(&sci->sc_iput_work);\n}"
  },
  {
    "function_name": "nilfs_segctor_collect_dirty_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1866-1904",
    "snippet": "static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct inode *ifile = sci->sc_root->ifile;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n retry:\n\tlist_for_each_entry_safe(ii, n, &nilfs->ns_dirty_files, i_dirty) {\n\t\tif (!ii->i_bh) {\n\t\t\tstruct buffer_head *ibh;\n\t\t\tint err;\n\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\terr = nilfs_ifile_get_inode_block(\n\t\t\t\tifile, ii->vfs_inode.i_ino, &ibh);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t\t\t      \"failed to get inode block.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmark_buffer_dirty(ibh);\n\t\t\tnilfs_mdt_mark_dirty(ifile);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t\tif (likely(!ii->i_bh))\n\t\t\t\tii->i_bh = ibh;\n\t\t\telse\n\t\t\t\tbrelse(ibh);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tclear_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\tset_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tlist_move_tail(&ii->i_dirty, &sci->sc_dirty_files);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ii->i_dirty",
            "&sci->sc_dirty_files"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_I_QUEUED",
            "&ii->i_state"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ibh"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ii->i_bh"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "ifile"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "ibh"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sci->sc_super",
            "__func__",
            "\"failed to get inode block.\\n\""
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_get_inode_block",
          "args": [
            "ifile",
            "ii->vfs_inode.i_ino",
            "&ibh"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_get_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "143-160",
          "snippet": "int nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ii",
            "n",
            "&nilfs->ns_dirty_files",
            "i_dirty"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct inode *ifile = sci->sc_root->ifile;\n\n\tspin_lock(&nilfs->ns_inode_lock);\n retry:\n\tlist_for_each_entry_safe(ii, n, &nilfs->ns_dirty_files, i_dirty) {\n\t\tif (!ii->i_bh) {\n\t\t\tstruct buffer_head *ibh;\n\t\t\tint err;\n\n\t\t\tspin_unlock(&nilfs->ns_inode_lock);\n\t\t\terr = nilfs_ifile_get_inode_block(\n\t\t\t\tifile, ii->vfs_inode.i_ino, &ibh);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tnilfs_warning(sci->sc_super, __func__,\n\t\t\t\t\t      \"failed to get inode block.\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmark_buffer_dirty(ibh);\n\t\t\tnilfs_mdt_mark_dirty(ifile);\n\t\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\t\tif (likely(!ii->i_bh))\n\t\t\t\tii->i_bh = ibh;\n\t\t\telse\n\t\t\t\tbrelse(ibh);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tclear_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\tset_bit(NILFS_I_BUSY, &ii->i_state);\n\t\tlist_move_tail(&ii->i_dirty, &sci->sc_dirty_files);\n\t}\n\tspin_unlock(&nilfs->ns_inode_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1854-1864",
    "snippet": "static int nilfs_segctor_wait(struct nilfs_sc_info *sci)\n{\n\tint ret;\n\n\tret = nilfs_wait_on_logs(&sci->sc_write_logs);\n\tif (!ret) {\n\t\tnilfs_segctor_complete_write(sci);\n\t\tnilfs_destroy_logs(&sci->sc_write_logs);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_destroy_logs",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "179-182",
          "snippet": "static inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_complete_write",
          "args": [
            "sci"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_complete_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1757-1852",
          "snippet": "static void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_wait_on_logs",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_wait_on_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "308-319",
          "snippet": "int nilfs_wait_on_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\terr = nilfs_segbuf_wait(segbuf);\n\t\tif (err && !ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_wait_on_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\terr = nilfs_segbuf_wait(segbuf);\n\t\tif (err && !ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_wait(struct nilfs_sc_info *sci)\n{\n\tint ret;\n\n\tret = nilfs_wait_on_logs(&sci->sc_write_logs);\n\tif (!ret) {\n\t\tnilfs_segctor_complete_write(sci);\n\t\tnilfs_destroy_logs(&sci->sc_write_logs);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_segctor_complete_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1757-1852",
    "snippet": "static void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_SC_SUPER_ROOT",
            "&sci->sc_flags"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_clear_metadata_dirty",
          "args": [
            "sci"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_clear_metadata_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "795-803",
          "snippet": "static void nilfs_segctor_clear_metadata_dirty(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_mdt_clear_dirty(sci->sc_root->ifile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_cpfile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_sufile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_dat);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_clear_metadata_dirty(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_mdt_clear_dirty(sci->sc_root->ifile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_cpfile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_sufile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_dat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_SC_SUPER_ROOT",
            "&sci->sc_flags"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_last_segment",
          "args": [
            "nilfs",
            "segbuf->sb_pseg_start",
            "segbuf->sb_sum.seg_seq",
            "nilfs->ns_cno++"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_last_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "41-59",
          "snippet": "void nilfs_set_last_segment(struct the_nilfs *nilfs,\n\t\t\t    sector_t start_blocknr, u64 seq, __u64 cno)\n{\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_last_pseg = start_blocknr;\n\tnilfs->ns_last_seq = seq;\n\tnilfs->ns_last_cno = cno;\n\n\tif (!nilfs_sb_dirty(nilfs)) {\n\t\tif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\n\t\t\tgoto stay_cursor;\n\n\t\tset_nilfs_sb_dirty(nilfs);\n\t}\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\n stay_cursor:\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_set_last_segment(struct the_nilfs *nilfs,\n\t\t\t    sector_t start_blocknr, u64 seq, __u64 cno)\n{\n\tspin_lock(&nilfs->ns_last_segment_lock);\n\tnilfs->ns_last_pseg = start_blocknr;\n\tnilfs->ns_last_seq = seq;\n\tnilfs->ns_last_cno = cno;\n\n\tif (!nilfs_sb_dirty(nilfs)) {\n\t\tif (nilfs->ns_prev_seq == nilfs->ns_last_seq)\n\t\t\tgoto stay_cursor;\n\n\t\tset_nilfs_sb_dirty(nilfs);\n\t}\n\tnilfs->ns_prev_seq = nilfs->ns_last_seq;\n\n stay_cursor:\n\tspin_unlock(&nilfs->ns_last_segment_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_set_next_segment",
          "args": [
            "nilfs",
            "segbuf"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_next_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1746-1755",
          "snippet": "static void nilfs_set_next_segment(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_segment_buffer *segbuf)\n{\n\tnilfs->ns_segnum = segbuf->sb_segnum;\n\tnilfs->ns_nextnum = segbuf->sb_nextnum;\n\tnilfs->ns_pseg_offset = segbuf->sb_pseg_start - segbuf->sb_fseg_start\n\t\t+ segbuf->sb_sum.nblocks;\n\tnilfs->ns_seg_seq = segbuf->sb_sum.seg_seq;\n\tnilfs->ns_ctime = segbuf->sb_sum.ctime;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_set_next_segment(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_segment_buffer *segbuf)\n{\n\tnilfs->ns_segnum = segbuf->sb_segnum;\n\tnilfs->ns_nextnum = segbuf->sb_nextnum;\n\tnilfs->ns_pseg_offset = segbuf->sb_pseg_start - segbuf->sb_fseg_start\n\t\t+ segbuf->sb_sum.nblocks;\n\tnilfs->ns_seg_seq = segbuf->sb_sum.seg_seq;\n\tnilfs->ns_ctime = segbuf->sb_sum.ctime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_LAST_SEGBUF",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_drop_collected_inodes",
          "args": [
            "&sci->sc_gc_inodes"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_drop_collected_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "931-942",
          "snippet": "static void nilfs_drop_collected_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\t\tset_bit(NILFS_I_UPDATED, &ii->i_state);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_drop_collected_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\t\tset_bit(NILFS_I_UPDATED, &ii->i_state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_end_page_io",
          "args": [
            "fs_page",
            "0"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_end_page_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1641-1677",
          "snippet": "static void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "bd_page"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_simplex",
          "args": [
            "segbuf"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_simplex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "133-139",
          "snippet": "static inline int nilfs_segbuf_simplex(struct nilfs_segment_buffer *segbuf)\n{\n\tunsigned int flags = segbuf->sb_sum.flags;\n\n\treturn (flags & (NILFS_SS_LOGBGN | NILFS_SS_LOGEND)) ==\n\t\t(NILFS_SS_LOGBGN | NILFS_SS_LOGEND);\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_segbuf_simplex(struct nilfs_segment_buffer *segbuf)\n{\n\tunsigned int flags = segbuf->sb_sum.flags;\n\n\treturn (flags & (NILFS_SS_LOGBGN | NILFS_SS_LOGEND)) ==\n\t\t(NILFS_SS_LOGBGN | NILFS_SS_LOGEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_redirected",
          "args": [
            "bh"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_nilfs_volatile",
          "args": [
            "bh"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_payload_buffers",
            "b_assoc_buffers"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_segsum_buffers",
            "b_assoc_buffers"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "&sci->sc_write_logs",
            "sb_list"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_complete_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint update_sr = false;\n\n\tlist_for_each_entry(segbuf, &sci->sc_write_logs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We assume that the buffers which belong to the same page\n\t\t * continue over the buffer list.\n\t\t * Under this assumption, the last BHs of pages is\n\t\t * identifiable by the discontinuity of bh->b_page\n\t\t * (page != fs_page).\n\t\t *\n\t\t * For B-tree node blocks, however, this assumption is not\n\t\t * guaranteed.  The cleanup code of B-tree node pages needs\n\t\t * special care.\n\t\t */\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tclear_buffer_delay(bh);\n\t\t\tclear_buffer_nilfs_volatile(bh);\n\t\t\tclear_buffer_nilfs_redirected(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tupdate_sr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, 0);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tif (!nilfs_segbuf_simplex(segbuf)) {\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGBGN) {\n\t\t\t\tset_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t\t\tsci->sc_lseg_stime = jiffies;\n\t\t\t}\n\t\t\tif (segbuf->sb_sum.flags & NILFS_SS_LOGEND)\n\t\t\t\tclear_bit(NILFS_SC_UNCLOSED, &sci->sc_flags);\n\t\t}\n\t}\n\t/*\n\t * Since pages may continue over multiple segment buffers,\n\t * end of the last page must be checked outside of the loop.\n\t */\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, 0);\n\n\tnilfs_drop_collected_inodes(&sci->sc_dirty_files);\n\n\tif (nilfs_doing_gc())\n\t\tnilfs_drop_collected_inodes(&sci->sc_gc_inodes);\n\telse\n\t\tnilfs->ns_nongc_ctime = sci->sc_seg_ctime;\n\n\tsci->sc_nblk_inc += sci->sc_nblk_this_inc;\n\n\tsegbuf = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\tnilfs_set_next_segment(nilfs, segbuf);\n\n\tif (update_sr) {\n\t\tnilfs->ns_flushed_device = 0;\n\t\tnilfs_set_last_segment(nilfs, segbuf->sb_pseg_start,\n\t\t\t\t       segbuf->sb_sum.seg_seq, nilfs->ns_cno++);\n\n\t\tclear_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t\tclear_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\t\tset_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n\t\tnilfs_segctor_clear_metadata_dirty(sci);\n\t} else\n\t\tclear_bit(NILFS_SC_SUPER_ROOT, &sci->sc_flags);\n}"
  },
  {
    "function_name": "nilfs_set_next_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1746-1755",
    "snippet": "static void nilfs_set_next_segment(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_segment_buffer *segbuf)\n{\n\tnilfs->ns_segnum = segbuf->sb_segnum;\n\tnilfs->ns_nextnum = segbuf->sb_nextnum;\n\tnilfs->ns_pseg_offset = segbuf->sb_pseg_start - segbuf->sb_fseg_start\n\t\t+ segbuf->sb_sum.nblocks;\n\tnilfs->ns_seg_seq = segbuf->sb_sum.seg_seq;\n\tnilfs->ns_ctime = segbuf->sb_sum.ctime;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_set_next_segment(struct the_nilfs *nilfs,\n\t\t\t\t   struct nilfs_segment_buffer *segbuf)\n{\n\tnilfs->ns_segnum = segbuf->sb_segnum;\n\tnilfs->ns_nextnum = segbuf->sb_nextnum;\n\tnilfs->ns_pseg_offset = segbuf->sb_pseg_start - segbuf->sb_fseg_start\n\t\t+ segbuf->sb_sum.nblocks;\n\tnilfs->ns_seg_seq = segbuf->sb_sum.seg_seq;\n\tnilfs->ns_ctime = segbuf->sb_sum.ctime;\n}"
  },
  {
    "function_name": "nilfs_segctor_abort_construction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1721-1744",
    "snippet": "static void nilfs_segctor_abort_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs, int err)\n{\n\tLIST_HEAD(logs);\n\tint ret;\n\n\tlist_splice_tail_init(&sci->sc_write_logs, &logs);\n\tret = nilfs_wait_on_logs(&logs);\n\tnilfs_abort_logs(&logs, ret ? : err);\n\n\tlist_splice_tail_init(&sci->sc_segbufs, &logs);\n\tnilfs_cancel_segusage(&logs, nilfs->ns_sufile);\n\tnilfs_free_incomplete_logs(&logs, nilfs);\n\n\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\tret = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\tNULL);\n\t\tWARN_ON(ret); /* do not happen */\n\t}\n\n\tnilfs_destroy_logs(&logs);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_destroy_logs",
          "args": [
            "&logs"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "179-182",
          "snippet": "static inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_cancel_freev",
          "args": [
            "nilfs->ns_sufile",
            "sci->sc_freesegs",
            "sci->sc_nfreesegs",
            "NULL"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_cancel_freev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "115-121",
          "snippet": "static inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_free_incomplete_logs",
          "args": [
            "&logs",
            "nilfs"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_free_incomplete_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1332-1367",
          "snippet": "static void nilfs_free_incomplete_logs(struct list_head *logs,\n\t\t\t\t       struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tif (nilfs->ns_nextnum != segbuf->sb_nextnum) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tif (atomic_read(&segbuf->sb_err)) {\n\t\t/* Case 1: The first segment failed */\n\t\tif (segbuf->sb_pseg_start != segbuf->sb_fseg_start)\n\t\t\t/* Case 1a:  Partial segment appended into an existing\n\t\t\t   segment */\n\t\t\tnilfs_terminate_segment(nilfs, segbuf->sb_fseg_start,\n\t\t\t\t\t\tsegbuf->sb_fseg_end);\n\t\telse /* Case 1b:  New full segment */\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\n\tprev = segbuf;\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tif (prev->sb_nextnum != segbuf->sb_nextnum) {\n\t\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\t\tWARN_ON(ret); /* never fails */\n\t\t}\n\t\tif (atomic_read(&segbuf->sb_err) &&\n\t\t    segbuf->sb_segnum != nilfs->ns_nextnum)\n\t\t\t/* Case 2: extended segment (!= next) failed */\n\t\t\tnilfs_sufile_set_error(sufile, segbuf->sb_segnum);\n\t\tprev = segbuf;\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_free_incomplete_logs(struct list_head *logs,\n\t\t\t\t       struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tif (nilfs->ns_nextnum != segbuf->sb_nextnum) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tif (atomic_read(&segbuf->sb_err)) {\n\t\t/* Case 1: The first segment failed */\n\t\tif (segbuf->sb_pseg_start != segbuf->sb_fseg_start)\n\t\t\t/* Case 1a:  Partial segment appended into an existing\n\t\t\t   segment */\n\t\t\tnilfs_terminate_segment(nilfs, segbuf->sb_fseg_start,\n\t\t\t\t\t\tsegbuf->sb_fseg_end);\n\t\telse /* Case 1b:  New full segment */\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\n\tprev = segbuf;\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tif (prev->sb_nextnum != segbuf->sb_nextnum) {\n\t\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\t\tWARN_ON(ret); /* never fails */\n\t\t}\n\t\tif (atomic_read(&segbuf->sb_err) &&\n\t\t    segbuf->sb_segnum != nilfs->ns_nextnum)\n\t\t\t/* Case 2: extended segment (!= next) failed */\n\t\t\tnilfs_sufile_set_error(sufile, segbuf->sb_segnum);\n\t\tprev = segbuf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_cancel_segusage",
          "args": [
            "&logs",
            "nilfs->ns_sufile"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cancel_segusage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1386-1402",
          "snippet": "static void nilfs_cancel_segusage(struct list_head *logs, struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t     segbuf->sb_pseg_start -\n\t\t\t\t\t     segbuf->sb_fseg_start, 0);\n\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     0, 0);\n\t\tWARN_ON(ret); /* always succeed */\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_cancel_segusage(struct list_head *logs, struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t     segbuf->sb_pseg_start -\n\t\t\t\t\t     segbuf->sb_fseg_start, 0);\n\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     0, 0);\n\t\tWARN_ON(ret); /* always succeed */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&sci->sc_segbufs",
            "&logs"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_abort_logs",
          "args": [
            "&logs",
            "ret ? : err"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_abort_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1679-1719",
          "snippet": "static void nilfs_abort_logs(struct list_head *logs, int err)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct buffer_head *bh;\n\n\tif (list_empty(logs))\n\t\treturn;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, err);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, err);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_abort_logs(struct list_head *logs, int err)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct buffer_head *bh;\n\n\tif (list_empty(logs))\n\t\treturn;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, err);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_wait_on_logs",
          "args": [
            "&logs"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_wait_on_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "308-319",
          "snippet": "int nilfs_wait_on_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\terr = nilfs_segbuf_wait(segbuf);\n\t\tif (err && !ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_wait_on_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err, ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\terr = nilfs_segbuf_wait(segbuf);\n\t\tif (err && !ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&sci->sc_write_logs",
            "&logs"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "logs"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_abort_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs, int err)\n{\n\tLIST_HEAD(logs);\n\tint ret;\n\n\tlist_splice_tail_init(&sci->sc_write_logs, &logs);\n\tret = nilfs_wait_on_logs(&logs);\n\tnilfs_abort_logs(&logs, ret ? : err);\n\n\tlist_splice_tail_init(&sci->sc_segbufs, &logs);\n\tnilfs_cancel_segusage(&logs, nilfs->ns_sufile);\n\tnilfs_free_incomplete_logs(&logs, nilfs);\n\n\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\tret = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\tNULL);\n\t\tWARN_ON(ret); /* do not happen */\n\t}\n\n\tnilfs_destroy_logs(&logs);\n}"
  },
  {
    "function_name": "nilfs_abort_logs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1679-1719",
    "snippet": "static void nilfs_abort_logs(struct list_head *logs, int err)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct buffer_head *bh;\n\n\tif (list_empty(logs))\n\t\treturn;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, err);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, err);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_end_page_io",
          "args": [
            "fs_page",
            "err"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_end_page_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1641-1677",
          "snippet": "static void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "bd_page"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_payload_buffers",
            "b_assoc_buffers"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_segsum_buffers",
            "b_assoc_buffers"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "logs",
            "sb_list"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "logs"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_abort_logs(struct list_head *logs, int err)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\tstruct buffer_head *bh;\n\n\tif (list_empty(logs))\n\t\treturn;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page)\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tend_page_writeback(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_end_page_io(fs_page, err);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page)\n\t\tend_page_writeback(bd_page);\n\n\tnilfs_end_page_io(fs_page, err);\n}"
  },
  {
    "function_name": "nilfs_end_page_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1641-1677",
    "snippet": "static void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_page_buffers_clean",
          "args": [
            "page"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nilfs_clear_page_dirty",
          "args": [
            "page"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__nilfs_clear_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "484-501",
          "snippet": "int __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint __nilfs_clear_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tspin_lock_irq(&mapping->tree_lock);\n\t\tif (test_bit(PG_dirty, &page->flags)) {\n\t\t\tradix_tree_tag_clear(&mapping->page_tree,\n\t\t\t\t\t     page_index(page),\n\t\t\t\t\t     PAGECACHE_TAG_DIRTY);\n\t\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\t\treturn clear_page_dirty_for_io(page);\n\t\t}\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn 0;\n\t}\n\treturn TestClearPageDirty(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_nilfs_node",
          "args": [
            "page_buffers(page)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_end_page_io(struct page *page, int err)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (buffer_nilfs_node(page_buffers(page)) && !PageWriteback(page)) {\n\t\t/*\n\t\t * For b-tree node pages, this function may be called twice\n\t\t * or more because they might be split in a segment.\n\t\t */\n\t\tif (PageDirty(page)) {\n\t\t\t/*\n\t\t\t * For pages holding split b-tree node buffers, dirty\n\t\t\t * flag on the buffers may be cleared discretely.\n\t\t\t * In that case, the page is once redirtied for\n\t\t\t * remaining buffers, and it must be cancelled if\n\t\t\t * all the buffers get cleaned later.\n\t\t\t */\n\t\t\tlock_page(page);\n\t\t\tif (nilfs_page_buffers_clean(page))\n\t\t\t\t__nilfs_clear_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!err) {\n\t\tif (!nilfs_page_buffers_clean(page))\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\tClearPageError(page);\n\t} else {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tSetPageError(page);\n\t}\n\n\tend_page_writeback(page);\n}"
  },
  {
    "function_name": "nilfs_segctor_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1631-1639",
    "snippet": "static int nilfs_segctor_write(struct nilfs_sc_info *sci,\n\t\t\t       struct the_nilfs *nilfs)\n{\n\tint ret;\n\n\tret = nilfs_write_logs(&sci->sc_segbufs, nilfs);\n\tlist_splice_tail_init(&sci->sc_segbufs, &sci->sc_write_logs);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&sci->sc_segbufs",
            "&sci->sc_write_logs"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_write_logs",
          "args": [
            "&sci->sc_segbufs",
            "nilfs"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "295-306",
          "snippet": "int nilfs_write_logs(struct list_head *logs, struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tret = nilfs_segbuf_write(segbuf, nilfs);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);",
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_write_logs(struct list_head *logs, struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret = 0;\n\n\tlist_for_each_entry(segbuf, logs, sb_list) {\n\t\tret = nilfs_segbuf_write(segbuf, nilfs);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_write(struct nilfs_sc_info *sci,\n\t\t\t       struct the_nilfs *nilfs)\n{\n\tint ret;\n\n\tret = nilfs_write_logs(&sci->sc_segbufs, nilfs);\n\tlist_splice_tail_init(&sci->sc_segbufs, &sci->sc_write_logs);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_segctor_prepare_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1581-1629",
    "snippet": "static void nilfs_segctor_prepare_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t}\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_begin_page_io(fs_page);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page) {\n\t\tlock_page(bd_page);\n\t\tclear_page_dirty_for_io(bd_page);\n\t\tset_page_writeback(bd_page);\n\t\tunlock_page(bd_page);\n\t}\n\tnilfs_begin_page_io(fs_page);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_begin_page_io",
          "args": [
            "fs_page"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_begin_page_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1568-1579",
          "snippet": "static void nilfs_begin_page_io(struct page *page)\n{\n\tif (!page || PageWriteback(page))\n\t\t/* For split b-tree node pages, this function may be called\n\t\t   twice.  We ignore the 2nd or later calls by this check. */\n\t\treturn;\n\n\tlock_page(page);\n\tclear_page_dirty_for_io(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_begin_page_io(struct page *page)\n{\n\tif (!page || PageWriteback(page))\n\t\t/* For split b-tree node pages, this function may be called\n\t\t   twice.  We ignore the 2nd or later calls by this check. */\n\t\treturn;\n\n\tlock_page(page);\n\tclear_page_dirty_for_io(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bd_page"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "bd_page"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "bd_page"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "bd_page"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_payload_buffers",
            "b_assoc_buffers"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "bd_page"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_segsum_buffers",
            "b_assoc_buffers"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "&sci->sc_segbufs",
            "sb_list"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_prepare_write(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tstruct page *bd_page = NULL, *fs_page = NULL;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tstruct buffer_head *bh;\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_segsum_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\tif (bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t}\n\t\t\t\tbd_page = bh->b_page;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers,\n\t\t\t\t    b_assoc_buffers) {\n\t\t\tset_buffer_async_write(bh);\n\t\t\tif (bh == segbuf->sb_super_root) {\n\t\t\t\tif (bh->b_page != bd_page) {\n\t\t\t\t\tlock_page(bd_page);\n\t\t\t\t\tclear_page_dirty_for_io(bd_page);\n\t\t\t\t\tset_page_writeback(bd_page);\n\t\t\t\t\tunlock_page(bd_page);\n\t\t\t\t\tbd_page = bh->b_page;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bh->b_page != fs_page) {\n\t\t\t\tnilfs_begin_page_io(fs_page);\n\t\t\t\tfs_page = bh->b_page;\n\t\t\t}\n\t\t}\n\t}\n\tif (bd_page) {\n\t\tlock_page(bd_page);\n\t\tclear_page_dirty_for_io(bd_page);\n\t\tset_page_writeback(bd_page);\n\t\tunlock_page(bd_page);\n\t}\n\tnilfs_begin_page_io(fs_page);\n}"
  },
  {
    "function_name": "nilfs_begin_page_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1568-1579",
    "snippet": "static void nilfs_begin_page_io(struct page *page)\n{\n\tif (!page || PageWriteback(page))\n\t\t/* For split b-tree node pages, this function may be called\n\t\t   twice.  We ignore the 2nd or later calls by this check. */\n\t\treturn;\n\n\tlock_page(page);\n\tclear_page_dirty_for_io(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_begin_page_io(struct page *page)\n{\n\tif (!page || PageWriteback(page))\n\t\t/* For split b-tree node pages, this function may be called\n\t\t   twice.  We ignore the 2nd or later calls by this check. */\n\t\treturn;\n\n\tlock_page(page);\n\tclear_page_dirty_for_io(page);\n\tset_page_writeback(page);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "nilfs_segctor_assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1554-1566",
    "snippet": "static int nilfs_segctor_assign(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\terr = nilfs_segctor_update_payload_blocknr(sci, segbuf, mode);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tnilfs_segbuf_fill_in_segsum(segbuf);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segbuf_fill_in_segsum",
          "args": [
            "segbuf"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_fill_in_segsum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "157-177",
          "snippet": "void nilfs_segbuf_fill_in_segsum(struct nilfs_segment_buffer *segbuf)\n{\n\tstruct nilfs_segment_summary *raw_sum;\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = list_entry(segbuf->sb_segsum_buffers.next,\n\t\t\t    struct buffer_head, b_assoc_buffers);\n\traw_sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\n\traw_sum->ss_magic    = cpu_to_le32(NILFS_SEGSUM_MAGIC);\n\traw_sum->ss_bytes    = cpu_to_le16(sizeof(*raw_sum));\n\traw_sum->ss_flags    = cpu_to_le16(segbuf->sb_sum.flags);\n\traw_sum->ss_seq      = cpu_to_le64(segbuf->sb_sum.seg_seq);\n\traw_sum->ss_create   = cpu_to_le64(segbuf->sb_sum.ctime);\n\traw_sum->ss_next     = cpu_to_le64(segbuf->sb_sum.next);\n\traw_sum->ss_nblocks  = cpu_to_le32(segbuf->sb_sum.nblocks);\n\traw_sum->ss_nfinfo   = cpu_to_le32(segbuf->sb_sum.nfinfo);\n\traw_sum->ss_sumbytes = cpu_to_le32(segbuf->sb_sum.sumbytes);\n\traw_sum->ss_pad      = 0;\n\traw_sum->ss_cno      = cpu_to_le64(segbuf->sb_sum.cno);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_fill_in_segsum(struct nilfs_segment_buffer *segbuf)\n{\n\tstruct nilfs_segment_summary *raw_sum;\n\tstruct buffer_head *bh_sum;\n\n\tbh_sum = list_entry(segbuf->sb_segsum_buffers.next,\n\t\t\t    struct buffer_head, b_assoc_buffers);\n\traw_sum = (struct nilfs_segment_summary *)bh_sum->b_data;\n\n\traw_sum->ss_magic    = cpu_to_le32(NILFS_SEGSUM_MAGIC);\n\traw_sum->ss_bytes    = cpu_to_le16(sizeof(*raw_sum));\n\traw_sum->ss_flags    = cpu_to_le16(segbuf->sb_sum.flags);\n\traw_sum->ss_seq      = cpu_to_le64(segbuf->sb_sum.seg_seq);\n\traw_sum->ss_create   = cpu_to_le64(segbuf->sb_sum.ctime);\n\traw_sum->ss_next     = cpu_to_le64(segbuf->sb_sum.next);\n\traw_sum->ss_nblocks  = cpu_to_le32(segbuf->sb_sum.nblocks);\n\traw_sum->ss_nfinfo   = cpu_to_le32(segbuf->sb_sum.nfinfo);\n\traw_sum->ss_sumbytes = cpu_to_le32(segbuf->sb_sum.sumbytes);\n\traw_sum->ss_pad      = 0;\n\traw_sum->ss_cno      = cpu_to_le64(segbuf->sb_sum.cno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_update_payload_blocknr",
          "args": [
            "sci",
            "segbuf",
            "mode"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_update_payload_blocknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1481-1552",
          "snippet": "static int\nnilfs_segctor_update_payload_blocknr(struct nilfs_sc_info *sci,\n\t\t\t\t     struct nilfs_segment_buffer *segbuf,\n\t\t\t\t     int mode)\n{\n\tstruct inode *inode = NULL;\n\tsector_t blocknr;\n\tunsigned long nfinfo = segbuf->sb_sum.nfinfo;\n\tunsigned long nblocks = 0, ndatablk = 0;\n\tstruct nilfs_sc_operations *sc_op = NULL;\n\tstruct nilfs_segsum_pointer ssp;\n\tstruct nilfs_finfo *finfo = NULL;\n\tunion nilfs_binfo binfo;\n\tstruct buffer_head *bh, *bh_org;\n\tino_t ino = 0;\n\tint err = 0;\n\n\tif (!nfinfo)\n\t\tgoto out;\n\n\tblocknr = segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk;\n\tssp.bh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tssp.offset = sizeof(struct nilfs_segment_summary);\n\n\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\n\t\tif (bh == segbuf->sb_super_root)\n\t\t\tbreak;\n\t\tif (!finfo) {\n\t\t\tfinfo =\tnilfs_segctor_map_segsum_entry(\n\t\t\t\tsci, &ssp, sizeof(*finfo));\n\t\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\n\t\t\tinode = bh->b_page->mapping->host;\n\n\t\t\tif (mode == SC_LSEG_DSYNC)\n\t\t\t\tsc_op = &nilfs_sc_dsync_ops;\n\t\t\telse if (ino == NILFS_DAT_INO)\n\t\t\t\tsc_op = &nilfs_sc_dat_ops;\n\t\t\telse /* file blocks */\n\t\t\t\tsc_op = &nilfs_sc_file_ops;\n\t\t}\n\t\tbh_org = bh;\n\t\tget_bh(bh_org);\n\t\terr = nilfs_bmap_assign(NILFS_I(inode)->i_bmap, &bh, blocknr,\n\t\t\t\t\t&binfo);\n\t\tif (bh != bh_org)\n\t\t\tnilfs_list_replace_buffer(bh_org, bh);\n\t\tbrelse(bh_org);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_bmap;\n\n\t\tif (ndatablk > 0)\n\t\t\tsc_op->write_data_binfo(sci, &ssp, &binfo);\n\t\telse\n\t\t\tsc_op->write_node_binfo(sci, &ssp, &binfo);\n\n\t\tblocknr++;\n\t\tif (--nblocks == 0) {\n\t\t\tfinfo = NULL;\n\t\t\tif (--nfinfo == 0)\n\t\t\t\tbreak;\n\t\t} else if (ndatablk > 0)\n\t\t\tndatablk--;\n\t}\n out:\n\treturn 0;\n\n failed_bmap:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
            "static struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};",
            "static struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};",
            "static struct nilfs_sc_operations nilfs_sc_dsync_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = NULL,\n\t.collect_bmap = NULL,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dsync_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = NULL,\n\t.collect_bmap = NULL,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = NULL,\n};\n\nstatic int\nnilfs_segctor_update_payload_blocknr(struct nilfs_sc_info *sci,\n\t\t\t\t     struct nilfs_segment_buffer *segbuf,\n\t\t\t\t     int mode)\n{\n\tstruct inode *inode = NULL;\n\tsector_t blocknr;\n\tunsigned long nfinfo = segbuf->sb_sum.nfinfo;\n\tunsigned long nblocks = 0, ndatablk = 0;\n\tstruct nilfs_sc_operations *sc_op = NULL;\n\tstruct nilfs_segsum_pointer ssp;\n\tstruct nilfs_finfo *finfo = NULL;\n\tunion nilfs_binfo binfo;\n\tstruct buffer_head *bh, *bh_org;\n\tino_t ino = 0;\n\tint err = 0;\n\n\tif (!nfinfo)\n\t\tgoto out;\n\n\tblocknr = segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk;\n\tssp.bh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tssp.offset = sizeof(struct nilfs_segment_summary);\n\n\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\n\t\tif (bh == segbuf->sb_super_root)\n\t\t\tbreak;\n\t\tif (!finfo) {\n\t\t\tfinfo =\tnilfs_segctor_map_segsum_entry(\n\t\t\t\tsci, &ssp, sizeof(*finfo));\n\t\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\n\t\t\tinode = bh->b_page->mapping->host;\n\n\t\t\tif (mode == SC_LSEG_DSYNC)\n\t\t\t\tsc_op = &nilfs_sc_dsync_ops;\n\t\t\telse if (ino == NILFS_DAT_INO)\n\t\t\t\tsc_op = &nilfs_sc_dat_ops;\n\t\t\telse /* file blocks */\n\t\t\t\tsc_op = &nilfs_sc_file_ops;\n\t\t}\n\t\tbh_org = bh;\n\t\tget_bh(bh_org);\n\t\terr = nilfs_bmap_assign(NILFS_I(inode)->i_bmap, &bh, blocknr,\n\t\t\t\t\t&binfo);\n\t\tif (bh != bh_org)\n\t\t\tnilfs_list_replace_buffer(bh_org, bh);\n\t\tbrelse(bh_org);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_bmap;\n\n\t\tif (ndatablk > 0)\n\t\t\tsc_op->write_data_binfo(sci, &ssp, &binfo);\n\t\telse\n\t\t\tsc_op->write_node_binfo(sci, &ssp, &binfo);\n\n\t\tblocknr++;\n\t\tif (--nblocks == 0) {\n\t\t\tfinfo = NULL;\n\t\t\tif (--nfinfo == 0)\n\t\t\t\tbreak;\n\t\t} else if (ndatablk > 0)\n\t\t\tndatablk--;\n\t}\n out:\n\treturn 0;\n\n failed_bmap:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "&sci->sc_segbufs",
            "sb_list"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_assign(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint err;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\terr = nilfs_segctor_update_payload_blocknr(sci, segbuf, mode);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tnilfs_segbuf_fill_in_segsum(segbuf);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_update_payload_blocknr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1481-1552",
    "snippet": "static int\nnilfs_segctor_update_payload_blocknr(struct nilfs_sc_info *sci,\n\t\t\t\t     struct nilfs_segment_buffer *segbuf,\n\t\t\t\t     int mode)\n{\n\tstruct inode *inode = NULL;\n\tsector_t blocknr;\n\tunsigned long nfinfo = segbuf->sb_sum.nfinfo;\n\tunsigned long nblocks = 0, ndatablk = 0;\n\tstruct nilfs_sc_operations *sc_op = NULL;\n\tstruct nilfs_segsum_pointer ssp;\n\tstruct nilfs_finfo *finfo = NULL;\n\tunion nilfs_binfo binfo;\n\tstruct buffer_head *bh, *bh_org;\n\tino_t ino = 0;\n\tint err = 0;\n\n\tif (!nfinfo)\n\t\tgoto out;\n\n\tblocknr = segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk;\n\tssp.bh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tssp.offset = sizeof(struct nilfs_segment_summary);\n\n\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\n\t\tif (bh == segbuf->sb_super_root)\n\t\t\tbreak;\n\t\tif (!finfo) {\n\t\t\tfinfo =\tnilfs_segctor_map_segsum_entry(\n\t\t\t\tsci, &ssp, sizeof(*finfo));\n\t\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\n\t\t\tinode = bh->b_page->mapping->host;\n\n\t\t\tif (mode == SC_LSEG_DSYNC)\n\t\t\t\tsc_op = &nilfs_sc_dsync_ops;\n\t\t\telse if (ino == NILFS_DAT_INO)\n\t\t\t\tsc_op = &nilfs_sc_dat_ops;\n\t\t\telse /* file blocks */\n\t\t\t\tsc_op = &nilfs_sc_file_ops;\n\t\t}\n\t\tbh_org = bh;\n\t\tget_bh(bh_org);\n\t\terr = nilfs_bmap_assign(NILFS_I(inode)->i_bmap, &bh, blocknr,\n\t\t\t\t\t&binfo);\n\t\tif (bh != bh_org)\n\t\t\tnilfs_list_replace_buffer(bh_org, bh);\n\t\tbrelse(bh_org);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_bmap;\n\n\t\tif (ndatablk > 0)\n\t\t\tsc_op->write_data_binfo(sci, &ssp, &binfo);\n\t\telse\n\t\t\tsc_op->write_node_binfo(sci, &ssp, &binfo);\n\n\t\tblocknr++;\n\t\tif (--nblocks == 0) {\n\t\t\tfinfo = NULL;\n\t\t\tif (--nfinfo == 0)\n\t\t\t\tbreak;\n\t\t} else if (ndatablk > 0)\n\t\t\tndatablk--;\n\t}\n out:\n\treturn 0;\n\n failed_bmap:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
      "static struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};",
      "static struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};",
      "static struct nilfs_sc_operations nilfs_sc_dsync_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = NULL,\n\t.collect_bmap = NULL,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc_op->write_node_binfo",
          "args": [
            "sci",
            "&ssp",
            "&binfo"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_op->write_data_binfo",
          "args": [
            "sci",
            "&ssp",
            "&binfo"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh_org"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_list_replace_buffer",
          "args": [
            "bh_org",
            "bh"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_list_replace_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1472-1479",
          "snippet": "static void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_assign",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "&bh",
            "blocknr",
            "&binfo"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "361-373",
          "snippet": "int nilfs_bmap_assign(struct nilfs_bmap *bmap,\n\t\t      struct buffer_head **bh,\n\t\t      unsigned long blocknr,\n\t\t      union nilfs_binfo *binfo)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_assign(bmap, bh, blocknr, binfo);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_assign(struct nilfs_bmap *bmap,\n\t\t      struct buffer_head **bh,\n\t\t      unsigned long blocknr,\n\t\t      union nilfs_binfo *binfo)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_assign(bmap, bh, blocknr, binfo);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh_org"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "finfo->fi_ndatablk"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "finfo->fi_ino"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "&ssp",
            "sizeof(*finfo)"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bh",
            "&segbuf->sb_payload_buffers",
            "b_assoc_buffers"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SEGBUF_FIRST_BH",
          "args": [
            "&segbuf->sb_segsum_buffers"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dsync_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = NULL,\n\t.collect_bmap = NULL,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = NULL,\n};\n\nstatic int\nnilfs_segctor_update_payload_blocknr(struct nilfs_sc_info *sci,\n\t\t\t\t     struct nilfs_segment_buffer *segbuf,\n\t\t\t\t     int mode)\n{\n\tstruct inode *inode = NULL;\n\tsector_t blocknr;\n\tunsigned long nfinfo = segbuf->sb_sum.nfinfo;\n\tunsigned long nblocks = 0, ndatablk = 0;\n\tstruct nilfs_sc_operations *sc_op = NULL;\n\tstruct nilfs_segsum_pointer ssp;\n\tstruct nilfs_finfo *finfo = NULL;\n\tunion nilfs_binfo binfo;\n\tstruct buffer_head *bh, *bh_org;\n\tino_t ino = 0;\n\tint err = 0;\n\n\tif (!nfinfo)\n\t\tgoto out;\n\n\tblocknr = segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk;\n\tssp.bh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tssp.offset = sizeof(struct nilfs_segment_summary);\n\n\tlist_for_each_entry(bh, &segbuf->sb_payload_buffers, b_assoc_buffers) {\n\t\tif (bh == segbuf->sb_super_root)\n\t\t\tbreak;\n\t\tif (!finfo) {\n\t\t\tfinfo =\tnilfs_segctor_map_segsum_entry(\n\t\t\t\tsci, &ssp, sizeof(*finfo));\n\t\t\tino = le64_to_cpu(finfo->fi_ino);\n\t\t\tnblocks = le32_to_cpu(finfo->fi_nblocks);\n\t\t\tndatablk = le32_to_cpu(finfo->fi_ndatablk);\n\n\t\t\tinode = bh->b_page->mapping->host;\n\n\t\t\tif (mode == SC_LSEG_DSYNC)\n\t\t\t\tsc_op = &nilfs_sc_dsync_ops;\n\t\t\telse if (ino == NILFS_DAT_INO)\n\t\t\t\tsc_op = &nilfs_sc_dat_ops;\n\t\t\telse /* file blocks */\n\t\t\t\tsc_op = &nilfs_sc_file_ops;\n\t\t}\n\t\tbh_org = bh;\n\t\tget_bh(bh_org);\n\t\terr = nilfs_bmap_assign(NILFS_I(inode)->i_bmap, &bh, blocknr,\n\t\t\t\t\t&binfo);\n\t\tif (bh != bh_org)\n\t\t\tnilfs_list_replace_buffer(bh_org, bh);\n\t\tbrelse(bh_org);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_bmap;\n\n\t\tif (ndatablk > 0)\n\t\t\tsc_op->write_data_binfo(sci, &ssp, &binfo);\n\t\telse\n\t\t\tsc_op->write_node_binfo(sci, &ssp, &binfo);\n\n\t\tblocknr++;\n\t\tif (--nblocks == 0) {\n\t\t\tfinfo = NULL;\n\t\t\tif (--nfinfo == 0)\n\t\t\t\tbreak;\n\t\t} else if (ndatablk > 0)\n\t\t\tndatablk--;\n\t}\n out:\n\treturn 0;\n\n failed_bmap:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_list_replace_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1472-1479",
    "snippet": "static void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&old_bh->b_assoc_buffers",
            "&new_bh->b_assoc_buffers"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&new_bh->b_assoc_buffers)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&new_bh->b_assoc_buffers"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}"
  },
  {
    "function_name": "nilfs_segctor_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1420-1470",
    "snippet": "static int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */",
      "#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_truncate_segments",
          "args": [
            "sci",
            "sci->sc_curseg",
            "nilfs->ns_sufile"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_truncate_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1404-1417",
          "snippet": "static void nilfs_segctor_truncate_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segment_buffer *last,\n\t\t\t\t\t    struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf = last;\n\tint ret;\n\n\tlist_for_each_entry_continue(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tsci->sc_segbuf_nblocks -= segbuf->sb_rest_blocks;\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret);\n\t}\n\tnilfs_truncate_logs(&sci->sc_segbufs, last);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_truncate_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segment_buffer *last,\n\t\t\t\t\t    struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf = last;\n\tint ret;\n\n\tlist_for_each_entry_continue(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tsci->sc_segbuf_nblocks -= segbuf->sb_rest_blocks;\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret);\n\t}\n\tnilfs_truncate_logs(&sci->sc_segbufs, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "nadd << 1",
            "SC_MAX_SEGDELTA"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_extend_segments",
          "args": [
            "sci",
            "nilfs",
            "nadd"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_extend_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1276-1330",
          "snippet": "static int nilfs_segctor_extend_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct the_nilfs *nilfs, int nadd)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 nextnextnum;\n\tLIST_HEAD(list);\n\tint err, ret, i;\n\n\tprev = NILFS_LAST_SEGBUF(&sci->sc_segbufs);\n\t/*\n\t * Since the segment specified with nextnum might be allocated during\n\t * the previous construction, the buffer including its segusage may\n\t * not be dirty.  The following call ensures that the buffer is dirty\n\t * and will pin the buffer on memory until the sufile is written.\n\t */\n\terr = nilfs_sufile_mark_dirty(sufile, prev->sb_nextnum);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tfor (i = 0; i < nadd; i++) {\n\t\t/* extend segment info */\n\t\terr = -ENOMEM;\n\t\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\t\tif (unlikely(!segbuf))\n\t\t\tgoto failed;\n\n\t\t/* map this buffer to region of segment on-disk */\n\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\tsci->sc_segbuf_nblocks += segbuf->sb_rest_blocks;\n\n\t\t/* allocate the next next full segment */\n\t\terr = nilfs_sufile_alloc(sufile, &nextnextnum);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_segbuf;\n\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq + 1;\n\t\tnilfs_segbuf_set_next_segnum(segbuf, nextnextnum, nilfs);\n\n\t\tlist_add_tail(&segbuf->sb_list, &list);\n\t\tprev = segbuf;\n\t}\n\tlist_splice_tail(&list, &sci->sc_segbufs);\n\treturn 0;\n\n failed_segbuf:\n\tnilfs_segbuf_free(segbuf);\n failed:\n\tlist_for_each_entry(segbuf, &list, sb_list) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tnilfs_destroy_logs(&list);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_extend_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct the_nilfs *nilfs, int nadd)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 nextnextnum;\n\tLIST_HEAD(list);\n\tint err, ret, i;\n\n\tprev = NILFS_LAST_SEGBUF(&sci->sc_segbufs);\n\t/*\n\t * Since the segment specified with nextnum might be allocated during\n\t * the previous construction, the buffer including its segusage may\n\t * not be dirty.  The following call ensures that the buffer is dirty\n\t * and will pin the buffer on memory until the sufile is written.\n\t */\n\terr = nilfs_sufile_mark_dirty(sufile, prev->sb_nextnum);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tfor (i = 0; i < nadd; i++) {\n\t\t/* extend segment info */\n\t\terr = -ENOMEM;\n\t\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\t\tif (unlikely(!segbuf))\n\t\t\tgoto failed;\n\n\t\t/* map this buffer to region of segment on-disk */\n\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\tsci->sc_segbuf_nblocks += segbuf->sb_rest_blocks;\n\n\t\t/* allocate the next next full segment */\n\t\terr = nilfs_sufile_alloc(sufile, &nextnextnum);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_segbuf;\n\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq + 1;\n\t\tnilfs_segbuf_set_next_segnum(segbuf, nextnextnum, nilfs);\n\n\t\tlist_add_tail(&segbuf->sb_list, &list);\n\t\tprev = segbuf;\n\t}\n\tlist_splice_tail(&list, &sci->sc_segbufs);\n\treturn 0;\n\n failed_segbuf:\n\tnilfs_segbuf_free(segbuf);\n failed:\n\tlist_for_each_entry(segbuf, &list, sb_list) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tnilfs_destroy_logs(&list);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_cancel_freev",
          "args": [
            "nilfs->ns_sufile",
            "sci->sc_freesegs",
            "sci->sc_nfreesegs",
            "NULL"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_cancel_freev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "115-121",
          "snippet": "static inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_clear_logs",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_clear_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "274-280",
          "snippet": "void nilfs_clear_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tlist_for_each_entry(segbuf, logs, sb_list)\n\t\tnilfs_segbuf_clear(segbuf);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_clear_logs(struct list_head *logs)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tlist_for_each_entry(segbuf, logs, sb_list)\n\t\tnilfs_segbuf_clear(segbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err != -E2BIG"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_collect_blocks",
          "args": [
            "sci",
            "mode"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_collect_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1056-1209",
          "snippet": "static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct list_head *head;\n\tstruct nilfs_inode_info *ii;\n\tsize_t ndone;\n\tint err = 0;\n\n\tswitch (sci->sc_stage.scnt) {\n\tcase NILFS_ST_INIT:\n\t\t/* Pre-processes */\n\t\tsci->sc_stage.flags = 0;\n\n\t\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags)) {\n\t\t\tsci->sc_nblk_inc = 0;\n\t\t\tsci->sc_curseg->sb_sum.flags = NILFS_SS_LOGBGN;\n\t\t\tif (mode == SC_LSEG_DSYNC) {\n\t\t\t\tsci->sc_stage.scnt = NILFS_ST_DSYNC;\n\t\t\t\tgoto dsync_mode;\n\t\t\t}\n\t\t}\n\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DAT;\n\t\t\tgoto dat_stage;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_GC:\n\t\tif (nilfs_doing_gc()) {\n\t\t\thead = &sci->sc_gc_inodes;\n\t\t\tii = list_prepare_entry(sci->sc_stage.gc_inode_ptr,\n\t\t\t\t\t\thead, i_dirty);\n\t\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\t\terr = nilfs_segctor_scan_file(\n\t\t\t\t\tsci, &ii->vfs_inode,\n\t\t\t\t\t&nilfs_sc_file_ops);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tsci->sc_stage.gc_inode_ptr = list_entry(\n\t\t\t\t\t\tii->i_dirty.prev,\n\t\t\t\t\t\tstruct nilfs_inode_info,\n\t\t\t\t\t\ti_dirty);\n\t\t\t\t\tgoto break_or_fail;\n\t\t\t\t}\n\t\t\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t\t\t}\n\t\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_FILE:\n\t\thead = &sci->sc_dirty_files;\n\t\tii = list_prepare_entry(sci->sc_stage.dirty_file_ptr, head,\n\t\t\t\t\ti_dirty);\n\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\tclear_bit(NILFS_I_DIRTY, &ii->i_state);\n\n\t\t\terr = nilfs_segctor_scan_file(sci, &ii->vfs_inode,\n\t\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tsci->sc_stage.dirty_file_ptr =\n\t\t\t\t\tlist_entry(ii->i_dirty.prev,\n\t\t\t\t\t\t   struct nilfs_inode_info,\n\t\t\t\t\t\t   i_dirty);\n\t\t\t\tgoto break_or_fail;\n\t\t\t}\n\t\t\t/* sci->sc_stage.dirty_file_ptr = NILFS_I(inode); */\n\t\t\t/* XXX: required ? */\n\t\t}\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tif (mode == SC_FLUSH_FILE) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;\n\t\tsci->sc_stage.flags |= NILFS_CF_IFILE_STARTED;\n\t\t/* Fall through */\n\tcase NILFS_ST_IFILE:\n\t\terr = nilfs_segctor_scan_file(sci, sci->sc_root->ifile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;\n\t\t/* Creating a checkpoint */\n\t\terr = nilfs_segctor_create_checkpoint(sci);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\t/* Fall through */\n\tcase NILFS_ST_CPFILE:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_cpfile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SUFILE:\n\t\terr = nilfs_sufile_freev(nilfs->ns_sufile, sci->sc_freesegs,\n\t\t\t\t\t sci->sc_nfreesegs, &ndone);\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t  sci->sc_freesegs, ndone,\n\t\t\t\t\t\t  NULL);\n\t\t\tbreak;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_SUFREED;\n\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_sufile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_DAT:\n dat_stage:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_dat,\n\t\t\t\t\t      &nilfs_sc_dat_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SR:\n\t\tif (mode == SC_LSEG_SR) {\n\t\t\t/* Appending a super root */\n\t\t\terr = nilfs_segctor_add_super_root(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* End of a logical segment */\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DSYNC:\n dsync_mode:\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_SYNDT;\n\t\tii = sci->sc_dsync_inode;\n\t\tif (!test_bit(NILFS_I_BUSY, &ii->i_state))\n\t\t\tbreak;\n\n\t\terr = nilfs_segctor_scan_file_dsync(sci, &ii->vfs_inode);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DONE:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n\n break_or_fail:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */",
            "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);",
            "static struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};",
            "static struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\nstatic struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};\n\nstatic int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct list_head *head;\n\tstruct nilfs_inode_info *ii;\n\tsize_t ndone;\n\tint err = 0;\n\n\tswitch (sci->sc_stage.scnt) {\n\tcase NILFS_ST_INIT:\n\t\t/* Pre-processes */\n\t\tsci->sc_stage.flags = 0;\n\n\t\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags)) {\n\t\t\tsci->sc_nblk_inc = 0;\n\t\t\tsci->sc_curseg->sb_sum.flags = NILFS_SS_LOGBGN;\n\t\t\tif (mode == SC_LSEG_DSYNC) {\n\t\t\t\tsci->sc_stage.scnt = NILFS_ST_DSYNC;\n\t\t\t\tgoto dsync_mode;\n\t\t\t}\n\t\t}\n\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DAT;\n\t\t\tgoto dat_stage;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_GC:\n\t\tif (nilfs_doing_gc()) {\n\t\t\thead = &sci->sc_gc_inodes;\n\t\t\tii = list_prepare_entry(sci->sc_stage.gc_inode_ptr,\n\t\t\t\t\t\thead, i_dirty);\n\t\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\t\terr = nilfs_segctor_scan_file(\n\t\t\t\t\tsci, &ii->vfs_inode,\n\t\t\t\t\t&nilfs_sc_file_ops);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tsci->sc_stage.gc_inode_ptr = list_entry(\n\t\t\t\t\t\tii->i_dirty.prev,\n\t\t\t\t\t\tstruct nilfs_inode_info,\n\t\t\t\t\t\ti_dirty);\n\t\t\t\t\tgoto break_or_fail;\n\t\t\t\t}\n\t\t\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t\t\t}\n\t\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_FILE:\n\t\thead = &sci->sc_dirty_files;\n\t\tii = list_prepare_entry(sci->sc_stage.dirty_file_ptr, head,\n\t\t\t\t\ti_dirty);\n\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\tclear_bit(NILFS_I_DIRTY, &ii->i_state);\n\n\t\t\terr = nilfs_segctor_scan_file(sci, &ii->vfs_inode,\n\t\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tsci->sc_stage.dirty_file_ptr =\n\t\t\t\t\tlist_entry(ii->i_dirty.prev,\n\t\t\t\t\t\t   struct nilfs_inode_info,\n\t\t\t\t\t\t   i_dirty);\n\t\t\t\tgoto break_or_fail;\n\t\t\t}\n\t\t\t/* sci->sc_stage.dirty_file_ptr = NILFS_I(inode); */\n\t\t\t/* XXX: required ? */\n\t\t}\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tif (mode == SC_FLUSH_FILE) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;\n\t\tsci->sc_stage.flags |= NILFS_CF_IFILE_STARTED;\n\t\t/* Fall through */\n\tcase NILFS_ST_IFILE:\n\t\terr = nilfs_segctor_scan_file(sci, sci->sc_root->ifile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;\n\t\t/* Creating a checkpoint */\n\t\terr = nilfs_segctor_create_checkpoint(sci);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\t/* Fall through */\n\tcase NILFS_ST_CPFILE:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_cpfile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SUFILE:\n\t\terr = nilfs_sufile_freev(nilfs->ns_sufile, sci->sc_freesegs,\n\t\t\t\t\t sci->sc_nfreesegs, &ndone);\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t  sci->sc_freesegs, ndone,\n\t\t\t\t\t\t  NULL);\n\t\t\tbreak;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_SUFREED;\n\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_sufile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_DAT:\n dat_stage:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_dat,\n\t\t\t\t\t      &nilfs_sc_dat_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SR:\n\t\tif (mode == SC_LSEG_SR) {\n\t\t\t/* Appending a super root */\n\t\t\terr = nilfs_segctor_add_super_root(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* End of a logical segment */\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DSYNC:\n dsync_mode:\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_SYNDT;\n\t\tii = sci->sc_dsync_inode;\n\t\tif (!test_bit(NILFS_I_BUSY, &ii->i_state))\n\t\t\tbreak;\n\n\t\terr = nilfs_segctor_scan_file_dsync(sci, &ii->vfs_inode);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DONE:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n\n break_or_fail:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_reset_segment_buffer",
          "args": [
            "sci"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_reset_segment_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "359-379",
          "snippet": "static int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_FIRST_SEGBUF",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_truncate_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1404-1417",
    "snippet": "static void nilfs_segctor_truncate_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segment_buffer *last,\n\t\t\t\t\t    struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf = last;\n\tint ret;\n\n\tlist_for_each_entry_continue(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tsci->sc_segbuf_nblocks -= segbuf->sb_rest_blocks;\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret);\n\t}\n\tnilfs_truncate_logs(&sci->sc_segbufs, last);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_truncate_logs",
          "args": [
            "&sci->sc_segbufs",
            "last"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_truncate_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "282-293",
          "snippet": "void nilfs_truncate_logs(struct list_head *logs,\n\t\t\t struct nilfs_segment_buffer *last)\n{\n\tstruct nilfs_segment_buffer *n, *segbuf;\n\n\tsegbuf = list_prepare_entry(last, logs, sb_list);\n\tlist_for_each_entry_safe_continue(segbuf, n, logs, sb_list) {\n\t\tlist_del_init(&segbuf->sb_list);\n\t\tnilfs_segbuf_clear(segbuf);\n\t\tnilfs_segbuf_free(segbuf);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_truncate_logs(struct list_head *logs,\n\t\t\t struct nilfs_segment_buffer *last)\n{\n\tstruct nilfs_segment_buffer *n, *segbuf;\n\n\tsegbuf = list_prepare_entry(last, logs, sb_list);\n\tlist_for_each_entry_safe_continue(segbuf, n, logs, sb_list) {\n\t\tlist_del_init(&segbuf->sb_list);\n\t\tnilfs_segbuf_clear(segbuf);\n\t\tnilfs_segbuf_free(segbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_free",
          "args": [
            "sufile",
            "segbuf->sb_nextnum"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "86-89",
          "snippet": "static inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "segbuf",
            "&sci->sc_segbufs",
            "sb_list"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_truncate_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segment_buffer *last,\n\t\t\t\t\t    struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf = last;\n\tint ret;\n\n\tlist_for_each_entry_continue(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tsci->sc_segbuf_nblocks -= segbuf->sb_rest_blocks;\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret);\n\t}\n\tnilfs_truncate_logs(&sci->sc_segbufs, last);\n}"
  },
  {
    "function_name": "nilfs_cancel_segusage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1386-1402",
    "snippet": "static void nilfs_cancel_segusage(struct list_head *logs, struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t     segbuf->sb_pseg_start -\n\t\t\t\t\t     segbuf->sb_fseg_start, 0);\n\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     0, 0);\n\t\tWARN_ON(ret); /* always succeed */\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_set_segment_usage",
          "args": [
            "sufile",
            "segbuf->sb_segnum",
            "0",
            "0"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_segment_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "521-549",
          "snippet": "int nilfs_sufile_set_segment_usage(struct inode *sufile, __u64 segnum,\n\t\t\t\t   unsigned long nblocks, time_t modtime)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum, bh, kaddr);\n\tWARN_ON(nilfs_segment_usage_error(su));\n\tif (modtime)\n\t\tsu->su_lastmod = cpu_to_le64(modtime);\n\tsu->su_nblocks = cpu_to_le32(nblocks);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tbrelse(bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_set_segment_usage(struct inode *sufile, __u64 segnum,\n\t\t\t\t   unsigned long nblocks, time_t modtime)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum, bh, kaddr);\n\tWARN_ON(nilfs_segment_usage_error(su));\n\tif (modtime)\n\t\tsu->su_lastmod = cpu_to_le64(modtime);\n\tsu->su_nblocks = cpu_to_le32(nblocks);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tbrelse(bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "segbuf",
            "logs",
            "sb_list"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_FIRST_SEGBUF",
          "args": [
            "logs"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_cancel_segusage(struct list_head *logs, struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t     segbuf->sb_pseg_start -\n\t\t\t\t\t     segbuf->sb_fseg_start, 0);\n\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     0, 0);\n\t\tWARN_ON(ret); /* always succeed */\n\t}\n}"
  },
  {
    "function_name": "nilfs_segctor_update_segusage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1369-1384",
    "snippet": "static void nilfs_segctor_update_segusage(struct nilfs_sc_info *sci,\n\t\t\t\t\t  struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tunsigned long live_blocks;\n\tint ret;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tlive_blocks = segbuf->sb_sum.nblocks +\n\t\t\t(segbuf->sb_pseg_start - segbuf->sb_fseg_start);\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     live_blocks,\n\t\t\t\t\t\t     sci->sc_seg_ctime);\n\t\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_set_segment_usage",
          "args": [
            "sufile",
            "segbuf->sb_segnum",
            "live_blocks",
            "sci->sc_seg_ctime"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_segment_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "521-549",
          "snippet": "int nilfs_sufile_set_segment_usage(struct inode *sufile, __u64 segnum,\n\t\t\t\t   unsigned long nblocks, time_t modtime)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum, bh, kaddr);\n\tWARN_ON(nilfs_segment_usage_error(su));\n\tif (modtime)\n\t\tsu->su_lastmod = cpu_to_le64(modtime);\n\tsu->su_nblocks = cpu_to_le32(nblocks);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tbrelse(bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_set_segment_usage(struct inode *sufile, __u64 segnum,\n\t\t\t\t   unsigned long nblocks, time_t modtime)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_segment_usage *su;\n\tvoid *kaddr;\n\tint ret;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\n\tkaddr = kmap_atomic(bh->b_page);\n\tsu = nilfs_sufile_block_get_segment_usage(sufile, segnum, bh, kaddr);\n\tWARN_ON(nilfs_segment_usage_error(su));\n\tif (modtime)\n\t\tsu->su_lastmod = cpu_to_le64(modtime);\n\tsu->su_nblocks = cpu_to_le32(nblocks);\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(bh);\n\tnilfs_mdt_mark_dirty(sufile);\n\tbrelse(bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "&sci->sc_segbufs",
            "sb_list"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_update_segusage(struct nilfs_sc_info *sci,\n\t\t\t\t\t  struct inode *sufile)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tunsigned long live_blocks;\n\tint ret;\n\n\tlist_for_each_entry(segbuf, &sci->sc_segbufs, sb_list) {\n\t\tlive_blocks = segbuf->sb_sum.nblocks +\n\t\t\t(segbuf->sb_pseg_start - segbuf->sb_fseg_start);\n\t\tret = nilfs_sufile_set_segment_usage(sufile, segbuf->sb_segnum,\n\t\t\t\t\t\t     live_blocks,\n\t\t\t\t\t\t     sci->sc_seg_ctime);\n\t\tWARN_ON(ret); /* always succeed because the segusage is dirty */\n\t}\n}"
  },
  {
    "function_name": "nilfs_free_incomplete_logs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1332-1367",
    "snippet": "static void nilfs_free_incomplete_logs(struct list_head *logs,\n\t\t\t\t       struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tif (nilfs->ns_nextnum != segbuf->sb_nextnum) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tif (atomic_read(&segbuf->sb_err)) {\n\t\t/* Case 1: The first segment failed */\n\t\tif (segbuf->sb_pseg_start != segbuf->sb_fseg_start)\n\t\t\t/* Case 1a:  Partial segment appended into an existing\n\t\t\t   segment */\n\t\t\tnilfs_terminate_segment(nilfs, segbuf->sb_fseg_start,\n\t\t\t\t\t\tsegbuf->sb_fseg_end);\n\t\telse /* Case 1b:  New full segment */\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\n\tprev = segbuf;\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tif (prev->sb_nextnum != segbuf->sb_nextnum) {\n\t\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\t\tWARN_ON(ret); /* never fails */\n\t\t}\n\t\tif (atomic_read(&segbuf->sb_err) &&\n\t\t    segbuf->sb_segnum != nilfs->ns_nextnum)\n\t\t\t/* Case 2: extended segment (!= next) failed */\n\t\t\tnilfs_sufile_set_error(sufile, segbuf->sb_segnum);\n\t\tprev = segbuf;\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_sufile_set_error",
          "args": [
            "sufile",
            "segbuf->sb_segnum"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "140-144",
          "snippet": "static inline int nilfs_sufile_set_error(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0,\n\t\t\t\t   nilfs_sufile_do_set_error);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_set_error(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0,\n\t\t\t\t   nilfs_sufile_do_set_error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&segbuf->sb_err"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_free",
          "args": [
            "sufile",
            "segbuf->sb_nextnum"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "86-89",
          "snippet": "static inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "segbuf",
            "logs",
            "sb_list"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nilfs_discontinued",
          "args": [
            "nilfs"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_terminate_segment",
          "args": [
            "nilfs",
            "segbuf->sb_fseg_start",
            "segbuf->sb_fseg_end"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_terminate_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "345-351",
          "snippet": "static inline void\nnilfs_terminate_segment(struct the_nilfs *nilfs, sector_t seg_start,\n\t\t\tsector_t seg_end)\n{\n\t/* terminate the current full segment (used in case of I/O-error) */\n\tnilfs->ns_pseg_offset = seg_end - seg_start + 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void\nnilfs_terminate_segment(struct the_nilfs *nilfs, sector_t seg_start,\n\t\t\tsector_t seg_end)\n{\n\t/* terminate the current full segment (used in case of I/O-error) */\n\tnilfs->ns_pseg_offset = seg_end - seg_start + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&segbuf->sb_err"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_FIRST_SEGBUF",
          "args": [
            "logs"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_free_incomplete_logs(struct list_head *logs,\n\t\t\t\t       struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\tint ret;\n\n\tsegbuf = NILFS_FIRST_SEGBUF(logs);\n\tif (nilfs->ns_nextnum != segbuf->sb_nextnum) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tif (atomic_read(&segbuf->sb_err)) {\n\t\t/* Case 1: The first segment failed */\n\t\tif (segbuf->sb_pseg_start != segbuf->sb_fseg_start)\n\t\t\t/* Case 1a:  Partial segment appended into an existing\n\t\t\t   segment */\n\t\t\tnilfs_terminate_segment(nilfs, segbuf->sb_fseg_start,\n\t\t\t\t\t\tsegbuf->sb_fseg_end);\n\t\telse /* Case 1b:  New full segment */\n\t\t\tset_nilfs_discontinued(nilfs);\n\t}\n\n\tprev = segbuf;\n\tlist_for_each_entry_continue(segbuf, logs, sb_list) {\n\t\tif (prev->sb_nextnum != segbuf->sb_nextnum) {\n\t\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\t\tWARN_ON(ret); /* never fails */\n\t\t}\n\t\tif (atomic_read(&segbuf->sb_err) &&\n\t\t    segbuf->sb_segnum != nilfs->ns_nextnum)\n\t\t\t/* Case 2: extended segment (!= next) failed */\n\t\t\tnilfs_sufile_set_error(sufile, segbuf->sb_segnum);\n\t\tprev = segbuf;\n\t}\n}"
  },
  {
    "function_name": "nilfs_segctor_extend_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1276-1330",
    "snippet": "static int nilfs_segctor_extend_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct the_nilfs *nilfs, int nadd)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 nextnextnum;\n\tLIST_HEAD(list);\n\tint err, ret, i;\n\n\tprev = NILFS_LAST_SEGBUF(&sci->sc_segbufs);\n\t/*\n\t * Since the segment specified with nextnum might be allocated during\n\t * the previous construction, the buffer including its segusage may\n\t * not be dirty.  The following call ensures that the buffer is dirty\n\t * and will pin the buffer on memory until the sufile is written.\n\t */\n\terr = nilfs_sufile_mark_dirty(sufile, prev->sb_nextnum);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tfor (i = 0; i < nadd; i++) {\n\t\t/* extend segment info */\n\t\terr = -ENOMEM;\n\t\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\t\tif (unlikely(!segbuf))\n\t\t\tgoto failed;\n\n\t\t/* map this buffer to region of segment on-disk */\n\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\tsci->sc_segbuf_nblocks += segbuf->sb_rest_blocks;\n\n\t\t/* allocate the next next full segment */\n\t\terr = nilfs_sufile_alloc(sufile, &nextnextnum);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_segbuf;\n\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq + 1;\n\t\tnilfs_segbuf_set_next_segnum(segbuf, nextnextnum, nilfs);\n\n\t\tlist_add_tail(&segbuf->sb_list, &list);\n\t\tprev = segbuf;\n\t}\n\tlist_splice_tail(&list, &sci->sc_segbufs);\n\treturn 0;\n\n failed_segbuf:\n\tnilfs_segbuf_free(segbuf);\n failed:\n\tlist_for_each_entry(segbuf, &list, sb_list) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tnilfs_destroy_logs(&list);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_destroy_logs",
          "args": [
            "&list"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_destroy_logs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "179-182",
          "snippet": "static inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_destroy_logs(struct list_head *logs)\n{\n\tnilfs_truncate_logs(logs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_free",
          "args": [
            "sufile",
            "segbuf->sb_nextnum"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "86-89",
          "snippet": "static inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_free(struct inode *sufile, __u64 segnum)\n{\n\treturn nilfs_sufile_update(sufile, segnum, 0, nilfs_sufile_do_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "segbuf",
            "&list",
            "sb_list"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_free",
          "args": [
            "segbuf"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "68-71",
          "snippet": "void nilfs_segbuf_free(struct nilfs_segment_buffer *segbuf)\n{\n\tkmem_cache_free(nilfs_segbuf_cachep, segbuf);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_free(struct nilfs_segment_buffer *segbuf)\n{\n\tkmem_cache_free(nilfs_segbuf_cachep, segbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&list",
            "&sci->sc_segbufs"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&segbuf->sb_list",
            "&list"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_set_next_segnum",
          "args": [
            "segbuf",
            "nextnextnum",
            "nilfs"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_set_next_segnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "101-106",
          "snippet": "void nilfs_segbuf_set_next_segnum(struct nilfs_segment_buffer *segbuf,\n\t\t\t\t  __u64 nextnum, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_nextnum = nextnum;\n\tsegbuf->sb_sum.next = nilfs_get_segment_start_blocknr(nilfs, nextnum);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);",
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_set_next_segnum(struct nilfs_segment_buffer *segbuf,\n\t\t\t\t  __u64 nextnum, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_nextnum = nextnum;\n\tsegbuf->sb_sum.next = nilfs_get_segment_start_blocknr(nilfs, nextnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_alloc",
          "args": [
            "sufile",
            "&nextnextnum"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "311-407",
          "snippet": "int nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_map",
          "args": [
            "segbuf",
            "prev->sb_nextnum",
            "0",
            "nilfs"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "73-83",
          "snippet": "void nilfs_segbuf_map(struct nilfs_segment_buffer *segbuf, __u64 segnum,\n\t\t     unsigned long offset, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_segnum = segnum;\n\tnilfs_get_segment_range(nilfs, segnum, &segbuf->sb_fseg_start,\n\t\t\t\t&segbuf->sb_fseg_end);\n\n\tsegbuf->sb_pseg_start = segbuf->sb_fseg_start + offset;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);",
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_map(struct nilfs_segment_buffer *segbuf, __u64 segnum,\n\t\t     unsigned long offset, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_segnum = segnum;\n\tnilfs_get_segment_range(nilfs, segnum, &segbuf->sb_fseg_start,\n\t\t\t\t&segbuf->sb_fseg_end);\n\n\tsegbuf->sb_pseg_start = segbuf->sb_fseg_start + offset;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!segbuf"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_new",
          "args": [
            "sci->sc_super"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "47-66",
          "snippet": "struct nilfs_segment_buffer *nilfs_segbuf_new(struct super_block *sb)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tsegbuf = kmem_cache_alloc(nilfs_segbuf_cachep, GFP_NOFS);\n\tif (unlikely(!segbuf))\n\t\treturn NULL;\n\n\tsegbuf->sb_super = sb;\n\tINIT_LIST_HEAD(&segbuf->sb_list);\n\tINIT_LIST_HEAD(&segbuf->sb_segsum_buffers);\n\tINIT_LIST_HEAD(&segbuf->sb_payload_buffers);\n\tsegbuf->sb_super_root = NULL;\n\n\tinit_completion(&segbuf->sb_bio_event);\n\tatomic_set(&segbuf->sb_err, 0);\n\tsegbuf->sb_nbio = 0;\n\n\treturn segbuf;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nstruct nilfs_segment_buffer *nilfs_segbuf_new(struct super_block *sb)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tsegbuf = kmem_cache_alloc(nilfs_segbuf_cachep, GFP_NOFS);\n\tif (unlikely(!segbuf))\n\t\treturn NULL;\n\n\tsegbuf->sb_super = sb;\n\tINIT_LIST_HEAD(&segbuf->sb_list);\n\tINIT_LIST_HEAD(&segbuf->sb_segsum_buffers);\n\tINIT_LIST_HEAD(&segbuf->sb_payload_buffers);\n\tsegbuf->sb_super_root = NULL;\n\n\tinit_completion(&segbuf->sb_bio_event);\n\tatomic_set(&segbuf->sb_err, 0);\n\tsegbuf->sb_nbio = 0;\n\n\treturn segbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_mark_dirty",
          "args": [
            "sufile",
            "prev->sb_nextnum"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "500-512",
          "snippet": "int nilfs_sufile_mark_dirty(struct inode *sufile, __u64 segnum)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (!ret) {\n\t\tmark_buffer_dirty(bh);\n\t\tnilfs_mdt_mark_dirty(sufile);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_mark_dirty(struct inode *sufile, __u64 segnum)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (!ret) {\n\t\tmark_buffer_dirty(bh);\n\t\tnilfs_mdt_mark_dirty(sufile);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_LAST_SEGBUF",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_extend_segments(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct the_nilfs *nilfs, int nadd)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\tstruct inode *sufile = nilfs->ns_sufile;\n\t__u64 nextnextnum;\n\tLIST_HEAD(list);\n\tint err, ret, i;\n\n\tprev = NILFS_LAST_SEGBUF(&sci->sc_segbufs);\n\t/*\n\t * Since the segment specified with nextnum might be allocated during\n\t * the previous construction, the buffer including its segusage may\n\t * not be dirty.  The following call ensures that the buffer is dirty\n\t * and will pin the buffer on memory until the sufile is written.\n\t */\n\terr = nilfs_sufile_mark_dirty(sufile, prev->sb_nextnum);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tfor (i = 0; i < nadd; i++) {\n\t\t/* extend segment info */\n\t\terr = -ENOMEM;\n\t\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\t\tif (unlikely(!segbuf))\n\t\t\tgoto failed;\n\n\t\t/* map this buffer to region of segment on-disk */\n\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\tsci->sc_segbuf_nblocks += segbuf->sb_rest_blocks;\n\n\t\t/* allocate the next next full segment */\n\t\terr = nilfs_sufile_alloc(sufile, &nextnextnum);\n\t\tif (unlikely(err))\n\t\t\tgoto failed_segbuf;\n\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq + 1;\n\t\tnilfs_segbuf_set_next_segnum(segbuf, nextnextnum, nilfs);\n\n\t\tlist_add_tail(&segbuf->sb_list, &list);\n\t\tprev = segbuf;\n\t}\n\tlist_splice_tail(&list, &sci->sc_segbufs);\n\treturn 0;\n\n failed_segbuf:\n\tnilfs_segbuf_free(segbuf);\n failed:\n\tlist_for_each_entry(segbuf, &list, sb_list) {\n\t\tret = nilfs_sufile_free(sufile, segbuf->sb_nextnum);\n\t\tWARN_ON(ret); /* never fails */\n\t}\n\tnilfs_destroy_logs(&list);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_begin_construction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1216-1274",
    "snippet": "static int nilfs_segctor_begin_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\t__u64 nextnum;\n\tint err, alloc = 0;\n\n\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\tif (unlikely(!segbuf))\n\t\treturn -ENOMEM;\n\n\tif (list_empty(&sci->sc_write_logs)) {\n\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum,\n\t\t\t\t nilfs->ns_pseg_offset, nilfs);\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_shift_to_next_segment(nilfs);\n\t\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum, 0, nilfs);\n\t\t}\n\n\t\tsegbuf->sb_sum.seg_seq = nilfs->ns_seg_seq;\n\t\tnextnum = nilfs->ns_nextnum;\n\n\t\tif (nilfs->ns_segnum == nilfs->ns_nextnum)\n\t\t\t/* Start from the head of a new full segment */\n\t\t\talloc++;\n\t} else {\n\t\t/* Continue logs */\n\t\tprev = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\t\tnilfs_segbuf_map_cont(segbuf, prev);\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq;\n\t\tnextnum = prev->sb_nextnum;\n\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\t\tsegbuf->sb_sum.seg_seq++;\n\t\t\talloc++;\n\t\t}\n\t}\n\n\terr = nilfs_sufile_mark_dirty(nilfs->ns_sufile, segbuf->sb_segnum);\n\tif (err)\n\t\tgoto failed;\n\n\tif (alloc) {\n\t\terr = nilfs_sufile_alloc(nilfs->ns_sufile, &nextnum);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\tnilfs_segbuf_set_next_segnum(segbuf, nextnum, nilfs);\n\n\tBUG_ON(!list_empty(&sci->sc_segbufs));\n\tlist_add_tail(&segbuf->sb_list, &sci->sc_segbufs);\n\tsci->sc_segbuf_nblocks = segbuf->sb_rest_blocks;\n\treturn 0;\n\n failed:\n\tnilfs_segbuf_free(segbuf);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segbuf_free",
          "args": [
            "segbuf"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "68-71",
          "snippet": "void nilfs_segbuf_free(struct nilfs_segment_buffer *segbuf)\n{\n\tkmem_cache_free(nilfs_segbuf_cachep, segbuf);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_free(struct nilfs_segment_buffer *segbuf)\n{\n\tkmem_cache_free(nilfs_segbuf_cachep, segbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&segbuf->sb_list",
            "&sci->sc_segbufs"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&sci->sc_segbufs)"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_set_next_segnum",
          "args": [
            "segbuf",
            "nextnum",
            "nilfs"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_set_next_segnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "101-106",
          "snippet": "void nilfs_segbuf_set_next_segnum(struct nilfs_segment_buffer *segbuf,\n\t\t\t\t  __u64 nextnum, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_nextnum = nextnum;\n\tsegbuf->sb_sum.next = nilfs_get_segment_start_blocknr(nilfs, nextnum);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);",
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_set_next_segnum(struct nilfs_segment_buffer *segbuf,\n\t\t\t\t  __u64 nextnum, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_nextnum = nextnum;\n\tsegbuf->sb_sum.next = nilfs_get_segment_start_blocknr(nilfs, nextnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_alloc",
          "args": [
            "nilfs->ns_sufile",
            "&nextnum"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "311-407",
          "snippet": "int nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_alloc(struct inode *sufile, __u64 *segnump)\n{\n\tstruct buffer_head *header_bh, *su_bh;\n\tstruct nilfs_sufile_header *header;\n\tstruct nilfs_segment_usage *su;\n\tstruct nilfs_sufile_info *sui = NILFS_SUI(sufile);\n\tsize_t susz = NILFS_MDT(sufile)->mi_entry_size;\n\t__u64 segnum, maxsegnum, last_alloc;\n\tvoid *kaddr;\n\tunsigned long nsegments, ncleansegs, nsus, cnt;\n\tint ret, j;\n\n\tdown_write(&NILFS_MDT(sufile)->mi_sem);\n\n\tret = nilfs_sufile_get_header_block(sufile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tkaddr = kmap_atomic(header_bh->b_page);\n\theader = kaddr + bh_offset(header_bh);\n\tncleansegs = le64_to_cpu(header->sh_ncleansegs);\n\tlast_alloc = le64_to_cpu(header->sh_last_alloc);\n\tkunmap_atomic(kaddr);\n\n\tnsegments = nilfs_sufile_get_nsegments(sufile);\n\tmaxsegnum = sui->allocmax;\n\tsegnum = last_alloc + 1;\n\tif (segnum < sui->allocmin || segnum > sui->allocmax)\n\t\tsegnum = sui->allocmin;\n\n\tfor (cnt = 0; cnt < nsegments; cnt += nsus) {\n\t\tif (segnum > maxsegnum) {\n\t\t\tif (cnt < sui->allocmax - sui->allocmin + 1) {\n\t\t\t\t/*\n\t\t\t\t * wrap around in the limited region.\n\t\t\t\t * if allocation started from\n\t\t\t\t * sui->allocmin, this never happens.\n\t\t\t\t */\n\t\t\t\tsegnum = sui->allocmin;\n\t\t\t\tmaxsegnum = last_alloc;\n\t\t\t} else if (segnum > sui->allocmin &&\n\t\t\t\t   sui->allocmax + 1 < nsegments) {\n\t\t\t\tsegnum = sui->allocmax + 1;\n\t\t\t\tmaxsegnum = nsegments - 1;\n\t\t\t} else if (sui->allocmin > 0)  {\n\t\t\t\tsegnum = 0;\n\t\t\t\tmaxsegnum = sui->allocmin - 1;\n\t\t\t} else {\n\t\t\t\tbreak; /* never happens */\n\t\t\t}\n\t\t}\n\t\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 1,\n\t\t\t\t\t\t\t   &su_bh);\n\t\tif (ret < 0)\n\t\t\tgoto out_header;\n\t\tkaddr = kmap_atomic(su_bh->b_page);\n\t\tsu = nilfs_sufile_block_get_segment_usage(\n\t\t\tsufile, segnum, su_bh, kaddr);\n\n\t\tnsus = nilfs_sufile_segment_usages_in_block(\n\t\t\tsufile, segnum, maxsegnum);\n\t\tfor (j = 0; j < nsus; j++, su = (void *)su + susz, segnum++) {\n\t\t\tif (!nilfs_segment_usage_clean(su))\n\t\t\t\tcontinue;\n\t\t\t/* found a clean segment */\n\t\t\tnilfs_segment_usage_set_dirty(su);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\t\theader = kaddr + bh_offset(header_bh);\n\t\t\tle64_add_cpu(&header->sh_ncleansegs, -1);\n\t\t\tle64_add_cpu(&header->sh_ndirtysegs, 1);\n\t\t\theader->sh_last_alloc = cpu_to_le64(segnum);\n\t\t\tkunmap_atomic(kaddr);\n\n\t\t\tsui->ncleansegs--;\n\t\t\tmark_buffer_dirty(header_bh);\n\t\t\tmark_buffer_dirty(su_bh);\n\t\t\tnilfs_mdt_mark_dirty(sufile);\n\t\t\tbrelse(su_bh);\n\t\t\t*segnump = segnum;\n\t\t\tgoto out_header;\n\t\t}\n\n\t\tkunmap_atomic(kaddr);\n\t\tbrelse(su_bh);\n\t}\n\n\t/* no segments left */\n\tret = -ENOSPC;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(sufile)->mi_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_mark_dirty",
          "args": [
            "nilfs->ns_sufile",
            "segbuf->sb_segnum"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.c",
          "lines": "500-512",
          "snippet": "int nilfs_sufile_mark_dirty(struct inode *sufile, __u64 segnum)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (!ret) {\n\t\tmark_buffer_dirty(bh);\n\t\tnilfs_mdt_mark_dirty(sufile);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sufile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sufile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_sufile_mark_dirty(struct inode *sufile, __u64 segnum)\n{\n\tstruct buffer_head *bh;\n\tint ret;\n\n\tret = nilfs_sufile_get_segment_usage_block(sufile, segnum, 0, &bh);\n\tif (!ret) {\n\t\tmark_buffer_dirty(bh);\n\t\tnilfs_mdt_mark_dirty(sufile);\n\t\tbrelse(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_map",
          "args": [
            "segbuf",
            "prev->sb_nextnum",
            "0",
            "nilfs"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "73-83",
          "snippet": "void nilfs_segbuf_map(struct nilfs_segment_buffer *segbuf, __u64 segnum,\n\t\t     unsigned long offset, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_segnum = segnum;\n\tnilfs_get_segment_range(nilfs, segnum, &segbuf->sb_fseg_start,\n\t\t\t\t&segbuf->sb_fseg_end);\n\n\tsegbuf->sb_pseg_start = segbuf->sb_fseg_start + offset;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);",
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_write(struct nilfs_segment_buffer *segbuf,\n\t\t\t      struct the_nilfs *nilfs);\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_map(struct nilfs_segment_buffer *segbuf, __u64 segnum,\n\t\t     unsigned long offset, struct the_nilfs *nilfs)\n{\n\tsegbuf->sb_segnum = segnum;\n\tnilfs_get_segment_range(nilfs, segnum, &segbuf->sb_fseg_start,\n\t\t\t\t&segbuf->sb_fseg_end);\n\n\tsegbuf->sb_pseg_start = segbuf->sb_fseg_start + offset;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_map_cont",
          "args": [
            "segbuf",
            "prev"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_map_cont",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "90-99",
          "snippet": "void nilfs_segbuf_map_cont(struct nilfs_segment_buffer *segbuf,\n\t\t\t   struct nilfs_segment_buffer *prev)\n{\n\tsegbuf->sb_segnum = prev->sb_segnum;\n\tsegbuf->sb_fseg_start = prev->sb_fseg_start;\n\tsegbuf->sb_fseg_end = prev->sb_fseg_end;\n\tsegbuf->sb_pseg_start = prev->sb_pseg_start + prev->sb_sum.nblocks;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nvoid nilfs_segbuf_map_cont(struct nilfs_segment_buffer *segbuf,\n\t\t\t   struct nilfs_segment_buffer *prev)\n{\n\tsegbuf->sb_segnum = prev->sb_segnum;\n\tsegbuf->sb_fseg_start = prev->sb_fseg_start;\n\tsegbuf->sb_fseg_end = prev->sb_fseg_end;\n\tsegbuf->sb_pseg_start = prev->sb_pseg_start + prev->sb_sum.nblocks;\n\tsegbuf->sb_rest_blocks =\n\t\tsegbuf->sb_fseg_end - segbuf->sb_pseg_start + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_LAST_SEGBUF",
          "args": [
            "&sci->sc_write_logs"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_shift_to_next_segment",
          "args": [
            "nilfs"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_shift_to_next_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "353-359",
          "snippet": "static inline void nilfs_shift_to_next_segment(struct the_nilfs *nilfs)\n{\n\t/* move forward with a full segment */\n\tnilfs->ns_segnum = nilfs->ns_nextnum;\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq++;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline void nilfs_shift_to_next_segment(struct the_nilfs *nilfs)\n{\n\t/* move forward with a full segment */\n\tnilfs->ns_segnum = nilfs->ns_nextnum;\n\tnilfs->ns_pseg_offset = 0;\n\tnilfs->ns_seg_seq++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!segbuf"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_new",
          "args": [
            "sci->sc_super"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "47-66",
          "snippet": "struct nilfs_segment_buffer *nilfs_segbuf_new(struct super_block *sb)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tsegbuf = kmem_cache_alloc(nilfs_segbuf_cachep, GFP_NOFS);\n\tif (unlikely(!segbuf))\n\t\treturn NULL;\n\n\tsegbuf->sb_super = sb;\n\tINIT_LIST_HEAD(&segbuf->sb_list);\n\tINIT_LIST_HEAD(&segbuf->sb_segsum_buffers);\n\tINIT_LIST_HEAD(&segbuf->sb_payload_buffers);\n\tsegbuf->sb_super_root = NULL;\n\n\tinit_completion(&segbuf->sb_bio_event);\n\tatomic_set(&segbuf->sb_err, 0);\n\tsegbuf->sb_nbio = 0;\n\n\treturn segbuf;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nstruct nilfs_segment_buffer *nilfs_segbuf_new(struct super_block *sb)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\n\tsegbuf = kmem_cache_alloc(nilfs_segbuf_cachep, GFP_NOFS);\n\tif (unlikely(!segbuf))\n\t\treturn NULL;\n\n\tsegbuf->sb_super = sb;\n\tINIT_LIST_HEAD(&segbuf->sb_list);\n\tINIT_LIST_HEAD(&segbuf->sb_segsum_buffers);\n\tINIT_LIST_HEAD(&segbuf->sb_payload_buffers);\n\tsegbuf->sb_super_root = NULL;\n\n\tinit_completion(&segbuf->sb_bio_event);\n\tatomic_set(&segbuf->sb_err, 0);\n\tsegbuf->sb_nbio = 0;\n\n\treturn segbuf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_begin_construction(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct the_nilfs *nilfs)\n{\n\tstruct nilfs_segment_buffer *segbuf, *prev;\n\t__u64 nextnum;\n\tint err, alloc = 0;\n\n\tsegbuf = nilfs_segbuf_new(sci->sc_super);\n\tif (unlikely(!segbuf))\n\t\treturn -ENOMEM;\n\n\tif (list_empty(&sci->sc_write_logs)) {\n\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum,\n\t\t\t\t nilfs->ns_pseg_offset, nilfs);\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_shift_to_next_segment(nilfs);\n\t\t\tnilfs_segbuf_map(segbuf, nilfs->ns_segnum, 0, nilfs);\n\t\t}\n\n\t\tsegbuf->sb_sum.seg_seq = nilfs->ns_seg_seq;\n\t\tnextnum = nilfs->ns_nextnum;\n\n\t\tif (nilfs->ns_segnum == nilfs->ns_nextnum)\n\t\t\t/* Start from the head of a new full segment */\n\t\t\talloc++;\n\t} else {\n\t\t/* Continue logs */\n\t\tprev = NILFS_LAST_SEGBUF(&sci->sc_write_logs);\n\t\tnilfs_segbuf_map_cont(segbuf, prev);\n\t\tsegbuf->sb_sum.seg_seq = prev->sb_sum.seg_seq;\n\t\tnextnum = prev->sb_nextnum;\n\n\t\tif (segbuf->sb_rest_blocks < NILFS_PSEG_MIN_BLOCKS) {\n\t\t\tnilfs_segbuf_map(segbuf, prev->sb_nextnum, 0, nilfs);\n\t\t\tsegbuf->sb_sum.seg_seq++;\n\t\t\talloc++;\n\t\t}\n\t}\n\n\terr = nilfs_sufile_mark_dirty(nilfs->ns_sufile, segbuf->sb_segnum);\n\tif (err)\n\t\tgoto failed;\n\n\tif (alloc) {\n\t\terr = nilfs_sufile_alloc(nilfs->ns_sufile, &nextnum);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\tnilfs_segbuf_set_next_segnum(segbuf, nextnum, nilfs);\n\n\tBUG_ON(!list_empty(&sci->sc_segbufs));\n\tlist_add_tail(&segbuf->sb_list, &sci->sc_segbufs);\n\tsci->sc_segbuf_nblocks = segbuf->sb_rest_blocks;\n\treturn 0;\n\n failed:\n\tnilfs_segbuf_free(segbuf);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_collect_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1056-1209",
    "snippet": "static int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct list_head *head;\n\tstruct nilfs_inode_info *ii;\n\tsize_t ndone;\n\tint err = 0;\n\n\tswitch (sci->sc_stage.scnt) {\n\tcase NILFS_ST_INIT:\n\t\t/* Pre-processes */\n\t\tsci->sc_stage.flags = 0;\n\n\t\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags)) {\n\t\t\tsci->sc_nblk_inc = 0;\n\t\t\tsci->sc_curseg->sb_sum.flags = NILFS_SS_LOGBGN;\n\t\t\tif (mode == SC_LSEG_DSYNC) {\n\t\t\t\tsci->sc_stage.scnt = NILFS_ST_DSYNC;\n\t\t\t\tgoto dsync_mode;\n\t\t\t}\n\t\t}\n\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DAT;\n\t\t\tgoto dat_stage;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_GC:\n\t\tif (nilfs_doing_gc()) {\n\t\t\thead = &sci->sc_gc_inodes;\n\t\t\tii = list_prepare_entry(sci->sc_stage.gc_inode_ptr,\n\t\t\t\t\t\thead, i_dirty);\n\t\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\t\terr = nilfs_segctor_scan_file(\n\t\t\t\t\tsci, &ii->vfs_inode,\n\t\t\t\t\t&nilfs_sc_file_ops);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tsci->sc_stage.gc_inode_ptr = list_entry(\n\t\t\t\t\t\tii->i_dirty.prev,\n\t\t\t\t\t\tstruct nilfs_inode_info,\n\t\t\t\t\t\ti_dirty);\n\t\t\t\t\tgoto break_or_fail;\n\t\t\t\t}\n\t\t\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t\t\t}\n\t\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_FILE:\n\t\thead = &sci->sc_dirty_files;\n\t\tii = list_prepare_entry(sci->sc_stage.dirty_file_ptr, head,\n\t\t\t\t\ti_dirty);\n\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\tclear_bit(NILFS_I_DIRTY, &ii->i_state);\n\n\t\t\terr = nilfs_segctor_scan_file(sci, &ii->vfs_inode,\n\t\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tsci->sc_stage.dirty_file_ptr =\n\t\t\t\t\tlist_entry(ii->i_dirty.prev,\n\t\t\t\t\t\t   struct nilfs_inode_info,\n\t\t\t\t\t\t   i_dirty);\n\t\t\t\tgoto break_or_fail;\n\t\t\t}\n\t\t\t/* sci->sc_stage.dirty_file_ptr = NILFS_I(inode); */\n\t\t\t/* XXX: required ? */\n\t\t}\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tif (mode == SC_FLUSH_FILE) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;\n\t\tsci->sc_stage.flags |= NILFS_CF_IFILE_STARTED;\n\t\t/* Fall through */\n\tcase NILFS_ST_IFILE:\n\t\terr = nilfs_segctor_scan_file(sci, sci->sc_root->ifile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;\n\t\t/* Creating a checkpoint */\n\t\terr = nilfs_segctor_create_checkpoint(sci);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\t/* Fall through */\n\tcase NILFS_ST_CPFILE:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_cpfile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SUFILE:\n\t\terr = nilfs_sufile_freev(nilfs->ns_sufile, sci->sc_freesegs,\n\t\t\t\t\t sci->sc_nfreesegs, &ndone);\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t  sci->sc_freesegs, ndone,\n\t\t\t\t\t\t  NULL);\n\t\t\tbreak;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_SUFREED;\n\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_sufile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_DAT:\n dat_stage:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_dat,\n\t\t\t\t\t      &nilfs_sc_dat_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SR:\n\t\tif (mode == SC_LSEG_SR) {\n\t\t\t/* Appending a super root */\n\t\t\terr = nilfs_segctor_add_super_root(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* End of a logical segment */\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DSYNC:\n dsync_mode:\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_SYNDT;\n\t\tii = sci->sc_dsync_inode;\n\t\tif (!test_bit(NILFS_I_BUSY, &ii->i_state))\n\t\t\tbreak;\n\n\t\terr = nilfs_segctor_scan_file_dsync(sci, &ii->vfs_inode);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DONE:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n\n break_or_fail:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */",
      "#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);",
      "static struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};",
      "static struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_scan_file_dsync",
          "args": [
            "sci",
            "&ii->vfs_inode"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_scan_file_dsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1035-1054",
          "snippet": "static int nilfs_segctor_scan_file_dsync(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct inode *inode)\n{\n\tLIST_HEAD(data_buffers);\n\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\tint err;\n\n\tn = nilfs_lookup_dirty_data_buffers(inode, &data_buffers, rest + 1,\n\t\t\t\t\t    sci->sc_dsync_start,\n\t\t\t\t\t    sci->sc_dsync_end);\n\n\terr = nilfs_segctor_apply_buffers(sci, inode, &data_buffers,\n\t\t\t\t\t  nilfs_collect_file_data);\n\tif (!err) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\tBUG_ON(n > rest);\n\t\t/* always receive -E2BIG or true error if n > rest */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_scan_file_dsync(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct inode *inode)\n{\n\tLIST_HEAD(data_buffers);\n\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\tint err;\n\n\tn = nilfs_lookup_dirty_data_buffers(inode, &data_buffers, rest + 1,\n\t\t\t\t\t    sci->sc_dsync_start,\n\t\t\t\t\t    sci->sc_dsync_end);\n\n\terr = nilfs_segctor_apply_buffers(sci, inode, &data_buffers,\n\t\t\t\t\t  nilfs_collect_file_data);\n\tif (!err) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\tBUG_ON(n > rest);\n\t\t/* always receive -E2BIG or true error if n > rest */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BUSY",
            "&ii->i_state"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_add_super_root",
          "args": [
            "sci"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_add_super_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "391-406",
          "snippet": "static int nilfs_segctor_add_super_root(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tint err;\n\n\tif (segbuf->sb_sum.nblocks >= segbuf->sb_rest_blocks) {\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsegbuf = sci->sc_curseg;\n\t}\n\terr = nilfs_segbuf_extend_payload(segbuf, &segbuf->sb_super_root);\n\tif (likely(!err))\n\t\tsegbuf->sb_sum.flags |= NILFS_SS_SR;\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_super_root(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tint err;\n\n\tif (segbuf->sb_sum.nblocks >= segbuf->sb_rest_blocks) {\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsegbuf = sci->sc_curseg;\n\t}\n\terr = nilfs_segbuf_extend_payload(segbuf, &segbuf->sb_super_root);\n\tif (likely(!err))\n\t\tsegbuf->sb_sum.flags |= NILFS_SS_SR;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_scan_file",
          "args": [
            "sci",
            "nilfs->ns_dat",
            "&nilfs_sc_dat_ops"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_scan_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "982-1033",
          "snippet": "static int nilfs_segctor_scan_file(struct nilfs_sc_info *sci,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct nilfs_sc_operations *sc_ops)\n{\n\tLIST_HEAD(data_buffers);\n\tLIST_HEAD(node_buffers);\n\tint err;\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\n\t\tn = nilfs_lookup_dirty_data_buffers(\n\t\t\tinode, &data_buffers, rest + 1, 0, LLONG_MAX);\n\t\tif (n > rest) {\n\t\t\terr = nilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &data_buffers,\n\t\t\t\tsc_ops->collect_data);\n\t\t\tBUG_ON(!err); /* always receive -E2BIG or true error */\n\t\t\tgoto break_or_fail;\n\t\t}\n\t}\n\tnilfs_lookup_dirty_node_buffers(inode, &node_buffers);\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\terr = nilfs_segctor_apply_buffers(\n\t\t\tsci, inode, &data_buffers, sc_ops->collect_data);\n\t\tif (unlikely(err)) {\n\t\t\t/* dispose node list */\n\t\t\tnilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &node_buffers, NULL);\n\t\t\tgoto break_or_fail;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_NODE;\n\t}\n\t/* Collect node */\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_node);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_bmap_lookup_dirty_buffers(NILFS_I(inode)->i_bmap, &node_buffers);\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_bmap);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_segctor_end_finfo(sci, inode);\n\tsci->sc_stage.flags &= ~NILFS_CF_NODE;\n\n break_or_fail:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_NODE\t\t0x0001\t/* Collecting node blocks */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_NODE\t\t0x0001\t/* Collecting node blocks */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_scan_file(struct nilfs_sc_info *sci,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct nilfs_sc_operations *sc_ops)\n{\n\tLIST_HEAD(data_buffers);\n\tLIST_HEAD(node_buffers);\n\tint err;\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\n\t\tn = nilfs_lookup_dirty_data_buffers(\n\t\t\tinode, &data_buffers, rest + 1, 0, LLONG_MAX);\n\t\tif (n > rest) {\n\t\t\terr = nilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &data_buffers,\n\t\t\t\tsc_ops->collect_data);\n\t\t\tBUG_ON(!err); /* always receive -E2BIG or true error */\n\t\t\tgoto break_or_fail;\n\t\t}\n\t}\n\tnilfs_lookup_dirty_node_buffers(inode, &node_buffers);\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\terr = nilfs_segctor_apply_buffers(\n\t\t\tsci, inode, &data_buffers, sc_ops->collect_data);\n\t\tif (unlikely(err)) {\n\t\t\t/* dispose node list */\n\t\t\tnilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &node_buffers, NULL);\n\t\t\tgoto break_or_fail;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_NODE;\n\t}\n\t/* Collect node */\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_node);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_bmap_lookup_dirty_buffers(NILFS_I(inode)->i_bmap, &node_buffers);\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_bmap);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_segctor_end_finfo(sci, inode);\n\tsci->sc_stage.flags &= ~NILFS_CF_NODE;\n\n break_or_fail:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_cancel_freev",
          "args": [
            "nilfs->ns_sufile",
            "sci->sc_freesegs",
            "ndone",
            "NULL"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_cancel_freev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "115-121",
          "snippet": "static inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_cancel_freev(struct inode *sufile,\n\t\t\t\t\t    __u64 *segnumv, size_t nsegs,\n\t\t\t\t\t    size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_cancel_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_sufile_freev",
          "args": [
            "nilfs->ns_sufile",
            "sci->sc_freesegs",
            "sci->sc_nfreesegs",
            "&ndone"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sufile_freev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/sufile.h",
          "lines": "98-103",
          "snippet": "static inline int nilfs_sufile_freev(struct inode *sufile, __u64 *segnumv,\n\t\t\t\t     size_t nsegs, size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_free);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int nilfs_sufile_freev(struct inode *sufile, __u64 *segnumv,\n\t\t\t\t     size_t nsegs, size_t *ndone)\n{\n\treturn nilfs_sufile_updatev(sufile, segnumv, nsegs, 0, ndone,\n\t\t\t\t    nilfs_sufile_do_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_create_checkpoint",
          "args": [
            "sci"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_create_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "805-827",
          "snippet": "static int nilfs_segctor_create_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\t/* XXX: this interface will be changed */\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 1,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (likely(!err)) {\n\t\t/* The following code is duplicated with cpfile.  But, it is\n\t\t   needed to collect the checkpoint even if it was not newly\n\t\t   created */\n\t\tmark_buffer_dirty(bh_cp);\n\t\tnilfs_mdt_mark_dirty(nilfs->ns_cpfile);\n\t\tnilfs_cpfile_put_checkpoint(\n\t\t\tnilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\t} else\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_create_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\t/* XXX: this interface will be changed */\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 1,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (likely(!err)) {\n\t\t/* The following code is duplicated with cpfile.  But, it is\n\t\t   needed to collect the checkpoint even if it was not newly\n\t\t   created */\n\t\tmark_buffer_dirty(bh_cp);\n\t\tnilfs_mdt_mark_dirty(nilfs->ns_cpfile);\n\t\tnilfs_cpfile_put_checkpoint(\n\t\t\tnilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\t} else\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ii->i_dirty.prev",
            "structnilfs_inode_info",
            "i_dirty"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "ii",
            "head",
            "i_dirty"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_prepare_entry",
          "args": [
            "sci->sc_stage.dirty_file_ptr",
            "head",
            "i_dirty"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_COLLECTED",
            "&ii->i_state"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ii->i_dirty.prev",
            "structnilfs_inode_info",
            "i_dirty"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "ii",
            "head",
            "i_dirty"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_prepare_entry",
          "args": [
            "sci->sc_stage.gc_inode_ptr",
            "head",
            "i_dirty"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n#define NILFS_CF_IFILE_STARTED\t0x0002\t/* IFILE stage has started */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\nstatic struct nilfs_sc_operations nilfs_sc_file_ops = {\n\t.collect_data = nilfs_collect_file_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_file_bmap,\n\t.write_data_binfo = nilfs_write_file_data_binfo,\n\t.write_node_binfo = nilfs_write_file_node_binfo,\n};\nstatic struct nilfs_sc_operations nilfs_sc_dat_ops = {\n\t.collect_data = nilfs_collect_dat_data,\n\t.collect_node = nilfs_collect_file_node,\n\t.collect_bmap = nilfs_collect_dat_bmap,\n\t.write_data_binfo = nilfs_write_dat_data_binfo,\n\t.write_node_binfo = nilfs_write_dat_node_binfo,\n};\n\nstatic int nilfs_segctor_collect_blocks(struct nilfs_sc_info *sci, int mode)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct list_head *head;\n\tstruct nilfs_inode_info *ii;\n\tsize_t ndone;\n\tint err = 0;\n\n\tswitch (sci->sc_stage.scnt) {\n\tcase NILFS_ST_INIT:\n\t\t/* Pre-processes */\n\t\tsci->sc_stage.flags = 0;\n\n\t\tif (!test_bit(NILFS_SC_UNCLOSED, &sci->sc_flags)) {\n\t\t\tsci->sc_nblk_inc = 0;\n\t\t\tsci->sc_curseg->sb_sum.flags = NILFS_SS_LOGBGN;\n\t\t\tif (mode == SC_LSEG_DSYNC) {\n\t\t\t\tsci->sc_stage.scnt = NILFS_ST_DSYNC;\n\t\t\t\tgoto dsync_mode;\n\t\t\t}\n\t\t}\n\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DAT;\n\t\t\tgoto dat_stage;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_GC:\n\t\tif (nilfs_doing_gc()) {\n\t\t\thead = &sci->sc_gc_inodes;\n\t\t\tii = list_prepare_entry(sci->sc_stage.gc_inode_ptr,\n\t\t\t\t\t\thead, i_dirty);\n\t\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\t\terr = nilfs_segctor_scan_file(\n\t\t\t\t\tsci, &ii->vfs_inode,\n\t\t\t\t\t&nilfs_sc_file_ops);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tsci->sc_stage.gc_inode_ptr = list_entry(\n\t\t\t\t\t\tii->i_dirty.prev,\n\t\t\t\t\t\tstruct nilfs_inode_info,\n\t\t\t\t\t\ti_dirty);\n\t\t\t\t\tgoto break_or_fail;\n\t\t\t\t}\n\t\t\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t\t\t}\n\t\t\tsci->sc_stage.gc_inode_ptr = NULL;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_FILE:\n\t\thead = &sci->sc_dirty_files;\n\t\tii = list_prepare_entry(sci->sc_stage.dirty_file_ptr, head,\n\t\t\t\t\ti_dirty);\n\t\tlist_for_each_entry_continue(ii, head, i_dirty) {\n\t\t\tclear_bit(NILFS_I_DIRTY, &ii->i_state);\n\n\t\t\terr = nilfs_segctor_scan_file(sci, &ii->vfs_inode,\n\t\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tsci->sc_stage.dirty_file_ptr =\n\t\t\t\t\tlist_entry(ii->i_dirty.prev,\n\t\t\t\t\t\t   struct nilfs_inode_info,\n\t\t\t\t\t\t   i_dirty);\n\t\t\t\tgoto break_or_fail;\n\t\t\t}\n\t\t\t/* sci->sc_stage.dirty_file_ptr = NILFS_I(inode); */\n\t\t\t/* XXX: required ? */\n\t\t}\n\t\tsci->sc_stage.dirty_file_ptr = NULL;\n\t\tif (mode == SC_FLUSH_FILE) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;\n\t\tsci->sc_stage.flags |= NILFS_CF_IFILE_STARTED;\n\t\t/* Fall through */\n\tcase NILFS_ST_IFILE:\n\t\terr = nilfs_segctor_scan_file(sci, sci->sc_root->ifile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;\n\t\t/* Creating a checkpoint */\n\t\terr = nilfs_segctor_create_checkpoint(sci);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\t/* Fall through */\n\tcase NILFS_ST_CPFILE:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_cpfile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SUFILE:\n\t\terr = nilfs_sufile_freev(nilfs->ns_sufile, sci->sc_freesegs,\n\t\t\t\t\t sci->sc_nfreesegs, &ndone);\n\t\tif (unlikely(err)) {\n\t\t\tnilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t  sci->sc_freesegs, ndone,\n\t\t\t\t\t\t  NULL);\n\t\t\tbreak;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_SUFREED;\n\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_sufile,\n\t\t\t\t\t      &nilfs_sc_file_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_DAT:\n dat_stage:\n\t\terr = nilfs_segctor_scan_file(sci, nilfs->ns_dat,\n\t\t\t\t\t      &nilfs_sc_dat_ops);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tif (mode == SC_FLUSH_DAT) {\n\t\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\t\treturn 0;\n\t\t}\n\t\tsci->sc_stage.scnt++;  /* Fall through */\n\tcase NILFS_ST_SR:\n\t\tif (mode == SC_LSEG_SR) {\n\t\t\t/* Appending a super root */\n\t\t\terr = nilfs_segctor_add_super_root(sci);\n\t\t\tif (unlikely(err))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* End of a logical segment */\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DSYNC:\n dsync_mode:\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_SYNDT;\n\t\tii = sci->sc_dsync_inode;\n\t\tif (!test_bit(NILFS_I_BUSY, &ii->i_state))\n\t\t\tbreak;\n\n\t\terr = nilfs_segctor_scan_file_dsync(sci, &ii->vfs_inode);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t\tsci->sc_curseg->sb_sum.flags |= NILFS_SS_LOGEND;\n\t\tsci->sc_stage.scnt = NILFS_ST_DONE;\n\t\treturn 0;\n\tcase NILFS_ST_DONE:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n\n break_or_fail:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_scan_file_dsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "1035-1054",
    "snippet": "static int nilfs_segctor_scan_file_dsync(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct inode *inode)\n{\n\tLIST_HEAD(data_buffers);\n\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\tint err;\n\n\tn = nilfs_lookup_dirty_data_buffers(inode, &data_buffers, rest + 1,\n\t\t\t\t\t    sci->sc_dsync_start,\n\t\t\t\t\t    sci->sc_dsync_end);\n\n\terr = nilfs_segctor_apply_buffers(sci, inode, &data_buffers,\n\t\t\t\t\t  nilfs_collect_file_data);\n\tif (!err) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\tBUG_ON(n > rest);\n\t\t/* always receive -E2BIG or true error if n > rest */\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "n > rest"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_end_finfo",
          "args": [
            "sci",
            "inode"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_end_finfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "437-469",
          "snippet": "static void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_apply_buffers",
          "args": [
            "sci",
            "inode",
            "&data_buffers",
            "nilfs_collect_file_data"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_apply_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "944-973",
          "snippet": "static int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_lookup_dirty_data_buffers",
          "args": [
            "inode",
            "&data_buffers",
            "rest + 1",
            "sci->sc_dsync_start",
            "sci->sc_dsync_end"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_lookup_dirty_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "623-680",
          "snippet": "static size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_buffer_rest",
          "args": [
            "sci"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_buffer_rest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "975-980",
          "snippet": "static size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "data_buffers"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_scan_file_dsync(struct nilfs_sc_info *sci,\n\t\t\t\t\t struct inode *inode)\n{\n\tLIST_HEAD(data_buffers);\n\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\tint err;\n\n\tn = nilfs_lookup_dirty_data_buffers(inode, &data_buffers, rest + 1,\n\t\t\t\t\t    sci->sc_dsync_start,\n\t\t\t\t\t    sci->sc_dsync_end);\n\n\terr = nilfs_segctor_apply_buffers(sci, inode, &data_buffers,\n\t\t\t\t\t  nilfs_collect_file_data);\n\tif (!err) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\tBUG_ON(n > rest);\n\t\t/* always receive -E2BIG or true error if n > rest */\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_scan_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "982-1033",
    "snippet": "static int nilfs_segctor_scan_file(struct nilfs_sc_info *sci,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct nilfs_sc_operations *sc_ops)\n{\n\tLIST_HEAD(data_buffers);\n\tLIST_HEAD(node_buffers);\n\tint err;\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\n\t\tn = nilfs_lookup_dirty_data_buffers(\n\t\t\tinode, &data_buffers, rest + 1, 0, LLONG_MAX);\n\t\tif (n > rest) {\n\t\t\terr = nilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &data_buffers,\n\t\t\t\tsc_ops->collect_data);\n\t\t\tBUG_ON(!err); /* always receive -E2BIG or true error */\n\t\t\tgoto break_or_fail;\n\t\t}\n\t}\n\tnilfs_lookup_dirty_node_buffers(inode, &node_buffers);\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\terr = nilfs_segctor_apply_buffers(\n\t\t\tsci, inode, &data_buffers, sc_ops->collect_data);\n\t\tif (unlikely(err)) {\n\t\t\t/* dispose node list */\n\t\t\tnilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &node_buffers, NULL);\n\t\t\tgoto break_or_fail;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_NODE;\n\t}\n\t/* Collect node */\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_node);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_bmap_lookup_dirty_buffers(NILFS_I(inode)->i_bmap, &node_buffers);\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_bmap);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_segctor_end_finfo(sci, inode);\n\tsci->sc_stage.flags &= ~NILFS_CF_NODE;\n\n break_or_fail:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define NILFS_CF_NODE\t\t0x0001\t/* Collecting node blocks */"
    ],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_end_finfo",
          "args": [
            "sci",
            "inode"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_end_finfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "437-469",
          "snippet": "static void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_apply_buffers",
          "args": [
            "sci",
            "inode",
            "&node_buffers",
            "sc_ops->collect_bmap"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_apply_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "944-973",
          "snippet": "static int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_lookup_dirty_buffers",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "&node_buffers"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_lookup_dirty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "335-340",
          "snippet": "void nilfs_bmap_lookup_dirty_buffers(struct nilfs_bmap *bmap,\n\t\t\t\t     struct list_head *listp)\n{\n\tif (bmap->b_ops->bop_lookup_dirty_buffers != NULL)\n\t\tbmap->b_ops->bop_lookup_dirty_buffers(bmap, listp);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_lookup_dirty_buffers(struct nilfs_bmap *bmap,\n\t\t\t\t     struct list_head *listp)\n{\n\tif (bmap->b_ops->bop_lookup_dirty_buffers != NULL)\n\t\tbmap->b_ops->bop_lookup_dirty_buffers(bmap, listp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_lookup_dirty_node_buffers",
          "args": [
            "inode",
            "&node_buffers"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_lookup_dirty_node_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "682-711",
          "snippet": "static void nilfs_lookup_dirty_node_buffers(struct inode *inode,\n\t\t\t\t\t    struct list_head *listp)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct address_space *mapping = &ii->i_btnode_cache;\n\tstruct pagevec pvec;\n\tstruct buffer_head *bh, *head;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tbh = head = page_buffers(pvec.pages[i]);\n\t\t\tdo {\n\t\t\t\tif (buffer_dirty(bh) &&\n\t\t\t\t\t\t!buffer_async_write(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tlist_add_tail(&bh->b_assoc_buffers,\n\t\t\t\t\t\t      listp);\n\t\t\t\t}\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_lookup_dirty_node_buffers(struct inode *inode,\n\t\t\t\t\t    struct list_head *listp)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct address_space *mapping = &ii->i_btnode_cache;\n\tstruct pagevec pvec;\n\tstruct buffer_head *bh, *head;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tbh = head = page_buffers(pvec.pages[i]);\n\t\t\tdo {\n\t\t\t\tif (buffer_dirty(bh) &&\n\t\t\t\t\t\t!buffer_async_write(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tlist_add_tail(&bh->b_assoc_buffers,\n\t\t\t\t\t\t      listp);\n\t\t\t\t}\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!err"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_lookup_dirty_data_buffers",
          "args": [
            "inode",
            "&data_buffers",
            "rest + 1",
            "0",
            "LLONG_MAX"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_lookup_dirty_data_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "623-680",
          "snippet": "static size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_buffer_rest",
          "args": [
            "sci"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_buffer_rest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "975-980",
          "snippet": "static size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "node_buffers"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "data_buffers"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_NODE\t\t0x0001\t/* Collecting node blocks */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_scan_file(struct nilfs_sc_info *sci,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct nilfs_sc_operations *sc_ops)\n{\n\tLIST_HEAD(data_buffers);\n\tLIST_HEAD(node_buffers);\n\tint err;\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\tsize_t n, rest = nilfs_segctor_buffer_rest(sci);\n\n\t\tn = nilfs_lookup_dirty_data_buffers(\n\t\t\tinode, &data_buffers, rest + 1, 0, LLONG_MAX);\n\t\tif (n > rest) {\n\t\t\terr = nilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &data_buffers,\n\t\t\t\tsc_ops->collect_data);\n\t\t\tBUG_ON(!err); /* always receive -E2BIG or true error */\n\t\t\tgoto break_or_fail;\n\t\t}\n\t}\n\tnilfs_lookup_dirty_node_buffers(inode, &node_buffers);\n\n\tif (!(sci->sc_stage.flags & NILFS_CF_NODE)) {\n\t\terr = nilfs_segctor_apply_buffers(\n\t\t\tsci, inode, &data_buffers, sc_ops->collect_data);\n\t\tif (unlikely(err)) {\n\t\t\t/* dispose node list */\n\t\t\tnilfs_segctor_apply_buffers(\n\t\t\t\tsci, inode, &node_buffers, NULL);\n\t\t\tgoto break_or_fail;\n\t\t}\n\t\tsci->sc_stage.flags |= NILFS_CF_NODE;\n\t}\n\t/* Collect node */\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_node);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_bmap_lookup_dirty_buffers(NILFS_I(inode)->i_bmap, &node_buffers);\n\terr = nilfs_segctor_apply_buffers(\n\t\tsci, inode, &node_buffers, sc_ops->collect_bmap);\n\tif (unlikely(err))\n\t\tgoto break_or_fail;\n\n\tnilfs_segctor_end_finfo(sci, inode);\n\tsci->sc_stage.flags &= ~NILFS_CF_NODE;\n\n break_or_fail:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_buffer_rest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "975-980",
    "snippet": "static size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic size_t nilfs_segctor_buffer_rest(struct nilfs_sc_info *sci)\n{\n\t/* Remaining number of blocks within segment buffer */\n\treturn sci->sc_segbuf_nblocks -\n\t\t(sci->sc_nblk_this_inc + sci->sc_curseg->sb_sum.nblocks);\n}"
  },
  {
    "function_name": "nilfs_segctor_apply_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "944-973",
    "snippet": "static int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);",
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "listp",
            "structbuffer_head",
            "b_assoc_buffers"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "listp"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect",
          "args": [
            "sci",
            "bh",
            "inode"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_collect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "1420-1470",
          "snippet": "static int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */",
            "#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define NILFS_CF_SUFREED\t0x0004\t/* segment usages has been freed */\n#define SC_MAX_SEGDELTA 64   /* Upper limit of the number of segments\n\t\t\t\tappended in collection retry loop */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_collect(struct nilfs_sc_info *sci,\n\t\t\t\t struct the_nilfs *nilfs, int mode)\n{\n\tstruct nilfs_cstage prev_stage = sci->sc_stage;\n\tint err, nadd = 1;\n\n\t/* Collection retry loop */\n\tfor (;;) {\n\t\tsci->sc_nblk_this_inc = 0;\n\t\tsci->sc_curseg = NILFS_FIRST_SEGBUF(&sci->sc_segbufs);\n\n\t\terr = nilfs_segctor_reset_segment_buffer(sci);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\n\t\terr = nilfs_segctor_collect_blocks(sci, mode);\n\t\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\tif (unlikely(err != -E2BIG))\n\t\t\tgoto failed;\n\n\t\t/* The current segment is filled up */\n\t\tif (mode != SC_LSEG_SR || sci->sc_stage.scnt < NILFS_ST_CPFILE)\n\t\t\tbreak;\n\n\t\tnilfs_clear_logs(&sci->sc_segbufs);\n\n\t\tif (sci->sc_stage.flags & NILFS_CF_SUFREED) {\n\t\t\terr = nilfs_sufile_cancel_freev(nilfs->ns_sufile,\n\t\t\t\t\t\t\tsci->sc_freesegs,\n\t\t\t\t\t\t\tsci->sc_nfreesegs,\n\t\t\t\t\t\t\tNULL);\n\t\t\tWARN_ON(err); /* do not happen */\n\t\t\tsci->sc_stage.flags &= ~NILFS_CF_SUFREED;\n\t\t}\n\n\t\terr = nilfs_segctor_extend_segments(sci, nilfs, nadd);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\n\t\tnadd = min_t(int, nadd << 1, SC_MAX_SEGDELTA);\n\t\tsci->sc_stage = prev_stage;\n\t}\n\tnilfs_segctor_truncate_segments(sci, sci->sc_curseg, nilfs->ns_sufile);\n\treturn 0;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bh->b_assoc_buffers"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bh",
            "n",
            "listp",
            "b_assoc_buffers"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic int nilfs_segctor_apply_buffers(struct nilfs_sc_info *sci,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct list_head *listp,\n\t\t\t\t       int (*collect)(struct nilfs_sc_info *,\n\t\t\t\t\t\t      struct buffer_head *,\n\t\t\t\t\t\t      struct inode *))\n{\n\tstruct buffer_head *bh, *n;\n\tint err = 0;\n\n\tif (collect) {\n\t\tlist_for_each_entry_safe(bh, n, listp, b_assoc_buffers) {\n\t\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\t\terr = collect(sci, bh, inode);\n\t\t\tbrelse(bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto dispose_buffers;\n\t\t}\n\t\treturn 0;\n\t}\n\n dispose_buffers:\n\twhile (!list_empty(listp)) {\n\t\tbh = list_first_entry(listp, struct buffer_head,\n\t\t\t\t      b_assoc_buffers);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbrelse(bh);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_drop_collected_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "931-942",
    "snippet": "static void nilfs_drop_collected_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\t\tset_bit(NILFS_I_UPDATED, &ii->i_state);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_UPDATED",
            "&ii->i_state"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_I_INODE_SYNC",
            "&ii->i_state"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NILFS_I_COLLECTED",
            "&ii->i_state"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ii",
            "head",
            "i_dirty"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_drop_collected_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (!test_and_clear_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tcontinue;\n\n\t\tclear_bit(NILFS_I_INODE_SYNC, &ii->i_state);\n\t\tset_bit(NILFS_I_UPDATED, &ii->i_state);\n\t}\n}"
  },
  {
    "function_name": "nilfs_redirty_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "921-929",
    "snippet": "static void nilfs_redirty_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (test_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tclear_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NILFS_I_COLLECTED",
            "&ii->i_state"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_COLLECTED",
            "&ii->i_state"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ii",
            "head",
            "i_dirty"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_redirty_inodes(struct list_head *head)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, head, i_dirty) {\n\t\tif (test_bit(NILFS_I_COLLECTED, &ii->i_state))\n\t\t\tclear_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}"
  },
  {
    "function_name": "nilfs_segctor_fill_in_super_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "894-919",
    "snippet": "static void nilfs_segctor_fill_in_super_root(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tunsigned isz, srsz;\n\n\tbh_sr = NILFS_LAST_SEGBUF(&sci->sc_segbufs)->sb_super_root;\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tisz = nilfs->ns_inode_size;\n\tsrsz = NILFS_SR_BYTES(isz);\n\n\traw_sr->sr_bytes = cpu_to_le16(srsz);\n\traw_sr->sr_nongc_ctime\n\t\t= cpu_to_le64(nilfs_doing_gc() ?\n\t\t\t      nilfs->ns_nongc_ctime : sci->sc_seg_ctime);\n\traw_sr->sr_flags = 0;\n\n\tnilfs_write_inode_common(nilfs->ns_dat, (void *)raw_sr +\n\t\t\t\t NILFS_SR_DAT_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_cpfile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_CPFILE_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_sufile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_SUFILE_OFFSET(isz), 1);\n\tmemset((void *)raw_sr + srsz, 0, nilfs->ns_blocksize - srsz);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)raw_sr + srsz",
            "0",
            "nilfs->ns_blocksize - srsz"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_write_inode_common",
          "args": [
            "nilfs->ns_sufile",
            "(void *)raw_sr +\n\t\t\t\t NILFS_SR_SUFILE_OFFSET(isz)",
            "1"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "653-689",
          "snippet": "void nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_SR_SUFILE_OFFSET",
          "args": [
            "isz"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SR_CPFILE_OFFSET",
          "args": [
            "isz"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SR_DAT_OFFSET",
          "args": [
            "isz"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs_doing_gc() ?\n\t\t\t      nilfs->ns_nongc_ctime : sci->sc_seg_ctime"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "srsz"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SR_BYTES",
          "args": [
            "isz"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_LAST_SEGBUF",
          "args": [
            "&sci->sc_segbufs"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_fill_in_super_root(struct nilfs_sc_info *sci,\n\t\t\t\t\t     struct the_nilfs *nilfs)\n{\n\tstruct buffer_head *bh_sr;\n\tstruct nilfs_super_root *raw_sr;\n\tunsigned isz, srsz;\n\n\tbh_sr = NILFS_LAST_SEGBUF(&sci->sc_segbufs)->sb_super_root;\n\traw_sr = (struct nilfs_super_root *)bh_sr->b_data;\n\tisz = nilfs->ns_inode_size;\n\tsrsz = NILFS_SR_BYTES(isz);\n\n\traw_sr->sr_bytes = cpu_to_le16(srsz);\n\traw_sr->sr_nongc_ctime\n\t\t= cpu_to_le64(nilfs_doing_gc() ?\n\t\t\t      nilfs->ns_nongc_ctime : sci->sc_seg_ctime);\n\traw_sr->sr_flags = 0;\n\n\tnilfs_write_inode_common(nilfs->ns_dat, (void *)raw_sr +\n\t\t\t\t NILFS_SR_DAT_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_cpfile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_CPFILE_OFFSET(isz), 1);\n\tnilfs_write_inode_common(nilfs->ns_sufile, (void *)raw_sr +\n\t\t\t\t NILFS_SR_SUFILE_OFFSET(isz), 1);\n\tmemset((void *)raw_sr + srsz, 0, nilfs->ns_blocksize - srsz);\n}"
  },
  {
    "function_name": "nilfs_segctor_fill_in_file_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "884-892",
    "snippet": "static void nilfs_segctor_fill_in_file_bmap(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, &sci->sc_dirty_files, i_dirty) {\n\t\tnilfs_fill_in_file_bmap(sci->sc_root->ifile, ii);\n\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_COLLECTED",
            "&ii->i_state"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_fill_in_file_bmap",
          "args": [
            "sci->sc_root->ifile",
            "ii"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_fill_in_file_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "867-882",
          "snippet": "static void nilfs_fill_in_file_bmap(struct inode *ifile,\n\t\t\t\t    struct nilfs_inode_info *ii)\n\n{\n\tstruct buffer_head *ibh;\n\tstruct nilfs_inode *raw_inode;\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state)) {\n\t\tibh = ii->i_bh;\n\t\tBUG_ON(!ibh);\n\t\traw_inode = nilfs_ifile_map_inode(ifile, ii->vfs_inode.i_ino,\n\t\t\t\t\t\t  ibh);\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\t\tnilfs_ifile_unmap_inode(ifile, ii->vfs_inode.i_ino, ibh);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_fill_in_file_bmap(struct inode *ifile,\n\t\t\t\t    struct nilfs_inode_info *ii)\n\n{\n\tstruct buffer_head *ibh;\n\tstruct nilfs_inode *raw_inode;\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state)) {\n\t\tibh = ii->i_bh;\n\t\tBUG_ON(!ibh);\n\t\traw_inode = nilfs_ifile_map_inode(ifile, ii->vfs_inode.i_ino,\n\t\t\t\t\t\t  ibh);\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\t\tnilfs_ifile_unmap_inode(ifile, ii->vfs_inode.i_ino, ibh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ii",
            "&sci->sc_dirty_files",
            "i_dirty"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_fill_in_file_bmap(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_inode_info *ii;\n\n\tlist_for_each_entry(ii, &sci->sc_dirty_files, i_dirty) {\n\t\tnilfs_fill_in_file_bmap(sci->sc_root->ifile, ii);\n\t\tset_bit(NILFS_I_COLLECTED, &ii->i_state);\n\t}\n}"
  },
  {
    "function_name": "nilfs_fill_in_file_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "867-882",
    "snippet": "static void nilfs_fill_in_file_bmap(struct inode *ifile,\n\t\t\t\t    struct nilfs_inode_info *ii)\n\n{\n\tstruct buffer_head *ibh;\n\tstruct nilfs_inode *raw_inode;\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state)) {\n\t\tibh = ii->i_bh;\n\t\tBUG_ON(!ibh);\n\t\traw_inode = nilfs_ifile_map_inode(ifile, ii->vfs_inode.i_ino,\n\t\t\t\t\t\t  ibh);\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\t\tnilfs_ifile_unmap_inode(ifile, ii->vfs_inode.i_ino, ibh);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_ifile_unmap_inode",
          "args": [
            "ifile",
            "ii->vfs_inode.i_ino",
            "ibh"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_unmap_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "42-46",
          "snippet": "static inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void nilfs_ifile_unmap_inode(struct inode *ifile, ino_t ino,\n\t\t\t\t\t   struct buffer_head *ibh)\n{\n\tkunmap(ibh->b_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_write",
          "args": [
            "ii->i_bmap",
            "raw_inode"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "528-537",
          "snippet": "void nilfs_bmap_write(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tdown_write(&bmap->b_sem);\n\tmemcpy(raw_inode->i_bmap, bmap->b_u.u_data,\n\t       NILFS_INODE_BMAP_SIZE * sizeof(__le64));\n\tif (bmap->b_inode->i_ino == NILFS_DAT_INO)\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\n\tup_write(&bmap->b_sem);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid nilfs_bmap_write(struct nilfs_bmap *bmap, struct nilfs_inode *raw_inode)\n{\n\tdown_write(&bmap->b_sem);\n\tmemcpy(raw_inode->i_bmap, bmap->b_u.u_data,\n\t       NILFS_INODE_BMAP_SIZE * sizeof(__le64));\n\tif (bmap->b_inode->i_ino == NILFS_DAT_INO)\n\t\tbmap->b_last_allocated_ptr = NILFS_BMAP_NEW_PTR_INIT;\n\n\tup_write(&bmap->b_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_ifile_map_inode",
          "args": [
            "ifile",
            "ii->vfs_inode.i_ino",
            "ibh"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ifile_map_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.h",
          "lines": "35-40",
          "snippet": "static inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct nilfs_inode *\nnilfs_ifile_map_inode(struct inode *ifile, ino_t ino, struct buffer_head *ibh)\n{\n\tvoid *kaddr = kmap(ibh->b_page);\n\treturn nilfs_palloc_block_get_entry(ifile, ino, ibh, kaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ibh"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_BMAP",
            "&ii->i_state"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_fill_in_file_bmap(struct inode *ifile,\n\t\t\t\t    struct nilfs_inode_info *ii)\n\n{\n\tstruct buffer_head *ibh;\n\tstruct nilfs_inode *raw_inode;\n\n\tif (test_bit(NILFS_I_BMAP, &ii->i_state)) {\n\t\tibh = ii->i_bh;\n\t\tBUG_ON(!ibh);\n\t\traw_inode = nilfs_ifile_map_inode(ifile, ii->vfs_inode.i_ino,\n\t\t\t\t\t\t  ibh);\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\t\tnilfs_ifile_unmap_inode(ifile, ii->vfs_inode.i_ino, ibh);\n\t}\n}"
  },
  {
    "function_name": "nilfs_segctor_fill_in_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "829-865",
    "snippet": "static int nilfs_segctor_fill_in_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 0,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (unlikely(err)) {\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\t\tgoto failed_ibh;\n\t}\n\traw_cp->cp_snapshot_list.ssl_next = 0;\n\traw_cp->cp_snapshot_list.ssl_prev = 0;\n\traw_cp->cp_inodes_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->inodes_count));\n\traw_cp->cp_blocks_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->blocks_count));\n\traw_cp->cp_nblk_inc =\n\t\tcpu_to_le64(sci->sc_nblk_inc + sci->sc_nblk_this_inc);\n\traw_cp->cp_create = cpu_to_le64(sci->sc_seg_ctime);\n\traw_cp->cp_cno = cpu_to_le64(nilfs->ns_cno);\n\n\tif (test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tnilfs_checkpoint_clear_minor(raw_cp);\n\telse\n\t\tnilfs_checkpoint_set_minor(raw_cp);\n\n\tnilfs_write_inode_common(sci->sc_root->ifile,\n\t\t\t\t &raw_cp->cp_ifile_inode, 1);\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\treturn 0;\n\n failed_ibh:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_cpfile_put_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "nilfs->ns_cno",
            "bh_cp"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_put_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "252-257",
          "snippet": "void nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_write_inode_common",
          "args": [
            "sci->sc_root->ifile",
            "&raw_cp->cp_ifile_inode",
            "1"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_write_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "653-689",
          "snippet": "void nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nvoid nilfs_write_inode_common(struct inode *inode,\n\t\t\t      struct nilfs_inode *raw_inode, int has_bmap)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\traw_inode->i_uid = cpu_to_le32(i_uid_read(inode));\n\traw_inode->i_gid = cpu_to_le32(i_gid_read(inode));\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\traw_inode->i_size = cpu_to_le64(inode->i_size);\n\traw_inode->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\traw_inode->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\traw_inode->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\traw_inode->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\traw_inode->i_blocks = cpu_to_le64(inode->i_blocks);\n\n\traw_inode->i_flags = cpu_to_le32(ii->i_flags);\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\n\tif (NILFS_ROOT_METADATA_FILE(inode->i_ino)) {\n\t\tstruct the_nilfs *nilfs = inode->i_sb->s_fs_info;\n\n\t\t/* zero-fill unused portion in the case of super root block */\n\t\traw_inode->i_xattr = 0;\n\t\traw_inode->i_pad = 0;\n\t\tmemset((void *)raw_inode + sizeof(*raw_inode), 0,\n\t\t       nilfs->ns_inode_size - sizeof(*raw_inode));\n\t}\n\n\tif (has_bmap)\n\t\tnilfs_bmap_write(ii->i_bmap, raw_inode);\n\telse if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_device_code =\n\t\t\tcpu_to_le64(huge_encode_dev(inode->i_rdev));\n\t/* When extending inode, nilfs->ns_inode_size should be checked\n\t   for substitutions of appended fields */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_set_minor",
          "args": [
            "raw_cp"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_checkpoint_clear_minor",
          "args": [
            "raw_cp"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_HAVE_DELTA",
            "&sci->sc_flags"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nilfs->ns_cno"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sci->sc_seg_ctime"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sci->sc_nblk_inc + sci->sc_nblk_this_inc"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "atomic64_read(&sci->sc_root->blocks_count)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&sci->sc_root->blocks_count"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "atomic64_read(&sci->sc_root->inodes_count)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&sci->sc_root->inodes_count"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err == -EINVAL || err == -ENOENT"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "nilfs->ns_cno",
            "0",
            "&raw_cp",
            "&bh_cp"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "181-240",
          "snippet": "int nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_fill_in_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 0,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (unlikely(err)) {\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\t\tgoto failed_ibh;\n\t}\n\traw_cp->cp_snapshot_list.ssl_next = 0;\n\traw_cp->cp_snapshot_list.ssl_prev = 0;\n\traw_cp->cp_inodes_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->inodes_count));\n\traw_cp->cp_blocks_count =\n\t\tcpu_to_le64(atomic64_read(&sci->sc_root->blocks_count));\n\traw_cp->cp_nblk_inc =\n\t\tcpu_to_le64(sci->sc_nblk_inc + sci->sc_nblk_this_inc);\n\traw_cp->cp_create = cpu_to_le64(sci->sc_seg_ctime);\n\traw_cp->cp_cno = cpu_to_le64(nilfs->ns_cno);\n\n\tif (test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tnilfs_checkpoint_clear_minor(raw_cp);\n\telse\n\t\tnilfs_checkpoint_set_minor(raw_cp);\n\n\tnilfs_write_inode_common(sci->sc_root->ifile,\n\t\t\t\t &raw_cp->cp_ifile_inode, 1);\n\tnilfs_cpfile_put_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\treturn 0;\n\n failed_ibh:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_create_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "805-827",
    "snippet": "static int nilfs_segctor_create_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\t/* XXX: this interface will be changed */\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 1,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (likely(!err)) {\n\t\t/* The following code is duplicated with cpfile.  But, it is\n\t\t   needed to collect the checkpoint even if it was not newly\n\t\t   created */\n\t\tmark_buffer_dirty(bh_cp);\n\t\tnilfs_mdt_mark_dirty(nilfs->ns_cpfile);\n\t\tnilfs_cpfile_put_checkpoint(\n\t\t\tnilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\t} else\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err == -EINVAL || err == -ENOENT"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_put_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "nilfs->ns_cno",
            "bh_cp"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_put_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "252-257",
          "snippet": "void nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nvoid nilfs_cpfile_put_checkpoint(struct inode *cpfile, __u64 cno,\n\t\t\t\t struct buffer_head *bh)\n{\n\tkunmap(bh->b_page);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "nilfs->ns_cpfile"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh_cp"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_cpfile_get_checkpoint",
          "args": [
            "nilfs->ns_cpfile",
            "nilfs->ns_cno",
            "1",
            "&raw_cp",
            "&bh_cp"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_cpfile_get_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/cpfile.c",
          "lines": "181-240",
          "snippet": "int nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpfile.h\"\n#include \"mdt.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/errno.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint nilfs_cpfile_get_checkpoint(struct inode *cpfile,\n\t\t\t\t__u64 cno,\n\t\t\t\tint create,\n\t\t\t\tstruct nilfs_checkpoint **cpp,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *header_bh, *cp_bh;\n\tstruct nilfs_cpfile_header *header;\n\tstruct nilfs_checkpoint *cp;\n\tvoid *kaddr;\n\tint ret;\n\n\tif (unlikely(cno < 1 || cno > nilfs_mdt_cno(cpfile) ||\n\t\t     (cno < nilfs_mdt_cno(cpfile) && create)))\n\t\treturn -EINVAL;\n\n\tdown_write(&NILFS_MDT(cpfile)->mi_sem);\n\n\tret = nilfs_cpfile_get_header_block(cpfile, &header_bh);\n\tif (ret < 0)\n\t\tgoto out_sem;\n\tret = nilfs_cpfile_get_checkpoint_block(cpfile, cno, create, &cp_bh);\n\tif (ret < 0)\n\t\tgoto out_header;\n\tkaddr = kmap(cp_bh->b_page);\n\tcp = nilfs_cpfile_block_get_checkpoint(cpfile, cno, cp_bh, kaddr);\n\tif (nilfs_checkpoint_invalid(cp)) {\n\t\tif (!create) {\n\t\t\tkunmap(cp_bh->b_page);\n\t\t\tbrelse(cp_bh);\n\t\t\tret = -ENOENT;\n\t\t\tgoto out_header;\n\t\t}\n\t\t/* a newly-created checkpoint */\n\t\tnilfs_checkpoint_clear_invalid(cp);\n\t\tif (!nilfs_cpfile_is_in_first(cpfile, cno))\n\t\t\tnilfs_cpfile_block_add_valid_checkpoints(cpfile, cp_bh,\n\t\t\t\t\t\t\t\t kaddr, 1);\n\t\tmark_buffer_dirty(cp_bh);\n\n\t\tkaddr = kmap_atomic(header_bh->b_page);\n\t\theader = nilfs_cpfile_block_get_header(cpfile, header_bh,\n\t\t\t\t\t\t       kaddr);\n\t\tle64_add_cpu(&header->ch_ncheckpoints, 1);\n\t\tkunmap_atomic(kaddr);\n\t\tmark_buffer_dirty(header_bh);\n\t\tnilfs_mdt_mark_dirty(cpfile);\n\t}\n\n\tif (cpp != NULL)\n\t\t*cpp = cp;\n\t*bhp = cp_bh;\n\n out_header:\n\tbrelse(header_bh);\n\n out_sem:\n\tup_write(&NILFS_MDT(cpfile)->mi_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_create_checkpoint(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tstruct buffer_head *bh_cp;\n\tstruct nilfs_checkpoint *raw_cp;\n\tint err;\n\n\t/* XXX: this interface will be changed */\n\terr = nilfs_cpfile_get_checkpoint(nilfs->ns_cpfile, nilfs->ns_cno, 1,\n\t\t\t\t\t  &raw_cp, &bh_cp);\n\tif (likely(!err)) {\n\t\t/* The following code is duplicated with cpfile.  But, it is\n\t\t   needed to collect the checkpoint even if it was not newly\n\t\t   created */\n\t\tmark_buffer_dirty(bh_cp);\n\t\tnilfs_mdt_mark_dirty(nilfs->ns_cpfile);\n\t\tnilfs_cpfile_put_checkpoint(\n\t\t\tnilfs->ns_cpfile, nilfs->ns_cno, bh_cp);\n\t} else\n\t\tWARN_ON(err == -EINVAL || err == -ENOENT);\n\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_clear_metadata_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "795-803",
    "snippet": "static void nilfs_segctor_clear_metadata_dirty(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_mdt_clear_dirty(sci->sc_root->ifile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_cpfile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_sufile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_dat);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_clear_dirty",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_clear_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "104-107",
          "snippet": "static inline void nilfs_mdt_clear_dirty(struct inode *inode)\n{\n\tclear_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_clear_dirty(struct inode *inode)\n{\n\tclear_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_clear_metadata_dirty(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_mdt_clear_dirty(sci->sc_root->ifile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_cpfile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_sufile);\n\tnilfs_mdt_clear_dirty(nilfs->ns_dat);\n}"
  },
  {
    "function_name": "nilfs_segctor_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "779-793",
    "snippet": "static int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_clean",
          "args": [
            "sci"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "771-777",
          "snippet": "static int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nilfs->ns_dirty_files"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_SC_DIRTY",
            "&sci->sc_flags"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_test_metadata_dirty",
          "args": [
            "nilfs",
            "sci->sc_root"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_test_metadata_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "755-769",
          "snippet": "static int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_confirm(struct nilfs_sc_info *sci)\n{\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\tint ret = 0;\n\n\tif (nilfs_test_metadata_dirty(nilfs, sci->sc_root))\n\t\tset_bit(NILFS_SC_DIRTY, &sci->sc_flags);\n\n\tspin_lock(&nilfs->ns_inode_lock);\n\tif (list_empty(&nilfs->ns_dirty_files) && nilfs_segctor_clean(sci))\n\t\tret++;\n\n\tspin_unlock(&nilfs->ns_inode_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_segctor_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "771-777",
    "snippet": "static int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sci->sc_gc_inodes"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_DIRTY",
            "&sci->sc_flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_clean(struct nilfs_sc_info *sci)\n{\n\treturn list_empty(&sci->sc_dirty_files) &&\n\t\t!test_bit(NILFS_SC_DIRTY, &sci->sc_flags) &&\n\t\tsci->sc_nfreesegs == 0 &&\n\t\t(!nilfs_doing_gc() || list_empty(&sci->sc_gc_inodes));\n}"
  },
  {
    "function_name": "nilfs_test_metadata_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "755-769",
    "snippet": "static int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_fetch_dirty",
          "args": [
            "nilfs->ns_dat"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_fetch_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "364-373",
          "snippet": "int nilfs_mdt_fetch_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (nilfs_bmap_test_and_clear_dirty(ii->i_bmap)) {\n\t\tset_bit(NILFS_I_DIRTY, &ii->i_state);\n\t\treturn 1;\n\t}\n\treturn test_bit(NILFS_I_DIRTY, &ii->i_state);\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nint nilfs_mdt_fetch_dirty(struct inode *inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\n\tif (nilfs_bmap_test_and_clear_dirty(ii->i_bmap)) {\n\t\tset_bit(NILFS_I_DIRTY, &ii->i_state);\n\t\treturn 1;\n\t}\n\treturn test_bit(NILFS_I_DIRTY, &ii->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic int nilfs_test_metadata_dirty(struct the_nilfs *nilfs,\n\t\t\t\t     struct nilfs_root *root)\n{\n\tint ret = 0;\n\n\tif (nilfs_mdt_fetch_dirty(root->ifile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_cpfile))\n\t\tret++;\n\tif (nilfs_mdt_fetch_dirty(nilfs->ns_sufile))\n\t\tret++;\n\tif ((ret || nilfs_doing_gc()) && nilfs_mdt_fetch_dirty(nilfs->ns_dat))\n\t\tret++;\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_iput_work_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "746-753",
    "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_dispose_list",
          "args": [
            "nilfs",
            "&sci->sc_iput_queue",
            "0"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "713-744",
          "snippet": "static void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */"
          ],
          "globals_used": [
            "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structnilfs_sc_info",
            "sc_iput_work"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
  },
  {
    "function_name": "nilfs_dispose_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "713-744",
    "snippet": "static void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */"
    ],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "&(*pii)->vfs_inode"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iput_work_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "746-753",
          "snippet": "static void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_iput_work_func(struct work_struct *work)\n{\n\tstruct nilfs_sc_info *sci = container_of(work, struct nilfs_sc_info,\n\t\t\t\t\t\t sc_iput_work);\n\tstruct the_nilfs *nilfs = sci->sc_super->s_fs_info;\n\n\tnilfs_dispose_list(nilfs, &sci->sc_iput_queue, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ii->i_dirty",
            "&nilfs->ns_dirty_files"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_I_QUEUED",
            "&ii->i_state"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_DIRTY",
            "&ii->i_state"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ii->i_bh"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ii->i_bh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ii->i_dirty"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ii",
            "n",
            "head",
            "i_dirty"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nilfs->ns_inode_lock"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define SC_N_INODEVEC\t16   /* Size of locally allocated inode vector */\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_dispose_list(struct the_nilfs *nilfs,\n\t\t\t       struct list_head *head, int force)\n{\n\tstruct nilfs_inode_info *ii, *n;\n\tstruct nilfs_inode_info *ivec[SC_N_INODEVEC], **pii;\n\tunsigned nv = 0;\n\n\twhile (!list_empty(head)) {\n\t\tspin_lock(&nilfs->ns_inode_lock);\n\t\tlist_for_each_entry_safe(ii, n, head, i_dirty) {\n\t\t\tlist_del_init(&ii->i_dirty);\n\t\t\tif (force) {\n\t\t\t\tif (unlikely(ii->i_bh)) {\n\t\t\t\t\tbrelse(ii->i_bh);\n\t\t\t\t\tii->i_bh = NULL;\n\t\t\t\t}\n\t\t\t} else if (test_bit(NILFS_I_DIRTY, &ii->i_state)) {\n\t\t\t\tset_bit(NILFS_I_QUEUED, &ii->i_state);\n\t\t\t\tlist_add_tail(&ii->i_dirty,\n\t\t\t\t\t      &nilfs->ns_dirty_files);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tivec[nv++] = ii;\n\t\t\tif (nv == SC_N_INODEVEC)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&nilfs->ns_inode_lock);\n\n\t\tfor (pii = ivec; nv > 0; pii++, nv--)\n\t\t\tiput(&(*pii)->vfs_inode);\n\t}\n}"
  },
  {
    "function_name": "nilfs_lookup_dirty_node_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "682-711",
    "snippet": "static void nilfs_lookup_dirty_node_buffers(struct inode *inode,\n\t\t\t\t\t    struct list_head *listp)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct address_space *mapping = &ii->i_btnode_cache;\n\tstruct pagevec pvec;\n\tstruct buffer_head *bh, *head;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tbh = head = page_buffers(pvec.pages[i]);\n\t\t\tdo {\n\t\t\t\tif (buffer_dirty(bh) &&\n\t\t\t\t\t\t!buffer_async_write(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tlist_add_tail(&bh->b_assoc_buffers,\n\t\t\t\t\t\t      listp);\n\t\t\t\t}\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bh->b_assoc_buffers",
            "listp"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "pvec.pages[i]"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "PAGEVEC_SIZE"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic void nilfs_lookup_dirty_node_buffers(struct inode *inode,\n\t\t\t\t\t    struct list_head *listp)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tstruct address_space *mapping = &ii->i_btnode_cache;\n\tstruct pagevec pvec;\n\tstruct buffer_head *bh, *head;\n\tunsigned int i;\n\tpgoff_t index = 0;\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\t  PAGEVEC_SIZE)) {\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tbh = head = page_buffers(pvec.pages[i]);\n\t\t\tdo {\n\t\t\t\tif (buffer_dirty(bh) &&\n\t\t\t\t\t\t!buffer_async_write(bh)) {\n\t\t\t\t\tget_bh(bh);\n\t\t\t\t\tlist_add_tail(&bh->b_assoc_buffers,\n\t\t\t\t\t\t      listp);\n\t\t\t\t}\n\t\t\t\tbh = bh->b_this_page;\n\t\t\t} while (bh != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "nilfs_lookup_dirty_data_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "623-680",
    "snippet": "static size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ndirties >= nlimit"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bh->b_assoc_buffers",
            "listp"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_async_write",
          "args": [
            "bh"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_async_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "420-423",
          "snippet": "void mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_async_write(struct buffer_head *bh)\n{\n\tmark_buffer_async_write_endio(bh, end_buffer_async_write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_page_buffers_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/page.c",
          "lines": "157-168",
          "snippet": "int nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/bitops.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/gfp.h>\n#include <linux/pagevec.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/page-flags.h>\n#include <linux/bitops.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n\nint nilfs_page_buffers_clean(struct page *page)\n{\n\tstruct buffer_head *bh, *head;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (buffer_dirty(bh))\n\t\t\treturn 0;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "1 << inode->i_blkbits",
            "0"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->index > last"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_count",
          "args": [
            "&pvec"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "min_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "pgoff_t",
            "last - index",
            "PAGEVEC_SIZE - 1"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index > last"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "start != 0 || end != LLONG_MAX"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_dispose_list(struct the_nilfs *, struct list_head *, int);\n\nstatic size_t nilfs_lookup_dirty_data_buffers(struct inode *inode,\n\t\t\t\t\t      struct list_head *listp,\n\t\t\t\t\t      size_t nlimit,\n\t\t\t\t\t      loff_t start, loff_t end)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct pagevec pvec;\n\tpgoff_t index = 0, last = ULONG_MAX;\n\tsize_t ndirties = 0;\n\tint i;\n\n\tif (unlikely(start != 0 || end != LLONG_MAX)) {\n\t\t/*\n\t\t * A valid range is given for sync-ing data pages. The\n\t\t * range is rounded to per-page; extra dirty buffers\n\t\t * may be included if blocksize < pagesize.\n\t\t */\n\t\tindex = start >> PAGE_SHIFT;\n\t\tlast = end >> PAGE_SHIFT;\n\t}\n\tpagevec_init(&pvec, 0);\n repeat:\n\tif (unlikely(index > last) ||\n\t    !pagevec_lookup_tag(&pvec, mapping, &index, PAGECACHE_TAG_DIRTY,\n\t\t\t\tmin_t(pgoff_t, last - index,\n\t\t\t\t      PAGEVEC_SIZE - 1) + 1))\n\t\treturn ndirties;\n\n\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\tstruct buffer_head *bh, *head;\n\t\tstruct page *page = pvec.pages[i];\n\n\t\tif (unlikely(page->index > last))\n\t\t\tbreak;\n\n\t\tlock_page(page);\n\t\tif (!page_has_buffers(page))\n\t\t\tcreate_empty_buffers(page, 1 << inode->i_blkbits, 0);\n\t\tunlock_page(page);\n\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (!buffer_dirty(bh) || buffer_async_write(bh))\n\t\t\t\tcontinue;\n\t\t\tget_bh(bh);\n\t\t\tlist_add_tail(&bh->b_assoc_buffers, listp);\n\t\t\tndirties++;\n\t\t\tif (unlikely(ndirties >= nlimit)) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\tcond_resched();\n\t\t\t\treturn ndirties;\n\t\t\t}\n\t\t} while (bh = bh->b_this_page, bh != head);\n\t}\n\tpagevec_release(&pvec);\n\tcond_resched();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "nilfs_write_dat_node_binfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "598-605",
    "snippet": "static void nilfs_write_dat_node_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t       struct nilfs_segsum_pointer *ssp,\n\t\t\t\t       union nilfs_binfo *binfo)\n{\n\tstruct nilfs_binfo_dat *binfo_dat =\n\t\tnilfs_segctor_map_segsum_entry(sci, ssp, sizeof(*binfo_dat));\n\t*binfo_dat = binfo->bi_dat;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "ssp",
            "sizeof(*binfo_dat)"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_write_dat_node_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t       struct nilfs_segsum_pointer *ssp,\n\t\t\t\t       union nilfs_binfo *binfo)\n{\n\tstruct nilfs_binfo_dat *binfo_dat =\n\t\tnilfs_segctor_map_segsum_entry(sci, ssp, sizeof(*binfo_dat));\n\t*binfo_dat = binfo->bi_dat;\n}"
  },
  {
    "function_name": "nilfs_write_dat_data_binfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "589-596",
    "snippet": "static void nilfs_write_dat_data_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t       struct nilfs_segsum_pointer *ssp,\n\t\t\t\t       union nilfs_binfo *binfo)\n{\n\t__le64 *blkoff = nilfs_segctor_map_segsum_entry(sci, ssp,\n\t\t\t\t\t\t\t  sizeof(*blkoff));\n\t*blkoff = binfo->bi_dat.bi_blkoff;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "ssp",
            "sizeof(*blkoff)"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_write_dat_data_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t       struct nilfs_segsum_pointer *ssp,\n\t\t\t\t       union nilfs_binfo *binfo)\n{\n\t__le64 *blkoff = nilfs_segctor_map_segsum_entry(sci, ssp,\n\t\t\t\t\t\t\t  sizeof(*blkoff));\n\t*blkoff = binfo->bi_dat.bi_blkoff;\n}"
  },
  {
    "function_name": "nilfs_collect_dat_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "581-587",
    "snippet": "static int nilfs_collect_dat_bmap(struct nilfs_sc_info *sci,\n\t\t\t\t  struct buffer_head *bh, struct inode *inode)\n{\n\tWARN_ON(!buffer_dirty(bh));\n\treturn nilfs_segctor_add_file_block(sci, bh, inode,\n\t\t\t\t\t    sizeof(struct nilfs_binfo_dat));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_add_file_block",
          "args": [
            "sci",
            "bh",
            "inode",
            "sizeof(struct nilfs_binfo_dat)"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_add_file_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "471-504",
          "snippet": "static int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer_dirty(bh)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_collect_dat_bmap(struct nilfs_sc_info *sci,\n\t\t\t\t  struct buffer_head *bh, struct inode *inode)\n{\n\tWARN_ON(!buffer_dirty(bh));\n\treturn nilfs_segctor_add_file_block(sci, bh, inode,\n\t\t\t\t\t    sizeof(struct nilfs_binfo_dat));\n}"
  },
  {
    "function_name": "nilfs_collect_dat_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "566-579",
    "snippet": "static int nilfs_collect_dat_data(struct nilfs_sc_info *sci,\n\t\t\t\t  struct buffer_head *bh, struct inode *inode)\n{\n\tint err;\n\n\terr = nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nilfs_segctor_add_file_block(sci, bh, inode, sizeof(__le64));\n\tif (!err)\n\t\tsci->sc_datablk_cnt++;\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_add_file_block",
          "args": [
            "sci",
            "bh",
            "inode",
            "sizeof(__le64)"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_add_file_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "471-504",
          "snippet": "static int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_propagate",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "bh"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_propagate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "319-328",
          "snippet": "int nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_collect_dat_data(struct nilfs_sc_info *sci,\n\t\t\t\t  struct buffer_head *bh, struct inode *inode)\n{\n\tint err;\n\n\terr = nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nilfs_segctor_add_file_block(sci, bh, inode, sizeof(__le64));\n\tif (!err)\n\t\tsci->sc_datablk_cnt++;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_write_file_node_binfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "549-556",
    "snippet": "static void nilfs_write_file_node_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct nilfs_segsum_pointer *ssp,\n\t\t\t\t\tunion nilfs_binfo *binfo)\n{\n\t__le64 *vblocknr = nilfs_segctor_map_segsum_entry(\n\t\tsci, ssp, sizeof(*vblocknr));\n\t*vblocknr = binfo->bi_v.bi_vblocknr;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "ssp",
            "sizeof(*vblocknr)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_write_file_node_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct nilfs_segsum_pointer *ssp,\n\t\t\t\t\tunion nilfs_binfo *binfo)\n{\n\t__le64 *vblocknr = nilfs_segctor_map_segsum_entry(\n\t\tsci, ssp, sizeof(*vblocknr));\n\t*vblocknr = binfo->bi_v.bi_vblocknr;\n}"
  },
  {
    "function_name": "nilfs_write_file_data_binfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "540-547",
    "snippet": "static void nilfs_write_file_data_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct nilfs_segsum_pointer *ssp,\n\t\t\t\t\tunion nilfs_binfo *binfo)\n{\n\tstruct nilfs_binfo_v *binfo_v = nilfs_segctor_map_segsum_entry(\n\t\tsci, ssp, sizeof(*binfo_v));\n\t*binfo_v = binfo->bi_v;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "ssp",
            "sizeof(*binfo_v)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_write_file_data_binfo(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct nilfs_segsum_pointer *ssp,\n\t\t\t\t\tunion nilfs_binfo *binfo)\n{\n\tstruct nilfs_binfo_v *binfo_v = nilfs_segctor_map_segsum_entry(\n\t\tsci, ssp, sizeof(*binfo_v));\n\t*binfo_v = binfo->bi_v;\n}"
  },
  {
    "function_name": "nilfs_collect_file_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "532-538",
    "snippet": "static int nilfs_collect_file_bmap(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   struct inode *inode)\n{\n\tWARN_ON(!buffer_dirty(bh));\n\treturn nilfs_segctor_add_file_block(sci, bh, inode, sizeof(__le64));\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_add_file_block",
          "args": [
            "sci",
            "bh",
            "inode",
            "sizeof(__le64)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_add_file_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "471-504",
          "snippet": "static int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer_dirty(bh)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_collect_file_bmap(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   struct inode *inode)\n{\n\tWARN_ON(!buffer_dirty(bh));\n\treturn nilfs_segctor_add_file_block(sci, bh, inode, sizeof(__le64));\n}"
  },
  {
    "function_name": "nilfs_collect_file_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "525-530",
    "snippet": "static int nilfs_collect_file_node(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   struct inode *inode)\n{\n\treturn nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_bmap_propagate",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "bh"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_propagate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "319-328",
          "snippet": "int nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_collect_file_node(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   struct inode *inode)\n{\n\treturn nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n}"
  },
  {
    "function_name": "nilfs_collect_file_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "509-523",
    "snippet": "static int nilfs_collect_file_data(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh, struct inode *inode)\n{\n\tint err;\n\n\terr = nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nilfs_segctor_add_file_block(sci, bh, inode,\n\t\t\t\t\t   sizeof(struct nilfs_binfo_v));\n\tif (!err)\n\t\tsci->sc_datablk_cnt++;\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_add_file_block",
          "args": [
            "sci",
            "bh",
            "inode",
            "sizeof(struct nilfs_binfo_v)"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_add_file_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "471-504",
          "snippet": "static int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_bmap_propagate",
          "args": [
            "NILFS_I(inode)->i_bmap",
            "bh"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_bmap_propagate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/bmap.c",
          "lines": "319-328",
          "snippet": "int nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"dat.h\"",
            "#include \"mdt.h\"",
            "#include \"btnode.h\"",
            "#include \"direct.h\"",
            "#include \"btree.h\"",
            "#include \"bmap.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"dat.h\"\n#include \"mdt.h\"\n#include \"btnode.h\"\n#include \"direct.h\"\n#include \"btree.h\"\n#include \"bmap.h\"\n#include \"nilfs.h\"\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint nilfs_bmap_propagate(struct nilfs_bmap *bmap, struct buffer_head *bh)\n{\n\tint ret;\n\n\tdown_write(&bmap->b_sem);\n\tret = bmap->b_ops->bop_propagate(bmap, bh);\n\tup_write(&bmap->b_sem);\n\n\treturn nilfs_bmap_convert_error(bmap, __func__, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_collect_file_data(struct nilfs_sc_info *sci,\n\t\t\t\t   struct buffer_head *bh, struct inode *inode)\n{\n\tint err;\n\n\terr = nilfs_bmap_propagate(NILFS_I(inode)->i_bmap, bh);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nilfs_segctor_add_file_block(sci, bh, inode,\n\t\t\t\t\t   sizeof(struct nilfs_binfo_v));\n\tif (!err)\n\t\tsci->sc_datablk_cnt++;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_add_file_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "471-504",
    "snippet": "static int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segbuf_add_file_buffer",
          "args": [
            "segbuf",
            "bh"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_add_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.h",
          "lines": "163-170",
          "snippet": "static inline void\nnilfs_segbuf_add_file_buffer(struct nilfs_segment_buffer *segbuf,\n\t\t\t     struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tnilfs_segbuf_add_payload_buffer(segbuf, bh);\n\tsegbuf->sb_sum.nfileblk++;\n}",
          "includes": [
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void\nnilfs_segbuf_add_file_buffer(struct nilfs_segment_buffer *segbuf,\n\t\t\t     struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tnilfs_segbuf_add_payload_buffer(segbuf, bh);\n\tsegbuf->sb_sum.nfileblk++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "&sci->sc_binfo_ptr",
            "binfo_size"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_begin_finfo",
          "args": [
            "sci",
            "inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_begin_finfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "423-435",
          "snippet": "static void nilfs_segctor_begin_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t      struct inode *inode)\n{\n\tsci->sc_curseg->sb_sum.nfinfo++;\n\tsci->sc_binfo_ptr = sci->sc_finfo_ptr;\n\tnilfs_segctor_map_segsum_entry(\n\t\tsci, &sci->sc_binfo_ptr, sizeof(struct nilfs_finfo));\n\n\tif (NILFS_I(inode)->i_root &&\n\t    !test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tset_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t/* skip finfo */\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_begin_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t      struct inode *inode)\n{\n\tsci->sc_curseg->sb_sum.nfinfo++;\n\tsci->sc_binfo_ptr = sci->sc_finfo_ptr;\n\tnilfs_segctor_map_segsum_entry(\n\t\tsci, &sci->sc_binfo_ptr, sizeof(struct nilfs_finfo));\n\n\tif (NILFS_I(inode)->i_root &&\n\t    !test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tset_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t/* skip finfo */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_extend_segsum",
          "args": [
            "segbuf"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_extend_segsum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "108-119",
          "snippet": "int nilfs_segbuf_extend_segsum(struct nilfs_segment_buffer *segbuf)\n{\n\tstruct buffer_head *bh;\n\n\tbh = sb_getblk(segbuf->sb_super,\n\t\t       segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tnilfs_segbuf_add_segsum_buffer(segbuf, bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_segbuf_extend_segsum(struct nilfs_segment_buffer *segbuf)\n{\n\tstruct buffer_head *bh;\n\n\tbh = sb_getblk(segbuf->sb_super,\n\t\t       segbuf->sb_pseg_start + segbuf->sb_sum.nsumblk);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tnilfs_segbuf_add_segsum_buffer(segbuf, bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "required"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_feed_segment",
          "args": [
            "sci"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_feed_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "381-389",
          "snippet": "static int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_end_finfo",
          "args": [
            "sci",
            "inode"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_end_finfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "437-469",
          "snippet": "static void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_segsum_block_required",
          "args": [
            "sci",
            "&sci->sc_binfo_ptr",
            "binfo_size"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_segsum_block_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "411-421",
          "snippet": "static int nilfs_segctor_segsum_block_required(\n\tstruct nilfs_sc_info *sci, const struct nilfs_segsum_pointer *ssp,\n\tunsigned binfo_size)\n{\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\t/* Size of finfo and binfo is enough small against blocksize */\n\n\treturn ssp->offset + binfo_size +\n\t\t(!sci->sc_blk_cnt ? sizeof(struct nilfs_finfo) : 0) >\n\t\tblocksize;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_segsum_block_required(\n\tstruct nilfs_sc_info *sci, const struct nilfs_segsum_pointer *ssp,\n\tunsigned binfo_size)\n{\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\t/* Size of finfo and binfo is enough small against blocksize */\n\n\treturn ssp->offset + binfo_size +\n\t\t(!sci->sc_blk_cnt ? sizeof(struct nilfs_finfo) : 0) >\n\t\tblocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_file_block(struct nilfs_sc_info *sci,\n\t\t\t\t\tstruct buffer_head *bh,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned binfo_size)\n{\n\tstruct nilfs_segment_buffer *segbuf;\n\tint required, err = 0;\n\n retry:\n\tsegbuf = sci->sc_curseg;\n\trequired = nilfs_segctor_segsum_block_required(\n\t\tsci, &sci->sc_binfo_ptr, binfo_size);\n\tif (segbuf->sb_sum.nblocks + required + 1 > segbuf->sb_rest_blocks) {\n\t\tnilfs_segctor_end_finfo(sci, inode);\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto retry;\n\t}\n\tif (unlikely(required)) {\n\t\terr = nilfs_segbuf_extend_segsum(segbuf);\n\t\tif (unlikely(err))\n\t\t\tgoto failed;\n\t}\n\tif (sci->sc_blk_cnt == 0)\n\t\tnilfs_segctor_begin_finfo(sci, inode);\n\n\tnilfs_segctor_map_segsum_entry(sci, &sci->sc_binfo_ptr, binfo_size);\n\t/* Substitution to vblocknr is delayed until update_blocknr() */\n\tnilfs_segbuf_add_file_buffer(segbuf, bh);\n\tsci->sc_blk_cnt++;\n failed:\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_end_finfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "437-469",
    "snippet": "static void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cno"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sci->sc_datablk_cnt"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sci->sc_blk_cnt"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ino"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "&sci->sc_finfo_ptr",
            "sizeof(*finfo)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_ROOT_METADATA_FILE",
          "args": [
            "inode->i_ino"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_I_GCINODE",
            "&ii->i_state"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_end_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t    struct inode *inode)\n{\n\tstruct nilfs_finfo *finfo;\n\tstruct nilfs_inode_info *ii;\n\tstruct nilfs_segment_buffer *segbuf;\n\t__u64 cno;\n\n\tif (sci->sc_blk_cnt == 0)\n\t\treturn;\n\n\tii = NILFS_I(inode);\n\n\tif (test_bit(NILFS_I_GCINODE, &ii->i_state))\n\t\tcno = ii->i_cno;\n\telse if (NILFS_ROOT_METADATA_FILE(inode->i_ino))\n\t\tcno = 0;\n\telse\n\t\tcno = sci->sc_cno;\n\n\tfinfo = nilfs_segctor_map_segsum_entry(sci, &sci->sc_finfo_ptr,\n\t\t\t\t\t\t sizeof(*finfo));\n\tfinfo->fi_ino = cpu_to_le64(inode->i_ino);\n\tfinfo->fi_nblocks = cpu_to_le32(sci->sc_blk_cnt);\n\tfinfo->fi_ndatablk = cpu_to_le32(sci->sc_datablk_cnt);\n\tfinfo->fi_cno = cpu_to_le64(cno);\n\n\tsegbuf = sci->sc_curseg;\n\tsegbuf->sb_sum.sumbytes = sci->sc_binfo_ptr.offset +\n\t\tsci->sc_super->s_blocksize * (segbuf->sb_sum.nsumblk - 1);\n\tsci->sc_finfo_ptr = sci->sc_binfo_ptr;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_begin_finfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "423-435",
    "snippet": "static void nilfs_segctor_begin_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t      struct inode *inode)\n{\n\tsci->sc_curseg->sb_sum.nfinfo++;\n\tsci->sc_binfo_ptr = sci->sc_finfo_ptr;\n\tnilfs_segctor_map_segsum_entry(\n\t\tsci, &sci->sc_binfo_ptr, sizeof(struct nilfs_finfo));\n\n\tif (NILFS_I(inode)->i_root &&\n\t    !test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tset_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t/* skip finfo */\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_SC_HAVE_DELTA",
            "&sci->sc_flags"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_HAVE_DELTA",
            "&sci->sc_flags"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "inode"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "78-81",
          "snippet": "static inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nstatic inline struct nilfs_inode_info *NILFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct nilfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_map_segsum_entry",
          "args": [
            "sci",
            "&sci->sc_binfo_ptr",
            "sizeof(struct nilfs_finfo)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_map_segsum_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "336-353",
          "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_begin_finfo(struct nilfs_sc_info *sci,\n\t\t\t\t      struct inode *inode)\n{\n\tsci->sc_curseg->sb_sum.nfinfo++;\n\tsci->sc_binfo_ptr = sci->sc_finfo_ptr;\n\tnilfs_segctor_map_segsum_entry(\n\t\tsci, &sci->sc_binfo_ptr, sizeof(struct nilfs_finfo));\n\n\tif (NILFS_I(inode)->i_root &&\n\t    !test_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags))\n\t\tset_bit(NILFS_SC_HAVE_DELTA, &sci->sc_flags);\n\t/* skip finfo */\n}"
  },
  {
    "function_name": "nilfs_segctor_segsum_block_required",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "411-421",
    "snippet": "static int nilfs_segctor_segsum_block_required(\n\tstruct nilfs_sc_info *sci, const struct nilfs_segsum_pointer *ssp,\n\tunsigned binfo_size)\n{\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\t/* Size of finfo and binfo is enough small against blocksize */\n\n\treturn ssp->offset + binfo_size +\n\t\t(!sci->sc_blk_cnt ? sizeof(struct nilfs_finfo) : 0) >\n\t\tblocksize;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_segsum_block_required(\n\tstruct nilfs_sc_info *sci, const struct nilfs_segsum_pointer *ssp,\n\tunsigned binfo_size)\n{\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\t/* Size of finfo and binfo is enough small against blocksize */\n\n\treturn ssp->offset + binfo_size +\n\t\t(!sci->sc_blk_cnt ? sizeof(struct nilfs_finfo) : 0) >\n\t\tblocksize;\n}"
  },
  {
    "function_name": "nilfs_segctor_add_super_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "391-406",
    "snippet": "static int nilfs_segctor_add_super_root(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tint err;\n\n\tif (segbuf->sb_sum.nblocks >= segbuf->sb_rest_blocks) {\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsegbuf = sci->sc_curseg;\n\t}\n\terr = nilfs_segbuf_extend_payload(segbuf, &segbuf->sb_super_root);\n\tif (likely(!err))\n\t\tsegbuf->sb_sum.flags |= NILFS_SS_SR;\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_extend_payload",
          "args": [
            "segbuf",
            "&segbuf->sb_super_root"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_extend_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "121-134",
          "snippet": "int nilfs_segbuf_extend_payload(struct nilfs_segment_buffer *segbuf,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = sb_getblk(segbuf->sb_super,\n\t\t       segbuf->sb_pseg_start + segbuf->sb_sum.nblocks);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tnilfs_segbuf_add_payload_buffer(segbuf, bh);\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_segbuf_extend_payload(struct nilfs_segment_buffer *segbuf,\n\t\t\t\tstruct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\n\tbh = sb_getblk(segbuf->sb_super,\n\t\t       segbuf->sb_pseg_start + segbuf->sb_sum.nblocks);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\n\tnilfs_segbuf_add_payload_buffer(segbuf, bh);\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_feed_segment",
          "args": [
            "sci"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_feed_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "381-389",
          "snippet": "static int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_add_super_root(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tint err;\n\n\tif (segbuf->sb_sum.nblocks >= segbuf->sb_rest_blocks) {\n\t\terr = nilfs_segctor_feed_segment(sci);\n\t\tif (err)\n\t\t\treturn err;\n\t\tsegbuf = sci->sc_curseg;\n\t}\n\terr = nilfs_segbuf_extend_payload(segbuf, &segbuf->sb_super_root);\n\tif (likely(!err))\n\t\tsegbuf->sb_sum.flags |= NILFS_SS_SR;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_segctor_feed_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "381-389",
    "snippet": "static int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_segctor_reset_segment_buffer",
          "args": [
            "sci"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_reset_segment_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "359-379",
          "snippet": "static int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_NEXT_SEGBUF",
          "args": [
            "sci->sc_curseg"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SEGBUF_IS_LAST",
          "args": [
            "sci->sc_curseg",
            "&sci->sc_segbufs"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_feed_segment(struct nilfs_sc_info *sci)\n{\n\tsci->sc_nblk_this_inc += sci->sc_curseg->sb_sum.nblocks;\n\tif (NILFS_SEGBUF_IS_LAST(sci->sc_curseg, &sci->sc_segbufs))\n\t\treturn -E2BIG; /* The current segment is filled up\n\t\t\t\t  (internal code) */\n\tsci->sc_curseg = NILFS_NEXT_SEGBUF(sci->sc_curseg);\n\treturn nilfs_segctor_reset_segment_buffer(sci);\n}"
  },
  {
    "function_name": "nilfs_segctor_reset_segment_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "359-379",
    "snippet": "static int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_SEGBUF_FIRST_BH",
          "args": [
            "&segbuf->sb_segsum_buffers"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segbuf_reset",
          "args": [
            "segbuf",
            "flags",
            "sci->sc_seg_ctime",
            "sci->sc_cno"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segbuf_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segbuf.c",
          "lines": "136-152",
          "snippet": "int nilfs_segbuf_reset(struct nilfs_segment_buffer *segbuf, unsigned flags,\n\t\t       time_t ctime, __u64 cno)\n{\n\tint err;\n\n\tsegbuf->sb_sum.nblocks = segbuf->sb_sum.nsumblk = 0;\n\terr = nilfs_segbuf_extend_segsum(segbuf);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsegbuf->sb_sum.flags = flags;\n\tsegbuf->sb_sum.sumbytes = sizeof(struct nilfs_segment_summary);\n\tsegbuf->sb_sum.nfinfo = segbuf->sb_sum.nfileblk = 0;\n\tsegbuf->sb_sum.ctime = ctime;\n\tsegbuf->sb_sum.cno = cno;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"page.h\"",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"page.h\"\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/crc32.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_segbuf_wait(struct nilfs_segment_buffer *segbuf);\n\nint nilfs_segbuf_reset(struct nilfs_segment_buffer *segbuf, unsigned flags,\n\t\t       time_t ctime, __u64 cno)\n{\n\tint err;\n\n\tsegbuf->sb_sum.nblocks = segbuf->sb_sum.nsumblk = 0;\n\terr = nilfs_segbuf_extend_segsum(segbuf);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsegbuf->sb_sum.flags = flags;\n\tsegbuf->sb_sum.sumbytes = sizeof(struct nilfs_segment_summary);\n\tsegbuf->sb_sum.nfinfo = segbuf->sb_sum.nfileblk = 0;\n\tsegbuf->sb_sum.ctime = ctime;\n\tsegbuf->sb_sum.cno = cno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_doing_gc",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_doing_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/nilfs.h",
          "lines": "187-190",
          "snippet": "static inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NILFS_TI_GC\t\t0x0004\t/* GC context */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\n#define NILFS_TI_GC\t\t0x0004\t/* GC context */\n\nstatic inline int nilfs_doing_gc(void)\n{\n\treturn nilfs_test_transaction_flag(NILFS_TI_GC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic int nilfs_segctor_reset_segment_buffer(struct nilfs_sc_info *sci)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tstruct buffer_head *sumbh;\n\tunsigned sumbytes;\n\tunsigned flags = 0;\n\tint err;\n\n\tif (nilfs_doing_gc())\n\t\tflags = NILFS_SS_GC;\n\terr = nilfs_segbuf_reset(segbuf, flags, sci->sc_seg_ctime, sci->sc_cno);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tsumbh = NILFS_SEGBUF_FIRST_BH(&segbuf->sb_segsum_buffers);\n\tsumbytes = segbuf->sb_sum.sumbytes;\n\tsci->sc_finfo_ptr.bh = sumbh;  sci->sc_finfo_ptr.offset = sumbytes;\n\tsci->sc_binfo_ptr.bh = sumbh;  sci->sc_binfo_ptr.offset = sumbytes;\n\tsci->sc_blk_cnt = sci->sc_datablk_cnt = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_segctor_map_segsum_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "336-353",
    "snippet": "static void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_SEGBUF_NEXT_BH",
          "args": [
            "ssp->bh"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_SEGBUF_BH_IS_LAST",
          "args": [
            "ssp->bh",
            "&segbuf->sb_segsum_buffers"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ssp->offset + bytes > blocksize"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void *nilfs_segctor_map_segsum_entry(struct nilfs_sc_info *sci,\n\t\t\t\t\t    struct nilfs_segsum_pointer *ssp,\n\t\t\t\t\t    unsigned bytes)\n{\n\tstruct nilfs_segment_buffer *segbuf = sci->sc_curseg;\n\tunsigned blocksize = sci->sc_super->s_blocksize;\n\tvoid *p;\n\n\tif (unlikely(ssp->offset + bytes > blocksize)) {\n\t\tssp->offset = 0;\n\t\tBUG_ON(NILFS_SEGBUF_BH_IS_LAST(ssp->bh,\n\t\t\t\t\t       &segbuf->sb_segsum_buffers));\n\t\tssp->bh = NILFS_SEGBUF_NEXT_BH(ssp->bh);\n\t}\n\tp = ssp->bh->b_data + ssp->offset;\n\tssp->offset += bytes;\n\treturn p;\n}"
  },
  {
    "function_name": "nilfs_transaction_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "324-334",
    "snippet": "static void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ti->ti_count > 0"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ti == NULL || ti->ti_magic != NILFS_TI_MAGIC"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_transaction_unlock(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tBUG_ON(ti->ti_count > 0);\n\n\tup_write(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n}"
  },
  {
    "function_name": "nilfs_transaction_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "295-322",
    "snippet": "static void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_immediate_flush",
          "args": [
            "sci"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_immediate_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2431-2450",
          "snippet": "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
            "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_PRIOR_FLUSH",
            "&sci->sc_flags"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cur_ti"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_transaction_lock(struct super_block *sb,\n\t\t\t\t   struct nilfs_transaction_info *ti,\n\t\t\t\t   int gcflag)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tWARN_ON(cur_ti);\n\tti->ti_flags = NILFS_TI_WRITER;\n\tti->ti_count = 0;\n\tti->ti_save = cur_ti;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\n\tfor (;;) {\n\t\tdown_write(&nilfs->ns_segctor_sem);\n\t\tif (!test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags))\n\t\t\tbreak;\n\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\n\t\tup_write(&nilfs->ns_segctor_sem);\n\t\tyield();\n\t}\n\tif (gcflag)\n\t\tti->ti_flags |= NILFS_TI_GC;\n}"
  },
  {
    "function_name": "nilfs_relax_pressure_in_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "272-293",
    "snippet": "void nilfs_relax_pressure_in_lock(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || !sci->sc_flush_request)\n\t\treturn;\n\n\tset_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (sci->sc_flush_request &&\n\t    test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags)) {\n\t\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\t\tti->ti_flags |= NILFS_TI_WRITER;\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\t\tti->ti_flags &= ~NILFS_TI_WRITER;\n\t}\n\tdowngrade_write(&nilfs->ns_segctor_sem);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "downgrade_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_immediate_flush",
          "args": [
            "sci"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_immediate_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2431-2450",
          "snippet": "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */",
            "#define FLUSH_FILE_BIT\t(0x1) /* data file only */"
          ],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\n#define FLUSH_DAT_BIT\t(1 << NILFS_DAT_INO) /* DAT only */\n#define FLUSH_FILE_BIT\t(0x1) /* data file only */\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *sci)\n{\n\tint mode = 0;\n\tint err;\n\n\tspin_lock(&sci->sc_state_lock);\n\tmode = (sci->sc_flush_request & FLUSH_DAT_BIT) ?\n\t\tSC_FLUSH_DAT : SC_FLUSH_FILE;\n\tspin_unlock(&sci->sc_state_lock);\n\n\tif (mode) {\n\t\terr = nilfs_segctor_do_construct(sci, mode);\n\n\t\tspin_lock(&sci->sc_state_lock);\n\t\tsci->sc_flush_request &= (mode == SC_FLUSH_FILE) ?\n\t\t\t~FLUSH_FILE_BIT : ~FLUSH_DAT_BIT;\n\t\tspin_unlock(&sci->sc_state_lock);\n\t}\n\tclear_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NILFS_SC_PRIOR_FLUSH",
            "&sci->sc_flags"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NILFS_SC_PRIOR_FLUSH",
            "&sci->sc_flags"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nvoid nilfs_relax_pressure_in_lock(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\tif (!sci || !sci->sc_flush_request)\n\t\treturn;\n\n\tset_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags);\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tdown_write(&nilfs->ns_segctor_sem);\n\tif (sci->sc_flush_request &&\n\t    test_bit(NILFS_SC_PRIOR_FLUSH, &sci->sc_flags)) {\n\t\tstruct nilfs_transaction_info *ti = current->journal_info;\n\n\t\tti->ti_flags |= NILFS_TI_WRITER;\n\t\tnilfs_segctor_do_immediate_flush(sci);\n\t\tti->ti_flags &= ~NILFS_TI_WRITER;\n\t}\n\tdowngrade_write(&nilfs->ns_segctor_sem);\n}"
  },
  {
    "function_name": "nilfs_transaction_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "254-270",
    "snippet": "void nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sb"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nilfs_transaction_cachep",
            "ti"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ti == NULL || ti->ti_magic != NILFS_TI_MAGIC"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nvoid nilfs_transaction_abort(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn;\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n}"
  },
  {
    "function_name": "nilfs_transaction_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "223-252",
    "snippet": "int nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
      "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
      "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sb"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nilfs_transaction_cachep",
            "ti"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_construct_segment",
          "args": [
            "sb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_construct_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2168-2183",
          "snippet": "int nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_construct_segment(struct super_block *sb)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\tstruct nilfs_transaction_info *ti;\n\tint err;\n\n\tif (!sci)\n\t\treturn -EROFS;\n\n\t/* A call inside transactions causes a deadlock. */\n\tBUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);\n\n\terr = nilfs_segctor_sync(sci);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_do_flush",
          "args": [
            "sci",
            "0"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_do_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2060-2071",
          "snippet": "static void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *sci, int bn)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_flush_request & (1 << bn))) {\n\t\tunsigned long prev_req = sci->sc_flush_request;\n\n\t\tsci->sc_flush_request |= (1 << bn);\n\t\tif (!prev_req)\n\t\t\twake_up(&sci->sc_wait_daemon);\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nilfs->ns_ndirtyblks"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_segctor_start_timer",
          "args": [
            "sci"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_segctor_start_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "2049-2058",
          "snippet": "static void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nilfs_segctor_start_timer(struct nilfs_sc_info *);",
            "static void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);",
            "static void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *sci)\n{\n\tspin_lock(&sci->sc_state_lock);\n\tif (!(sci->sc_state & NILFS_SEGCTOR_COMMIT)) {\n\t\tsci->sc_timer.expires = jiffies + sci->sc_interval;\n\t\tadd_timer(&sci->sc_timer);\n\t\tsci->sc_state |= NILFS_SEGCTOR_COMMIT;\n\t}\n\tspin_unlock(&sci->sc_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ti == NULL || ti->ti_magic != NILFS_TI_MAGIC"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_segctor_start_timer(struct nilfs_sc_info *);\nstatic void nilfs_segctor_do_flush(struct nilfs_sc_info *, int);\nstatic void nilfs_segctor_do_immediate_flush(struct nilfs_sc_info *);\n\nint nilfs_transaction_commit(struct super_block *sb)\n{\n\tstruct nilfs_transaction_info *ti = current->journal_info;\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tint err = 0;\n\n\tBUG_ON(ti == NULL || ti->ti_magic != NILFS_TI_MAGIC);\n\tti->ti_flags |= NILFS_TI_COMMIT;\n\tif (ti->ti_count > 0) {\n\t\tti->ti_count--;\n\t\treturn 0;\n\t}\n\tif (nilfs->ns_writer) {\n\t\tstruct nilfs_sc_info *sci = nilfs->ns_writer;\n\n\t\tif (ti->ti_flags & NILFS_TI_COMMIT)\n\t\t\tnilfs_segctor_start_timer(sci);\n\t\tif (atomic_read(&nilfs->ns_ndirtyblks) > sci->sc_watermark)\n\t\t\tnilfs_segctor_do_flush(sci, 0);\n\t}\n\tup_read(&nilfs->ns_segctor_sem);\n\tcurrent->journal_info = ti->ti_save;\n\n\tif (ti->ti_flags & NILFS_TI_SYNC)\n\t\terr = nilfs_construct_segment(sb);\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_transaction_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "180-210",
    "snippet": "int nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sb"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nilfs_transaction_cachep",
            "ti"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_near_disk_full",
          "args": [
            "nilfs"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_near_disk_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.c",
          "lines": "708-717",
          "snippet": "int nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"alloc.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"alloc.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint nilfs_near_disk_full(struct the_nilfs *nilfs)\n{\n\tunsigned long ncleansegs, nincsegs;\n\n\tncleansegs = nilfs_sufile_get_ncleansegs(nilfs->ns_sufile);\n\tnincsegs = atomic_read(&nilfs->ns_ndirtyblks) /\n\t\tnilfs->ns_blocks_per_segment + 1;\n\n\treturn ncleansegs <= nilfs->ns_nrsvsegs + nincsegs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nilfs->ns_segctor_sem"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "sb"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_prepare_segment_lock",
          "args": [
            "ti"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_prepare_segment_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
          "lines": "118-151",
          "snippet": "static int nilfs_prepare_segment_lock(struct nilfs_transaction_info *ti)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tvoid *save = NULL;\n\n\tif (cur_ti) {\n\t\tif (cur_ti->ti_magic == NILFS_TI_MAGIC)\n\t\t\treturn ++cur_ti->ti_count;\n\t\telse {\n\t\t\t/*\n\t\t\t * If journal_info field is occupied by other FS,\n\t\t\t * it is saved and will be restored on\n\t\t\t * nilfs_transaction_commit().\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: journal info from a different \"\n\t\t\t       \"FS\\n\");\n\t\t\tsave = current->journal_info;\n\t\t}\n\t}\n\tif (!ti) {\n\t\tti = kmem_cache_alloc(nilfs_transaction_cachep, GFP_NOFS);\n\t\tif (!ti)\n\t\t\treturn -ENOMEM;\n\t\tti->ti_flags = NILFS_TI_DYNAMIC_ALLOC;\n\t} else {\n\t\tti->ti_flags = 0;\n\t}\n\tti->ti_count = 0;\n\tti->ti_save = save;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\treturn 0;\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic int nilfs_prepare_segment_lock(struct nilfs_transaction_info *ti)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tvoid *save = NULL;\n\n\tif (cur_ti) {\n\t\tif (cur_ti->ti_magic == NILFS_TI_MAGIC)\n\t\t\treturn ++cur_ti->ti_count;\n\t\telse {\n\t\t\t/*\n\t\t\t * If journal_info field is occupied by other FS,\n\t\t\t * it is saved and will be restored on\n\t\t\t * nilfs_transaction_commit().\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: journal info from a different \"\n\t\t\t       \"FS\\n\");\n\t\t\tsave = current->journal_info;\n\t\t}\n\t}\n\tif (!ti) {\n\t\tti = kmem_cache_alloc(nilfs_transaction_cachep, GFP_NOFS);\n\t\tif (!ti)\n\t\t\treturn -ENOMEM;\n\t\tti->ti_flags = NILFS_TI_DYNAMIC_ALLOC;\n\t} else {\n\t\tti->ti_flags = 0;\n\t}\n\tti->ti_count = 0;\n\tti->ti_save = save;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nint nilfs_transaction_begin(struct super_block *sb,\n\t\t\t    struct nilfs_transaction_info *ti,\n\t\t\t    int vacancy_check)\n{\n\tstruct the_nilfs *nilfs;\n\tint ret = nilfs_prepare_segment_lock(ti);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\tif (ret > 0)\n\t\treturn 0;\n\n\tsb_start_intwrite(sb);\n\n\tnilfs = sb->s_fs_info;\n\tdown_read(&nilfs->ns_segctor_sem);\n\tif (vacancy_check && nilfs_near_disk_full(nilfs)) {\n\t\tup_read(&nilfs->ns_segctor_sem);\n\t\tret = -ENOSPC;\n\t\tgoto failed;\n\t}\n\treturn 0;\n\n failed:\n\tti = current->journal_info;\n\tcurrent->journal_info = ti->ti_save;\n\tif (ti->ti_flags & NILFS_TI_DYNAMIC_ALLOC)\n\t\tkmem_cache_free(nilfs_transaction_cachep, ti);\n\tsb_end_intwrite(sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "nilfs_prepare_segment_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/segment.c",
    "lines": "118-151",
    "snippet": "static int nilfs_prepare_segment_lock(struct nilfs_transaction_info *ti)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tvoid *save = NULL;\n\n\tif (cur_ti) {\n\t\tif (cur_ti->ti_magic == NILFS_TI_MAGIC)\n\t\t\treturn ++cur_ti->ti_count;\n\t\telse {\n\t\t\t/*\n\t\t\t * If journal_info field is occupied by other FS,\n\t\t\t * it is saved and will be restored on\n\t\t\t * nilfs_transaction_commit().\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: journal info from a different \"\n\t\t\t       \"FS\\n\");\n\t\t\tsave = current->journal_info;\n\t\t}\n\t}\n\tif (!ti) {\n\t\tti = kmem_cache_alloc(nilfs_transaction_cachep, GFP_NOFS);\n\t\tif (!ti)\n\t\t\treturn -ENOMEM;\n\t\tti->ti_flags = NILFS_TI_DYNAMIC_ALLOC;\n\t} else {\n\t\tti->ti_flags = 0;\n\t}\n\tti->ti_count = 0;\n\tti->ti_save = save;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\treturn 0;\n}",
    "includes": [
      "#include \"segbuf.h\"",
      "#include \"ifile.h\"",
      "#include \"cpfile.h\"",
      "#include \"sufile.h\"",
      "#include \"segment.h\"",
      "#include \"page.h\"",
      "#include \"btnode.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/crc32.h>",
      "#include <linux/kthread.h>",
      "#include <linux/freezer.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/completion.h>",
      "#include <linux/bio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nilfs_transaction_cachep",
            "GFP_NOFS"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t       \"NILFS warning: journal info from a different \"\n\t\t\t       \"FS\\n\""
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic int nilfs_prepare_segment_lock(struct nilfs_transaction_info *ti)\n{\n\tstruct nilfs_transaction_info *cur_ti = current->journal_info;\n\tvoid *save = NULL;\n\n\tif (cur_ti) {\n\t\tif (cur_ti->ti_magic == NILFS_TI_MAGIC)\n\t\t\treturn ++cur_ti->ti_count;\n\t\telse {\n\t\t\t/*\n\t\t\t * If journal_info field is occupied by other FS,\n\t\t\t * it is saved and will be restored on\n\t\t\t * nilfs_transaction_commit().\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NILFS warning: journal info from a different \"\n\t\t\t       \"FS\\n\");\n\t\t\tsave = current->journal_info;\n\t\t}\n\t}\n\tif (!ti) {\n\t\tti = kmem_cache_alloc(nilfs_transaction_cachep, GFP_NOFS);\n\t\tif (!ti)\n\t\t\treturn -ENOMEM;\n\t\tti->ti_flags = NILFS_TI_DYNAMIC_ALLOC;\n\t} else {\n\t\tti->ti_flags = 0;\n\t}\n\tti->ti_count = 0;\n\tti->ti_save = save;\n\tti->ti_magic = NILFS_TI_MAGIC;\n\tcurrent->journal_info = ti;\n\treturn 0;\n}"
  }
]