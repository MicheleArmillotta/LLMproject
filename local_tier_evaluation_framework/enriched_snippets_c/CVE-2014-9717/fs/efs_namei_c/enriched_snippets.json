[
  {
    "function_name": "efs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "109-119",
    "snippet": "struct dentry *efs_get_parent(struct dentry *child)\n{\n\tstruct dentry *parent = ERR_PTR(-ENOENT);\n\tefs_ino_t ino;\n\n\tino = efs_find_entry(child->d_inode, \"..\", 2);\n\tif (ino)\n\t\tparent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));\n\n\treturn parent;\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "efs_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "efs_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "efs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "47-174",
          "snippet": "struct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "efs_find_entry",
          "args": [
            "child->d_inode",
            "\"..\"",
            "2"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "efs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
          "lines": "15-62",
          "snippet": "static efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"efs.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstruct dentry *efs_get_parent(struct dentry *child)\n{\n\tstruct dentry *parent = ERR_PTR(-ENOENT);\n\tefs_ino_t ino;\n\n\tino = efs_find_entry(child->d_inode, \"..\", 2);\n\tif (ino)\n\t\tparent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));\n\n\treturn parent;\n}"
  },
  {
    "function_name": "efs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "102-107",
    "snippet": "struct dentry *efs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "efs_nfs_get_inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstruct dentry *efs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}"
  },
  {
    "function_name": "efs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "95-100",
    "snippet": "struct dentry *efs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "efs_nfs_get_inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstruct dentry *efs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    efs_nfs_get_inode);\n}"
  },
  {
    "function_name": "efs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "76-93",
    "snippet": "static struct inode *efs_nfs_get_inode(struct super_block *sb, u64 ino,\n\t\tu32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = efs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "efs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "47-174",
          "snippet": "struct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic struct inode *efs_nfs_get_inode(struct super_block *sb, u64 ino,\n\t\tu32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = efs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "efs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "64-74",
    "snippet": "struct dentry *efs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tefs_ino_t inodenum;\n\tstruct inode *inode = NULL;\n\n\tinodenum = efs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (inodenum)\n\t\tinode = efs_iget(dir->i_sb, inodenum);\n\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "efs_iget",
          "args": [
            "dir->i_sb",
            "inodenum"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "efs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "47-174",
          "snippet": "struct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "efs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "efs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
          "lines": "15-62",
          "snippet": "static efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"efs.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstruct dentry *efs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tefs_ino_t inodenum;\n\tstruct inode *inode = NULL;\n\n\tinodenum = efs_find_entry(dir, dentry->d_name.name, dentry->d_name.len);\n\tif (inodenum)\n\t\tinode = efs_iget(dir->i_sb, inodenum);\n\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "efs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/namei.c",
    "lines": "15-62",
    "snippet": "static efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"efs.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/string.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dirslot->inode"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "nameptr",
            "len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EFS_SLOTAT",
          "args": [
            "dirblock",
            "slot"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): invalid directory block\\n\"",
            "__func__"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dirblock->magic"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): failed to read dir block %d\\n\"",
            "__func__",
            "block"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "efs_bmap(inode, block)"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "efs_bmap",
          "args": [
            "inode",
            "block"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "efs_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/file.c",
          "lines": "36-56",
          "snippet": "int efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}",
          "includes": [
            "#include \"efs.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"efs.h\"\n#include <linux/buffer_head.h>\n\nint efs_bmap(struct inode *inode, efs_block_t block) {\n\n\tif (block < 0) {\n\t\tpr_warn(\"%s(): block < 0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/* are we about to read past the end of a file ? */\n\tif (!(block < inode->i_blocks)) {\n#ifdef DEBUG\n\t\t/*\n\t\t * i have no idea why this happens as often as it does\n\t\t */\n\t\tpr_warn(\"%s(): block %d >= %ld (filesize %ld)\\n\",\n\t\t\t__func__, block, inode->i_blocks, inode->i_size);\n#endif\n\t\treturn 0;\n\t}\n\n\treturn efs_map_block(inode, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\"",
            "__func__"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"efs.h\"\n#include <linux/exportfs.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic efs_ino_t efs_find_entry(struct inode *inode, const char *name, int len)\n{\n\tstruct buffer_head *bh;\n\n\tint\t\t\tslot, namelen;\n\tchar\t\t\t*nameptr;\n\tstruct efs_dir\t\t*dirblock;\n\tstruct efs_dentry\t*dirslot;\n\tefs_ino_t\t\tinodenum;\n\tefs_block_t\t\tblock;\n \n\tif (inode->i_size & (EFS_DIRBSIZE-1))\n\t\tpr_warn(\"%s(): directory size not a multiple of EFS_DIRBSIZE\\n\",\n\t\t\t__func__);\n\n\tfor(block = 0; block < inode->i_blocks; block++) {\n\n\t\tbh = sb_bread(inode->i_sb, efs_bmap(inode, block));\n\t\tif (!bh) {\n\t\t\tpr_err(\"%s(): failed to read dir block %d\\n\",\n\t\t\t       __func__, block);\n\t\t\treturn 0;\n\t\t}\n    \n\t\tdirblock = (struct efs_dir *) bh->b_data;\n\n\t\tif (be16_to_cpu(dirblock->magic) != EFS_DIRBLK_MAGIC) {\n\t\t\tpr_err(\"%s(): invalid directory block\\n\", __func__);\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (slot = 0; slot < dirblock->slots; slot++) {\n\t\t\tdirslot  = (struct efs_dentry *) (((char *) bh->b_data) + EFS_SLOTAT(dirblock, slot));\n\n\t\t\tnamelen  = dirslot->namelen;\n\t\t\tnameptr  = dirslot->name;\n\n\t\t\tif ((namelen == len) && (!memcmp(name, nameptr, len))) {\n\t\t\t\tinodenum = be32_to_cpu(dirslot->inode);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn inodenum;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
  }
]