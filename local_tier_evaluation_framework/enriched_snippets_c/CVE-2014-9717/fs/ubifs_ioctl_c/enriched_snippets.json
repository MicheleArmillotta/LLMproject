[
  {
    "function_name": "ioctl(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "191-204",
    "snippet": "mpat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ubifs_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ile, cmd, (",
          "args": [
            "nsig",
            "d l",
            "g)compat_ptr(arg));\n}\n#endif"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g));\n}\n#en",
          "args": [
            "if"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\nmpat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase FS_IOC32_GETFLAGS:\n\t\tcmd = FS_IOC_GETFLAGS;\n\t\tbreak;\n\tcase FS_IOC32_SETFLAGS:\n\t\tcmd = FS_IOC_SETFLAGS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ubifs_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n}\n#endif"
  },
  {
    "function_name": "truct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "147-188",
    "snippet": "ctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint flags, err;\n\tstruct inode *inode = file_inode(file);\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\tflags = ubifs2ioctl(ubifs_inode(inode)->flags);\n\n\t\tdbg_gen(\"get flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\t\treturn put_user(flags, (int __user *) arg);\n\n\tcase FS_IOC_SETFLAGS: {\n\t\tif (IS_RDONLY(inode))\n\t\t\treturn -EROFS;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~FS_DIRSYNC_FL;\n\n\t\t/*\n\t\t * Make sure the file-system is read-write and make sure it\n\t\t * will not become read-only while we are changing the flags.\n\t\t */\n\t\terr = mnt_want_write_file(file);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdbg_gen(\"set flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\t\terr = setflags(inode, flags);\n\t\tmnt_drop_write_file(file);\n\t\treturn err;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONF",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e_file(file);\n\t\tret",
          "args": [
            "rn e"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e, flags",
          "args": [
            ";\n\t\tm",
            "_drop"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags:",
          "args": [
            "#x, i_flags %#x\", flags, inod",
            ">i_fl",
            "s);\n\t\terr = se"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_ioctl_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ioctl.c",
          "lines": "142-192",
          "snippet": "static int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}",
          "includes": [
            "#include \"dat.h\"",
            "#include \"sufile.h\"",
            "#include \"cpfile.h\"",
            "#include \"bmap.h\"",
            "#include \"segment.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/nilfs2_fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */",
            "#include <linux/compat.h>\t/* compat_ptr() */",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */",
            "#include <linux/capability.h>\t/* capable() */",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dat.h\"\n#include \"sufile.h\"\n#include \"cpfile.h\"\n#include \"bmap.h\"\n#include \"segment.h\"\n#include \"nilfs.h\"\n#include <linux/nilfs2_fs.h>\n#include <linux/buffer_head.h>\n#include <linux/mount.h>\t/* mnt_want_write_file(), mnt_drop_write_file() */\n#include <linux/compat.h>\t/* compat_ptr() */\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\t/* copy_from_user(), copy_to_user() */\n#include <linux/capability.h>\t/* capable() */\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n\nstatic int nilfs_ioctl_setflags(struct inode *inode, struct file *filp,\n\t\t\t\tvoid __user *argp)\n{\n\tstruct nilfs_transaction_info ti;\n\tunsigned int flags, oldflags;\n\tint ret;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (get_user(flags, (int __user *)argp))\n\t\treturn -EFAULT;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = nilfs_mask_flags(inode->i_mode, flags);\n\n\tmutex_lock(&inode->i_mutex);\n\n\toldflags = NILFS_I(inode)->i_flags;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by the\n\t * relevant capability.\n\t */\n\tret = -EPERM;\n\tif (((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) &&\n\t    !capable(CAP_LINUX_IMMUTABLE))\n\t\tgoto out;\n\n\tret = nilfs_transaction_begin(inode->i_sb, &ti, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tNILFS_I(inode)->i_flags = (oldflags & ~FS_FL_USER_MODIFIABLE) |\n\t\t(flags & FS_FL_USER_MODIFIABLE);\n\n\tnilfs_set_inode_flags(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tif (IS_SYNC(inode))\n\t\tnilfs_set_transaction_flag(NILFS_TI_SYNC);\n\n\tnilfs_mark_inode_dirty(inode);\n\tret = nilfs_transaction_commit(inode->i_sb);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e_file(file);\n\t\tif",
          "args": [
            "err)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "))\n\t\t\tflags &"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s, (int",
          "args": [
            "_user",
            ") arg))\n\t\t\treturn"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_capable(inode))\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de))\n\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s, (int",
          "args": [
            "_user",
            ") arg);\n\n\tcase FS_"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_inode(",
          "args": [
            "node)->flags);\n\n\t\tdbg_gen"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->flag",
          "args": [
            ");"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le);\n\n\tswi",
          "args": [
            "ch ("
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\nctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint flags, err;\n\tstruct inode *inode = file_inode(file);\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\tflags = ubifs2ioctl(ubifs_inode(inode)->flags);\n\n\t\tdbg_gen(\"get flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\t\treturn put_user(flags, (int __user *) arg);\n\n\tcase FS_IOC_SETFLAGS: {\n\t\tif (IS_RDONLY(inode))\n\t\t\treturn -EROFS;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\tflags &= ~FS_DIRSYNC_FL;\n\n\t\t/*\n\t\t * Make sure the file-system is read-write and make sure it\n\t\t * will not become read-only while we are changing the flags.\n\t\t */\n\t\terr = mnt_want_write_file(file);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdbg_gen(\"set flags: %#x, i_flags %#x\", flags, inode->i_flags);\n\t\terr = setflags(inode, flags);\n\t\tmnt_drop_write_file(file);\n\t\treturn err;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n#ifdef CONF"
  },
  {
    "function_name": "ct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "102-145",
    "snippet": "tflags(struct inode *inode, int flags)\n{\n\tint oldflags, err, release;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t\t.dirtied_ino_d = ui->data_len };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tmutex_lock(&ui->ui_mutex);\n\toldflags = ubifs2ioctl(ui->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tui->flags = ioctl2ubifs(flags);\n\tubifs_set_inode_flags(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\trelease = ui->dirty;\n\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = write_inode_now(inode, 1);\n\treturn err;\n\nout_unlock:\n\tubifs_err(\"can't modify inode %lu attributes\", inode->i_ino);\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nlong ubifs_",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\tr",
          "args": [
            "t",
            "n er"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\tubifs_rel"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n't modif",
          "args": [
            "inode %lu attributes\", inode->i_in",
            ";\n\tmutex_unl"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ow(inode, 1);",
          "args": [
            "eturn",
            "r"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\ter",
          "args": [
            "= wr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "S_SY"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\n\tif (rele"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_sync(inode);\n\tmut",
          "args": [
            "x_unl"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\trel",
          "args": [
            "ase ="
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_flags(inode);\n\tino",
          "args": [
            "e->i_"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lags);\n\tubi",
          "args": [
            "s_set"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INUX_IM",
          "args": [
            "UTABLE)) {\n\t\t\terr ="
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->flags);",
          "args": [
            "if ((flag"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\toldflags"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\ntflags(struct inode *inode, int flags)\n{\n\tint oldflags, err, release;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t\t.dirtied_ino_d = ui->data_len };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tmutex_lock(&ui->ui_mutex);\n\toldflags = ubifs2ioctl(ui->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tui->flags = ioctl2ubifs(flags);\n\tubifs_set_inode_flags(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\trelease = ui->dirty;\n\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = write_inode_now(inode, 1);\n\treturn err;\n\nout_unlock:\n\tubifs_err(\"can't modify inode %lu attributes\", inode->i_ino);\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nlong ubifs_"
  },
  {
    "function_name": "nt ubifs_fl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "84-100",
    "snippet": "ifs2ioctl(int ubifs_flags)\n{\n\tint ioctl_flags = 0;\n\n\tif (ubifs_flags & UBIFS_COMPR_FL)\n\t\tioctl_flags |= FS_COMPR_FL;\n\tif (ubifs_flags & UBIFS_SYNC_FL)\n\t\tioctl_flags |= FS_SYNC_FL;\n\tif (ubifs_flags & UBIFS_APPEND_FL)\n\t\tioctl_flags |= FS_APPEND_FL;\n\tif (ubifs_flags & UBIFS_IMMUTABLE_FL)\n\t\tioctl_flags |= FS_IMMUTABLE_FL;\n\tif (ubifs_flags & UBIFS_DIRSYNC_FL)\n\t\tioctl_flags |= FS_DIRSYNC_FL;\n\n\treturn ioctl_flags;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\nifs2ioctl(int ubifs_flags)\n{\n\tint ioctl_flags = 0;\n\n\tif (ubifs_flags & UBIFS_COMPR_FL)\n\t\tioctl_flags |= FS_COMPR_FL;\n\tif (ubifs_flags & UBIFS_SYNC_FL)\n\t\tioctl_flags |= FS_SYNC_FL;\n\tif (ubifs_flags & UBIFS_APPEND_FL)\n\t\tioctl_flags |= FS_APPEND_FL;\n\tif (ubifs_flags & UBIFS_IMMUTABLE_FL)\n\t\tioctl_flags |= FS_IMMUTABLE_FL;\n\tif (ubifs_flags & UBIFS_DIRSYNC_FL)\n\t\tioctl_flags |= FS_DIRSYNC_FL;\n\n\treturn ioctl_flags;\n}\n\nstatic int"
  },
  {
    "function_name": "nt ioctl_fl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "59-75",
    "snippet": "ctl2ubifs(int ioctl_flags)\n{\n\tint ubifs_flags = 0;\n\n\tif (ioctl_flags & FS_COMPR_FL)\n\t\tubifs_flags |= UBIFS_COMPR_FL;\n\tif (ioctl_flags & FS_SYNC_FL)\n\t\tubifs_flags |= UBIFS_SYNC_FL;\n\tif (ioctl_flags & FS_APPEND_FL)\n\t\tubifs_flags |= UBIFS_APPEND_FL;\n\tif (ioctl_flags & FS_IMMUTABLE_FL)\n\t\tubifs_flags |= UBIFS_IMMUTABLE_FL;\n\tif (ioctl_flags & FS_DIRSYNC_FL)\n\t\tubifs_flags |= UBIFS_DIRSYNC_FL;\n\n\treturn ubifs_flags;\n}\n\n/*\n * ubifs",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\nctl2ubifs(int ioctl_flags)\n{\n\tint ubifs_flags = 0;\n\n\tif (ioctl_flags & FS_COMPR_FL)\n\t\tubifs_flags |= UBIFS_COMPR_FL;\n\tif (ioctl_flags & FS_SYNC_FL)\n\t\tubifs_flags |= UBIFS_SYNC_FL;\n\tif (ioctl_flags & FS_APPEND_FL)\n\t\tubifs_flags |= UBIFS_APPEND_FL;\n\tif (ioctl_flags & FS_IMMUTABLE_FL)\n\t\tubifs_flags |= UBIFS_IMMUTABLE_FL;\n\tif (ioctl_flags & FS_DIRSYNC_FL)\n\t\tubifs_flags |= UBIFS_DIRSYNC_FL;\n\n\treturn ubifs_flags;\n}\n\n/*\n * ubifs"
  },
  {
    "function_name": "de_flags(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
    "lines": "37-50",
    "snippet": "t_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = ubifs_inode(inode)->flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_DIRSYNC);\n\tif (flags & UBIFS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & UBIFS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & UBIFS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & UBIFS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}\n\n/*\n * ioctl",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/mount.h>\n#include \"ubi",
      "ux/compat.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node)->flag",
          "args": [
            ";\n\n\ti"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\nt_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = ubifs_inode(inode)->flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_DIRSYNC);\n\tif (flags & UBIFS_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & UBIFS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & UBIFS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & UBIFS_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}\n\n/*\n * ioctl"
  }
]