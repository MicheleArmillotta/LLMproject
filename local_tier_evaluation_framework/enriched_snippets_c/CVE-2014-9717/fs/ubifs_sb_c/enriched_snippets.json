[
  {
    "function_name": "ree_space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "780-809",
    "snippet": "up_free_space(struct ubifs_info *c)\n{\n\tint err;\n\tstruct ubifs_sb_node *sup;\n\n\tubifs_assert(c->space_fixup);\n\tubifs_assert(!c->ro_mount);\n\n\tubifs_msg(\"start fixing up free space\");\n\n\terr = fixup_free_space(c);\n\tif (err)\n\t\treturn err;\n\n\tsup = ubifs_read_sb_node(c);\n\tif (IS_ERR(sup))\n\t\treturn PTR_ERR(sup);\n\n\t/* Free-space fixup is no longer required */\n\tc->space_fixup = 0;\n\tsup->flags &= cpu_to_le32(~UBIFS_FLG_SPACE_FIXUP);\n\n\terr = ubifs_write_sb_node(c, sup);\n\tkfree(sup);\n\tif (err)\n\t\treturn err;\n\n\tubifs_msg(\"free space fixup complete\");\n\treturn err;\n}",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ee space",
          "args": [
            "ixup complete\");\n\treturn er"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_node(c, sup);\n\tkf",
          "args": [
            "e",
            "sup"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_FLG_S",
          "args": [
            "ACE_FIXUP);\n\n\terr = ub"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "/* F",
          "args": [
            "ee-"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n P"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_node(c);\n\tif (IS_",
          "args": [
            "R"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ace(c);\n\tif (err",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "art fixin",
          "args": [
            "up free space\");\n\n\terr = fi"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_mount",
          "args": [
            ";\n\n\tubifs_ms"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_fix",
          "args": [
            "p);\n\tubifs_ass"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nup_free_space(struct ubifs_info *c)\n{\n\tint err;\n\tstruct ubifs_sb_node *sup;\n\n\tubifs_assert(c->space_fixup);\n\tubifs_assert(!c->ro_mount);\n\n\tubifs_msg(\"start fixing up free space\");\n\n\terr = fixup_free_space(c);\n\tif (err)\n\t\treturn err;\n\n\tsup = ubifs_read_sb_node(c);\n\tif (IS_ERR(sup))\n\t\treturn PTR_ERR(sup);\n\n\t/* Free-space fixup is no longer required */\n\tc->space_fixup = 0;\n\tsup->flags &= cpu_to_le32(~UBIFS_FLG_SPACE_FIXUP);\n\n\terr = ubifs_write_sb_node(c, sup);\n\tkfree(sup);\n\tif (err)\n\t\treturn err;\n\n\tubifs_msg(\"free space fixup complete\");\n\treturn err;\n}"
  },
  {
    "function_name": "ace(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "697-765",
    "snippet": "xup_free_space(struct ubifs_info *c)\n{\n\tint lnum, err = 0;\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_get_lprops(c);\n\n\t/* Fixup LEBs in the master area */\n\tfor (lnum = UBIFS_MST_LNUM; lnum < UBIFS_LOG_LNUM; lnum++) {\n\t\terr = fixup_leb(c, lnum, c->mst_offs + c->mst_node_alsz);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Unmap unused log LEBs */\n\tlnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\twhile (lnum != c->ltail_lnum) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t}\n\n\t/*\n\t * Fixup the log head which contains the only a CS node at the\n\t * beginning.\n\t */\n\terr = fixup_leb(c, c->lhead_lnum,\n\t\t\tALIGN(UBIFS_CS_NODE_SZ, c->min_io_size));\n\tif (err)\n\t\tgoto out;\n\n\t/* Fixup LEBs in the LPT area */\n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\tint free = c->ltab[lnum - c->lpt_first].free;\n\n\t\tif (free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Unmap LEBs in the orphans area */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Fixup LEBs in the main area */\n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lprops->free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - lprops->free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, c->",
          "args": [
            "e",
            "size",
            "lprops->free);\n\t\t\tif (err"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "oto ou"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, lnum);",
          "args": [
            "f",
            "IS_E"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, c->",
          "args": [
            "e",
            "size",
            "free);\n\t\t\tif (err"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lhead_",
          "args": [
            "n",
            ",\n\t\t\tALIGN(UB",
            "S_NODE_SZ, c->min_io_size));\n\tif (err)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_NOD",
          "args": [
            "_SZ, c->min_io_s",
            "e));\n\tif (err)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, lnum);\n\t}",
          "args": [
            "*"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, 0);",
          "args": [
            "f (e",
            ")"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, c->lhead_",
          "args": [
            "n",
            ");\n\twhile (ln"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, c->",
          "args": [
            "s",
            "offs",
            "c->mst_node_alsz);\n\t\tif (err)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\t/* Fix",
          "args": [
            "p"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nxup_free_space(struct ubifs_info *c)\n{\n\tint lnum, err = 0;\n\tstruct ubifs_lprops *lprops;\n\n\tubifs_get_lprops(c);\n\n\t/* Fixup LEBs in the master area */\n\tfor (lnum = UBIFS_MST_LNUM; lnum < UBIFS_LOG_LNUM; lnum++) {\n\t\terr = fixup_leb(c, lnum, c->mst_offs + c->mst_node_alsz);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Unmap unused log LEBs */\n\tlnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\twhile (lnum != c->ltail_lnum) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t}\n\n\t/*\n\t * Fixup the log head which contains the only a CS node at the\n\t * beginning.\n\t */\n\terr = fixup_leb(c, c->lhead_lnum,\n\t\t\tALIGN(UBIFS_CS_NODE_SZ, c->min_io_size));\n\tif (err)\n\t\tgoto out;\n\n\t/* Fixup LEBs in the LPT area */\n\tfor (lnum = c->lpt_first; lnum <= c->lpt_last; lnum++) {\n\t\tint free = c->ltab[lnum - c->lpt_first].free;\n\n\t\tif (free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Unmap LEBs in the orphans area */\n\tfor (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {\n\t\terr = fixup_leb(c, lnum, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* Fixup LEBs in the main area */\n\tfor (lnum = c->main_first; lnum < c->leb_cnt; lnum++) {\n\t\tlprops = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lprops)) {\n\t\t\terr = PTR_ERR(lprops);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (lprops->free > 0) {\n\t\t\terr = fixup_leb(c, lnum, c->leb_size - lprops->free);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "uct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "669-688",
    "snippet": "xup_leb(struct ubifs_info *c, int lnum, int len)\n{\n\tint err;\n\n\tubifs_assert(len >= 0);\n\tubifs_assert(len % c->min_io_size == 0);\n\tubifs_assert(len < c->leb_size);\n\n\tif (len == 0) {\n\t\tdbg_mnt(\"unmap empty LEB %d\", lnum);\n\t\treturn ubifs_leb_unmap(c, lnum);\n\t}\n\n\tdbg_mnt(\"fixup LEB %d, data len %d\", lnum, len);\n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, len, 1);\n\tif (err)\n\t\treturn err;\n\n\treturn ubifs_leb_change(c, lnum, c->sbuf, len);\n}\n\n/**\n * fixu",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nge(c, lnum, c->",
          "args": [
            "b",
            ", le",
            ";\n}\n\n/*",
            "*"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, c->",
          "args": [
            "b",
            ", 0,",
            "en, 1);",
            "i",
            "(er"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p LEB %",
          "args": [
            ", data len %d\", lnum, len);",
            "err",
            "ubi"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);\n\t}",
          "args": [
            "bg_m"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p empty",
          "args": [
            "LEB %d\", lnum);\n\t\tre",
            "rn u"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len < c->leb",
          "args": [
            "size);\n\n\tif (len"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len % c->min",
          "args": [
            "io_size == 0);\n\tubifs_ass"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len >= 0);",
          "args": [
            "bifs_ass"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nxup_leb(struct ubifs_info *c, int lnum, int len)\n{\n\tint err;\n\n\tubifs_assert(len >= 0);\n\tubifs_assert(len % c->min_io_size == 0);\n\tubifs_assert(len < c->leb_size);\n\n\tif (len == 0) {\n\t\tdbg_mnt(\"unmap empty LEB %d\", lnum);\n\t\treturn ubifs_leb_unmap(c, lnum);\n\t}\n\n\tdbg_mnt(\"fixup LEB %d, data len %d\", lnum, len);\n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, len, 1);\n\tif (err)\n\t\treturn err;\n\n\treturn ubifs_leb_change(c, lnum, c->sbuf, len);\n}\n\n/**\n * fixu"
  },
  {
    "function_name": "perblock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "526-656",
    "snippet": "d_superblock(struct ubifs_info *c)\n{\n\tint err, sup_flags;\n\tstruct ubifs_sb_node *sup;\n\n\tif (c->empty) {\n\t\terr = create_default_filesystem(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsup = ubifs_read_sb_node(c);\n\tif (IS_ERR(sup))\n\t\treturn PTR_ERR(sup);\n\n\tc->fmt_version = le32_to_cpu(sup->fmt_version);\n\tc->ro_compat_version = le32_to_cpu(sup->ro_compat_version);\n\n\t/*\n\t * The software supports all previous versions but not future versions,\n\t * due to the unavailability of time-travelling equipment.\n\t */\n\tif (c->fmt_version > UBIFS_FORMAT_VERSION) {\n\t\tubifs_assert(!c->ro_media || c->ro_mount);\n\t\tif (!c->ro_mount ||\n\t\t    c->ro_compat_version > UBIFS_RO_COMPAT_VERSION) {\n\t\t\tubifs_err(\"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t\t  UBIFS_FORMAT_VERSION,\n\t\t\t\t  UBIFS_RO_COMPAT_VERSION);\n\t\t\tif (c->ro_compat_version <= UBIFS_RO_COMPAT_VERSION) {\n\t\t\t\tubifs_msg(\"only R/O mounting is possible\");\n\t\t\t\terr = -EROFS;\n\t\t\t} else\n\t\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The FS is mounted R/O, and the media format is\n\t\t * R/O-compatible with the UBIFS implementation, so we can\n\t\t * mount.\n\t\t */\n\t\tc->rw_incompat = 1;\n\t}\n\n\tif (c->fmt_version < 3) {\n\t\tubifs_err(\"on-flash format version %d is not supported\",\n\t\t\t  c->fmt_version);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (sup->key_hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\tc->key_hash = key_r5_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_R5;\n\t\tbreak;\n\n\tcase UBIFS_KEY_HASH_TEST:\n\t\tc->key_hash = key_test_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_TEST;\n\t\tbreak;\n\t};\n\n\tc->key_fmt = sup->key_fmt;\n\n\tswitch (c->key_fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\tc->key_len = UBIFS_SK_LEN;\n\t\tbreak;\n\tdefault:\n\t\tubifs_err(\"unsupported key format\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tc->leb_cnt       = le32_to_cpu(sup->leb_cnt);\n\tc->max_leb_cnt   = le32_to_cpu(sup->max_leb_cnt);\n\tc->max_bud_bytes = le64_to_cpu(sup->max_bud_bytes);\n\tc->log_lebs      = le32_to_cpu(sup->log_lebs);\n\tc->lpt_lebs      = le32_to_cpu(sup->lpt_lebs);\n\tc->orph_lebs     = le32_to_cpu(sup->orph_lebs);\n\tc->jhead_cnt     = le32_to_cpu(sup->jhead_cnt) + NONDATA_JHEADS_CNT;\n\tc->fanout        = le32_to_cpu(sup->fanout);\n\tc->lsave_cnt     = le32_to_cpu(sup->lsave_cnt);\n\tc->rp_size       = le64_to_cpu(sup->rp_size);\n\tc->rp_uid        = make_kuid(&init_user_ns, le32_to_cpu(sup->rp_uid));\n\tc->rp_gid        = make_kgid(&init_user_ns, le32_to_cpu(sup->rp_gid));\n\tsup_flags        = le32_to_cpu(sup->flags);\n\tif (!c->mount_opts.override_compr)\n\t\tc->default_compr = le16_to_cpu(sup->default_compr);\n\n\tc->vfs_sb->s_time_gran = le32_to_cpu(sup->time_gran);\n\tmemcpy(&c->uuid, &sup->uuid, 16);\n\tc->big_lpt = !!(sup_flags & UBIFS_FLG_BIGLPT);\n\tc->space_fixup = !!(sup_flags & UBIFS_FLG_SPACE_FIXUP);\n\n\t/* Automatically increase file system size to the maximum size */\n\tc->old_leb_cnt = c->leb_cnt;\n\tif (c->leb_cnt < c->vi.size && c->leb_cnt < c->max_leb_cnt) {\n\t\tc->leb_cnt = min_t(int, c->max_leb_cnt, c->vi.size);\n\t\tif (c->ro_mount)\n\t\t\tdbg_mnt(\"Auto resizing (ro) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_leb_cnt,\tc->leb_cnt);\n\t\telse {\n\t\t\tdbg_mnt(\"Auto resizing (sb) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_leb_cnt, c->leb_cnt);\n\t\t\tsup->leb_cnt = cpu_to_le32(c->leb_cnt);\n\t\t\terr = ubifs_write_sb_node(c, sup);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc->old_leb_cnt = c->leb_cnt;\n\t\t}\n\t}\n\n\tc->log_bytes = (long long)c->log_lebs * c->leb_size;\n\tc->log_last = UBIFS_LOG_LNUM + c->log_lebs - 1;\n\tc->lpt_first = UBIFS_LOG_LNUM + c->log_lebs;\n\tc->lpt_last = c->lpt_first + c->lpt_lebs - 1;\n\tc->orph_first = c->lpt_last + 1;\n\tc->orph_last = c->orph_first + c->orph_lebs - 1;\n\tc->main_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS;\n\tc->main_lebs -= c->log_lebs + c->lpt_lebs + c->orph_lebs;\n\tc->main_first = c->leb_cnt - c->main_lebs;\n\n\terr = validate_sb(c, sup);\nout:\n\tkfree(sup);\n\treturn err;\n}\n\n/**\n * fixu",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": ", sup);\nout",
          "args": [
            "fre"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_node(c, sup);",
          "args": [
            "f",
            "err"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->leb_cnt);",
          "args": [
            "err = u"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resizi",
          "args": [
            "g (sb) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_",
            "t, c->leb_cnt)",
            "sup->le"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resizi",
          "args": [
            "g (ro) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_",
            "t,\tc->leb_cnt)",
            "else {"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">max_",
          "args": [
            "eb_",
            "t, c->vi.size)",
            "if (c->r"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id, &s",
          "args": [
            "p->uuid,",
            "6);\n\tc->bi",
            "lp"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->time_gr",
          "args": [
            "n);\n\tmemcpy(&c"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->default",
          "args": [
            "compr);\n\n\tc->vfs_s"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->flags);",
          "args": [
            "if (!c->m"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_user_n",
          "args": [
            ", le32_to_cpu",
            "up->rp_gid));\n\tsup_flags"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->rp_gid)",
          "args": [
            ";\n\tsup_flag"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_user_n",
          "args": [
            ", le32_to_cpu",
            "up->rp_uid));\n\tc->rp_gid"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->rp_uid)",
          "args": [
            ";\n\tc->rp_gi"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->rp_size",
          "args": [
            ";\n\tc->rp_uid"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->lsave_c",
          "args": [
            "t);\n\tc->rp_siz"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->fanout)",
          "args": [
            "c->lsave_"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->jhead_c",
          "args": [
            "t) + NONDATA_J"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->orph_le",
          "args": [
            "s);\n\tc->jhead_"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->lpt_leb",
          "args": [
            ");\n\tc->orph_l"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->log_leb",
          "args": [
            ");\n\tc->lpt_le"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->max_bud",
          "args": [
            "bytes);\n\tc->log_le"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->max_leb",
          "args": [
            "cnt);\n\tc->max_bu"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->leb_cnt",
          "args": [
            ";\n\tc->max_le"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "supported",
          "args": [
            "key format\");\n\t\terr = -E"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_is_collation_rule_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.h",
          "lines": "29-44",
          "snippet": "static inline bool ntfs_is_collation_rule_supported(COLLATION_RULE cr) {\n\tint i;\n\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we return false for everything else for\n\t * now.\n\t */\n\tif (unlikely(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG))\n\t\treturn false;\n\ti = le32_to_cpu(cr);\n\tif (likely(((i >= 0) && (i <= 0x02)) ||\n\t\t\t((i >= 0x10) && (i <= 0x13))))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"types.h\"\n\nstatic inline bool ntfs_is_collation_rule_supported(COLLATION_RULE cr) {\n\tint i;\n\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we return false for everything else for\n\t * now.\n\t */\n\tif (unlikely(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG))\n\t\treturn false;\n\ti = le32_to_cpu(cr);\n\tif (likely(((i >= 0) && (i <= 0x02)) ||\n\t\t\t((i >= 0x10) && (i <= 0x13))))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "-flash fo",
          "args": [
            "mat version %d is not supported\",\n\t\t\t  c->fmt",
            "n);\n\t\terr = -E"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ly R/O mo",
          "args": [
            "nting is possible\");\n\t\t\t\terr ="
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "-flash fo",
          "args": [
            "mat version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t\t  c->fm",
            "n, c->ro_compa",
            "version,\n\t\t\t\t  UBIFS",
            "VERSION,\n\t\t\t\t  UBIFS",
            "AT_VERSION);\n\t\t\tif (c->"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "|| c->ro_mount);\n\t\tif (!c->"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->ro_comp",
          "args": [
            "t_version);\n\n\t/*\n\t * T"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->fmt_ver",
          "args": [
            "ion);\n\tc->ro_com"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->f",
          "args": [
            "t_v"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c);\n\tif (IS_",
          "args": [
            "R"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_filesystem(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nd_superblock(struct ubifs_info *c)\n{\n\tint err, sup_flags;\n\tstruct ubifs_sb_node *sup;\n\n\tif (c->empty) {\n\t\terr = create_default_filesystem(c);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsup = ubifs_read_sb_node(c);\n\tif (IS_ERR(sup))\n\t\treturn PTR_ERR(sup);\n\n\tc->fmt_version = le32_to_cpu(sup->fmt_version);\n\tc->ro_compat_version = le32_to_cpu(sup->ro_compat_version);\n\n\t/*\n\t * The software supports all previous versions but not future versions,\n\t * due to the unavailability of time-travelling equipment.\n\t */\n\tif (c->fmt_version > UBIFS_FORMAT_VERSION) {\n\t\tubifs_assert(!c->ro_media || c->ro_mount);\n\t\tif (!c->ro_mount ||\n\t\t    c->ro_compat_version > UBIFS_RO_COMPAT_VERSION) {\n\t\t\tubifs_err(\"on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d\",\n\t\t\t\t  c->fmt_version, c->ro_compat_version,\n\t\t\t\t  UBIFS_FORMAT_VERSION,\n\t\t\t\t  UBIFS_RO_COMPAT_VERSION);\n\t\t\tif (c->ro_compat_version <= UBIFS_RO_COMPAT_VERSION) {\n\t\t\t\tubifs_msg(\"only R/O mounting is possible\");\n\t\t\t\terr = -EROFS;\n\t\t\t} else\n\t\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The FS is mounted R/O, and the media format is\n\t\t * R/O-compatible with the UBIFS implementation, so we can\n\t\t * mount.\n\t\t */\n\t\tc->rw_incompat = 1;\n\t}\n\n\tif (c->fmt_version < 3) {\n\t\tubifs_err(\"on-flash format version %d is not supported\",\n\t\t\t  c->fmt_version);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (sup->key_hash) {\n\tcase UBIFS_KEY_HASH_R5:\n\t\tc->key_hash = key_r5_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_R5;\n\t\tbreak;\n\n\tcase UBIFS_KEY_HASH_TEST:\n\t\tc->key_hash = key_test_hash;\n\t\tc->key_hash_type = UBIFS_KEY_HASH_TEST;\n\t\tbreak;\n\t};\n\n\tc->key_fmt = sup->key_fmt;\n\n\tswitch (c->key_fmt) {\n\tcase UBIFS_SIMPLE_KEY_FMT:\n\t\tc->key_len = UBIFS_SK_LEN;\n\t\tbreak;\n\tdefault:\n\t\tubifs_err(\"unsupported key format\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tc->leb_cnt       = le32_to_cpu(sup->leb_cnt);\n\tc->max_leb_cnt   = le32_to_cpu(sup->max_leb_cnt);\n\tc->max_bud_bytes = le64_to_cpu(sup->max_bud_bytes);\n\tc->log_lebs      = le32_to_cpu(sup->log_lebs);\n\tc->lpt_lebs      = le32_to_cpu(sup->lpt_lebs);\n\tc->orph_lebs     = le32_to_cpu(sup->orph_lebs);\n\tc->jhead_cnt     = le32_to_cpu(sup->jhead_cnt) + NONDATA_JHEADS_CNT;\n\tc->fanout        = le32_to_cpu(sup->fanout);\n\tc->lsave_cnt     = le32_to_cpu(sup->lsave_cnt);\n\tc->rp_size       = le64_to_cpu(sup->rp_size);\n\tc->rp_uid        = make_kuid(&init_user_ns, le32_to_cpu(sup->rp_uid));\n\tc->rp_gid        = make_kgid(&init_user_ns, le32_to_cpu(sup->rp_gid));\n\tsup_flags        = le32_to_cpu(sup->flags);\n\tif (!c->mount_opts.override_compr)\n\t\tc->default_compr = le16_to_cpu(sup->default_compr);\n\n\tc->vfs_sb->s_time_gran = le32_to_cpu(sup->time_gran);\n\tmemcpy(&c->uuid, &sup->uuid, 16);\n\tc->big_lpt = !!(sup_flags & UBIFS_FLG_BIGLPT);\n\tc->space_fixup = !!(sup_flags & UBIFS_FLG_SPACE_FIXUP);\n\n\t/* Automatically increase file system size to the maximum size */\n\tc->old_leb_cnt = c->leb_cnt;\n\tif (c->leb_cnt < c->vi.size && c->leb_cnt < c->max_leb_cnt) {\n\t\tc->leb_cnt = min_t(int, c->max_leb_cnt, c->vi.size);\n\t\tif (c->ro_mount)\n\t\t\tdbg_mnt(\"Auto resizing (ro) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_leb_cnt,\tc->leb_cnt);\n\t\telse {\n\t\t\tdbg_mnt(\"Auto resizing (sb) from %d LEBs to %d LEBs\",\n\t\t\t\tc->old_leb_cnt, c->leb_cnt);\n\t\t\tsup->leb_cnt = cpu_to_le32(c->leb_cnt);\n\t\t\terr = ubifs_write_sb_node(c, sup);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc->old_leb_cnt = c->leb_cnt;\n\t\t}\n\t}\n\n\tc->log_bytes = (long long)c->log_lebs * c->leb_size;\n\tc->log_last = UBIFS_LOG_LNUM + c->log_lebs - 1;\n\tc->lpt_first = UBIFS_LOG_LNUM + c->log_lebs;\n\tc->lpt_last = c->lpt_first + c->lpt_lebs - 1;\n\tc->orph_first = c->lpt_last + 1;\n\tc->orph_last = c->orph_first + c->orph_lebs - 1;\n\tc->main_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS;\n\tc->main_lebs -= c->log_lebs + c->lpt_lebs + c->orph_lebs;\n\tc->main_first = c->leb_cnt - c->main_lebs;\n\n\terr = validate_sb(c, sup);\nout:\n\tkfree(sup);\n\treturn err;\n}\n\n/**\n * fixu"
  },
  {
    "function_name": "b_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "510-516",
    "snippet": "te_sb_node(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tint len = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\n\tubifs_prepare_node(c, sup, UBIFS_SB_NODE_SZ, 1);\n\treturn ubifs_leb_change(c, UBIFS_SB_LNUM, sup, len);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nge(c, UBIFS_SB_",
          "args": [
            "N",
            ", sup, len);",
            "/*",
            "*"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, sup, UBIF",
          "args": [
            "_",
            "_NO",
            "_SZ, 1);\n\treturn",
            "b"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NOD",
          "args": [
            "_SZ, c->min_io_s",
            "e);\n\n\tubifs_pr"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nte_sb_node(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tint len = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\n\tubifs_prepare_node(c, sup, UBIFS_SB_NODE_SZ, 1);\n\treturn ubifs_leb_change(c, UBIFS_SB_LNUM, sup, len);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "484-501",
    "snippet": "sb_node *ubifs_read_sb_node(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tint err;\n\n\tsup = kmalloc(ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size), GFP_NOFS);\n\tif (!sup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_read_node(c, sup, UBIFS_SB_NODE, UBIFS_SB_NODE_SZ,\n\t\t\t      UBIFS_SB_LNUM, 0);\n\tif (err) {\n\t\tkfree(sup);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn sup;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n\tr",
          "args": [
            "tur"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n E"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de(c, sup, UBIF",
          "args": [
            "_",
            "_NO",
            ", UBIFS_SB_NO",
            "_SZ,\n\t\t\t      UB",
            ", 0);\n\tif (er"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "rr = ub"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(UBIFS_",
          "args": [
            "B_NODE_SZ, c->min_io_size), GFP_NOFS);",
            "f (!sup)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NOD",
          "args": [
            "_SZ, c->min_io_s",
            "e), GFP_NOFS);"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nsb_node *ubifs_read_sb_node(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tint err;\n\n\tsup = kmalloc(ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size), GFP_NOFS);\n\tif (!sup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ubifs_read_node(c, sup, UBIFS_SB_NODE, UBIFS_SB_NODE_SZ,\n\t\t\t      UBIFS_SB_LNUM, 0);\n\tif (err) {\n\t\tkfree(sup);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn sup;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "352-474",
    "snippet": "lidate_sb(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tlong long max_bytes;\n\tint err = 1, min_leb_cnt;\n\n\tif (!c->key_hash) {\n\t\terr = 2;\n\t\tgoto failed;\n\t}\n\n\tif (sup->key_fmt != UBIFS_SIMPLE_KEY_FMT) {\n\t\terr = 3;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->min_io_size) != c->min_io_size) {\n\t\tubifs_err(\"min. I/O unit mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->min_io_size), c->min_io_size);\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->leb_size) != c->leb_size) {\n\t\tubifs_err(\"LEB size mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->leb_size), c->leb_size);\n\t\tgoto failed;\n\t}\n\n\tif (c->log_lebs < UBIFS_MIN_LOG_LEBS ||\n\t    c->lpt_lebs < UBIFS_MIN_LPT_LEBS ||\n\t    c->orph_lebs < UBIFS_MIN_ORPH_LEBS ||\n\t    c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\terr = 4;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Calculate minimum allowed amount of main area LEBs. This is very\n\t * similar to %UBIFS_MIN_LEB_CNT, but we take into account real what we\n\t * have just read from the superblock.\n\t */\n\tmin_leb_cnt = UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs;\n\tmin_leb_cnt += c->lpt_lebs + c->orph_lebs + c->jhead_cnt + 6;\n\n\tif (c->leb_cnt < min_leb_cnt || c->leb_cnt > c->vi.size) {\n\t\tubifs_err(\"bad LEB count: %d in superblock, %d on UBI volume, %d minimum required\",\n\t\t\t  c->leb_cnt, c->vi.size, min_leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->max_leb_cnt < c->leb_cnt) {\n\t\tubifs_err(\"max. LEB count %d less than LEB count %d\",\n\t\t\t  c->max_leb_cnt, c->leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\tubifs_err(\"too few main LEBs count %d, must be at least %d\",\n\t\t\t  c->main_lebs, UBIFS_MIN_MAIN_LEBS);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * UBIFS_MIN_BUD_LEBS;\n\tif (c->max_bud_bytes < max_bytes) {\n\t\tubifs_err(\"too small journal (%lld bytes), must be at least %lld bytes\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * c->main_lebs;\n\tif (c->max_bud_bytes > max_bytes) {\n\t\tubifs_err(\"too large journal size (%lld bytes), only %lld bytes available in the main area\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tif (c->jhead_cnt < NONDATA_JHEADS_CNT + 1 ||\n\t    c->jhead_cnt > NONDATA_JHEADS_CNT + UBIFS_MAX_JHEADS) {\n\t\terr = 9;\n\t\tgoto failed;\n\t}\n\n\tif (c->fanout < UBIFS_MIN_FANOUT ||\n\t    ubifs_idx_node_sz(c, c->fanout) > c->leb_size) {\n\t\terr = 10;\n\t\tgoto failed;\n\t}\n\n\tif (c->lsave_cnt < 0 || (c->lsave_cnt > DEFAULT_LSAVE_CNT &&\n\t    c->lsave_cnt > c->max_leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS -\n\t    c->log_lebs - c->lpt_lebs - c->orph_lebs)) {\n\t\terr = 11;\n\t\tgoto failed;\n\t}\n\n\tif (UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs + c->lpt_lebs +\n\t    c->orph_lebs + c->main_lebs != c->leb_cnt) {\n\t\terr = 12;\n\t\tgoto failed;\n\t}\n\n\tif (c->default_compr >= UBIFS_COMPR_TYPES_CNT) {\n\t\terr = 13;\n\t\tgoto failed;\n\t}\n\n\tif (c->rp_size < 0 || max_bytes < c->rp_size) {\n\t\terr = 14;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->time_gran) > 1000000000 ||\n\t    le32_to_cpu(sup->time_gran) < 1) {\n\t\terr = 15;\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tubifs_err(\"bad superblock, error %d\", err);\n\tubifs_dump_node(c, sup);\n\treturn -EINVAL;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, sup);\n\tre",
          "args": [
            "u",
            "-E"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d superbl",
          "args": [
            "ck, error %d\", err);\n\tubif",
            "dum"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->time_gr",
          "args": [
            "n) < 1) {\n\t\ter"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->time_gr",
          "args": [
            "n) > 100000000"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->fanout",
          "args": [
            "c->leb_si"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o large j",
          "args": [
            "urnal size (%lld bytes), only %lld bytes available in the main area\",\n\t\t\t  c->max",
            "tes, max_bytes);",
            "goto fai"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o small j",
          "args": [
            "urnal (%lld bytes), must be at least %lld bytes\",\n\t\t\t  c->max",
            "tes, max_bytes);",
            "goto fai"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o few mai",
          "args": [
            "LEBs count %d, must be at least %d\",\n\t\t\t  c->mai",
            "UBIFS_MIN_M",
            "N_LEBS);\n\t\tgoto fai"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x. LEB co",
          "args": [
            "nt %d less than LEB count %d\",\n\t\t\t  c->max",
            "t, c->leb_cnt)",
            "goto fai"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d LEB cou",
          "args": [
            "t: %d in superblock, %d on UBI volume, %d minimum required\",\n\t\t\t  c->leb",
            "->vi.size,",
            "in_leb_cnt",
            "goto fai"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B size mi",
          "args": [
            "match: %d in superblock, %d real\",\n\t\t\t  le32_t",
            "up->leb_size), c->leb_size",
            "goto fai"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->leb_siz",
          "args": [
            "), c->leb_siz"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->leb_siz",
          "args": [
            ") != c->leb_s"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n. I/O un",
          "args": [
            "t mismatch: %d in superblock, %d real\",\n\t\t\t  le32_t",
            "up->min_io_size), c->min_io_s",
            "e);\n\t\tgoto fai"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->min_io_",
          "args": [
            "ize), c->min_io_"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up->min_io_",
          "args": [
            "ize) != c->min_i"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlidate_sb(struct ubifs_info *c, struct ubifs_sb_node *sup)\n{\n\tlong long max_bytes;\n\tint err = 1, min_leb_cnt;\n\n\tif (!c->key_hash) {\n\t\terr = 2;\n\t\tgoto failed;\n\t}\n\n\tif (sup->key_fmt != UBIFS_SIMPLE_KEY_FMT) {\n\t\terr = 3;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->min_io_size) != c->min_io_size) {\n\t\tubifs_err(\"min. I/O unit mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->min_io_size), c->min_io_size);\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->leb_size) != c->leb_size) {\n\t\tubifs_err(\"LEB size mismatch: %d in superblock, %d real\",\n\t\t\t  le32_to_cpu(sup->leb_size), c->leb_size);\n\t\tgoto failed;\n\t}\n\n\tif (c->log_lebs < UBIFS_MIN_LOG_LEBS ||\n\t    c->lpt_lebs < UBIFS_MIN_LPT_LEBS ||\n\t    c->orph_lebs < UBIFS_MIN_ORPH_LEBS ||\n\t    c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\terr = 4;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Calculate minimum allowed amount of main area LEBs. This is very\n\t * similar to %UBIFS_MIN_LEB_CNT, but we take into account real what we\n\t * have just read from the superblock.\n\t */\n\tmin_leb_cnt = UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs;\n\tmin_leb_cnt += c->lpt_lebs + c->orph_lebs + c->jhead_cnt + 6;\n\n\tif (c->leb_cnt < min_leb_cnt || c->leb_cnt > c->vi.size) {\n\t\tubifs_err(\"bad LEB count: %d in superblock, %d on UBI volume, %d minimum required\",\n\t\t\t  c->leb_cnt, c->vi.size, min_leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->max_leb_cnt < c->leb_cnt) {\n\t\tubifs_err(\"max. LEB count %d less than LEB count %d\",\n\t\t\t  c->max_leb_cnt, c->leb_cnt);\n\t\tgoto failed;\n\t}\n\n\tif (c->main_lebs < UBIFS_MIN_MAIN_LEBS) {\n\t\tubifs_err(\"too few main LEBs count %d, must be at least %d\",\n\t\t\t  c->main_lebs, UBIFS_MIN_MAIN_LEBS);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * UBIFS_MIN_BUD_LEBS;\n\tif (c->max_bud_bytes < max_bytes) {\n\t\tubifs_err(\"too small journal (%lld bytes), must be at least %lld bytes\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tmax_bytes = (long long)c->leb_size * c->main_lebs;\n\tif (c->max_bud_bytes > max_bytes) {\n\t\tubifs_err(\"too large journal size (%lld bytes), only %lld bytes available in the main area\",\n\t\t\t  c->max_bud_bytes, max_bytes);\n\t\tgoto failed;\n\t}\n\n\tif (c->jhead_cnt < NONDATA_JHEADS_CNT + 1 ||\n\t    c->jhead_cnt > NONDATA_JHEADS_CNT + UBIFS_MAX_JHEADS) {\n\t\terr = 9;\n\t\tgoto failed;\n\t}\n\n\tif (c->fanout < UBIFS_MIN_FANOUT ||\n\t    ubifs_idx_node_sz(c, c->fanout) > c->leb_size) {\n\t\terr = 10;\n\t\tgoto failed;\n\t}\n\n\tif (c->lsave_cnt < 0 || (c->lsave_cnt > DEFAULT_LSAVE_CNT &&\n\t    c->lsave_cnt > c->max_leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS -\n\t    c->log_lebs - c->lpt_lebs - c->orph_lebs)) {\n\t\terr = 11;\n\t\tgoto failed;\n\t}\n\n\tif (UBIFS_SB_LEBS + UBIFS_MST_LEBS + c->log_lebs + c->lpt_lebs +\n\t    c->orph_lebs + c->main_lebs != c->leb_cnt) {\n\t\terr = 12;\n\t\tgoto failed;\n\t}\n\n\tif (c->default_compr >= UBIFS_COMPR_TYPES_CNT) {\n\t\terr = 13;\n\t\tgoto failed;\n\t}\n\n\tif (c->rp_size < 0 || max_bytes < c->rp_size) {\n\t\terr = 14;\n\t\tgoto failed;\n\t}\n\n\tif (le32_to_cpu(sup->time_gran) > 1000000000 ||\n\t    le32_to_cpu(sup->time_gran) < 1) {\n\t\terr = 15;\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tubifs_err(\"bad superblock, error %d\", err);\n\tubifs_dump_node(c, sup);\n\treturn -EINVAL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "t_filesystem(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/sb.c",
    "lines": "73-340",
    "snippet": "eate_default_filesystem(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tstruct ubifs_mst_node *mst;\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_branch *br;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_cs_node *cs;\n\tunion ubifs_key key;\n\tint err, tmp, jnl_lebs, log_lebs, max_buds, main_lebs, main_first;\n\tint lpt_lebs, lpt_first, orph_lebs, big_lpt, ino_waste, sup_flags = 0;\n\tint min_leb_cnt = UBIFS_MIN_LEB_CNT;\n\tlong long tmp64, main_bytes;\n\t__le64 tmp_le64;\n\n\t/* Some functions called from here depend on the @c->key_len filed */\n\tc->key_len = UBIFS_SK_LEN;\n\n\t/*\n\t * First of all, we have to calculate default file-system geometry -\n\t * log size, journal size, etc.\n\t */\n\tif (c->leb_cnt < 0x7FFFFFFF / DEFAULT_JNL_PERCENT)\n\t\t/* We can first multiply then divide and have no overflow */\n\t\tjnl_lebs = c->leb_cnt * DEFAULT_JNL_PERCENT / 100;\n\telse\n\t\tjnl_lebs = (c->leb_cnt / 100) * DEFAULT_JNL_PERCENT;\n\n\tif (jnl_lebs < UBIFS_MIN_JNL_LEBS)\n\t\tjnl_lebs = UBIFS_MIN_JNL_LEBS;\n\tif (jnl_lebs * c->leb_size > DEFAULT_MAX_JNL)\n\t\tjnl_lebs = DEFAULT_MAX_JNL / c->leb_size;\n\n\t/*\n\t * The log should be large enough to fit reference nodes for all bud\n\t * LEBs. Because buds do not have to start from the beginning of LEBs\n\t * (half of the LEB may contain committed data), the log should\n\t * generally be larger, make it twice as large.\n\t */\n\ttmp = 2 * (c->ref_node_alsz * jnl_lebs) + c->leb_size - 1;\n\tlog_lebs = tmp / c->leb_size;\n\t/* Plus one LEB reserved for commit */\n\tlog_lebs += 1;\n\tif (c->leb_cnt - min_leb_cnt > 8) {\n\t\t/* And some extra space to allow writes while committing */\n\t\tlog_lebs += 1;\n\t\tmin_leb_cnt += 1;\n\t}\n\n\tmax_buds = jnl_lebs - log_lebs;\n\tif (max_buds < UBIFS_MIN_BUD_LEBS)\n\t\tmax_buds = UBIFS_MIN_BUD_LEBS;\n\n\t/*\n\t * Orphan nodes are stored in a separate area. One node can store a lot\n\t * of orphan inode numbers, but when new orphan comes we just add a new\n\t * orphan node. At some point the nodes are consolidated into one\n\t * orphan node.\n\t */\n\torph_lebs = UBIFS_MIN_ORPH_LEBS;\n\tif (c->leb_cnt - min_leb_cnt > 1)\n\t\t/*\n\t\t * For debugging purposes it is better to have at least 2\n\t\t * orphan LEBs, because the orphan subsystem would need to do\n\t\t * consolidations and would be stressed more.\n\t\t */\n\t\torph_lebs += 1;\n\n\tmain_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS - log_lebs;\n\tmain_lebs -= orph_lebs;\n\n\tlpt_first = UBIFS_LOG_LNUM + log_lebs;\n\tc->lsave_cnt = DEFAULT_LSAVE_CNT;\n\tc->max_leb_cnt = c->leb_cnt;\n\terr = ubifs_create_dflt_lpt(c, &main_lebs, lpt_first, &lpt_lebs,\n\t\t\t\t    &big_lpt);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"LEB Properties Tree created (LEBs %d-%d)\", lpt_first,\n\t\tlpt_first + lpt_lebs - 1);\n\n\tmain_first = c->leb_cnt - main_lebs;\n\n\t/* Create default superblock */\n\ttmp = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\tsup = kzalloc(tmp, GFP_KERNEL);\n\tif (!sup)\n\t\treturn -ENOMEM;\n\n\ttmp64 = (long long)max_buds * c->leb_size;\n\tif (big_lpt)\n\t\tsup_flags |= UBIFS_FLG_BIGLPT;\n\n\tsup->ch.node_type  = UBIFS_SB_NODE;\n\tsup->key_hash      = UBIFS_KEY_HASH_R5;\n\tsup->flags         = cpu_to_le32(sup_flags);\n\tsup->min_io_size   = cpu_to_le32(c->min_io_size);\n\tsup->leb_size      = cpu_to_le32(c->leb_size);\n\tsup->leb_cnt       = cpu_to_le32(c->leb_cnt);\n\tsup->max_leb_cnt   = cpu_to_le32(c->max_leb_cnt);\n\tsup->max_bud_bytes = cpu_to_le64(tmp64);\n\tsup->log_lebs      = cpu_to_le32(log_lebs);\n\tsup->lpt_lebs      = cpu_to_le32(lpt_lebs);\n\tsup->orph_lebs     = cpu_to_le32(orph_lebs);\n\tsup->jhead_cnt     = cpu_to_le32(DEFAULT_JHEADS_CNT);\n\tsup->fanout        = cpu_to_le32(DEFAULT_FANOUT);\n\tsup->lsave_cnt     = cpu_to_le32(c->lsave_cnt);\n\tsup->fmt_version   = cpu_to_le32(UBIFS_FORMAT_VERSION);\n\tsup->time_gran     = cpu_to_le32(DEFAULT_TIME_GRAN);\n\tif (c->mount_opts.override_compr)\n\t\tsup->default_compr = cpu_to_le16(c->mount_opts.compr_type);\n\telse\n\t\tsup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);\n\n\tgenerate_random_uuid(sup->uuid);\n\n\tmain_bytes = (long long)main_lebs * c->leb_size;\n\ttmp64 = div_u64(main_bytes * DEFAULT_RP_PERCENT, 100);\n\tif (tmp64 > DEFAULT_MAX_RP_SIZE)\n\t\ttmp64 = DEFAULT_MAX_RP_SIZE;\n\tsup->rp_size = cpu_to_le64(tmp64);\n\tsup->ro_compat_version = cpu_to_le32(UBIFS_RO_COMPAT_VERSION);\n\n\terr = ubifs_write_node(c, sup, UBIFS_SB_NODE_SZ, 0, 0);\n\tkfree(sup);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default superblock created at LEB 0:0\");\n\n\t/* Create default master node */\n\tmst = kzalloc(c->mst_node_alsz, GFP_KERNEL);\n\tif (!mst)\n\t\treturn -ENOMEM;\n\n\tmst->ch.node_type = UBIFS_MST_NODE;\n\tmst->log_lnum     = cpu_to_le32(UBIFS_LOG_LNUM);\n\tmst->highest_inum = cpu_to_le64(UBIFS_FIRST_INO);\n\tmst->cmt_no       = 0;\n\tmst->root_lnum    = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->root_offs    = 0;\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tmst->root_len     = cpu_to_le32(tmp);\n\tmst->gc_lnum      = cpu_to_le32(main_first + DEFAULT_GC_LEB);\n\tmst->ihead_lnum   = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->ihead_offs   = cpu_to_le32(ALIGN(tmp, c->min_io_size));\n\tmst->index_size   = cpu_to_le64(ALIGN(tmp, 8));\n\tmst->lpt_lnum     = cpu_to_le32(c->lpt_lnum);\n\tmst->lpt_offs     = cpu_to_le32(c->lpt_offs);\n\tmst->nhead_lnum   = cpu_to_le32(c->nhead_lnum);\n\tmst->nhead_offs   = cpu_to_le32(c->nhead_offs);\n\tmst->ltab_lnum    = cpu_to_le32(c->ltab_lnum);\n\tmst->ltab_offs    = cpu_to_le32(c->ltab_offs);\n\tmst->lsave_lnum   = cpu_to_le32(c->lsave_lnum);\n\tmst->lsave_offs   = cpu_to_le32(c->lsave_offs);\n\tmst->lscan_lnum   = cpu_to_le32(main_first);\n\tmst->empty_lebs   = cpu_to_le32(main_lebs - 2);\n\tmst->idx_lebs     = cpu_to_le32(1);\n\tmst->leb_cnt      = cpu_to_le32(c->leb_cnt);\n\n\t/* Calculate lprops statistics */\n\ttmp64 = main_bytes;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\ttmp64 -= ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tmst->total_free = cpu_to_le64(tmp64);\n\n\ttmp64 = ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\tino_waste = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size) -\n\t\t\t  UBIFS_INO_NODE_SZ;\n\ttmp64 += ino_waste;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tmst->total_dirty = cpu_to_le64(tmp64);\n\n\t/*  The indexing LEB does not contribute to dark space */\n\ttmp64 = ((long long)(c->main_lebs - 1) * c->dark_wm);\n\tmst->total_dark = cpu_to_le64(tmp64);\n\n\tmst->total_used = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM, 0);\n\tif (err) {\n\t\tkfree(mst);\n\t\treturn err;\n\t}\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM + 1,\n\t\t\t       0);\n\tkfree(mst);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default master node created at LEB %d:0\", UBIFS_MST_LNUM);\n\n\t/* Create the root indexing node */\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tidx = kzalloc(ALIGN(tmp, c->min_io_size), GFP_KERNEL);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\tc->key_fmt = UBIFS_SIMPLE_KEY_FMT;\n\tc->key_hash = key_r5_hash;\n\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(1);\n\tino_key_init(c, &key, UBIFS_ROOT_INO);\n\tbr = ubifs_idx_branch(c, idx, 0);\n\tkey_write_idx(c, &key, &br->key);\n\tbr->lnum = cpu_to_le32(main_first + DEFAULT_DATA_LEB);\n\tbr->len  = cpu_to_le32(UBIFS_INO_NODE_SZ);\n\terr = ubifs_write_node(c, idx, tmp, main_first + DEFAULT_IDX_LEB, 0);\n\tkfree(idx);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default root indexing node created LEB %d:0\",\n\t\tmain_first + DEFAULT_IDX_LEB);\n\n\t/* Create default root inode */\n\ttmp = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tino = kzalloc(tmp, GFP_KERNEL);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\tino_key_init_flash(c, &ino->key, UBIFS_ROOT_INO);\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino->creat_sqnum = cpu_to_le64(++c->max_sqnum);\n\tino->nlink = cpu_to_le32(2);\n\ttmp_le64 = cpu_to_le64(CURRENT_TIME_SEC.tv_sec);\n\tino->atime_sec   = tmp_le64;\n\tino->ctime_sec   = tmp_le64;\n\tino->mtime_sec   = tmp_le64;\n\tino->atime_nsec  = 0;\n\tino->ctime_nsec  = 0;\n\tino->mtime_nsec  = 0;\n\tino->mode = cpu_to_le32(S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO);\n\tino->size = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\t/* Set compression enabled by default */\n\tino->flags = cpu_to_le32(UBIFS_COMPR_FL);\n\n\terr = ubifs_write_node(c, ino, UBIFS_INO_NODE_SZ,\n\t\t\t       main_first + DEFAULT_DATA_LEB, 0);\n\tkfree(ino);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"root inode created at LEB %d:0\",\n\t\tmain_first + DEFAULT_DATA_LEB);\n\n\t/*\n\t * The first node in the log has to be the commit start node. This is\n\t * always the case during normal file-system operation. Write a fake\n\t * commit start node to the log.\n\t */\n\ttmp = ALIGN(UBIFS_CS_NODE_SZ, c->min_io_size);\n\tcs = kzalloc(tmp, GFP_KERNEL);\n\tif (!cs)\n\t\treturn -ENOMEM;\n\n\tcs->ch.node_type = UBIFS_CS_NODE;\n\terr = ubifs_write_node(c, cs, UBIFS_CS_NODE_SZ, UBIFS_LOG_LNUM, 0);\n\tkfree(cs);\n\tif (err)\n\t\treturn err;\n\n\tubifs_msg(\"default file-system created\");\n\treturn 0;\n}\n\n/**\n * vali",
    "includes": [
      "ux/math64.h>\n\n/*\n * Defaul",
      "ux/random.h>\n#include <lin",
      "ux/slab.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fault fil",
          "args": [
            "-system created\");\n\treturn 0;"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f (er",
          "args": [
            ")"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, cs, UBIFS",
          "args": [
            "C",
            "NO",
            "_SZ, UBIFS_LOG_L",
            "M, 0);\n\tkfree(",
            ")"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_KER",
          "args": [
            "EL)",
            "if (!cs)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_NOD",
          "args": [
            "_SZ, c->min_io_s",
            "e);\n\tcs = kzal"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode",
          "args": [
            "reated at LEB %d:0\",\n\t\tmain_firs",
            "DEFAULT_DATA_LEB);\n\n\t/*\n\t * T"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ct inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/ioctl.c",
          "lines": "102-145",
          "snippet": "tflags(struct inode *inode, int flags)\n{\n\tint oldflags, err, release;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t\t.dirtied_ino_d = ui->data_len };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tmutex_lock(&ui->ui_mutex);\n\toldflags = ubifs2ioctl(ui->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tui->flags = ioctl2ubifs(flags);\n\tubifs_set_inode_flags(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\trelease = ui->dirty;\n\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = write_inode_now(inode, 1);\n\treturn err;\n\nout_unlock:\n\tubifs_err(\"can't modify inode %lu attributes\", inode->i_ino);\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nlong ubifs_",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs",
            "ux/mount.h>\n#include \"ubi",
            "ux/compat.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/mount.h>\n#include \"ubi\nux/compat.h>\n#include <lin\n\ntflags(struct inode *inode, int flags)\n{\n\tint oldflags, err, release;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t\t.dirtied_ino_d = ui->data_len };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t * the relevant capability.\n\t */\n\tmutex_lock(&ui->ui_mutex);\n\toldflags = ubifs2ioctl(ui->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tui->flags = ioctl2ubifs(flags);\n\tubifs_set_inode_flags(inode);\n\tinode->i_ctime = ubifs_current_time(inode);\n\trelease = ui->dirty;\n\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = write_inode_now(inode, 1);\n\treturn err;\n\nout_unlock:\n\tubifs_err(\"can't modify inode %lu attributes\", inode->i_ino);\n\tmutex_unlock(&ui->ui_mutex);\n\tubifs_release_budget(c, &req);\n\treturn err;\n}\n\nlong ubifs_"
        }
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, ino, UBIF",
          "args": [
            "_",
            "O_N",
            "E_SZ,\n\t\t\t       m",
            "DEFAULT_DATA_LEB, 0);\n\tkfree(",
            "o"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_COMPR_",
          "args": [
            "L);\n\n\terr = ub"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_INO_NO",
          "args": [
            "E_SZ);\n\n\t/* Set c"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_IFDIR | S_",
          "args": [
            "RUGO | S_IWUSR | S_IXUGO);\n\tino->size"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URRENT_TIME",
          "args": [
            "SEC.tv_sec);\n\tino->atim"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\ttmp_le6",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+c->max_sqn",
          "args": [
            "m);\n\tino->nlin"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flash(c, &ino->key",
          "args": [
            "IFS_ROOT_",
            "O);\n\tino->ch.n"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_KER",
          "args": [
            "EL)",
            "if (!ino)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NO_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e);\n\tino = kza"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ult roo",
          "args": [
            "indexing node created LEB %d:0\",\n\t\tmain_firs",
            "DEFAULT_IDX_LEB);\n\n\t/* Creat"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, idx, tmp,",
          "args": [
            "m",
            "n_f",
            "st",
            "DEFAULT_IDX_LEB, 0);\n\tkfree(",
            "x"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_INO_NO",
          "args": [
            "E_SZ);\n\terr = ubi"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_first +",
          "args": [
            "DEFAULT_DATA_LEB);\n\tbr->len"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, &br",
          "args": [
            ">",
            "y);",
            "r->lnum"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, 0);",
          "args": [
            "k",
            "_wr",
            "e"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, UBI",
          "args": [
            "S",
            "OOT_",
            "O);\n\tbr = ubif"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tino_key",
          "args": [
            "i"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(tmp, c",
          "args": [
            ">min_io_size), GFP_KERNEL)",
            "if (!idx)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e), GFP_KERNEL"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1);\n\tidx",
          "args": [
            "a"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ult mas",
          "args": [
            "er node created at LEB %d:0\", UBIFS_MST_L",
            "M);\n\n\t/* Creat"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, mst, UBIF",
          "args": [
            "_",
            "T_N",
            "E_SZ, UBIFS_MST_L",
            "M + 1,\n\t\t\t       0",
            "t"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n e"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ode(c, mst, UBIF",
          "args": [
            "_",
            "T_N",
            "E_SZ, UBIFS_MST_L",
            "M, 0);\n\tif (er"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_INO_NO",
          "args": [
            "E_SZ);\n\n\terr = ub"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp64);\n\n\tms",
          "args": [
            "->tot"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp64);\n\n\t/*",
          "args": [
            "The"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_no",
          "args": [
            "e_sz(c, 1), 8);\n\tmst->t",
            "a"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1), 8);",
          "args": [
            "s",
            ">"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NO_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e) -\n\t\t\t  UBIF"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_no",
          "args": [
            "e_sz(c, 1), c->min_io_s",
            "e);\n\tino_waste"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1), c->mi",
          "args": [
            "_",
            "_"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp64);\n\n\ttm",
          "args": [
            "64 ="
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NO_NO",
          "args": [
            "E_SZ, c->min_io_s",
            "e);\n\tmst->tota"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_no",
          "args": [
            "e_sz(c, 1), c->min_io_s",
            "e);\n\ttmp64 -="
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1), c->mi",
          "args": [
            "_",
            "_"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->leb_cnt);",
          "args": [
            "/* Calcu"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tmst->le",
          "args": [
            "_"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_lebs -",
          "args": [
            ");\n\tmst->idx_"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_first);",
          "args": [
            "mst->empt"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lsave_off",
          "args": [
            ");\n\tmst->lsca"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lsave_lnu",
          "args": [
            ");\n\tmst->lsav"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ltab_offs",
          "args": [
            ";\n\tmst->lsav"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ltab_lnum",
          "args": [
            ";\n\tmst->ltab"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->nhead_off",
          "args": [
            ");\n\tmst->ltab"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->nhead_lnu",
          "args": [
            ");\n\tmst->nhea"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lpt_offs)",
          "args": [
            "mst->nhea"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lpt_lnum)",
          "args": [
            "mst->lpt_"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIGN(tmp, 8",
          "args": [
            ");\n\tmst->lpt_"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tm",
          "args": [
            "t->",
            "t"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIGN(tmp, c",
          "args": [
            ">min_io_size));\n\tmst->inde"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e));\n\tmst->ind"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_first +",
          "args": [
            "DEFAULT_IDX_LEB);\n\tmst->ihea"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_first +",
          "args": [
            "DEFAULT_GC_LEB);\n\tmst->ihea"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp);\n\tmst->",
          "args": [
            "c_l"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, 1);\n\tmst-",
          "args": [
            "r",
            "t"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ain_first +",
          "args": [
            "DEFAULT_IDX_LEB);\n\tmst->root"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_FIRST_",
          "args": [
            "NO);\n\tmst->cmt_"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_LOG_LN",
          "args": [
            "M);\n\tmst->high"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_node_",
          "args": [
            "lsz, GFP_KERNEL)",
            "if (!mst)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ult sup",
          "args": [
            "rblock created at LEB 0:0\");\n\n\t/* Creat"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (e",
          "args": [
            "r)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, sup, UBIF",
          "args": [
            "_",
            "_NO",
            "_SZ, 0, 0);\n\tkfr",
            "(",
            "p"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_RO_COM",
          "args": [
            "AT_VERSION);\n\n\terr = ub"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp64);\n\tsup",
          "args": [
            ">ro_c"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes *",
          "args": [
            "DEFAULT_RP_PERCENT, 100);\n\tif (",
            "p64"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_uuid(sup->uuid);",
          "args": [
            "main_byt"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_COMPR_",
          "args": [
            "ZO);\n\n\tgenerate"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->mount_opt",
          "args": [
            ".compr_type);\n\telse\n\t\tsu"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "285-290",
          "snippet": "static void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_mount_options(struct ceph_mount_options *args)\n{\n\tdout(\"destroy_mount_options %p\\n\", args);\n\tkfree(args->snapdir_name);\n\tkfree(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EFAULT_TIME",
          "args": [
            "GRAN);\n\tif (c->mo"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_FORMAT",
          "args": [
            "VERSION);\n\tsup->time"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->lsave_cnt",
          "args": [
            ";\n\tsup->fmt_"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EFAULT_FANO",
          "args": [
            "T);\n\tsup->lsav"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EFAULT_JHEA",
          "args": [
            "S_CNT);\n\tsup->fano"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rph_lebs);",
          "args": [
            "sup->jhea"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_lebs);",
          "args": [
            "up->orph"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "og_lebs);",
          "args": [
            "up->lpt_"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp64);\n\tsup",
          "args": [
            ">log_"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->max_leb_c",
          "args": [
            "t);\n\tsup->max_"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->leb_cnt);",
          "args": [
            "sup->max_"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->leb_size)",
          "args": [
            "sup->leb_"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min_io_si",
          "args": [
            "e);\n\tsup->leb_"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_min_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "304-308",
          "snippet": "static inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_flags);",
          "args": [
            "sup->min_"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_KER",
          "args": [
            "EL)",
            "if (!sup)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NOD",
          "args": [
            "_SZ, c->min_io_s",
            "e);\n\tsup = kza"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Propert",
          "args": [
            "es Tree created (LEBs %d-%d)\", lpt_first,",
            "lpt_first",
            "pt_lebs - 1);\n\n\tmain_fir"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dflt_lpt(c, &main_leb",
          "args": [
            ",",
            "pt_first,",
            "pt_lebs,",
            "&bi",
            "f (err)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * Defaul\nux/random.h>\n#include <lin\nux/slab.h>\n#include <lin\nfs.h\"\n#include <lin\n\neate_default_filesystem(struct ubifs_info *c)\n{\n\tstruct ubifs_sb_node *sup;\n\tstruct ubifs_mst_node *mst;\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_branch *br;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_cs_node *cs;\n\tunion ubifs_key key;\n\tint err, tmp, jnl_lebs, log_lebs, max_buds, main_lebs, main_first;\n\tint lpt_lebs, lpt_first, orph_lebs, big_lpt, ino_waste, sup_flags = 0;\n\tint min_leb_cnt = UBIFS_MIN_LEB_CNT;\n\tlong long tmp64, main_bytes;\n\t__le64 tmp_le64;\n\n\t/* Some functions called from here depend on the @c->key_len filed */\n\tc->key_len = UBIFS_SK_LEN;\n\n\t/*\n\t * First of all, we have to calculate default file-system geometry -\n\t * log size, journal size, etc.\n\t */\n\tif (c->leb_cnt < 0x7FFFFFFF / DEFAULT_JNL_PERCENT)\n\t\t/* We can first multiply then divide and have no overflow */\n\t\tjnl_lebs = c->leb_cnt * DEFAULT_JNL_PERCENT / 100;\n\telse\n\t\tjnl_lebs = (c->leb_cnt / 100) * DEFAULT_JNL_PERCENT;\n\n\tif (jnl_lebs < UBIFS_MIN_JNL_LEBS)\n\t\tjnl_lebs = UBIFS_MIN_JNL_LEBS;\n\tif (jnl_lebs * c->leb_size > DEFAULT_MAX_JNL)\n\t\tjnl_lebs = DEFAULT_MAX_JNL / c->leb_size;\n\n\t/*\n\t * The log should be large enough to fit reference nodes for all bud\n\t * LEBs. Because buds do not have to start from the beginning of LEBs\n\t * (half of the LEB may contain committed data), the log should\n\t * generally be larger, make it twice as large.\n\t */\n\ttmp = 2 * (c->ref_node_alsz * jnl_lebs) + c->leb_size - 1;\n\tlog_lebs = tmp / c->leb_size;\n\t/* Plus one LEB reserved for commit */\n\tlog_lebs += 1;\n\tif (c->leb_cnt - min_leb_cnt > 8) {\n\t\t/* And some extra space to allow writes while committing */\n\t\tlog_lebs += 1;\n\t\tmin_leb_cnt += 1;\n\t}\n\n\tmax_buds = jnl_lebs - log_lebs;\n\tif (max_buds < UBIFS_MIN_BUD_LEBS)\n\t\tmax_buds = UBIFS_MIN_BUD_LEBS;\n\n\t/*\n\t * Orphan nodes are stored in a separate area. One node can store a lot\n\t * of orphan inode numbers, but when new orphan comes we just add a new\n\t * orphan node. At some point the nodes are consolidated into one\n\t * orphan node.\n\t */\n\torph_lebs = UBIFS_MIN_ORPH_LEBS;\n\tif (c->leb_cnt - min_leb_cnt > 1)\n\t\t/*\n\t\t * For debugging purposes it is better to have at least 2\n\t\t * orphan LEBs, because the orphan subsystem would need to do\n\t\t * consolidations and would be stressed more.\n\t\t */\n\t\torph_lebs += 1;\n\n\tmain_lebs = c->leb_cnt - UBIFS_SB_LEBS - UBIFS_MST_LEBS - log_lebs;\n\tmain_lebs -= orph_lebs;\n\n\tlpt_first = UBIFS_LOG_LNUM + log_lebs;\n\tc->lsave_cnt = DEFAULT_LSAVE_CNT;\n\tc->max_leb_cnt = c->leb_cnt;\n\terr = ubifs_create_dflt_lpt(c, &main_lebs, lpt_first, &lpt_lebs,\n\t\t\t\t    &big_lpt);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"LEB Properties Tree created (LEBs %d-%d)\", lpt_first,\n\t\tlpt_first + lpt_lebs - 1);\n\n\tmain_first = c->leb_cnt - main_lebs;\n\n\t/* Create default superblock */\n\ttmp = ALIGN(UBIFS_SB_NODE_SZ, c->min_io_size);\n\tsup = kzalloc(tmp, GFP_KERNEL);\n\tif (!sup)\n\t\treturn -ENOMEM;\n\n\ttmp64 = (long long)max_buds * c->leb_size;\n\tif (big_lpt)\n\t\tsup_flags |= UBIFS_FLG_BIGLPT;\n\n\tsup->ch.node_type  = UBIFS_SB_NODE;\n\tsup->key_hash      = UBIFS_KEY_HASH_R5;\n\tsup->flags         = cpu_to_le32(sup_flags);\n\tsup->min_io_size   = cpu_to_le32(c->min_io_size);\n\tsup->leb_size      = cpu_to_le32(c->leb_size);\n\tsup->leb_cnt       = cpu_to_le32(c->leb_cnt);\n\tsup->max_leb_cnt   = cpu_to_le32(c->max_leb_cnt);\n\tsup->max_bud_bytes = cpu_to_le64(tmp64);\n\tsup->log_lebs      = cpu_to_le32(log_lebs);\n\tsup->lpt_lebs      = cpu_to_le32(lpt_lebs);\n\tsup->orph_lebs     = cpu_to_le32(orph_lebs);\n\tsup->jhead_cnt     = cpu_to_le32(DEFAULT_JHEADS_CNT);\n\tsup->fanout        = cpu_to_le32(DEFAULT_FANOUT);\n\tsup->lsave_cnt     = cpu_to_le32(c->lsave_cnt);\n\tsup->fmt_version   = cpu_to_le32(UBIFS_FORMAT_VERSION);\n\tsup->time_gran     = cpu_to_le32(DEFAULT_TIME_GRAN);\n\tif (c->mount_opts.override_compr)\n\t\tsup->default_compr = cpu_to_le16(c->mount_opts.compr_type);\n\telse\n\t\tsup->default_compr = cpu_to_le16(UBIFS_COMPR_LZO);\n\n\tgenerate_random_uuid(sup->uuid);\n\n\tmain_bytes = (long long)main_lebs * c->leb_size;\n\ttmp64 = div_u64(main_bytes * DEFAULT_RP_PERCENT, 100);\n\tif (tmp64 > DEFAULT_MAX_RP_SIZE)\n\t\ttmp64 = DEFAULT_MAX_RP_SIZE;\n\tsup->rp_size = cpu_to_le64(tmp64);\n\tsup->ro_compat_version = cpu_to_le32(UBIFS_RO_COMPAT_VERSION);\n\n\terr = ubifs_write_node(c, sup, UBIFS_SB_NODE_SZ, 0, 0);\n\tkfree(sup);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default superblock created at LEB 0:0\");\n\n\t/* Create default master node */\n\tmst = kzalloc(c->mst_node_alsz, GFP_KERNEL);\n\tif (!mst)\n\t\treturn -ENOMEM;\n\n\tmst->ch.node_type = UBIFS_MST_NODE;\n\tmst->log_lnum     = cpu_to_le32(UBIFS_LOG_LNUM);\n\tmst->highest_inum = cpu_to_le64(UBIFS_FIRST_INO);\n\tmst->cmt_no       = 0;\n\tmst->root_lnum    = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->root_offs    = 0;\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tmst->root_len     = cpu_to_le32(tmp);\n\tmst->gc_lnum      = cpu_to_le32(main_first + DEFAULT_GC_LEB);\n\tmst->ihead_lnum   = cpu_to_le32(main_first + DEFAULT_IDX_LEB);\n\tmst->ihead_offs   = cpu_to_le32(ALIGN(tmp, c->min_io_size));\n\tmst->index_size   = cpu_to_le64(ALIGN(tmp, 8));\n\tmst->lpt_lnum     = cpu_to_le32(c->lpt_lnum);\n\tmst->lpt_offs     = cpu_to_le32(c->lpt_offs);\n\tmst->nhead_lnum   = cpu_to_le32(c->nhead_lnum);\n\tmst->nhead_offs   = cpu_to_le32(c->nhead_offs);\n\tmst->ltab_lnum    = cpu_to_le32(c->ltab_lnum);\n\tmst->ltab_offs    = cpu_to_le32(c->ltab_offs);\n\tmst->lsave_lnum   = cpu_to_le32(c->lsave_lnum);\n\tmst->lsave_offs   = cpu_to_le32(c->lsave_offs);\n\tmst->lscan_lnum   = cpu_to_le32(main_first);\n\tmst->empty_lebs   = cpu_to_le32(main_lebs - 2);\n\tmst->idx_lebs     = cpu_to_le32(1);\n\tmst->leb_cnt      = cpu_to_le32(c->leb_cnt);\n\n\t/* Calculate lprops statistics */\n\ttmp64 = main_bytes;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\ttmp64 -= ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tmst->total_free = cpu_to_le64(tmp64);\n\n\ttmp64 = ALIGN(ubifs_idx_node_sz(c, 1), c->min_io_size);\n\tino_waste = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size) -\n\t\t\t  UBIFS_INO_NODE_SZ;\n\ttmp64 += ino_waste;\n\ttmp64 -= ALIGN(ubifs_idx_node_sz(c, 1), 8);\n\tmst->total_dirty = cpu_to_le64(tmp64);\n\n\t/*  The indexing LEB does not contribute to dark space */\n\ttmp64 = ((long long)(c->main_lebs - 1) * c->dark_wm);\n\tmst->total_dark = cpu_to_le64(tmp64);\n\n\tmst->total_used = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM, 0);\n\tif (err) {\n\t\tkfree(mst);\n\t\treturn err;\n\t}\n\terr = ubifs_write_node(c, mst, UBIFS_MST_NODE_SZ, UBIFS_MST_LNUM + 1,\n\t\t\t       0);\n\tkfree(mst);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default master node created at LEB %d:0\", UBIFS_MST_LNUM);\n\n\t/* Create the root indexing node */\n\ttmp = ubifs_idx_node_sz(c, 1);\n\tidx = kzalloc(ALIGN(tmp, c->min_io_size), GFP_KERNEL);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\tc->key_fmt = UBIFS_SIMPLE_KEY_FMT;\n\tc->key_hash = key_r5_hash;\n\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(1);\n\tino_key_init(c, &key, UBIFS_ROOT_INO);\n\tbr = ubifs_idx_branch(c, idx, 0);\n\tkey_write_idx(c, &key, &br->key);\n\tbr->lnum = cpu_to_le32(main_first + DEFAULT_DATA_LEB);\n\tbr->len  = cpu_to_le32(UBIFS_INO_NODE_SZ);\n\terr = ubifs_write_node(c, idx, tmp, main_first + DEFAULT_IDX_LEB, 0);\n\tkfree(idx);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"default root indexing node created LEB %d:0\",\n\t\tmain_first + DEFAULT_IDX_LEB);\n\n\t/* Create default root inode */\n\ttmp = ALIGN(UBIFS_INO_NODE_SZ, c->min_io_size);\n\tino = kzalloc(tmp, GFP_KERNEL);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\tino_key_init_flash(c, &ino->key, UBIFS_ROOT_INO);\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino->creat_sqnum = cpu_to_le64(++c->max_sqnum);\n\tino->nlink = cpu_to_le32(2);\n\ttmp_le64 = cpu_to_le64(CURRENT_TIME_SEC.tv_sec);\n\tino->atime_sec   = tmp_le64;\n\tino->ctime_sec   = tmp_le64;\n\tino->mtime_sec   = tmp_le64;\n\tino->atime_nsec  = 0;\n\tino->ctime_nsec  = 0;\n\tino->mtime_nsec  = 0;\n\tino->mode = cpu_to_le32(S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO);\n\tino->size = cpu_to_le64(UBIFS_INO_NODE_SZ);\n\n\t/* Set compression enabled by default */\n\tino->flags = cpu_to_le32(UBIFS_COMPR_FL);\n\n\terr = ubifs_write_node(c, ino, UBIFS_INO_NODE_SZ,\n\t\t\t       main_first + DEFAULT_DATA_LEB, 0);\n\tkfree(ino);\n\tif (err)\n\t\treturn err;\n\n\tdbg_gen(\"root inode created at LEB %d:0\",\n\t\tmain_first + DEFAULT_DATA_LEB);\n\n\t/*\n\t * The first node in the log has to be the commit start node. This is\n\t * always the case during normal file-system operation. Write a fake\n\t * commit start node to the log.\n\t */\n\ttmp = ALIGN(UBIFS_CS_NODE_SZ, c->min_io_size);\n\tcs = kzalloc(tmp, GFP_KERNEL);\n\tif (!cs)\n\t\treturn -ENOMEM;\n\n\tcs->ch.node_type = UBIFS_CS_NODE;\n\terr = ubifs_write_node(c, cs, UBIFS_CS_NODE_SZ, UBIFS_LOG_LNUM, 0);\n\tkfree(cs);\n\tif (err)\n\t\treturn err;\n\n\tubifs_msg(\"default file-system created\");\n\treturn 0;\n}\n\n/**\n * vali"
  }
]