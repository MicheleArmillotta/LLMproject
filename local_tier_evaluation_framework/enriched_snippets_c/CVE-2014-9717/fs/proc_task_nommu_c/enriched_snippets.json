[
  {
    "function_name": "tid_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "327-330",
    "snippet": "static int tid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn maps_open(inode, file, &proc_tid_maps_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations proc_tid_maps_ops = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_tid_map\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "maps_open",
          "args": [
            "inode",
            "file",
            "&proc_tid_maps_ops"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "289-308",
          "snippet": "static int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct seq_operations proc_tid_maps_ops = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_tid_map\n};\n\nstatic int tid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn maps_open(inode, file, &proc_tid_maps_ops);\n}"
  },
  {
    "function_name": "pid_maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "322-325",
    "snippet": "static int pid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn maps_open(inode, file, &proc_pid_maps_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations proc_pid_maps_ops = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_pid_map\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "maps_open",
          "args": [
            "inode",
            "file",
            "&proc_pid_maps_ops"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "maps_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "289-308",
          "snippet": "static int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct seq_operations proc_pid_maps_ops = {\n\t.start\t= m_start,\n\t.next\t= m_next,\n\t.stop\t= m_stop,\n\t.show\t= show_pid_map\n};\n\nstatic int pid_maps_open(struct inode *inode, struct file *file)\n{\n\treturn maps_open(inode, file, &proc_pid_maps_ops);\n}"
  },
  {
    "function_name": "map_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "311-320",
    "snippet": "static int map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct proc_maps_private *priv = seq->private;\n\n\tif (priv->mm)\n\t\tmmdrop(priv->mm);\n\n\treturn seq_release_private(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "priv->mm"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct proc_maps_private *priv = seq->private;\n\n\tif (priv->mm)\n\t\tmmdrop(priv->mm);\n\n\treturn seq_release_private(inode, file);\n}"
  },
  {
    "function_name": "maps_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "289-308",
    "snippet": "static int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "priv->mm"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "priv->mm"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mem_open",
          "args": [
            "inode",
            "PTRACE_MODE_READ"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mem_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "605-623",
          "snippet": "struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "ops",
            "sizeof(*priv)"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "615-638",
          "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int maps_open(struct inode *inode, struct file *file,\n\t\t     const struct seq_operations *ops)\n{\n\tstruct proc_maps_private *priv;\n\n\tpriv = __seq_open_private(file, ops, sizeof(*priv));\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->inode = inode;\n\tpriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\n\tif (IS_ERR(priv->mm)) {\n\t\tint err = PTR_ERR(priv->mm);\n\n\t\tseq_release_private(inode, file);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "m_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "267-273",
    "snippet": "static void *m_next(struct seq_file *m, void *_p, loff_t *pos)\n{\n\tstruct rb_node *p = _p;\n\n\t(*pos)++;\n\treturn p ? rb_next(p) : NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void *m_next(struct seq_file *m, void *_p, loff_t *pos)\n{\n\tstruct rb_node *p = _p;\n\n\t(*pos)++;\n\treturn p ? rb_next(p) : NULL;\n}"
  },
  {
    "function_name": "m_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "253-265",
    "snippet": "static void m_stop(struct seq_file *m, void *_vml)\n{\n\tstruct proc_maps_private *priv = m->private;\n\n\tif (!IS_ERR_OR_NULL(_vml)) {\n\t\tup_read(&priv->mm->mmap_sem);\n\t\tmmput(priv->mm);\n\t}\n\tif (priv->task) {\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "priv->task"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "priv->mm"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&priv->mm->mmap_sem"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "_vml"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void m_stop(struct seq_file *m, void *_vml)\n{\n\tstruct proc_maps_private *priv = m->private;\n\n\tif (!IS_ERR_OR_NULL(_vml)) {\n\t\tup_read(&priv->mm->mmap_sem);\n\t\tmmput(priv->mm);\n\t}\n\tif (priv->task) {\n\t\tput_task_struct(priv->task);\n\t\tpriv->task = NULL;\n\t}\n}"
  },
  {
    "function_name": "m_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "226-251",
    "snippet": "static void *m_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct mm_struct *mm;\n\tstruct rb_node *p;\n\tloff_t n = *pos;\n\n\t/* pin the task and mm whilst we play with them */\n\tpriv->task = get_proc_task(priv->inode);\n\tif (!priv->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\tmm = priv->mm;\n\tif (!mm || !atomic_inc_not_zero(&mm->mm_users))\n\t\treturn NULL;\n\n\tdown_read(&mm->mmap_sem);\n\t/* start from the Nth VMA */\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p))\n\t\tif (n-- == 0)\n\t\t\treturn p;\n\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&mm->mm_users"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "priv->inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void *m_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct mm_struct *mm;\n\tstruct rb_node *p;\n\tloff_t n = *pos;\n\n\t/* pin the task and mm whilst we play with them */\n\tpriv->task = get_proc_task(priv->inode);\n\tif (!priv->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\tmm = priv->mm;\n\tif (!mm || !atomic_inc_not_zero(&mm->mm_users))\n\t\treturn NULL;\n\n\tdown_read(&mm->mmap_sem);\n\t/* start from the Nth VMA */\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p))\n\t\tif (n-- == 0)\n\t\t\treturn p;\n\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\n\treturn NULL;\n}"
  },
  {
    "function_name": "show_tid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "221-224",
    "snippet": "static int show_tid_map(struct seq_file *m, void *_p)\n{\n\treturn show_map(m, _p, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_map",
          "args": [
            "m",
            "_p",
            "0"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "show_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "208-214",
          "snippet": "static int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int show_tid_map(struct seq_file *m, void *_p)\n{\n\treturn show_map(m, _p, 0);\n}"
  },
  {
    "function_name": "show_pid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "216-219",
    "snippet": "static int show_pid_map(struct seq_file *m, void *_p)\n{\n\treturn show_map(m, _p, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_map",
          "args": [
            "m",
            "_p",
            "1"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "show_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "208-214",
          "snippet": "static int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int show_pid_map(struct seq_file *m, void *_p)\n{\n\treturn show_map(m, _p, 1);\n}"
  },
  {
    "function_name": "show_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "208-214",
    "snippet": "static int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nommu_vma_show",
          "args": [
            "m",
            "rb_entry(p, struct vm_area_struct, vm_rb)",
            "is_pid"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "nommu_vma_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "148-203",
          "snippet": "static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\n\t\t\t  int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\tunsigned long long pgoff = 0;\n\n\tflags = vma->vm_flags;\n\tfile = vma->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   vma->vm_start,\n\t\t   vma->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   pgoff,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t} else if (mm) {\n\t\tpid_t tid = pid_of_stack(priv, vma, is_pid);\n\n\t\tif (tid != 0) {\n\t\t\tseq_pad(m, ' ');\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_printf(m, \"[stack]\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\n\t\t\t  int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\tunsigned long long pgoff = 0;\n\n\tflags = vma->vm_flags;\n\tfile = vma->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   vma->vm_start,\n\t\t   vma->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   pgoff,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t} else if (mm) {\n\t\tpid_t tid = pid_of_stack(priv, vma, is_pid);\n\n\t\tif (tid != 0) {\n\t\t\tseq_pad(m, ' ');\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_printf(m, \"[stack]\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int show_map(struct seq_file *m, void *_p, int is_pid)\n{\n\tstruct rb_node *p = _p;\n\n\treturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\n\t\t\t      is_pid);\n}"
  },
  {
    "function_name": "nommu_vma_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "148-203",
    "snippet": "static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\n\t\t\t  int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\tunsigned long long pgoff = 0;\n\n\tflags = vma->vm_flags;\n\tfile = vma->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   vma->vm_start,\n\t\t   vma->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   pgoff,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t} else if (mm) {\n\t\tpid_t tid = pid_of_stack(priv, vma, is_pid);\n\n\t\tif (tid != 0) {\n\t\t\tseq_pad(m, ' ');\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_printf(m, \"[stack]\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"[stack:%d]\"",
            "tid"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_pad",
          "args": [
            "m",
            "' '"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "seq_pad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "748-755",
          "snippet": "void seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid seq_pad(struct seq_file *m, char c)\n{\n\tint size = m->pad_until - m->count;\n\tif (size > 0)\n\t\tseq_printf(m, \"%*s\", size, \"\");\n\tif (c)\n\t\tseq_putc(m, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_of_stack",
          "args": [
            "priv",
            "vma",
            "is_pid"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "pid_of_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
          "lines": "126-143",
          "snippet": "static pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&file->f_path",
            "\"\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_setwidth",
          "args": [
            "m",
            "25 + sizeof(void *) * 6 - 1"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\n\t\t\t  int is_pid)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct proc_maps_private *priv = m->private;\n\tunsigned long ino = 0;\n\tstruct file *file;\n\tdev_t dev = 0;\n\tint flags;\n\tunsigned long long pgoff = 0;\n\n\tflags = vma->vm_flags;\n\tfile = vma->vm_file;\n\n\tif (file) {\n\t\tstruct inode *inode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tpgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\n\t}\n\n\tseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\n\tseq_printf(m,\n\t\t   \"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu \",\n\t\t   vma->vm_start,\n\t\t   vma->vm_end,\n\t\t   flags & VM_READ ? 'r' : '-',\n\t\t   flags & VM_WRITE ? 'w' : '-',\n\t\t   flags & VM_EXEC ? 'x' : '-',\n\t\t   flags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\n\t\t   pgoff,\n\t\t   MAJOR(dev), MINOR(dev), ino);\n\n\tif (file) {\n\t\tseq_pad(m, ' ');\n\t\tseq_path(m, &file->f_path, \"\");\n\t} else if (mm) {\n\t\tpid_t tid = pid_of_stack(priv, vma, is_pid);\n\n\t\tif (tid != 0) {\n\t\t\tseq_pad(m, ' ');\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_printf(m, \"[stack]\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \"[stack:%d]\", tid);\n\t\t}\n\t}\n\n\tseq_putc(m, '\\n');\n\treturn 0;\n}"
  },
  {
    "function_name": "pid_of_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "126-143",
    "snippet": "static pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "task",
            "inode->i_sb->s_fs_info"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_of_stack",
          "args": [
            "task",
            "vma",
            "is_pid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "proc_pid(inode)",
            "PIDTYPE_PID"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic pid_t pid_of_stack(struct proc_maps_private *priv,\n\t\t\t\tstruct vm_area_struct *vma, bool is_pid)\n{\n\tstruct inode *inode = priv->inode;\n\tstruct task_struct *task;\n\tpid_t ret = 0;\n\n\trcu_read_lock();\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\ttask = task_of_stack(task, vma, is_pid);\n\t\tif (task)\n\t\t\tret = task_pid_nr_ns(task, inode->i_sb->s_fs_info);\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "task_statm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "95-124",
    "snippet": "unsigned long task_statm(struct mm_struct *mm,\n\t\t\t unsigned long *shared, unsigned long *text,\n\t\t\t unsigned long *data, unsigned long *resident)\n{\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tstruct rb_node *p;\n\tunsigned long size = kobjsize(mm);\n\n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\t\tsize += kobjsize(vma);\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize += kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t}\n\t}\n\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\t*data = (PAGE_ALIGN(mm->start_stack) - (mm->start_data & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\tup_read(&mm->mmap_sem);\n\tsize >>= PAGE_SHIFT;\n\tsize += *text + *data;\n\t*resident = size;\n\treturn size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mm->start_stack"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "mm->end_code"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "region"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "vma"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "mm"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long task_statm(struct mm_struct *mm,\n\t\t\t unsigned long *shared, unsigned long *text,\n\t\t\t unsigned long *data, unsigned long *resident)\n{\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tstruct rb_node *p;\n\tunsigned long size = kobjsize(mm);\n\n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\t\tsize += kobjsize(vma);\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize += kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t}\n\t}\n\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\t*data = (PAGE_ALIGN(mm->start_stack) - (mm->start_data & PAGE_MASK))\n\t\t>> PAGE_SHIFT;\n\tup_read(&mm->mmap_sem);\n\tsize >>= PAGE_SHIFT;\n\tsize += *text + *data;\n\t*resident = size;\n\treturn size;\n}"
  },
  {
    "function_name": "task_vsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "80-93",
    "snippet": "unsigned long task_vsize(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct rb_node *p;\n\tunsigned long vsize = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\t\tvsize += vma->vm_end - vma->vm_start;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn vsize;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned long task_vsize(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct rb_node *p;\n\tunsigned long vsize = 0;\n\n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\t\tvsize += vma->vm_end - vma->vm_start;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn vsize;\n}"
  },
  {
    "function_name": "task_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_nommu.c",
    "lines": "18-78",
    "snippet": "void task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tstruct rb_node *p;\n\tunsigned long bytes = 0, sbytes = 0, slack = 0, size;\n        \n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\n\t\tbytes += kobjsize(vma);\n\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize = kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t} else {\n\t\t\tsize = vma->vm_end - vma->vm_start;\n\t\t}\n\n\t\tif (atomic_read(&mm->mm_count) > 1 ||\n\t\t    vma->vm_flags & VM_MAYSHARE) {\n\t\t\tsbytes += size;\n\t\t} else {\n\t\t\tbytes += size;\n\t\t\tif (region)\n\t\t\t\tslack = region->vm_end - vma->vm_end;\n\t\t}\n\t}\n\n\tif (atomic_read(&mm->mm_count) > 1)\n\t\tsbytes += kobjsize(mm);\n\telse\n\t\tbytes += kobjsize(mm);\n\t\n\tif (current->fs && current->fs->users > 1)\n\t\tsbytes += kobjsize(current->fs);\n\telse\n\t\tbytes += kobjsize(current->fs);\n\n\tif (current->files && atomic_read(&current->files->count) > 1)\n\t\tsbytes += kobjsize(current->files);\n\telse\n\t\tbytes += kobjsize(current->files);\n\n\tif (current->sighand && atomic_read(&current->sighand->count) > 1)\n\t\tsbytes += kobjsize(current->sighand);\n\telse\n\t\tbytes += kobjsize(current->sighand);\n\n\tbytes += kobjsize(current); /* includes kernel stack */\n\n\tseq_printf(m,\n\t\t\"Mem:\\t%8lu bytes\\n\"\n\t\t\"Slack:\\t%8lu bytes\\n\"\n\t\t\"Shared:\\t%8lu bytes\\n\",\n\t\tbytes, slack, sbytes);\n\n\tup_read(&mm->mmap_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Mem:\\t%8lu bytes\\n\"\n\t\t\"Slack:\\t%8lu bytes\\n\"\n\t\t\"Shared:\\t%8lu bytes\\n\"",
            "bytes",
            "slack",
            "sbytes"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->sighand"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->sighand"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->sighand->count"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->files"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->files"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->files->count"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->fs"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "current->fs"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "mm"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "mm"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_count"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "region"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobjsize",
          "args": [
            "vma"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structvm_area_struct",
            "vm_rb"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mm->mm_rb"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid task_mem(struct seq_file *m, struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tstruct vm_region *region;\n\tstruct rb_node *p;\n\tunsigned long bytes = 0, sbytes = 0, slack = 0, size;\n        \n\tdown_read(&mm->mmap_sem);\n\tfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\n\t\tvma = rb_entry(p, struct vm_area_struct, vm_rb);\n\n\t\tbytes += kobjsize(vma);\n\n\t\tregion = vma->vm_region;\n\t\tif (region) {\n\t\t\tsize = kobjsize(region);\n\t\t\tsize += region->vm_end - region->vm_start;\n\t\t} else {\n\t\t\tsize = vma->vm_end - vma->vm_start;\n\t\t}\n\n\t\tif (atomic_read(&mm->mm_count) > 1 ||\n\t\t    vma->vm_flags & VM_MAYSHARE) {\n\t\t\tsbytes += size;\n\t\t} else {\n\t\t\tbytes += size;\n\t\t\tif (region)\n\t\t\t\tslack = region->vm_end - vma->vm_end;\n\t\t}\n\t}\n\n\tif (atomic_read(&mm->mm_count) > 1)\n\t\tsbytes += kobjsize(mm);\n\telse\n\t\tbytes += kobjsize(mm);\n\t\n\tif (current->fs && current->fs->users > 1)\n\t\tsbytes += kobjsize(current->fs);\n\telse\n\t\tbytes += kobjsize(current->fs);\n\n\tif (current->files && atomic_read(&current->files->count) > 1)\n\t\tsbytes += kobjsize(current->files);\n\telse\n\t\tbytes += kobjsize(current->files);\n\n\tif (current->sighand && atomic_read(&current->sighand->count) > 1)\n\t\tsbytes += kobjsize(current->sighand);\n\telse\n\t\tbytes += kobjsize(current->sighand);\n\n\tbytes += kobjsize(current); /* includes kernel stack */\n\n\tseq_printf(m,\n\t\t\"Mem:\\t%8lu bytes\\n\"\n\t\t\"Slack:\\t%8lu bytes\\n\"\n\t\t\"Shared:\\t%8lu bytes\\n\",\n\t\tbytes, slack, sbytes);\n\n\tup_read(&mm->mmap_sem);\n}"
  }
]