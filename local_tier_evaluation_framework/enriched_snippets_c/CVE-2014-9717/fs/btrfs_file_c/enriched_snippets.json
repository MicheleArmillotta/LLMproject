[
  {
    "function_name": "btrfs_fdatawrite_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2843-2867",
    "snippet": "int btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_HAS_ASYNC_EXTENT",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_auto_defrag_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2831-2841",
    "snippet": "int btrfs_auto_defrag_init(void)\n{\n\tbtrfs_inode_defrag_cachep = kmem_cache_create(\"btrfs_inode_defrag\",\n\t\t\t\t\tsizeof(struct inode_defrag), 0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_inode_defrag_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_inode_defrag\"",
            "sizeof(struct inode_defrag)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nint btrfs_auto_defrag_init(void)\n{\n\tbtrfs_inode_defrag_cachep = kmem_cache_create(\"btrfs_inode_defrag\",\n\t\t\t\t\tsizeof(struct inode_defrag), 0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_inode_defrag_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_auto_defrag_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2825-2829",
    "snippet": "void btrfs_auto_defrag_exit(void)\n{\n\tif (btrfs_inode_defrag_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_defrag_cachep);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_inode_defrag_cachep"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nvoid btrfs_auto_defrag_exit(void)\n{\n\tif (btrfs_inode_defrag_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_defrag_cachep);\n}"
  },
  {
    "function_name": "btrfs_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2776-2805",
    "snippet": "static loff_t btrfs_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\tcase SEEK_END:\n\tcase SEEK_CUR:\n\t\toffset = generic_file_llseek(file, offset, whence);\n\t\tgoto out;\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tif (offset >= i_size_read(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tret = find_desired_extent(inode, &offset, whence);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_desired_extent",
          "args": [
            "inode",
            "&offset",
            "whence"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "find_desired_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2712-2774",
          "snippet": "static int find_desired_extent(struct inode *inode, loff_t *offset, int whence)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 start;\n\tu64 len;\n\tint ret = 0;\n\n\tif (inode->i_size == 0)\n\t\treturn -ENXIO;\n\n\t/*\n\t * *offset can be negative, in this case we start finding DATA/HOLE from\n\t * the very start of the file.\n\t */\n\tstart = max_t(loff_t, 0, *offset);\n\n\tlockstart = round_down(start, root->sectorsize);\n\tlockend = round_up(i_size_read(inode), root->sectorsize);\n\tif (lockend <= lockstart)\n\t\tlockend = lockstart + root->sectorsize;\n\tlockend--;\n\tlen = lockend - lockstart + 1;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend, 0,\n\t\t\t &cached_state);\n\n\twhile (start < inode->i_size) {\n\t\tem = btrfs_get_extent_fiemap(inode, NULL, 0, start, len, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (whence == SEEK_HOLE &&\n\t\t    (em->block_start == EXTENT_MAP_HOLE ||\n\t\t     test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\t\telse if (whence == SEEK_DATA &&\n\t\t\t   (em->block_start != EXTENT_MAP_HOLE &&\n\t\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcond_resched();\n\t}\n\tfree_extent_map(em);\n\tif (!ret) {\n\t\tif (whence == SEEK_DATA && start >= inode->i_size)\n\t\t\tret = -ENXIO;\n\t\telse\n\t\t\t*offset = min_t(loff_t, start, inode->i_size);\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int find_desired_extent(struct inode *inode, loff_t *offset, int whence)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 start;\n\tu64 len;\n\tint ret = 0;\n\n\tif (inode->i_size == 0)\n\t\treturn -ENXIO;\n\n\t/*\n\t * *offset can be negative, in this case we start finding DATA/HOLE from\n\t * the very start of the file.\n\t */\n\tstart = max_t(loff_t, 0, *offset);\n\n\tlockstart = round_down(start, root->sectorsize);\n\tlockend = round_up(i_size_read(inode), root->sectorsize);\n\tif (lockend <= lockstart)\n\t\tlockend = lockstart + root->sectorsize;\n\tlockend--;\n\tlen = lockend - lockstart + 1;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend, 0,\n\t\t\t &cached_state);\n\n\twhile (start < inode->i_size) {\n\t\tem = btrfs_get_extent_fiemap(inode, NULL, 0, start, len, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (whence == SEEK_HOLE &&\n\t\t    (em->block_start == EXTENT_MAP_HOLE ||\n\t\t     test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\t\telse if (whence == SEEK_DATA &&\n\t\t\t   (em->block_start != EXTENT_MAP_HOLE &&\n\t\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcond_resched();\n\t}\n\tfree_extent_map(em);\n\tif (!ret) {\n\t\tif (whence == SEEK_DATA && start >= inode->i_size)\n\t\t\tret = -ENXIO;\n\t\telse\n\t\t\t*offset = min_t(loff_t, start, inode->i_size);\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic loff_t btrfs_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\tcase SEEK_END:\n\tcase SEEK_CUR:\n\t\toffset = generic_file_llseek(file, offset, whence);\n\t\tgoto out;\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tif (offset >= i_size_read(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tret = find_desired_extent(inode, &offset, whence);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}"
  },
  {
    "function_name": "find_desired_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2712-2774",
    "snippet": "static int find_desired_extent(struct inode *inode, loff_t *offset, int whence)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 start;\n\tu64 len;\n\tint ret = 0;\n\n\tif (inode->i_size == 0)\n\t\treturn -ENXIO;\n\n\t/*\n\t * *offset can be negative, in this case we start finding DATA/HOLE from\n\t * the very start of the file.\n\t */\n\tstart = max_t(loff_t, 0, *offset);\n\n\tlockstart = round_down(start, root->sectorsize);\n\tlockend = round_up(i_size_read(inode), root->sectorsize);\n\tif (lockend <= lockstart)\n\t\tlockend = lockstart + root->sectorsize;\n\tlockend--;\n\tlen = lockend - lockstart + 1;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend, 0,\n\t\t\t &cached_state);\n\n\twhile (start < inode->i_size) {\n\t\tem = btrfs_get_extent_fiemap(inode, NULL, 0, start, len, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (whence == SEEK_HOLE &&\n\t\t    (em->block_start == EXTENT_MAP_HOLE ||\n\t\t     test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\t\telse if (whence == SEEK_DATA &&\n\t\t\t   (em->block_start != EXTENT_MAP_HOLE &&\n\t\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcond_resched();\n\t}\n\tfree_extent_map(em);\n\tif (!ret) {\n\t\tif (whence == SEEK_DATA && start >= inode->i_size)\n\t\t\tret = -ENXIO;\n\t\telse\n\t\t\t*offset = min_t(loff_t, start, inode->i_size);\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "start",
            "inode->i_size"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_PREALLOC",
            "&em->flags"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent_fiemap",
          "args": [
            "inode",
            "NULL",
            "0",
            "start",
            "len",
            "0"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "0",
            "&cached_state"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "i_size_read(inode)",
            "root->sectorsize"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "start",
            "root->sectorsize"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "loff_t",
            "0",
            "*offset"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int find_desired_extent(struct inode *inode, loff_t *offset, int whence)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 start;\n\tu64 len;\n\tint ret = 0;\n\n\tif (inode->i_size == 0)\n\t\treturn -ENXIO;\n\n\t/*\n\t * *offset can be negative, in this case we start finding DATA/HOLE from\n\t * the very start of the file.\n\t */\n\tstart = max_t(loff_t, 0, *offset);\n\n\tlockstart = round_down(start, root->sectorsize);\n\tlockend = round_up(i_size_read(inode), root->sectorsize);\n\tif (lockend <= lockstart)\n\t\tlockend = lockstart + root->sectorsize;\n\tlockend--;\n\tlen = lockend - lockstart + 1;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend, 0,\n\t\t\t &cached_state);\n\n\twhile (start < inode->i_size) {\n\t\tem = btrfs_get_extent_fiemap(inode, NULL, 0, start, len, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (whence == SEEK_HOLE &&\n\t\t    (em->block_start == EXTENT_MAP_HOLE ||\n\t\t     test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\t\telse if (whence == SEEK_DATA &&\n\t\t\t   (em->block_start != EXTENT_MAP_HOLE &&\n\t\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags)))\n\t\t\tbreak;\n\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcond_resched();\n\t}\n\tfree_extent_map(em);\n\tif (!ret) {\n\t\tif (whence == SEEK_DATA && start >= inode->i_size)\n\t\t\tret = -ENXIO;\n\t\telse\n\t\t\t*offset = min_t(loff_t, start, inode->i_size);\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2549-2710",
    "snippet": "static long btrfs_fallocate(struct file *file, int mode,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 cur_offset;\n\tu64 last_byte;\n\tu64 alloc_start;\n\tu64 alloc_end;\n\tu64 alloc_hint = 0;\n\tu64 locked_end;\n\tstruct extent_map *em;\n\tint blocksize = BTRFS_I(inode)->root->sectorsize;\n\tint ret;\n\n\talloc_start = round_down(offset, blocksize);\n\talloc_end = round_up(offset + len, blocksize);\n\n\t/* Make sure we aren't being give some crap mode */\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn btrfs_punch_hole(inode, offset, len);\n\n\t/*\n\t * Make sure we have enough space before we do the\n\t * allocation.\n\t */\n\tret = btrfs_check_data_free_space(inode, alloc_end - alloc_start);\n\tif (ret)\n\t\treturn ret;\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, alloc_end - alloc_start);\n\t\tif (ret)\n\t\t\tgoto out_reserve_fail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tret = inode_newsize_ok(inode, alloc_end);\n\tif (ret)\n\t\tgoto out;\n\n\tif (alloc_start > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, i_size_read(inode),\n\t\t\t\t\talloc_start);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t * If we are fallocating from the end of the file onward we\n\t\t * need to zero out the end of the page if i_size lands in the\n\t\t * middle of a page.\n\t\t */\n\t\tret = btrfs_truncate_page(inode, inode->i_size, 0, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * wait for ordered IO before we have any locks.  We'll loop again\n\t * below with the locks held.\n\t */\n\tret = btrfs_wait_ordered_range(inode, alloc_start,\n\t\t\t\t       alloc_end - alloc_start);\n\tif (ret)\n\t\tgoto out;\n\n\tlocked_end = alloc_end - 1;\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\t/* the extent lock is ordered inside the running\n\t\t * transaction\n\t\t */\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, alloc_start,\n\t\t\t\t locked_end, 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    alloc_end - 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > alloc_start &&\n\t\t    ordered->file_offset < alloc_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     alloc_start, locked_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\t/*\n\t\t\t * we can't wait on the range with the transaction\n\t\t\t * running or with the extent lock held\n\t\t\t */\n\t\t\tret = btrfs_wait_ordered_range(inode, alloc_start,\n\t\t\t\t\t\t       alloc_end - alloc_start);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcur_offset = alloc_start;\n\twhile (1) {\n\t\tu64 actual_end;\n\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\t      alloc_end - cur_offset, 0);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tif (!em)\n\t\t\t\tret = -ENOMEM;\n\t\t\telse\n\t\t\t\tret = PTR_ERR(em);\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), alloc_end);\n\t\tactual_end = min_t(u64, extent_map_end(em), offset + len);\n\t\tlast_byte = ALIGN(last_byte, blocksize);\n\n\t\tif (em->block_start == EXTENT_MAP_HOLE ||\n\t\t    (cur_offset >= inode->i_size &&\n\t\t     !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))) {\n\t\t\tret = btrfs_prealloc_file_range(inode, mode, cur_offset,\n\t\t\t\t\t\t\tlast_byte - cur_offset,\n\t\t\t\t\t\t\t1 << inode->i_blkbits,\n\t\t\t\t\t\t\toffset + len,\n\t\t\t\t\t\t\t&alloc_hint);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (actual_end > inode->i_size &&\n\t\t\t   !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\t/*\n\t\t\t * We didn't need to allocate any more space, but we\n\t\t\t * still extended the size of the file so we need to\n\t\t\t * update i_size.\n\t\t\t */\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\ti_size_write(inode, actual_end);\n\t\t\tbtrfs_ordered_update_i_size(inode, actual_end, NULL);\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= alloc_end) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,\n\t\t\t     &cached_state, GFP_NOFS);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tif (root->fs_info->quota_enabled)\n\t\tbtrfs_qgroup_free(root, alloc_end - alloc_start);\nout_reserve_fail:\n\t/* Let go of our reservation. */\n\tbtrfs_free_reserved_data_space(inode, alloc_end - alloc_start);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_reserved_data_space",
          "args": [
            "inode",
            "alloc_end - alloc_start"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_reserved_data_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3750-3765",
          "snippet": "void btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_free",
          "args": [
            "root",
            "alloc_end - alloc_start"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2448-2499",
          "snippet": "void btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "alloc_start",
            "locked_end",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ordered_update_i_size",
          "args": [
            "inode",
            "actual_end",
            "NULL"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ordered_update_i_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "869-983",
          "snippet": "int btrfs_ordered_update_i_size(struct inode *inode, u64 offset,\n\t\t\t\tstruct btrfs_ordered_extent *ordered)\n{\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tu64 disk_i_size;\n\tu64 new_i_size;\n\tu64 i_size = i_size_read(inode);\n\tstruct rb_node *node;\n\tstruct rb_node *prev = NULL;\n\tstruct btrfs_ordered_extent *test;\n\tint ret = 1;\n\n\tspin_lock_irq(&tree->lock);\n\tif (ordered) {\n\t\toffset = entry_end(ordered);\n\t\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags))\n\t\t\toffset = min(offset,\n\t\t\t\t     ordered->file_offset +\n\t\t\t\t     ordered->truncated_len);\n\t} else {\n\t\toffset = ALIGN(offset, BTRFS_I(inode)->root->sectorsize);\n\t}\n\tdisk_i_size = BTRFS_I(inode)->disk_i_size;\n\n\t/* truncate file */\n\tif (disk_i_size > i_size) {\n\t\tBTRFS_I(inode)->disk_i_size = i_size;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if the disk i_size is already at the inode->i_size, or\n\t * this ordered extent is inside the disk i_size, we're done\n\t */\n\tif (disk_i_size == i_size)\n\t\tgoto out;\n\n\t/*\n\t * We still need to update disk_i_size if outstanding_isize is greater\n\t * than disk_i_size.\n\t */\n\tif (offset <= disk_i_size &&\n\t    (!ordered || ordered->outstanding_isize <= disk_i_size))\n\t\tgoto out;\n\n\t/*\n\t * walk backward from this ordered extent to disk_i_size.\n\t * if we find an ordered extent then we can't update disk i_size\n\t * yet\n\t */\n\tif (ordered) {\n\t\tnode = rb_prev(&ordered->rb_node);\n\t} else {\n\t\tprev = tree_search(tree, offset);\n\t\t/*\n\t\t * we insert file extents without involving ordered struct,\n\t\t * so there should be no ordered struct cover this offset\n\t\t */\n\t\tif (prev) {\n\t\t\ttest = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(offset_in_entry(test, offset));\n\t\t}\n\t\tnode = prev;\n\t}\n\tfor (; node; node = rb_prev(node)) {\n\t\ttest = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\n\t\t/* We treat this entry as if it doesnt exist */\n\t\tif (test_bit(BTRFS_ORDERED_UPDATED_ISIZE, &test->flags))\n\t\t\tcontinue;\n\t\tif (test->file_offset + test->len <= disk_i_size)\n\t\t\tbreak;\n\t\tif (test->file_offset >= i_size)\n\t\t\tbreak;\n\t\tif (entry_end(test) > disk_i_size) {\n\t\t\t/*\n\t\t\t * we don't update disk_i_size now, so record this\n\t\t\t * undealt i_size. Or we will not know the real\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (test->outstanding_isize < offset)\n\t\t\t\ttest->outstanding_isize = offset;\n\t\t\tif (ordered &&\n\t\t\t    ordered->outstanding_isize >\n\t\t\t    test->outstanding_isize)\n\t\t\t\ttest->outstanding_isize =\n\t\t\t\t\t\tordered->outstanding_isize;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnew_i_size = min_t(u64, offset, i_size);\n\n\t/*\n\t * Some ordered extents may completed before the current one, and\n\t * we hold the real i_size in ->outstanding_isize.\n\t */\n\tif (ordered && ordered->outstanding_isize > new_i_size)\n\t\tnew_i_size = min_t(u64, ordered->outstanding_isize, i_size);\n\tBTRFS_I(inode)->disk_i_size = new_i_size;\n\tret = 0;\nout:\n\t/*\n\t * We need to do this because we can't remove ordered extents until\n\t * after the i_disk_size has been updated and then the inode has been\n\t * updated to reflect the change, so we need to tell anybody who finds\n\t * this ordered extent that we've already done all the real work, we\n\t * just haven't completed all the other work.\n\t */\n\tif (ordered)\n\t\tset_bit(BTRFS_ORDERED_UPDATED_ISIZE, &ordered->flags);\n\tspin_unlock_irq(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_ordered_update_i_size(struct inode *inode, u64 offset,\n\t\t\t\tstruct btrfs_ordered_extent *ordered)\n{\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tu64 disk_i_size;\n\tu64 new_i_size;\n\tu64 i_size = i_size_read(inode);\n\tstruct rb_node *node;\n\tstruct rb_node *prev = NULL;\n\tstruct btrfs_ordered_extent *test;\n\tint ret = 1;\n\n\tspin_lock_irq(&tree->lock);\n\tif (ordered) {\n\t\toffset = entry_end(ordered);\n\t\tif (test_bit(BTRFS_ORDERED_TRUNCATED, &ordered->flags))\n\t\t\toffset = min(offset,\n\t\t\t\t     ordered->file_offset +\n\t\t\t\t     ordered->truncated_len);\n\t} else {\n\t\toffset = ALIGN(offset, BTRFS_I(inode)->root->sectorsize);\n\t}\n\tdisk_i_size = BTRFS_I(inode)->disk_i_size;\n\n\t/* truncate file */\n\tif (disk_i_size > i_size) {\n\t\tBTRFS_I(inode)->disk_i_size = i_size;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if the disk i_size is already at the inode->i_size, or\n\t * this ordered extent is inside the disk i_size, we're done\n\t */\n\tif (disk_i_size == i_size)\n\t\tgoto out;\n\n\t/*\n\t * We still need to update disk_i_size if outstanding_isize is greater\n\t * than disk_i_size.\n\t */\n\tif (offset <= disk_i_size &&\n\t    (!ordered || ordered->outstanding_isize <= disk_i_size))\n\t\tgoto out;\n\n\t/*\n\t * walk backward from this ordered extent to disk_i_size.\n\t * if we find an ordered extent then we can't update disk i_size\n\t * yet\n\t */\n\tif (ordered) {\n\t\tnode = rb_prev(&ordered->rb_node);\n\t} else {\n\t\tprev = tree_search(tree, offset);\n\t\t/*\n\t\t * we insert file extents without involving ordered struct,\n\t\t * so there should be no ordered struct cover this offset\n\t\t */\n\t\tif (prev) {\n\t\t\ttest = rb_entry(prev, struct btrfs_ordered_extent,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(offset_in_entry(test, offset));\n\t\t}\n\t\tnode = prev;\n\t}\n\tfor (; node; node = rb_prev(node)) {\n\t\ttest = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\n\t\t/* We treat this entry as if it doesnt exist */\n\t\tif (test_bit(BTRFS_ORDERED_UPDATED_ISIZE, &test->flags))\n\t\t\tcontinue;\n\t\tif (test->file_offset + test->len <= disk_i_size)\n\t\t\tbreak;\n\t\tif (test->file_offset >= i_size)\n\t\t\tbreak;\n\t\tif (entry_end(test) > disk_i_size) {\n\t\t\t/*\n\t\t\t * we don't update disk_i_size now, so record this\n\t\t\t * undealt i_size. Or we will not know the real\n\t\t\t * i_size.\n\t\t\t */\n\t\t\tif (test->outstanding_isize < offset)\n\t\t\t\ttest->outstanding_isize = offset;\n\t\t\tif (ordered &&\n\t\t\t    ordered->outstanding_isize >\n\t\t\t    test->outstanding_isize)\n\t\t\t\ttest->outstanding_isize =\n\t\t\t\t\t\tordered->outstanding_isize;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnew_i_size = min_t(u64, offset, i_size);\n\n\t/*\n\t * Some ordered extents may completed before the current one, and\n\t * we hold the real i_size in ->outstanding_isize.\n\t */\n\tif (ordered && ordered->outstanding_isize > new_i_size)\n\t\tnew_i_size = min_t(u64, ordered->outstanding_isize, i_size);\n\tBTRFS_I(inode)->disk_i_size = new_i_size;\n\tret = 0;\nout:\n\t/*\n\t * We need to do this because we can't remove ordered extents until\n\t * after the i_disk_size has been updated and then the inode has been\n\t * updated to reflect the change, so we need to tell anybody who finds\n\t * this ordered extent that we've already done all the real work, we\n\t * just haven't completed all the other work.\n\t */\n\tif (ordered)\n\t\tset_bit(BTRFS_ORDERED_UPDATED_ISIZE, &ordered->flags);\n\tspin_unlock_irq(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "actual_end"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_prealloc_file_range",
          "args": [
            "inode",
            "mode",
            "cur_offset",
            "last_byte - cur_offset",
            "1 << inode->i_blkbits",
            "offset + len",
            "&alloc_hint"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prealloc_file_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9520-9527",
          "snippet": "int btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t      u64 start, u64 num_bytes, u64 min_size,\n\t\t\t      loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint,\n\t\t\t\t\t   NULL);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t      u64 start, u64 num_bytes, u64 min_size,\n\t\t\t      loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint,\n\t\t\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_PREALLOC",
            "&em->flags"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "last_byte",
            "blocksize"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "extent_map_end(em)",
            "offset + len"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "extent_map_end(em)",
            "alloc_end"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "cur_offset",
            "alloc_end - cur_offset",
            "0"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "inode",
            "alloc_start",
            "alloc_end - alloc_start"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_first_ordered_extent",
          "args": [
            "inode",
            "alloc_end - 1"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_first_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "845-863",
          "snippet": "struct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "alloc_start",
            "locked_end",
            "0",
            "&cached_state"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_page",
          "args": [
            "inode",
            "inode->i_size",
            "0",
            "0"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4433-4534",
          "snippet": "int btrfs_truncate_page(struct inode *inode, loff_t from, loff_t len,\n\t\t\tint front)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tchar *kaddr;\n\tu32 blocksize = root->sectorsize;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(mapping);\n\tint ret = 0;\n\tu64 page_start;\n\tu64 page_end;\n\n\tif ((offset & (blocksize - 1)) == 0 &&\n\t    (!len || ((len & (blocksize - 1)) == 0)))\n\t\tgoto out;\n\tret = btrfs_delalloc_reserve_space(inode, PAGE_CACHE_SIZE);\n\tif (ret)\n\t\tgoto out;\n\nagain:\n\tpage = find_or_create_page(mapping, index, mask);\n\tif (!page) {\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\tif (!PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tlock_page(page);\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\twait_on_page_writeback(page);\n\n\tlock_extent_bits(io_tree, page_start, page_end, 0, &cached_state);\n\tset_page_extent_mapped(page);\n\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start, page_end,\n\t\t\t  EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t  0, 0, &cached_state, GFP_NOFS);\n\n\tret = btrfs_set_extent_delalloc(inode, page_start, page_end,\n\t\t\t\t\t&cached_state);\n\tif (ret) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tgoto out_unlock;\n\t}\n\n\tif (offset != PAGE_CACHE_SIZE) {\n\t\tif (!len)\n\t\t\tlen = PAGE_CACHE_SIZE - offset;\n\t\tkaddr = kmap(page);\n\t\tif (front)\n\t\t\tmemset(kaddr, 0, offset);\n\t\telse\n\t\t\tmemset(kaddr + offset, 0, len);\n\t\tflush_dcache_page(page);\n\t\tkunmap(page);\n\t}\n\tClearPageChecked(page);\n\tset_page_dirty(page);\n\tunlock_extent_cached(io_tree, page_start, page_end, &cached_state,\n\t\t\t     GFP_NOFS);\n\nout_unlock:\n\tif (ret)\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_truncate_page(struct inode *inode, loff_t from, loff_t len,\n\t\t\tint front)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tchar *kaddr;\n\tu32 blocksize = root->sectorsize;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(mapping);\n\tint ret = 0;\n\tu64 page_start;\n\tu64 page_end;\n\n\tif ((offset & (blocksize - 1)) == 0 &&\n\t    (!len || ((len & (blocksize - 1)) == 0)))\n\t\tgoto out;\n\tret = btrfs_delalloc_reserve_space(inode, PAGE_CACHE_SIZE);\n\tif (ret)\n\t\tgoto out;\n\nagain:\n\tpage = find_or_create_page(mapping, index, mask);\n\tif (!page) {\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\tif (!PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tlock_page(page);\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\twait_on_page_writeback(page);\n\n\tlock_extent_bits(io_tree, page_start, page_end, 0, &cached_state);\n\tset_page_extent_mapped(page);\n\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start, page_end,\n\t\t\t  EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t  0, 0, &cached_state, GFP_NOFS);\n\n\tret = btrfs_set_extent_delalloc(inode, page_start, page_end,\n\t\t\t\t\t&cached_state);\n\tif (ret) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tgoto out_unlock;\n\t}\n\n\tif (offset != PAGE_CACHE_SIZE) {\n\t\tif (!len)\n\t\t\tlen = PAGE_CACHE_SIZE - offset;\n\t\tkaddr = kmap(page);\n\t\tif (front)\n\t\t\tmemset(kaddr, 0, offset);\n\t\telse\n\t\t\tmemset(kaddr + offset, 0, len);\n\t\tflush_dcache_page(page);\n\t\tkunmap(page);\n\t}\n\tClearPageChecked(page);\n\tset_page_dirty(page);\n\tunlock_extent_cached(io_tree, page_start, page_end, &cached_state,\n\t\t\t     GFP_NOFS);\n\nout_unlock:\n\tif (ret)\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cont_expand",
          "args": [
            "inode",
            "i_size_read(inode)",
            "alloc_start"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cont_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4585-4688",
          "snippet": "int btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "alloc_end"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_reserve",
          "args": [
            "root",
            "alloc_end - alloc_start"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2367-2446",
          "snippet": "int btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_data_free_space",
          "args": [
            "inode",
            "alloc_end - alloc_start"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_data_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3638-3745",
          "snippet": "int btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);\nstatic noinline struct;\n\nint btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_punch_hole",
          "args": [
            "inode",
            "offset",
            "len"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_punch_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2257-2547",
          "snippet": "static int btrfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trunc_metadata_size(root, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tint rsv_count;\n\tbool same_page;\n\tbool no_holes = btrfs_fs_incompat(root->fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_page = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tino_size = round_up(inode->i_size, PAGE_CACHE_SIZE);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, BTRFS_I(inode)->root->sectorsize);\n\tlockend = round_down(offset + len,\n\t\t\t     BTRFS_I(inode)->root->sectorsize) - 1;\n\tsame_page = ((offset >> PAGE_CACHE_SHIFT) ==\n\t\t    ((offset + len - 1) >> PAGE_CACHE_SHIFT));\n\n\t/*\n\t * We needn't truncate any page which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same page and we aren't doing the\n\t * entire page.\n\t */\n\tif (same_page && len < PAGE_CACHE_SIZE) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_page = true;\n\t\t\tret = btrfs_truncate_page(inode, offset, len, 0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t/* zero back part of the first page */\n\tif (offset < ino_size) {\n\t\ttruncated_page = true;\n\t\tret = btrfs_truncate_page(inode, offset, 0, 0);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Check the aligned pages after the first unaligned page,\n\t * if offset != orig_start, which means the first unaligned page\n\t * including serveral following pages are already in holes,\n\t * the extra check can be skipped */\n\tif (offset == orig_start) {\n\t\t/* after truncate page, check hole again */\n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(inode, &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t/* Check the tail unaligned part is in a hole */\n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(inode, &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t/* zero the front end of the last page */\n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_page = true;\n\t\t\t\tret = btrfs_truncate_page(inode,\n\t\t\t\t\t\ttail_start + tail_len, 0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t\t 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, lockend);\n\n\t\t/*\n\t\t * We need to make sure we have no ordered extents in this range\n\t\t * and nobody raced in and read a page in this range, if we did\n\t\t * we need to try again.\n\t\t */\n\t\tif ((!ordered ||\n\t\t    (ordered->file_offset + ordered->len <= lockstart ||\n\t\t     ordered->file_offset > lockend)) &&\n\t\t     !btrfs_page_exists_in_range(inode, lockstart, lockend)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t     lockend, &cached_state, GFP_NOFS);\n\t\tret = btrfs_wait_ordered_range(inode, lockstart,\n\t\t\t\t\t       lockend - lockstart + 1);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\trsv->size = btrfs_calc_trunc_metadata_size(root, 1);\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 - update the inode\n\t * 1 - removing the extents in the range\n\t * 1 - adding the hole extent if no_holes isn't set\n\t */\n\trsv_count = no_holes ? 2 : 3;\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size);\n\tBUG_ON(ret);\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = lockstart;\n\tlen = lockend - cur_offset;\n\twhile (cur_offset < lockend) {\n\t\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t\t   cur_offset, lockend + 1,\n\t\t\t\t\t   &drop_end, 1, 0, 0, NULL);\n\t\tif (ret != -ENOSPC)\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\t\tif (cur_offset < ino_size) {\n\t\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t\t drop_end);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur_offset = drop_end;\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\ttrans = btrfs_start_transaction(root, rsv_count);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size);\n\t\tBUG_ON(ret);\t/* shouldn't happen */\n\t\ttrans->block_rsv = rsv;\n\n\t\tret = find_first_non_hole(inode, &cur_offset, &len);\n\t\tif (unlikely(ret < 0))\n\t\t\tbreak;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_trans;\n\t}\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t/*\n\t * Don't insert file hole extent item if it's for a range beyond eof\n\t * (because it's useless) or if it represents a 0 bytes range (when\n\t * cur_offset == drop_end).\n\t */\n\tif (cur_offset < ino_size && cur_offset < drop_end) {\n\t\tret = fill_holes(trans, inode, path, cur_offset, drop_end);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_trans;\n\t\t}\n\t}\n\nout_trans:\n\tif (!trans)\n\t\tgoto out_free;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\tret = btrfs_update_inode(trans, root, inode);\n\tupdated_inode = true;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout_free:\n\tbtrfs_free_path(path);\n\tbtrfs_free_block_rsv(root, rsv);\nout:\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\nout_only_mutex:\n\tif (!updated_inode && truncated_page && !ret && !err) {\n\t\t/*\n\t\t * If we only end up zeroing part of a page, we still need to\n\t\t * update the inode item, so that all the time fields are\n\t\t * updated as well as the necessary btrfs inode in memory fields\n\t\t * for detecting, at fsync time, if the inode isn't yet in the\n\t\t * log tree or it's there but not up to date.\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t} else {\n\t\t\terr = btrfs_update_inode(trans, root, inode);\n\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t}\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret && !err)\n\t\terr = ret;\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int btrfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trunc_metadata_size(root, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tint rsv_count;\n\tbool same_page;\n\tbool no_holes = btrfs_fs_incompat(root->fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_page = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tino_size = round_up(inode->i_size, PAGE_CACHE_SIZE);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, BTRFS_I(inode)->root->sectorsize);\n\tlockend = round_down(offset + len,\n\t\t\t     BTRFS_I(inode)->root->sectorsize) - 1;\n\tsame_page = ((offset >> PAGE_CACHE_SHIFT) ==\n\t\t    ((offset + len - 1) >> PAGE_CACHE_SHIFT));\n\n\t/*\n\t * We needn't truncate any page which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same page and we aren't doing the\n\t * entire page.\n\t */\n\tif (same_page && len < PAGE_CACHE_SIZE) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_page = true;\n\t\t\tret = btrfs_truncate_page(inode, offset, len, 0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t/* zero back part of the first page */\n\tif (offset < ino_size) {\n\t\ttruncated_page = true;\n\t\tret = btrfs_truncate_page(inode, offset, 0, 0);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Check the aligned pages after the first unaligned page,\n\t * if offset != orig_start, which means the first unaligned page\n\t * including serveral following pages are already in holes,\n\t * the extra check can be skipped */\n\tif (offset == orig_start) {\n\t\t/* after truncate page, check hole again */\n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(inode, &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t/* Check the tail unaligned part is in a hole */\n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(inode, &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t/* zero the front end of the last page */\n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_page = true;\n\t\t\t\tret = btrfs_truncate_page(inode,\n\t\t\t\t\t\ttail_start + tail_len, 0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t\t 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, lockend);\n\n\t\t/*\n\t\t * We need to make sure we have no ordered extents in this range\n\t\t * and nobody raced in and read a page in this range, if we did\n\t\t * we need to try again.\n\t\t */\n\t\tif ((!ordered ||\n\t\t    (ordered->file_offset + ordered->len <= lockstart ||\n\t\t     ordered->file_offset > lockend)) &&\n\t\t     !btrfs_page_exists_in_range(inode, lockstart, lockend)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t     lockend, &cached_state, GFP_NOFS);\n\t\tret = btrfs_wait_ordered_range(inode, lockstart,\n\t\t\t\t\t       lockend - lockstart + 1);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\trsv->size = btrfs_calc_trunc_metadata_size(root, 1);\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 - update the inode\n\t * 1 - removing the extents in the range\n\t * 1 - adding the hole extent if no_holes isn't set\n\t */\n\trsv_count = no_holes ? 2 : 3;\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size);\n\tBUG_ON(ret);\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = lockstart;\n\tlen = lockend - cur_offset;\n\twhile (cur_offset < lockend) {\n\t\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t\t   cur_offset, lockend + 1,\n\t\t\t\t\t   &drop_end, 1, 0, 0, NULL);\n\t\tif (ret != -ENOSPC)\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\t\tif (cur_offset < ino_size) {\n\t\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t\t drop_end);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur_offset = drop_end;\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\ttrans = btrfs_start_transaction(root, rsv_count);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size);\n\t\tBUG_ON(ret);\t/* shouldn't happen */\n\t\ttrans->block_rsv = rsv;\n\n\t\tret = find_first_non_hole(inode, &cur_offset, &len);\n\t\tif (unlikely(ret < 0))\n\t\t\tbreak;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_trans;\n\t}\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t/*\n\t * Don't insert file hole extent item if it's for a range beyond eof\n\t * (because it's useless) or if it represents a 0 bytes range (when\n\t * cur_offset == drop_end).\n\t */\n\tif (cur_offset < ino_size && cur_offset < drop_end) {\n\t\tret = fill_holes(trans, inode, path, cur_offset, drop_end);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_trans;\n\t\t}\n\t}\n\nout_trans:\n\tif (!trans)\n\t\tgoto out_free;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\tret = btrfs_update_inode(trans, root, inode);\n\tupdated_inode = true;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout_free:\n\tbtrfs_free_path(path);\n\tbtrfs_free_block_rsv(root, rsv);\nout:\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\nout_only_mutex:\n\tif (!updated_inode && truncated_page && !ret && !err) {\n\t\t/*\n\t\t * If we only end up zeroing part of a page, we still need to\n\t\t * update the inode item, so that all the time fields are\n\t\t * updated as well as the necessary btrfs inode in memory fields\n\t\t * for detecting, at fsync time, if the inode isn't yet in the\n\t\t * log tree or it's there but not up to date.\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t} else {\n\t\t\terr = btrfs_update_inode(trans, root, inode);\n\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t}\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret && !err)\n\t\terr = ret;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset + len",
            "blocksize"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "offset",
            "blocksize"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic long btrfs_fallocate(struct file *file, int mode,\n\t\t\t    loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 cur_offset;\n\tu64 last_byte;\n\tu64 alloc_start;\n\tu64 alloc_end;\n\tu64 alloc_hint = 0;\n\tu64 locked_end;\n\tstruct extent_map *em;\n\tint blocksize = BTRFS_I(inode)->root->sectorsize;\n\tint ret;\n\n\talloc_start = round_down(offset, blocksize);\n\talloc_end = round_up(offset + len, blocksize);\n\n\t/* Make sure we aren't being give some crap mode */\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn btrfs_punch_hole(inode, offset, len);\n\n\t/*\n\t * Make sure we have enough space before we do the\n\t * allocation.\n\t */\n\tret = btrfs_check_data_free_space(inode, alloc_end - alloc_start);\n\tif (ret)\n\t\treturn ret;\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, alloc_end - alloc_start);\n\t\tif (ret)\n\t\t\tgoto out_reserve_fail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tret = inode_newsize_ok(inode, alloc_end);\n\tif (ret)\n\t\tgoto out;\n\n\tif (alloc_start > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, i_size_read(inode),\n\t\t\t\t\talloc_start);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t * If we are fallocating from the end of the file onward we\n\t\t * need to zero out the end of the page if i_size lands in the\n\t\t * middle of a page.\n\t\t */\n\t\tret = btrfs_truncate_page(inode, inode->i_size, 0, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * wait for ordered IO before we have any locks.  We'll loop again\n\t * below with the locks held.\n\t */\n\tret = btrfs_wait_ordered_range(inode, alloc_start,\n\t\t\t\t       alloc_end - alloc_start);\n\tif (ret)\n\t\tgoto out;\n\n\tlocked_end = alloc_end - 1;\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\t/* the extent lock is ordered inside the running\n\t\t * transaction\n\t\t */\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, alloc_start,\n\t\t\t\t locked_end, 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    alloc_end - 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > alloc_start &&\n\t\t    ordered->file_offset < alloc_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     alloc_start, locked_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\t/*\n\t\t\t * we can't wait on the range with the transaction\n\t\t\t * running or with the extent lock held\n\t\t\t */\n\t\t\tret = btrfs_wait_ordered_range(inode, alloc_start,\n\t\t\t\t\t\t       alloc_end - alloc_start);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcur_offset = alloc_start;\n\twhile (1) {\n\t\tu64 actual_end;\n\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\t      alloc_end - cur_offset, 0);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tif (!em)\n\t\t\t\tret = -ENOMEM;\n\t\t\telse\n\t\t\t\tret = PTR_ERR(em);\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), alloc_end);\n\t\tactual_end = min_t(u64, extent_map_end(em), offset + len);\n\t\tlast_byte = ALIGN(last_byte, blocksize);\n\n\t\tif (em->block_start == EXTENT_MAP_HOLE ||\n\t\t    (cur_offset >= inode->i_size &&\n\t\t     !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))) {\n\t\t\tret = btrfs_prealloc_file_range(inode, mode, cur_offset,\n\t\t\t\t\t\t\tlast_byte - cur_offset,\n\t\t\t\t\t\t\t1 << inode->i_blkbits,\n\t\t\t\t\t\t\toffset + len,\n\t\t\t\t\t\t\t&alloc_hint);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (actual_end > inode->i_size &&\n\t\t\t   !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\t/*\n\t\t\t * We didn't need to allocate any more space, but we\n\t\t\t * still extended the size of the file so we need to\n\t\t\t * update i_size.\n\t\t\t */\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\ti_size_write(inode, actual_end);\n\t\t\tbtrfs_ordered_update_i_size(inode, actual_end, NULL);\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= alloc_end) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,\n\t\t\t     &cached_state, GFP_NOFS);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tif (root->fs_info->quota_enabled)\n\t\tbtrfs_qgroup_free(root, alloc_end - alloc_start);\nout_reserve_fail:\n\t/* Let go of our reservation. */\n\tbtrfs_free_reserved_data_space(inode, alloc_end - alloc_start);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_punch_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2257-2547",
    "snippet": "static int btrfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trunc_metadata_size(root, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tint rsv_count;\n\tbool same_page;\n\tbool no_holes = btrfs_fs_incompat(root->fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_page = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tino_size = round_up(inode->i_size, PAGE_CACHE_SIZE);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, BTRFS_I(inode)->root->sectorsize);\n\tlockend = round_down(offset + len,\n\t\t\t     BTRFS_I(inode)->root->sectorsize) - 1;\n\tsame_page = ((offset >> PAGE_CACHE_SHIFT) ==\n\t\t    ((offset + len - 1) >> PAGE_CACHE_SHIFT));\n\n\t/*\n\t * We needn't truncate any page which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same page and we aren't doing the\n\t * entire page.\n\t */\n\tif (same_page && len < PAGE_CACHE_SIZE) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_page = true;\n\t\t\tret = btrfs_truncate_page(inode, offset, len, 0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t/* zero back part of the first page */\n\tif (offset < ino_size) {\n\t\ttruncated_page = true;\n\t\tret = btrfs_truncate_page(inode, offset, 0, 0);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Check the aligned pages after the first unaligned page,\n\t * if offset != orig_start, which means the first unaligned page\n\t * including serveral following pages are already in holes,\n\t * the extra check can be skipped */\n\tif (offset == orig_start) {\n\t\t/* after truncate page, check hole again */\n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(inode, &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t/* Check the tail unaligned part is in a hole */\n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(inode, &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t/* zero the front end of the last page */\n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_page = true;\n\t\t\t\tret = btrfs_truncate_page(inode,\n\t\t\t\t\t\ttail_start + tail_len, 0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t\t 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, lockend);\n\n\t\t/*\n\t\t * We need to make sure we have no ordered extents in this range\n\t\t * and nobody raced in and read a page in this range, if we did\n\t\t * we need to try again.\n\t\t */\n\t\tif ((!ordered ||\n\t\t    (ordered->file_offset + ordered->len <= lockstart ||\n\t\t     ordered->file_offset > lockend)) &&\n\t\t     !btrfs_page_exists_in_range(inode, lockstart, lockend)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t     lockend, &cached_state, GFP_NOFS);\n\t\tret = btrfs_wait_ordered_range(inode, lockstart,\n\t\t\t\t\t       lockend - lockstart + 1);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\trsv->size = btrfs_calc_trunc_metadata_size(root, 1);\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 - update the inode\n\t * 1 - removing the extents in the range\n\t * 1 - adding the hole extent if no_holes isn't set\n\t */\n\trsv_count = no_holes ? 2 : 3;\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size);\n\tBUG_ON(ret);\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = lockstart;\n\tlen = lockend - cur_offset;\n\twhile (cur_offset < lockend) {\n\t\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t\t   cur_offset, lockend + 1,\n\t\t\t\t\t   &drop_end, 1, 0, 0, NULL);\n\t\tif (ret != -ENOSPC)\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\t\tif (cur_offset < ino_size) {\n\t\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t\t drop_end);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur_offset = drop_end;\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\ttrans = btrfs_start_transaction(root, rsv_count);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size);\n\t\tBUG_ON(ret);\t/* shouldn't happen */\n\t\ttrans->block_rsv = rsv;\n\n\t\tret = find_first_non_hole(inode, &cur_offset, &len);\n\t\tif (unlikely(ret < 0))\n\t\t\tbreak;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_trans;\n\t}\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t/*\n\t * Don't insert file hole extent item if it's for a range beyond eof\n\t * (because it's useless) or if it represents a 0 bytes range (when\n\t * cur_offset == drop_end).\n\t */\n\tif (cur_offset < ino_size && cur_offset < drop_end) {\n\t\tret = fill_holes(trans, inode, path, cur_offset, drop_end);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_trans;\n\t\t}\n\t}\n\nout_trans:\n\tif (!trans)\n\t\tgoto out_free;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\tret = btrfs_update_inode(trans, root, inode);\n\tupdated_inode = true;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout_free:\n\tbtrfs_free_path(path);\n\tbtrfs_free_block_rsv(root, rsv);\nout:\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\nout_only_mutex:\n\tif (!updated_inode && truncated_page && !ret && !err) {\n\t\t/*\n\t\t * If we only end up zeroing part of a page, we still need to\n\t\t * update the inode item, so that all the time fields are\n\t\t * updated as well as the necessary btrfs inode in memory fields\n\t\t * for detecting, at fsync time, if the inode isn't yet in the\n\t\t * log tree or it's there but not up to date.\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t} else {\n\t\t\terr = btrfs_update_inode(trans, root, inode);\n\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t}\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret && !err)\n\t\terr = ret;\n\treturn err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "1"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_rsv",
          "args": [
            "root",
            "rsv"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4694-4701",
          "snippet": "void btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "root"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_holes",
          "args": [
            "trans",
            "inode",
            "path",
            "cur_offset",
            "drop_end"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "fill_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2128-2224",
          "snippet": "static int fill_holes(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t      struct btrfs_path *path, u64 offset, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_map *hole_em;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (btrfs_fs_incompat(root->fs_info, NO_HOLES))\n\t\tgoto out;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tBUG_ON(!ret);\n\n\tleaf = path->nodes[0];\n\tif (hole_mergeable(inode, leaf, path->slots[0]-1, offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tpath->slots[0]--;\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) +\n\t\t\tend - offset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\n\tif (hole_mergeable(inode, leaf, path->slots[0], offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tkey.offset = offset;\n\t\tbtrfs_set_item_key_safe(root, path, &key);\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) + end -\n\t\t\toffset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_insert_file_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       0, 0, end - offset, 0, end - offset,\n\t\t\t\t       0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tbtrfs_release_path(path);\n\n\thole_em = alloc_extent_map();\n\tif (!hole_em) {\n\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\thole_em->start = offset;\n\t\thole_em->len = end - offset;\n\t\thole_em->ram_bytes = hole_em->len;\n\t\thole_em->orig_start = offset;\n\n\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\thole_em->block_len = 0;\n\t\thole_em->orig_block_len = 0;\n\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\thole_em->generation = trans->transid;\n\n\t\tdo {\n\t\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\t\twrite_lock(&em_tree->lock);\n\t\t\tret = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t} while (ret == -EEXIST);\n\t\tfree_extent_map(hole_em);\n\t\tif (ret)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int fill_holes(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t      struct btrfs_path *path, u64 offset, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_map *hole_em;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (btrfs_fs_incompat(root->fs_info, NO_HOLES))\n\t\tgoto out;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tBUG_ON(!ret);\n\n\tleaf = path->nodes[0];\n\tif (hole_mergeable(inode, leaf, path->slots[0]-1, offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tpath->slots[0]--;\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) +\n\t\t\tend - offset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\n\tif (hole_mergeable(inode, leaf, path->slots[0], offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tkey.offset = offset;\n\t\tbtrfs_set_item_key_safe(root, path, &key);\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) + end -\n\t\t\toffset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_insert_file_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       0, 0, end - offset, 0, end - offset,\n\t\t\t\t       0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tbtrfs_release_path(path);\n\n\thole_em = alloc_extent_map();\n\tif (!hole_em) {\n\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\thole_em->start = offset;\n\t\thole_em->len = end - offset;\n\t\thole_em->ram_bytes = hole_em->len;\n\t\thole_em->orig_start = offset;\n\n\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\thole_em->block_len = 0;\n\t\thole_em->orig_block_len = 0;\n\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\thole_em->generation = trans->transid;\n\n\t\tdo {\n\t\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\t\twrite_lock(&em_tree->lock);\n\t\t\tret = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t} while (ret == -EEXIST);\n\t\tfree_extent_map(hole_em);\n\t\tif (ret)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_non_hole",
          "args": [
            "inode",
            "&cur_offset",
            "&len"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_non_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2232-2255",
          "snippet": "static int find_first_non_hole(struct inode *inode, u64 *start, u64 *len)\n{\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = btrfs_get_extent(inode, NULL, 0, *start, *len, 0);\n\tif (IS_ERR_OR_NULL(em)) {\n\t\tif (!em)\n\t\t\tret = -ENOMEM;\n\t\telse\n\t\t\tret = PTR_ERR(em);\n\t\treturn ret;\n\t}\n\n\t/* Hole or vacuum extent(only exists in no-hole mode) */\n\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\tret = 1;\n\t\t*len = em->start + em->len > *start + *len ?\n\t\t       0 : *start + *len - em->start - em->len;\n\t\t*start = em->start + em->len;\n\t}\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int find_first_non_hole(struct inode *inode, u64 *start, u64 *len)\n{\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = btrfs_get_extent(inode, NULL, 0, *start, *len, 0);\n\tif (IS_ERR_OR_NULL(em)) {\n\t\tif (!em)\n\t\t\tret = -ENOMEM;\n\t\telse\n\t\t\tret = PTR_ERR(em);\n\t\treturn ret;\n\t}\n\n\t/* Hole or vacuum extent(only exists in no-hole mode) */\n\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\tret = 1;\n\t\t*len = em->start + em->len > *start + *len ?\n\t\t       0 : *start + *len - em->start - em->len;\n\t\t*start = em->start + em->len;\n\t}\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_migrate",
          "args": [
            "&root->fs_info->trans_block_rsv",
            "rsv",
            "min_size"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4769-4774",
          "snippet": "int btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_drop_extents",
          "args": [
            "trans",
            "root",
            "inode",
            "path",
            "cur_offset",
            "lockend + 1",
            "&drop_end",
            "1",
            "0",
            "0",
            "NULL"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_drop_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "695-1011",
          "snippet": "int __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trunc_metadata_size",
          "args": [
            "root",
            "1"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trunc_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3309-3313",
          "snippet": "static inline u64 btrfs_calc_trunc_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn root->nodesize * BTRFS_MAX_LEVEL * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trunc_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn root->nodesize * BTRFS_MAX_LEVEL * num_items;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_block_rsv",
          "args": [
            "root",
            "BTRFS_BLOCK_RSV_TEMP"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4678-4692",
          "snippet": "struct btrfs_block_rsv *btrfs_alloc_block_rsv(struct btrfs_root *root,\n\t\t\t\t\t      unsigned short type)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tblock_rsv = kmalloc(sizeof(*block_rsv), GFP_NOFS);\n\tif (!block_rsv)\n\t\treturn NULL;\n\n\tbtrfs_init_block_rsv(block_rsv, type);\n\tblock_rsv->space_info = __find_space_info(fs_info,\n\t\t\t\t\t\t  BTRFS_BLOCK_GROUP_METADATA);\n\treturn block_rsv;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_rsv *btrfs_alloc_block_rsv(struct btrfs_root *root,\n\t\t\t\t\t      unsigned short type)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tblock_rsv = kmalloc(sizeof(*block_rsv), GFP_NOFS);\n\tif (!block_rsv)\n\t\treturn NULL;\n\n\tbtrfs_init_block_rsv(block_rsv, type);\n\tblock_rsv->space_info = __find_space_info(fs_info,\n\t\t\t\t\t\t  BTRFS_BLOCK_GROUP_METADATA);\n\treturn block_rsv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "inode",
            "lockstart",
            "lockend - lockstart + 1"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_page_exists_in_range",
          "args": [
            "inode",
            "lockstart",
            "lockend"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_first_ordered_extent",
          "args": [
            "inode",
            "lockend"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_first_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "845-863",
          "snippet": "struct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "0",
            "&cached_state"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "lockstart",
            "lockend"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_page",
          "args": [
            "inode",
            "tail_start + tail_len",
            "0",
            "1"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4433-4534",
          "snippet": "int btrfs_truncate_page(struct inode *inode, loff_t from, loff_t len,\n\t\t\tint front)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tchar *kaddr;\n\tu32 blocksize = root->sectorsize;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(mapping);\n\tint ret = 0;\n\tu64 page_start;\n\tu64 page_end;\n\n\tif ((offset & (blocksize - 1)) == 0 &&\n\t    (!len || ((len & (blocksize - 1)) == 0)))\n\t\tgoto out;\n\tret = btrfs_delalloc_reserve_space(inode, PAGE_CACHE_SIZE);\n\tif (ret)\n\t\tgoto out;\n\nagain:\n\tpage = find_or_create_page(mapping, index, mask);\n\tif (!page) {\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\tif (!PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tlock_page(page);\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\twait_on_page_writeback(page);\n\n\tlock_extent_bits(io_tree, page_start, page_end, 0, &cached_state);\n\tset_page_extent_mapped(page);\n\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start, page_end,\n\t\t\t  EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t  0, 0, &cached_state, GFP_NOFS);\n\n\tret = btrfs_set_extent_delalloc(inode, page_start, page_end,\n\t\t\t\t\t&cached_state);\n\tif (ret) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tgoto out_unlock;\n\t}\n\n\tif (offset != PAGE_CACHE_SIZE) {\n\t\tif (!len)\n\t\t\tlen = PAGE_CACHE_SIZE - offset;\n\t\tkaddr = kmap(page);\n\t\tif (front)\n\t\t\tmemset(kaddr, 0, offset);\n\t\telse\n\t\t\tmemset(kaddr + offset, 0, len);\n\t\tflush_dcache_page(page);\n\t\tkunmap(page);\n\t}\n\tClearPageChecked(page);\n\tset_page_dirty(page);\n\tunlock_extent_cached(io_tree, page_start, page_end, &cached_state,\n\t\t\t     GFP_NOFS);\n\nout_unlock:\n\tif (ret)\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_truncate_page(struct inode *inode, loff_t from, loff_t len,\n\t\t\tint front)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tchar *kaddr;\n\tu32 blocksize = root->sectorsize;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tstruct page *page;\n\tgfp_t mask = btrfs_alloc_write_mask(mapping);\n\tint ret = 0;\n\tu64 page_start;\n\tu64 page_end;\n\n\tif ((offset & (blocksize - 1)) == 0 &&\n\t    (!len || ((len & (blocksize - 1)) == 0)))\n\t\tgoto out;\n\tret = btrfs_delalloc_reserve_space(inode, PAGE_CACHE_SIZE);\n\tif (ret)\n\t\tgoto out;\n\nagain:\n\tpage = find_or_create_page(mapping, index, mask);\n\tif (!page) {\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage_start = page_offset(page);\n\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\tif (!PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tlock_page(page);\n\t\tif (page->mapping != mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\twait_on_page_writeback(page);\n\n\tlock_extent_bits(io_tree, page_start, page_end, 0, &cached_state);\n\tset_page_extent_mapped(page);\n\n\tordered = btrfs_lookup_ordered_extent(inode, page_start);\n\tif (ordered) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tgoto again;\n\t}\n\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start, page_end,\n\t\t\t  EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t  0, 0, &cached_state, GFP_NOFS);\n\n\tret = btrfs_set_extent_delalloc(inode, page_start, page_end,\n\t\t\t\t\t&cached_state);\n\tif (ret) {\n\t\tunlock_extent_cached(io_tree, page_start, page_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tgoto out_unlock;\n\t}\n\n\tif (offset != PAGE_CACHE_SIZE) {\n\t\tif (!len)\n\t\t\tlen = PAGE_CACHE_SIZE - offset;\n\t\tkaddr = kmap(page);\n\t\tif (front)\n\t\t\tmemset(kaddr, 0, offset);\n\t\telse\n\t\t\tmemset(kaddr + offset, 0, len);\n\t\tflush_dcache_page(page);\n\t\tkunmap(page);\n\t}\n\tClearPageChecked(page);\n\tset_page_dirty(page);\n\tunlock_extent_cached(io_tree, page_start, page_end, &cached_state,\n\t\t\t     GFP_NOFS);\n\nout_unlock:\n\tif (ret)\n\t\tbtrfs_delalloc_release_space(inode, PAGE_CACHE_SIZE);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "offset + len",
            "BTRFS_I(inode)->root->sectorsize"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset",
            "BTRFS_I(inode)->root->sectorsize"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "inode->i_size",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "root->fs_info",
            "NO_HOLES"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int btrfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct btrfs_trans_handle *trans;\n\tu64 lockstart;\n\tu64 lockend;\n\tu64 tail_start;\n\tu64 tail_len;\n\tu64 orig_start = offset;\n\tu64 cur_offset;\n\tu64 min_size = btrfs_calc_trunc_metadata_size(root, 1);\n\tu64 drop_end;\n\tint ret = 0;\n\tint err = 0;\n\tint rsv_count;\n\tbool same_page;\n\tbool no_holes = btrfs_fs_incompat(root->fs_info, NO_HOLES);\n\tu64 ino_size;\n\tbool truncated_page = false;\n\tbool updated_inode = false;\n\n\tret = btrfs_wait_ordered_range(inode, offset, len);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tino_size = round_up(inode->i_size, PAGE_CACHE_SIZE);\n\tret = find_first_non_hole(inode, &offset, &len);\n\tif (ret < 0)\n\t\tgoto out_only_mutex;\n\tif (ret && !len) {\n\t\t/* Already in a large hole */\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\tlockstart = round_up(offset, BTRFS_I(inode)->root->sectorsize);\n\tlockend = round_down(offset + len,\n\t\t\t     BTRFS_I(inode)->root->sectorsize) - 1;\n\tsame_page = ((offset >> PAGE_CACHE_SHIFT) ==\n\t\t    ((offset + len - 1) >> PAGE_CACHE_SHIFT));\n\n\t/*\n\t * We needn't truncate any page which is beyond the end of the file\n\t * because we are sure there is no data there.\n\t */\n\t/*\n\t * Only do this if we are in the same page and we aren't doing the\n\t * entire page.\n\t */\n\tif (same_page && len < PAGE_CACHE_SIZE) {\n\t\tif (offset < ino_size) {\n\t\t\ttruncated_page = true;\n\t\t\tret = btrfs_truncate_page(inode, offset, len, 0);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tgoto out_only_mutex;\n\t}\n\n\t/* zero back part of the first page */\n\tif (offset < ino_size) {\n\t\ttruncated_page = true;\n\t\tret = btrfs_truncate_page(inode, offset, 0, 0);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Check the aligned pages after the first unaligned page,\n\t * if offset != orig_start, which means the first unaligned page\n\t * including serveral following pages are already in holes,\n\t * the extra check can be skipped */\n\tif (offset == orig_start) {\n\t\t/* after truncate page, check hole again */\n\t\tlen = offset + len - lockstart;\n\t\toffset = lockstart;\n\t\tret = find_first_non_hole(inode, &offset, &len);\n\t\tif (ret < 0)\n\t\t\tgoto out_only_mutex;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tgoto out_only_mutex;\n\t\t}\n\t\tlockstart = offset;\n\t}\n\n\t/* Check the tail unaligned part is in a hole */\n\ttail_start = lockend + 1;\n\ttail_len = offset + len - tail_start;\n\tif (tail_len) {\n\t\tret = find_first_non_hole(inode, &tail_start, &tail_len);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto out_only_mutex;\n\t\tif (!ret) {\n\t\t\t/* zero the front end of the last page */\n\t\t\tif (tail_start + tail_len < ino_size) {\n\t\t\t\ttruncated_page = true;\n\t\t\t\tret = btrfs_truncate_page(inode,\n\t\t\t\t\t\ttail_start + tail_len, 0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_only_mutex;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lockend < lockstart) {\n\t\tret = 0;\n\t\tgoto out_only_mutex;\n\t}\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\ttruncate_pagecache_range(inode, lockstart, lockend);\n\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t\t 0, &cached_state);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, lockend);\n\n\t\t/*\n\t\t * We need to make sure we have no ordered extents in this range\n\t\t * and nobody raced in and read a page in this range, if we did\n\t\t * we need to try again.\n\t\t */\n\t\tif ((!ordered ||\n\t\t    (ordered->file_offset + ordered->len <= lockstart ||\n\t\t     ordered->file_offset > lockend)) &&\n\t\t     !btrfs_page_exists_in_range(inode, lockstart, lockend)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t     lockend, &cached_state, GFP_NOFS);\n\t\tret = btrfs_wait_ordered_range(inode, lockstart,\n\t\t\t\t\t       lockend - lockstart + 1);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\tif (!rsv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\trsv->size = btrfs_calc_trunc_metadata_size(root, 1);\n\trsv->failfast = 1;\n\n\t/*\n\t * 1 - update the inode\n\t * 1 - removing the extents in the range\n\t * 1 - adding the hole extent if no_holes isn't set\n\t */\n\trsv_count = no_holes ? 2 : 3;\n\ttrans = btrfs_start_transaction(root, rsv_count);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv, rsv,\n\t\t\t\t      min_size);\n\tBUG_ON(ret);\n\ttrans->block_rsv = rsv;\n\n\tcur_offset = lockstart;\n\tlen = lockend - cur_offset;\n\twhile (cur_offset < lockend) {\n\t\tret = __btrfs_drop_extents(trans, root, inode, path,\n\t\t\t\t\t   cur_offset, lockend + 1,\n\t\t\t\t\t   &drop_end, 1, 0, 0, NULL);\n\t\tif (ret != -ENOSPC)\n\t\t\tbreak;\n\n\t\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\t\tif (cur_offset < ino_size) {\n\t\t\tret = fill_holes(trans, inode, path, cur_offset,\n\t\t\t\t\t drop_end);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcur_offset = drop_end;\n\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\ttrans = btrfs_start_transaction(root, rsv_count);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_block_rsv_migrate(&root->fs_info->trans_block_rsv,\n\t\t\t\t\t      rsv, min_size);\n\t\tBUG_ON(ret);\t/* shouldn't happen */\n\t\ttrans->block_rsv = rsv;\n\n\t\tret = find_first_non_hole(inode, &cur_offset, &len);\n\t\tif (unlikely(ret < 0))\n\t\t\tbreak;\n\t\tif (ret && !len) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_trans;\n\t}\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\t/*\n\t * Don't insert file hole extent item if it's for a range beyond eof\n\t * (because it's useless) or if it represents a 0 bytes range (when\n\t * cur_offset == drop_end).\n\t */\n\tif (cur_offset < ino_size && cur_offset < drop_end) {\n\t\tret = fill_holes(trans, inode, path, cur_offset, drop_end);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_trans;\n\t\t}\n\t}\n\nout_trans:\n\tif (!trans)\n\t\tgoto out_free;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\tret = btrfs_update_inode(trans, root, inode);\n\tupdated_inode = true;\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout_free:\n\tbtrfs_free_path(path);\n\tbtrfs_free_block_rsv(root, rsv);\nout:\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, lockstart, lockend,\n\t\t\t     &cached_state, GFP_NOFS);\nout_only_mutex:\n\tif (!updated_inode && truncated_page && !ret && !err) {\n\t\t/*\n\t\t * If we only end up zeroing part of a page, we still need to\n\t\t * update the inode item, so that all the time fields are\n\t\t * updated as well as the necessary btrfs inode in memory fields\n\t\t * for detecting, at fsync time, if the inode isn't yet in the\n\t\t * log tree or it's there but not up to date.\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 1);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t} else {\n\t\t\terr = btrfs_update_inode(trans, root, inode);\n\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t}\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret && !err)\n\t\terr = ret;\n\treturn err;\n}"
  },
  {
    "function_name": "find_first_non_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2232-2255",
    "snippet": "static int find_first_non_hole(struct inode *inode, u64 *start, u64 *len)\n{\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = btrfs_get_extent(inode, NULL, 0, *start, *len, 0);\n\tif (IS_ERR_OR_NULL(em)) {\n\t\tif (!em)\n\t\t\tret = -ENOMEM;\n\t\telse\n\t\t\tret = PTR_ERR(em);\n\t\treturn ret;\n\t}\n\n\t/* Hole or vacuum extent(only exists in no-hole mode) */\n\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\tret = 1;\n\t\t*len = em->start + em->len > *start + *len ?\n\t\t       0 : *start + *len - em->start - em->len;\n\t\t*start = em->start + em->len;\n\t}\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "*start",
            "*len",
            "0"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int find_first_non_hole(struct inode *inode, u64 *start, u64 *len)\n{\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = btrfs_get_extent(inode, NULL, 0, *start, *len, 0);\n\tif (IS_ERR_OR_NULL(em)) {\n\t\tif (!em)\n\t\t\tret = -ENOMEM;\n\t\telse\n\t\t\tret = PTR_ERR(em);\n\t\treturn ret;\n\t}\n\n\t/* Hole or vacuum extent(only exists in no-hole mode) */\n\tif (em->block_start == EXTENT_MAP_HOLE) {\n\t\tret = 1;\n\t\t*len = em->start + em->len > *start + *len ?\n\t\t       0 : *start + *len - em->start - em->len;\n\t\t*start = em->start + em->len;\n\t}\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "fill_holes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2128-2224",
    "snippet": "static int fill_holes(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t      struct btrfs_path *path, u64 offset, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_map *hole_em;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (btrfs_fs_incompat(root->fs_info, NO_HOLES))\n\t\tgoto out;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tBUG_ON(!ret);\n\n\tleaf = path->nodes[0];\n\tif (hole_mergeable(inode, leaf, path->slots[0]-1, offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tpath->slots[0]--;\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) +\n\t\t\tend - offset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\n\tif (hole_mergeable(inode, leaf, path->slots[0], offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tkey.offset = offset;\n\t\tbtrfs_set_item_key_safe(root, path, &key);\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) + end -\n\t\t\toffset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_insert_file_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       0, 0, end - offset, 0, end - offset,\n\t\t\t\t       0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tbtrfs_release_path(path);\n\n\thole_em = alloc_extent_map();\n\tif (!hole_em) {\n\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\thole_em->start = offset;\n\t\thole_em->len = end - offset;\n\t\thole_em->ram_bytes = hole_em->len;\n\t\thole_em->orig_start = offset;\n\n\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\thole_em->block_len = 0;\n\t\thole_em->orig_block_len = 0;\n\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\thole_em->generation = trans->transid;\n\n\t\tdo {\n\t\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\t\twrite_lock(&em_tree->lock);\n\t\t\tret = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t} while (ret == -EEXIST);\n\t\tfree_extent_map(hole_em);\n\t\tif (ret)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_NEEDS_FULL_SYNC",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "hole_em"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "hole_em",
            "1"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "offset",
            "end - 1",
            "0"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_file_extent",
          "args": [
            "trans",
            "root",
            "btrfs_ino(inode)",
            "offset",
            "0",
            "0",
            "end - offset",
            "0",
            "end - offset",
            "0",
            "0",
            "0"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "40-84",
          "snippet": "int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "0"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_ram_bytes",
          "args": [
            "leaf",
            "fi",
            "num_bytes"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "num_bytes"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key_safe",
          "args": [
            "root",
            "path",
            "&key"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hole_mergeable",
          "args": [
            "inode",
            "leaf",
            "path->slots[0]",
            "offset",
            "end"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "hole_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2099-2126",
          "snippet": "static int hole_mergeable(struct inode *inode, struct extent_buffer *leaf,\n\t\t\t  int slot, u64 start, u64 end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi))\n\t\treturn 0;\n\n\tif (key.offset == end)\n\t\treturn 1;\n\tif (key.offset + btrfs_file_extent_num_bytes(leaf, fi) == start)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int hole_mergeable(struct inode *inode, struct extent_buffer *leaf,\n\t\t\t  int slot, u64 start, u64 end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi))\n\t\treturn 0;\n\n\tif (key.offset == end)\n\t\treturn 1;\n\tif (key.offset + btrfs_file_extent_num_bytes(leaf, fi) == start)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "0"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_ram_bytes",
          "args": [
            "leaf",
            "fi",
            "num_bytes"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "num_bytes"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "root->fs_info",
            "NO_HOLES"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int fill_holes(struct btrfs_trans_handle *trans, struct inode *inode,\n\t\t      struct btrfs_path *path, u64 offset, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_map *hole_em;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (btrfs_fs_incompat(root->fs_info, NO_HOLES))\n\t\tgoto out;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\tBUG_ON(!ret);\n\n\tleaf = path->nodes[0];\n\tif (hole_mergeable(inode, leaf, path->slots[0]-1, offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tpath->slots[0]--;\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) +\n\t\t\tend - offset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\n\tif (hole_mergeable(inode, leaf, path->slots[0], offset, end)) {\n\t\tu64 num_bytes;\n\n\t\tkey.offset = offset;\n\t\tbtrfs_set_item_key_safe(root, path, &key);\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tnum_bytes = btrfs_file_extent_num_bytes(leaf, fi) + end -\n\t\t\toffset;\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, num_bytes);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, 0);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_insert_file_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       0, 0, end - offset, 0, end - offset,\n\t\t\t\t       0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tbtrfs_release_path(path);\n\n\thole_em = alloc_extent_map();\n\tif (!hole_em) {\n\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\thole_em->start = offset;\n\t\thole_em->len = end - offset;\n\t\thole_em->ram_bytes = hole_em->len;\n\t\thole_em->orig_start = offset;\n\n\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\thole_em->block_len = 0;\n\t\thole_em->orig_block_len = 0;\n\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\thole_em->generation = trans->transid;\n\n\t\tdo {\n\t\t\tbtrfs_drop_extent_cache(inode, offset, end - 1, 0);\n\t\t\twrite_lock(&em_tree->lock);\n\t\t\tret = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t} while (ret == -EEXIST);\n\t\tfree_extent_map(hole_em);\n\t\tif (ret)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hole_mergeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2099-2126",
    "snippet": "static int hole_mergeable(struct inode *inode, struct extent_buffer *leaf,\n\t\t\t  int slot, u64 start, u64 end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi))\n\t\treturn 0;\n\n\tif (key.offset == end)\n\t\treturn 1;\n\tif (key.offset + btrfs_file_extent_num_bytes(leaf, fi) == start)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int hole_mergeable(struct inode *inode, struct extent_buffer *leaf,\n\t\t\t  int slot, u64 start, u64 end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG)\n\t\treturn 0;\n\n\tif (btrfs_file_extent_disk_bytenr(leaf, fi))\n\t\treturn 0;\n\n\tif (key.offset == end)\n\t\treturn 1;\n\tif (key.offset + btrfs_file_extent_num_bytes(leaf, fi) == start)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "2086-2097",
    "snippet": "static int btrfs_file_mmap(struct file\t*filp, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\n\tfile_accessed(filp);\n\tvma->vm_ops = &btrfs_file_vm_ops;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct btrfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= btrfs_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "filp"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic const struct vm_operations_struct btrfs_file_vm_ops = {\n\t.fault\t\t= filemap_fault,\n\t.map_pages\t= filemap_map_pages,\n\t.page_mkwrite\t= btrfs_page_mkwrite,\n};\n\nstatic int btrfs_file_mmap(struct file\t*filp, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\n\tfile_accessed(filp);\n\tvma->vm_ops = &btrfs_file_vm_ops;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_sync_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1870-2078",
    "snippet": "int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_log_ctx ctx;\n\tint ret = 0;\n\tbool full_sync = 0;\n\n\ttrace_btrfs_sync_file(file, datasync);\n\n\t/*\n\t * We write the dirty pages in the range and wait until they complete\n\t * out of the ->i_mutex. If so, we can flush the dirty pages by\n\t * multi-task, and make the performance up.  See\n\t * btrfs_wait_ordered_range for an explanation of the ASYNC check.\n\t */\n\tret = start_ordered_ops(inode, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tatomic_inc(&root->log_batch);\n\tfull_sync = test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags);\n\t/*\n\t * We might have have had more pages made dirty after calling\n\t * start_ordered_ops and before acquiring the inode's i_mutex.\n\t */\n\tif (full_sync) {\n\t\t/*\n\t\t * For a full sync, we need to make sure any ordered operations\n\t\t * start and finish before we start logging the inode, so that\n\t\t * all extents are persisted and the respective file extent\n\t\t * items are in the fs/subvol btree.\n\t\t */\n\t\tret = btrfs_wait_ordered_range(inode, start, end - start + 1);\n\t} else {\n\t\t/*\n\t\t * Start any new ordered operations before starting to log the\n\t\t * inode. We will wait for them to finish in btrfs_sync_log().\n\t\t *\n\t\t * Right before acquiring the inode's mutex, we might have new\n\t\t * writes dirtying pages, which won't immediately start the\n\t\t * respective ordered operations - that is done through the\n\t\t * fill_delalloc callbacks invoked from the writepage and\n\t\t * writepages address space operations. So make sure we start\n\t\t * all ordered operations before starting to log our inode. Not\n\t\t * doing this means that while logging the inode, writeback\n\t\t * could start and invoke writepage/writepages, which would call\n\t\t * the fill_delalloc callbacks (cow_file_range,\n\t\t * submit_compressed_extents). These callbacks add first an\n\t\t * extent map to the modified list of extents and then create\n\t\t * the respective ordered operation, which means in\n\t\t * tree-log.c:btrfs_log_inode() we might capture all existing\n\t\t * ordered operations (with btrfs_get_logged_extents()) before\n\t\t * the fill_delalloc callback adds its ordered operation, and by\n\t\t * the time we visit the modified list of extent maps (with\n\t\t * btrfs_log_changed_extents()), we see and process the extent\n\t\t * map they created. We then use the extent map to construct a\n\t\t * file extent item for logging without waiting for the\n\t\t * respective ordered operation to finish - this file extent\n\t\t * item points to a disk location that might not have yet been\n\t\t * written to, containing random data - so after a crash a log\n\t\t * replay will make our inode have file extent items that point\n\t\t * to disk locations containing invalid data, as we returned\n\t\t * success to userspace without waiting for the respective\n\t\t * ordered operation to finish, because it wasn't captured by\n\t\t * btrfs_get_logged_extents().\n\t\t */\n\t\tret = start_ordered_ops(inode, start, end);\n\t}\n\tif (ret) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\tatomic_inc(&root->log_batch);\n\n\t/*\n\t * If the last transaction that changed this file was before the current\n\t * transaction and we have the full sync flag set in our inode, we can\n\t * bail out now without any syncing.\n\t *\n\t * Note that we can't bail out if the full sync flag isn't set. This is\n\t * because when the full sync flag is set we start all ordered extents\n\t * and wait for them to fully complete - when they complete they update\n\t * the inode's last_trans field through:\n\t *\n\t *     btrfs_finish_ordered_io() ->\n\t *         btrfs_update_inode_fallback() ->\n\t *             btrfs_update_inode() ->\n\t *                 btrfs_set_inode_last_trans()\n\t *\n\t * So we are sure that last_trans is up to date and can do this check to\n\t * bail out safely. For the fast path, when the full sync flag is not\n\t * set in our inode, we can not do it because we start only our ordered\n\t * extents and don't wait for them to complete (that is when\n\t * btrfs_finish_ordered_io runs), so here at this point their last_trans\n\t * value might be less than or equals to fs_info->last_trans_committed,\n\t * and setting a speculative last_trans for an inode when a buffered\n\t * write is made (such as fs_info->generation + 1 for example) would not\n\t * be reliable since after setting the value and before fsync is called\n\t * any number of transactions can start and commit (transaction kthread\n\t * commits the current transaction periodically), and a transaction\n\t * commit does not start nor waits for ordered extents to complete.\n\t */\n\tsmp_mb();\n\tif (btrfs_inode_in_log(inode, root->fs_info->generation) ||\n\t    (full_sync && BTRFS_I(inode)->last_trans <=\n\t     root->fs_info->last_trans_committed)) {\n\t\t/*\n\t\t * We'v had everything committed since the last time we were\n\t\t * modified so clear this flag in case it was set for whatever\n\t\t * reason, it's no longer relevant.\n\t\t */\n\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ok we haven't committed the transaction yet, lets do a commit\n\t */\n\tif (file->private_data)\n\t\tbtrfs_ioctl_trans_end(file);\n\n\t/*\n\t * We use start here because we will need to wait on the IO to complete\n\t * in btrfs_sync_log, which could require joining a transaction (for\n\t * example checking cross references in the nocow path).  If we use join\n\t * here we could get into a situation where we're waiting on IO to\n\t * happen that is blocked on a transaction trying to commit.  With start\n\t * we inc the extwriter counter, so we wait for all extwriters to exit\n\t * before we start blocking join'ers.  This comment is to keep somebody\n\t * from thinking they are super smart and changing this to\n\t * btrfs_join_transaction *cough*Josef*cough*.\n\t */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\ttrans->sync = true;\n\n\tbtrfs_init_log_ctx(&ctx);\n\n\tret = btrfs_log_dentry_safe(trans, root, dentry, start, end, &ctx);\n\tif (ret < 0) {\n\t\t/* Fallthrough and commit/free transaction. */\n\t\tret = 1;\n\t}\n\n\t/* we've logged all the items and now have a consistent\n\t * version of the file in the log.  It is possible that\n\t * someone will come in and modify the file, but that's\n\t * fine because the log is consistent on disk, and we\n\t * have references to all of the file's extents\n\t *\n\t * It is possible that someone will come in and log the\n\t * file again, but that will end up using the synchronization\n\t * inside btrfs_sync_log to keep things safe.\n\t */\n\tmutex_unlock(&inode->i_mutex);\n\n\t/*\n\t * If any of the ordered extents had an error, just return it to user\n\t * space, so that the application knows some writes didn't succeed and\n\t * can take proper action (retry for e.g.). Blindly committing the\n\t * transaction in this case, would fool userspace that everything was\n\t * successful. And we also want to make sure our log doesn't contain\n\t * file extent items pointing to extents that weren't fully written to -\n\t * just like in the non fast fsync path, where we check for the ordered\n\t * operation's error flag before writing to the log tree and return -EIO\n\t * if any of them had this flag set (btrfs_wait_ordered_range) -\n\t * therefore we need to check for errors in the ordered operations,\n\t * which are indicated by ctx.io_err.\n\t */\n\tif (ctx.io_err) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tret = ctx.io_err;\n\t\tgoto out;\n\t}\n\n\tif (ret != BTRFS_NO_LOG_SYNC) {\n\t\tif (!ret) {\n\t\t\tret = btrfs_sync_log(trans, root, &ctx);\n\t\t\tif (!ret) {\n\t\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!full_sync) {\n\t\t\tret = btrfs_wait_ordered_range(inode, start,\n\t\t\t\t\t\t       end - start + 1);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_end_transaction(trans, root);\n\t}\nout:\n\treturn ret > 0 ? -EIO : ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "inode",
            "start",
            "end - start + 1"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sync_log",
          "args": [
            "trans",
            "root",
            "&ctx"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sync_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2511-2757",
          "snippet": "int btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = root->fs_info->log_root_tree;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(trans, root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(trans, root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(root, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(trans, root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tret = -EAGAIN;\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tatomic_inc(&log_root_tree->log_batch);\n\tatomic_inc(&log_root_tree->log_writers);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tret = update_log_root(trans, log);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tif (atomic_dec_and_test(&log_root_tree->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&log_root_tree->log_writer_wait))\n\t\t\twake_up(&log_root_tree->log_writer_wait);\n\t}\n\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages,\n\t\t\t\t\t\tmark);\n\t\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\twait_for_writer(trans, log_root_tree);\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(log_root_tree,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_marked_extents(log_root_tree,\n\t\t\t\t\t\t&log_root_tree->dirty_log_pages,\n\t\t\t\t\t\tEXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_for_commit,\n\t\t\t\tlog_root_tree->node->start);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_for_commit,\n\t\t\t\tbtrfs_header_level(log_root_tree->node));\n\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * nobody else is going to jump in and write the the ctree\n\t * super here because the log_commit atomic below is protecting\n\t * us.  We must be called with a transaction handle pinning\n\t * the running transaction open, so a full commit can't hop\n\t * in and cause problems either.\n\t */\n\tret = write_ctree_super(trans, root->fs_info->tree_root, 1);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\t/*\n\t * We needn't get log_mutex here because we are sure all\n\t * the other tasks are blocked.\n\t */\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tif (waitqueue_active(&log_root_tree->log_commit_wait[index2]))\n\t\twake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\t/* See above. */\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\n\tmutex_lock(&root->log_mutex);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\tif (waitqueue_active(&root->log_commit_wait[index1]))\n\t\twake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nint btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = root->fs_info->log_root_tree;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(trans, root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(trans, root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(root, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(trans, root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tret = -EAGAIN;\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tatomic_inc(&log_root_tree->log_batch);\n\tatomic_inc(&log_root_tree->log_writers);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tret = update_log_root(trans, log);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tif (atomic_dec_and_test(&log_root_tree->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&log_root_tree->log_writer_wait))\n\t\t\twake_up(&log_root_tree->log_writer_wait);\n\t}\n\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages,\n\t\t\t\t\t\tmark);\n\t\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\twait_for_writer(trans, log_root_tree);\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(log_root_tree,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_marked_extents(log_root_tree,\n\t\t\t\t\t\t&log_root_tree->dirty_log_pages,\n\t\t\t\t\t\tEXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_for_commit,\n\t\t\t\tlog_root_tree->node->start);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_for_commit,\n\t\t\t\tbtrfs_header_level(log_root_tree->node));\n\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * nobody else is going to jump in and write the the ctree\n\t * super here because the log_commit atomic below is protecting\n\t * us.  We must be called with a transaction handle pinning\n\t * the running transaction open, so a full commit can't hop\n\t * in and cause problems either.\n\t */\n\tret = write_ctree_super(trans, root->fs_info->tree_root, 1);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\t/*\n\t * We needn't get log_mutex here because we are sure all\n\t * the other tasks are blocked.\n\t */\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tif (waitqueue_active(&log_root_tree->log_commit_wait[index2]))\n\t\twake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\t/* See above. */\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\n\tmutex_lock(&root->log_mutex);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\tif (waitqueue_active(&root->log_commit_wait[index1]))\n\t\twake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_log_dentry_safe",
          "args": [
            "trans",
            "root",
            "dentry",
            "start",
            "end",
            "&ctx"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_log_dentry_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "4509-4523",
          "snippet": "int btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct dentry *dentry,\n\t\t\t  const loff_t start,\n\t\t\t  const loff_t end,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent,\n\t\t\t\t     start, end, 0, ctx);\n\tdput(parent);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nint btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct dentry *dentry,\n\t\t\t  const loff_t start,\n\t\t\t  const loff_t end,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent,\n\t\t\t\t     start, end, 0, ctx);\n\tdput(parent);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_log_ctx",
          "args": [
            "&ctx"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_log_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "35-41",
          "snippet": "static inline void btrfs_init_log_ctx(struct btrfs_log_ctx *ctx)\n{\n\tctx->log_ret = 0;\n\tctx->log_transid = 0;\n\tctx->io_err = 0;\n\tINIT_LIST_HEAD(&ctx->list);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_init_log_ctx(struct btrfs_log_ctx *ctx)\n{\n\tctx->log_ret = 0;\n\tctx->log_transid = 0;\n\tctx->io_err = 0;\n\tINIT_LIST_HEAD(&ctx->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_trans_end",
          "args": [
            "file"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3995-4012",
          "snippet": "long btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nlong btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_INODE_NEEDS_FULL_SYNC",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_in_log",
          "args": [
            "inode",
            "root->fs_info->generation"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_in_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "251-269",
          "snippet": "static inline int btrfs_inode_in_log(struct inode *inode, u64 generation)\n{\n\tif (BTRFS_I(inode)->logged_trans == generation &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->last_log_commit &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->root->last_log_commit) {\n\t\t/*\n\t\t * After a ranged fsync we might have left some extent maps\n\t\t * (that fall outside the fsync's range). So return false\n\t\t * here if the list isn't empty, to make sure btrfs_log_inode()\n\t\t * will be called and process those extent maps.\n\t\t */\n\t\tsmp_mb();\n\t\tif (list_empty(&BTRFS_I(inode)->extent_tree.modified_extents))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline int btrfs_inode_in_log(struct inode *inode, u64 generation)\n{\n\tif (BTRFS_I(inode)->logged_trans == generation &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->last_log_commit &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->root->last_log_commit) {\n\t\t/*\n\t\t * After a ranged fsync we might have left some extent maps\n\t\t * (that fall outside the fsync's range). So return false\n\t\t * here if the list isn't empty, to make sure btrfs_log_inode()\n\t\t * will be called and process those extent maps.\n\t\t */\n\t\tsmp_mb();\n\t\tif (list_empty(&BTRFS_I(inode)->extent_tree.modified_extents))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_batch"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_ordered_ops",
          "args": [
            "inode",
            "start",
            "end"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "start_ordered_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1848-1857",
          "snippet": "static int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\tret = btrfs_fdatawrite_range(inode, start, end);\n\tatomic_dec(&BTRFS_I(inode)->sync_writers);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\tret = btrfs_fdatawrite_range(inode, start, end);\n\tatomic_dec(&BTRFS_I(inode)->sync_writers);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_NEEDS_FULL_SYNC",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_batch"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_sync_file",
          "args": [
            "file",
            "datasync"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_log_ctx ctx;\n\tint ret = 0;\n\tbool full_sync = 0;\n\n\ttrace_btrfs_sync_file(file, datasync);\n\n\t/*\n\t * We write the dirty pages in the range and wait until they complete\n\t * out of the ->i_mutex. If so, we can flush the dirty pages by\n\t * multi-task, and make the performance up.  See\n\t * btrfs_wait_ordered_range for an explanation of the ASYNC check.\n\t */\n\tret = start_ordered_ops(inode, start, end);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\tatomic_inc(&root->log_batch);\n\tfull_sync = test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags);\n\t/*\n\t * We might have have had more pages made dirty after calling\n\t * start_ordered_ops and before acquiring the inode's i_mutex.\n\t */\n\tif (full_sync) {\n\t\t/*\n\t\t * For a full sync, we need to make sure any ordered operations\n\t\t * start and finish before we start logging the inode, so that\n\t\t * all extents are persisted and the respective file extent\n\t\t * items are in the fs/subvol btree.\n\t\t */\n\t\tret = btrfs_wait_ordered_range(inode, start, end - start + 1);\n\t} else {\n\t\t/*\n\t\t * Start any new ordered operations before starting to log the\n\t\t * inode. We will wait for them to finish in btrfs_sync_log().\n\t\t *\n\t\t * Right before acquiring the inode's mutex, we might have new\n\t\t * writes dirtying pages, which won't immediately start the\n\t\t * respective ordered operations - that is done through the\n\t\t * fill_delalloc callbacks invoked from the writepage and\n\t\t * writepages address space operations. So make sure we start\n\t\t * all ordered operations before starting to log our inode. Not\n\t\t * doing this means that while logging the inode, writeback\n\t\t * could start and invoke writepage/writepages, which would call\n\t\t * the fill_delalloc callbacks (cow_file_range,\n\t\t * submit_compressed_extents). These callbacks add first an\n\t\t * extent map to the modified list of extents and then create\n\t\t * the respective ordered operation, which means in\n\t\t * tree-log.c:btrfs_log_inode() we might capture all existing\n\t\t * ordered operations (with btrfs_get_logged_extents()) before\n\t\t * the fill_delalloc callback adds its ordered operation, and by\n\t\t * the time we visit the modified list of extent maps (with\n\t\t * btrfs_log_changed_extents()), we see and process the extent\n\t\t * map they created. We then use the extent map to construct a\n\t\t * file extent item for logging without waiting for the\n\t\t * respective ordered operation to finish - this file extent\n\t\t * item points to a disk location that might not have yet been\n\t\t * written to, containing random data - so after a crash a log\n\t\t * replay will make our inode have file extent items that point\n\t\t * to disk locations containing invalid data, as we returned\n\t\t * success to userspace without waiting for the respective\n\t\t * ordered operation to finish, because it wasn't captured by\n\t\t * btrfs_get_logged_extents().\n\t\t */\n\t\tret = start_ordered_ops(inode, start, end);\n\t}\n\tif (ret) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\tatomic_inc(&root->log_batch);\n\n\t/*\n\t * If the last transaction that changed this file was before the current\n\t * transaction and we have the full sync flag set in our inode, we can\n\t * bail out now without any syncing.\n\t *\n\t * Note that we can't bail out if the full sync flag isn't set. This is\n\t * because when the full sync flag is set we start all ordered extents\n\t * and wait for them to fully complete - when they complete they update\n\t * the inode's last_trans field through:\n\t *\n\t *     btrfs_finish_ordered_io() ->\n\t *         btrfs_update_inode_fallback() ->\n\t *             btrfs_update_inode() ->\n\t *                 btrfs_set_inode_last_trans()\n\t *\n\t * So we are sure that last_trans is up to date and can do this check to\n\t * bail out safely. For the fast path, when the full sync flag is not\n\t * set in our inode, we can not do it because we start only our ordered\n\t * extents and don't wait for them to complete (that is when\n\t * btrfs_finish_ordered_io runs), so here at this point their last_trans\n\t * value might be less than or equals to fs_info->last_trans_committed,\n\t * and setting a speculative last_trans for an inode when a buffered\n\t * write is made (such as fs_info->generation + 1 for example) would not\n\t * be reliable since after setting the value and before fsync is called\n\t * any number of transactions can start and commit (transaction kthread\n\t * commits the current transaction periodically), and a transaction\n\t * commit does not start nor waits for ordered extents to complete.\n\t */\n\tsmp_mb();\n\tif (btrfs_inode_in_log(inode, root->fs_info->generation) ||\n\t    (full_sync && BTRFS_I(inode)->last_trans <=\n\t     root->fs_info->last_trans_committed)) {\n\t\t/*\n\t\t * We'v had everything committed since the last time we were\n\t\t * modified so clear this flag in case it was set for whatever\n\t\t * reason, it's no longer relevant.\n\t\t */\n\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * ok we haven't committed the transaction yet, lets do a commit\n\t */\n\tif (file->private_data)\n\t\tbtrfs_ioctl_trans_end(file);\n\n\t/*\n\t * We use start here because we will need to wait on the IO to complete\n\t * in btrfs_sync_log, which could require joining a transaction (for\n\t * example checking cross references in the nocow path).  If we use join\n\t * here we could get into a situation where we're waiting on IO to\n\t * happen that is blocked on a transaction trying to commit.  With start\n\t * we inc the extwriter counter, so we wait for all extwriters to exit\n\t * before we start blocking join'ers.  This comment is to keep somebody\n\t * from thinking they are super smart and changing this to\n\t * btrfs_join_transaction *cough*Josef*cough*.\n\t */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\ttrans->sync = true;\n\n\tbtrfs_init_log_ctx(&ctx);\n\n\tret = btrfs_log_dentry_safe(trans, root, dentry, start, end, &ctx);\n\tif (ret < 0) {\n\t\t/* Fallthrough and commit/free transaction. */\n\t\tret = 1;\n\t}\n\n\t/* we've logged all the items and now have a consistent\n\t * version of the file in the log.  It is possible that\n\t * someone will come in and modify the file, but that's\n\t * fine because the log is consistent on disk, and we\n\t * have references to all of the file's extents\n\t *\n\t * It is possible that someone will come in and log the\n\t * file again, but that will end up using the synchronization\n\t * inside btrfs_sync_log to keep things safe.\n\t */\n\tmutex_unlock(&inode->i_mutex);\n\n\t/*\n\t * If any of the ordered extents had an error, just return it to user\n\t * space, so that the application knows some writes didn't succeed and\n\t * can take proper action (retry for e.g.). Blindly committing the\n\t * transaction in this case, would fool userspace that everything was\n\t * successful. And we also want to make sure our log doesn't contain\n\t * file extent items pointing to extents that weren't fully written to -\n\t * just like in the non fast fsync path, where we check for the ordered\n\t * operation's error flag before writing to the log tree and return -EIO\n\t * if any of them had this flag set (btrfs_wait_ordered_range) -\n\t * therefore we need to check for errors in the ordered operations,\n\t * which are indicated by ctx.io_err.\n\t */\n\tif (ctx.io_err) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tret = ctx.io_err;\n\t\tgoto out;\n\t}\n\n\tif (ret != BTRFS_NO_LOG_SYNC) {\n\t\tif (!ret) {\n\t\t\tret = btrfs_sync_log(trans, root, &ctx);\n\t\t\tif (!ret) {\n\t\t\t\tret = btrfs_end_transaction(trans, root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!full_sync) {\n\t\t\tret = btrfs_wait_ordered_range(inode, start,\n\t\t\t\t\t\t       end - start + 1);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_end_transaction(trans, root);\n\t}\nout:\n\treturn ret > 0 ? -EIO : ret;\n}"
  },
  {
    "function_name": "start_ordered_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1848-1857",
    "snippet": "static int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\tret = btrfs_fdatawrite_range(inode, start, end);\n\tatomic_dec(&BTRFS_I(inode)->sync_writers);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&BTRFS_I(inode)->sync_writers"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fdatawrite_range",
          "args": [
            "inode",
            "start",
            "end"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2843-2867",
          "snippet": "int btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&BTRFS_I(inode)->sync_writers"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int start_ordered_ops(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\tret = btrfs_fdatawrite_range(inode, start, end);\n\tatomic_dec(&BTRFS_I(inode)->sync_writers);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1832-1846",
    "snippet": "int btrfs_release_file(struct inode *inode, struct file *filp)\n{\n\tif (filp->private_data)\n\t\tbtrfs_ioctl_trans_end(filp);\n\t/*\n\t * ordered_data_close is set by settattr when we are about to truncate\n\t * a file from a non-zero size to a zero size.  This tries to\n\t * flush down new bytes that may have been written if the\n\t * application were using truncate to replace a file in place.\n\t */\n\tif (test_and_clear_bit(BTRFS_INODE_ORDERED_DATA_CLOSE,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "BTRFS_INODE_ORDERED_DATA_CLOSE",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_trans_end",
          "args": [
            "filp"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3995-4012",
          "snippet": "long btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nlong btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_release_file(struct inode *inode, struct file *filp)\n{\n\tif (filp->private_data)\n\t\tbtrfs_ioctl_trans_end(filp);\n\t/*\n\t * ordered_data_close is set by settattr when we are about to truncate\n\t * a file from a non-zero size to a zero size.  This tries to\n\t * flush down new bytes that may have been written if the\n\t * application were using truncate to replace a file in place.\n\t */\n\tif (test_and_clear_bit(BTRFS_INODE_ORDERED_DATA_CLOSE,\n\t\t\t       &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1733-1830",
    "snippet": "static ssize_t btrfs_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 start_pos;\n\tu64 end_pos;\n\tssize_t num_written = 0;\n\tssize_t err = 0;\n\tsize_t count = iov_iter_count(from);\n\tbool sync = (file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host);\n\tloff_t pos = iocb->ki_pos;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\tif (count == 0) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\tiov_iter_truncate(from, count);\n\n\terr = file_remove_suid(file);\n\tif (err) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If BTRFS flips readonly due to some impossible error\n\t * (fs_info->fs_state now has BTRFS_SUPER_FLAG_ERROR),\n\t * although we have opened a file as writable, we have\n\t * to stop this write operation to ensure FS consistency.\n\t */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We reserve space for updating the inode when we reserve space for the\n\t * extent we are going to write, so we will enospc out there.  We don't\n\t * need to start yet another transaction to update the inode as we will\n\t * update the inode when we finish writing whatever data we write.\n\t */\n\tupdate_time_for_write(inode);\n\n\tstart_pos = round_down(pos, root->sectorsize);\n\tif (start_pos > i_size_read(inode)) {\n\t\t/* Expand hole size to cover write data, preventing empty gap */\n\t\tend_pos = round_up(pos + count, root->sectorsize);\n\t\terr = btrfs_cont_expand(inode, i_size_read(inode), end_pos);\n\t\tif (err) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sync)\n\t\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\n\tif (file->f_flags & O_DIRECT) {\n\t\tnum_written = __btrfs_direct_write(iocb, from, pos);\n\t} else {\n\t\tnum_written = __btrfs_buffered_write(file, from, pos);\n\t\tif (num_written > 0)\n\t\t\tiocb->ki_pos = pos + num_written;\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\t/*\n\t * We also have to set last_sub_trans to the current log transid,\n\t * otherwise subsequent syncs to a file that's been synced in this\n\t * transaction will appear to have already occured.\n\t */\n\tBTRFS_I(inode)->last_sub_trans = root->log_transid;\n\tif (num_written > 0) {\n\t\terr = generic_write_sync(file, pos, num_written);\n\t\tif (err < 0)\n\t\t\tnum_written = err;\n\t}\n\n\tif (sync)\n\t\tatomic_dec(&BTRFS_I(inode)->sync_writers);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn num_written ? num_written : err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&BTRFS_I(inode)->sync_writers"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "pos",
            "num_written"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_buffered_write",
          "args": [
            "file",
            "from",
            "pos"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_buffered_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1465-1672",
          "snippet": "static noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_direct_write",
          "args": [
            "iocb",
            "from",
            "pos"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1674-1713",
          "snippet": "static ssize_t __btrfs_direct_write(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from,\n\t\t\t\t    loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t written;\n\tssize_t written_buffered;\n\tloff_t endbyte;\n\tint err;\n\n\twritten = generic_file_direct_write(iocb, from, pos);\n\n\tif (written < 0 || !iov_iter_count(from))\n\t\treturn written;\n\n\tpos += written;\n\twritten_buffered = __btrfs_buffered_write(file, from, pos);\n\tif (written_buffered < 0) {\n\t\terr = written_buffered;\n\t\tgoto out;\n\t}\n\t/*\n\t * Ensure all data is persisted. We want the next direct IO read to be\n\t * able to read what was just written.\n\t */\n\tendbyte = pos + written_buffered - 1;\n\terr = btrfs_fdatawrite_range(inode, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\terr = filemap_fdatawait_range(inode->i_mapping, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\twritten += written_buffered;\n\tiocb->ki_pos = pos + written_buffered;\n\tinvalidate_mapping_pages(file->f_mapping, pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\nout:\n\treturn written ? written : err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic ssize_t __btrfs_direct_write(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from,\n\t\t\t\t    loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t written;\n\tssize_t written_buffered;\n\tloff_t endbyte;\n\tint err;\n\n\twritten = generic_file_direct_write(iocb, from, pos);\n\n\tif (written < 0 || !iov_iter_count(from))\n\t\treturn written;\n\n\tpos += written;\n\twritten_buffered = __btrfs_buffered_write(file, from, pos);\n\tif (written_buffered < 0) {\n\t\terr = written_buffered;\n\t\tgoto out;\n\t}\n\t/*\n\t * Ensure all data is persisted. We want the next direct IO read to be\n\t * able to read what was just written.\n\t */\n\tendbyte = pos + written_buffered - 1;\n\terr = btrfs_fdatawrite_range(inode, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\terr = filemap_fdatawait_range(inode->i_mapping, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\twritten += written_buffered;\n\tiocb->ki_pos = pos + written_buffered;\n\tinvalidate_mapping_pages(file->f_mapping, pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\nout:\n\treturn written ? written : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&BTRFS_I(inode)->sync_writers"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cont_expand",
          "args": [
            "inode",
            "i_size_read(inode)",
            "end_pos"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cont_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4585-4688",
          "snippet": "int btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "pos + count",
            "root->sectorsize"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "pos",
            "root->sectorsize"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_time_for_write",
          "args": [
            "inode"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "update_time_for_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1715-1731",
          "snippet": "static void update_time_for_write(struct inode *inode)\n{\n\tstruct timespec now;\n\n\tif (IS_NOCMTIME(inode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tinode->i_mtime = now;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tinode->i_ctime = now;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void update_time_for_write(struct inode *inode)\n{\n\tstruct timespec now;\n\n\tif (IS_NOCMTIME(inode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tinode->i_mtime = now;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tinode->i_ctime = now;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_remove_suid",
          "args": [
            "file"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1675-1700",
          "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic ssize_t btrfs_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 start_pos;\n\tu64 end_pos;\n\tssize_t num_written = 0;\n\tssize_t err = 0;\n\tsize_t count = iov_iter_count(from);\n\tbool sync = (file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host);\n\tloff_t pos = iocb->ki_pos;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\tif (count == 0) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\tiov_iter_truncate(from, count);\n\n\terr = file_remove_suid(file);\n\tif (err) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If BTRFS flips readonly due to some impossible error\n\t * (fs_info->fs_state now has BTRFS_SUPER_FLAG_ERROR),\n\t * although we have opened a file as writable, we have\n\t * to stop this write operation to ensure FS consistency.\n\t */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\terr = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We reserve space for updating the inode when we reserve space for the\n\t * extent we are going to write, so we will enospc out there.  We don't\n\t * need to start yet another transaction to update the inode as we will\n\t * update the inode when we finish writing whatever data we write.\n\t */\n\tupdate_time_for_write(inode);\n\n\tstart_pos = round_down(pos, root->sectorsize);\n\tif (start_pos > i_size_read(inode)) {\n\t\t/* Expand hole size to cover write data, preventing empty gap */\n\t\tend_pos = round_up(pos + count, root->sectorsize);\n\t\terr = btrfs_cont_expand(inode, i_size_read(inode), end_pos);\n\t\tif (err) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sync)\n\t\tatomic_inc(&BTRFS_I(inode)->sync_writers);\n\n\tif (file->f_flags & O_DIRECT) {\n\t\tnum_written = __btrfs_direct_write(iocb, from, pos);\n\t} else {\n\t\tnum_written = __btrfs_buffered_write(file, from, pos);\n\t\tif (num_written > 0)\n\t\t\tiocb->ki_pos = pos + num_written;\n\t}\n\n\tmutex_unlock(&inode->i_mutex);\n\n\t/*\n\t * We also have to set last_sub_trans to the current log transid,\n\t * otherwise subsequent syncs to a file that's been synced in this\n\t * transaction will appear to have already occured.\n\t */\n\tBTRFS_I(inode)->last_sub_trans = root->log_transid;\n\tif (num_written > 0) {\n\t\terr = generic_write_sync(file, pos, num_written);\n\t\tif (err < 0)\n\t\t\tnum_written = err;\n\t}\n\n\tif (sync)\n\t\tatomic_dec(&BTRFS_I(inode)->sync_writers);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn num_written ? num_written : err;\n}"
  },
  {
    "function_name": "update_time_for_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1715-1731",
    "snippet": "static void update_time_for_write(struct inode *inode)\n{\n\tstruct timespec now;\n\n\tif (IS_NOCMTIME(inode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tinode->i_mtime = now;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tinode->i_ctime = now;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_ctime",
            "&now"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_mtime",
            "&now"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOCMTIME",
          "args": [
            "inode"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void update_time_for_write(struct inode *inode)\n{\n\tstruct timespec now;\n\n\tif (IS_NOCMTIME(inode))\n\t\treturn;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tinode->i_mtime = now;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tinode->i_ctime = now;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n}"
  },
  {
    "function_name": "__btrfs_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1674-1713",
    "snippet": "static ssize_t __btrfs_direct_write(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from,\n\t\t\t\t    loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t written;\n\tssize_t written_buffered;\n\tloff_t endbyte;\n\tint err;\n\n\twritten = generic_file_direct_write(iocb, from, pos);\n\n\tif (written < 0 || !iov_iter_count(from))\n\t\treturn written;\n\n\tpos += written;\n\twritten_buffered = __btrfs_buffered_write(file, from, pos);\n\tif (written_buffered < 0) {\n\t\terr = written_buffered;\n\t\tgoto out;\n\t}\n\t/*\n\t * Ensure all data is persisted. We want the next direct IO read to be\n\t * able to read what was just written.\n\t */\n\tendbyte = pos + written_buffered - 1;\n\terr = btrfs_fdatawrite_range(inode, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\terr = filemap_fdatawait_range(inode->i_mapping, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\twritten += written_buffered;\n\tiocb->ki_pos = pos + written_buffered;\n\tinvalidate_mapping_pages(file->f_mapping, pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\nout:\n\treturn written ? written : err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "file->f_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "endbyte >> PAGE_CACHE_SHIFT"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "inode->i_mapping",
            "pos",
            "endbyte"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_fdatawrite_range",
          "args": [
            "inode",
            "pos",
            "endbyte"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fdatawrite_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2843-2867",
          "snippet": "int btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tint ret;\n\n\t/*\n\t * So with compression we will find and lock a dirty page and clear the\n\t * first one as dirty, setup an async extent, and immediately return\n\t * with the entire range locked but with nobody actually marked with\n\t * writeback.  So we can't just filemap_write_and_wait_range() and\n\t * expect it to work since it will just kick off a thread to do the\n\t * actual work.  So we need to call filemap_fdatawrite_range _again_\n\t * since it will wait on the page lock, which won't be unlocked until\n\t * after the pages have been marked as writeback and so we're good to go\n\t * from there.  We have to do this otherwise we'll miss the ordered\n\t * extents and that results in badness.  Please Josef, do not think you\n\t * know better and pull this out at some point in the future, it is\n\t * right and you are wrong.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (!ret && test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\tret = filemap_fdatawrite_range(inode->i_mapping, start, end);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_buffered_write",
          "args": [
            "file",
            "from",
            "pos"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_buffered_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1465-1672",
          "snippet": "static noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_direct_write",
          "args": [
            "iocb",
            "from",
            "pos"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic ssize_t __btrfs_direct_write(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from,\n\t\t\t\t    loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t written;\n\tssize_t written_buffered;\n\tloff_t endbyte;\n\tint err;\n\n\twritten = generic_file_direct_write(iocb, from, pos);\n\n\tif (written < 0 || !iov_iter_count(from))\n\t\treturn written;\n\n\tpos += written;\n\twritten_buffered = __btrfs_buffered_write(file, from, pos);\n\tif (written_buffered < 0) {\n\t\terr = written_buffered;\n\t\tgoto out;\n\t}\n\t/*\n\t * Ensure all data is persisted. We want the next direct IO read to be\n\t * able to read what was just written.\n\t */\n\tendbyte = pos + written_buffered - 1;\n\terr = btrfs_fdatawrite_range(inode, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\terr = filemap_fdatawait_range(inode->i_mapping, pos, endbyte);\n\tif (err)\n\t\tgoto out;\n\twritten += written_buffered;\n\tiocb->ki_pos = pos + written_buffered;\n\tinvalidate_mapping_pages(file->f_mapping, pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t endbyte >> PAGE_CACHE_SHIFT);\nout:\n\treturn written ? written : err;\n}"
  },
  {
    "function_name": "__btrfs_buffered_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1465-1672",
    "snippet": "static noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_space",
          "args": [
            "inode",
            "release_bytes"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5347-5351",
          "snippet": "void btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_metadata",
          "args": [
            "inode",
            "release_bytes"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5272-5300",
          "snippet": "void btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_write_no_snapshoting",
          "args": [
            "root"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_write_no_snapshoting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9780-9790",
          "snippet": "void btrfs_end_write_no_snapshoting(struct btrfs_root *root)\n{\n\tpercpu_counter_dec(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we wake up\n\t * waiters.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&root->subv_writers->wait))\n\t\twake_up(&root->subv_writers->wait);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_write_no_snapshoting(struct btrfs_root *root)\n{\n\tpercpu_counter_dec(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we wake up\n\t * waiters.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&root->subv_writers->wait))\n\t\twake_up(&root->subv_writers->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "root"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_drop_pages",
          "args": [
            "pages",
            "num_pages"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "468-482",
          "snippet": "static void btrfs_drop_pages(struct page **pages, size_t num_pages)\n{\n\tsize_t i;\n\tfor (i = 0; i < num_pages; i++) {\n\t\t/* page checked is some magic around finding pages that\n\t\t * have been modified without going through btrfs_set_page_dirty\n\t\t * clear it here. There should be no need to mark the pages\n\t\t * accessed as prepare_pages should have marked them accessed\n\t\t * in prepare_pages via find_or_create_page()\n\t\t */\n\t\tClearPageChecked(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void btrfs_drop_pages(struct page **pages, size_t num_pages)\n{\n\tsize_t i;\n\tfor (i = 0; i < num_pages; i++) {\n\t\t/* page checked is some magic around finding pages that\n\t\t * have been modified without going through btrfs_set_page_dirty\n\t\t * clear it here. There should be no need to mark the pages\n\t\t * accessed as prepare_pages should have marked them accessed\n\t\t * in prepare_pages via find_or_create_page()\n\t\t */\n\t\tClearPageChecked(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "EXTENT_NORESERVE",
            "NULL",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "pos",
            "root->sectorsize"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dirty_pages",
          "args": [
            "root",
            "inode",
            "pages",
            "dirty_pages",
            "pos",
            "copied",
            "NULL"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "492-529",
          "snippet": "int btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "copied + offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_copy_from_user",
          "args": [
            "pos",
            "num_pages",
            "write_bytes",
            "pages",
            "i"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "413-463",
          "snippet": "static noinline int btrfs_copy_from_user(loff_t pos, int num_pages,\n\t\t\t\t\t size_t write_bytes,\n\t\t\t\t\t struct page **prepared_pages,\n\t\t\t\t\t struct iov_iter *i)\n{\n\tsize_t copied = 0;\n\tsize_t total_copied = 0;\n\tint pg = 0;\n\tint offset = pos & (PAGE_CACHE_SIZE - 1);\n\n\twhile (write_bytes > 0) {\n\t\tsize_t count = min_t(size_t,\n\t\t\t\t     PAGE_CACHE_SIZE - offset, write_bytes);\n\t\tstruct page *page = prepared_pages[pg];\n\t\t/*\n\t\t * Copy data from userspace to the current page\n\t\t */\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, count);\n\n\t\t/* Flush processor's dcache for this page */\n\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * if we get a partial write, we can end up with\n\t\t * partially up to date pages.  These add\n\t\t * a lot of complexity, so make sure they don't\n\t\t * happen by forcing this copy to be retried.\n\t\t *\n\t\t * The rest of the btrfs_file_write code will fall\n\t\t * back to page at a time copies after we return 0.\n\t\t */\n\t\tif (!PageUptodate(page) && copied < count)\n\t\t\tcopied = 0;\n\n\t\tiov_iter_advance(i, copied);\n\t\twrite_bytes -= copied;\n\t\ttotal_copied += copied;\n\n\t\t/* Return to btrfs_file_write_iter to fault page */\n\t\tif (unlikely(copied == 0))\n\t\t\tbreak;\n\n\t\tif (copied < PAGE_CACHE_SIZE - offset) {\n\t\t\toffset += copied;\n\t\t} else {\n\t\t\tpg++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn total_copied;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int btrfs_copy_from_user(loff_t pos, int num_pages,\n\t\t\t\t\t size_t write_bytes,\n\t\t\t\t\t struct page **prepared_pages,\n\t\t\t\t\t struct iov_iter *i)\n{\n\tsize_t copied = 0;\n\tsize_t total_copied = 0;\n\tint pg = 0;\n\tint offset = pos & (PAGE_CACHE_SIZE - 1);\n\n\twhile (write_bytes > 0) {\n\t\tsize_t count = min_t(size_t,\n\t\t\t\t     PAGE_CACHE_SIZE - offset, write_bytes);\n\t\tstruct page *page = prepared_pages[pg];\n\t\t/*\n\t\t * Copy data from userspace to the current page\n\t\t */\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, count);\n\n\t\t/* Flush processor's dcache for this page */\n\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * if we get a partial write, we can end up with\n\t\t * partially up to date pages.  These add\n\t\t * a lot of complexity, so make sure they don't\n\t\t * happen by forcing this copy to be retried.\n\t\t *\n\t\t * The rest of the btrfs_file_write code will fall\n\t\t * back to page at a time copies after we return 0.\n\t\t */\n\t\tif (!PageUptodate(page) && copied < count)\n\t\t\tcopied = 0;\n\n\t\tiov_iter_advance(i, copied);\n\t\twrite_bytes -= copied;\n\t\ttotal_copied += copied;\n\n\t\t/* Return to btrfs_file_write_iter to fault page */\n\t\tif (unlikely(copied == 0))\n\t\t\tbreak;\n\n\t\tif (copied < PAGE_CACHE_SIZE - offset) {\n\t\t\toffset += copied;\n\t\t} else {\n\t\t\tpg++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn total_copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_and_cleanup_extent_if_need",
          "args": [
            "inode",
            "pages",
            "num_pages",
            "pos",
            "&lockstart",
            "&lockend",
            "&cached_state"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "lock_and_cleanup_extent_if_need",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1366-1420",
          "snippet": "static noinline int\nlock_and_cleanup_extent_if_need(struct inode *inode, struct page **pages,\n\t\t\t\tsize_t num_pages, loff_t pos,\n\t\t\t\tu64 *lockstart, u64 *lockend,\n\t\t\t\tstruct extent_state **cached_state)\n{\n\tu64 start_pos;\n\tu64 last_pos;\n\tint i;\n\tint ret = 0;\n\n\tstart_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);\n\tlast_pos = start_pos + ((u64)num_pages << PAGE_CACHE_SHIFT) - 1;\n\n\tif (start_pos < inode->i_size) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t start_pos, last_pos, 0, cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start_pos,\n\t\t\t\t\t\t     last_pos - start_pos + 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > start_pos &&\n\t\t    ordered->file_offset <= last_pos) {\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     start_pos, last_pos,\n\t\t\t\t\t     cached_state, GFP_NOFS);\n\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\tunlock_page(pages[i]);\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t}\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, start_pos,\n\t\t\t\t  last_pos, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t\t  0, 0, cached_state, GFP_NOFS);\n\t\t*lockstart = start_pos;\n\t\t*lockend = last_pos;\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (clear_page_dirty_for_io(pages[i]))\n\t\t\taccount_page_redirty(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tWARN_ON(!PageLocked(pages[i]));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int\nlock_and_cleanup_extent_if_need(struct inode *inode, struct page **pages,\n\t\t\t\tsize_t num_pages, loff_t pos,\n\t\t\t\tu64 *lockstart, u64 *lockend,\n\t\t\t\tstruct extent_state **cached_state)\n{\n\tu64 start_pos;\n\tu64 last_pos;\n\tint i;\n\tint ret = 0;\n\n\tstart_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);\n\tlast_pos = start_pos + ((u64)num_pages << PAGE_CACHE_SHIFT) - 1;\n\n\tif (start_pos < inode->i_size) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t start_pos, last_pos, 0, cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start_pos,\n\t\t\t\t\t\t     last_pos - start_pos + 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > start_pos &&\n\t\t    ordered->file_offset <= last_pos) {\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     start_pos, last_pos,\n\t\t\t\t\t     cached_state, GFP_NOFS);\n\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\tunlock_page(pages[i]);\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t}\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, start_pos,\n\t\t\t\t  last_pos, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t\t  0, 0, cached_state, GFP_NOFS);\n\t\t*lockstart = start_pos;\n\t\t*lockend = last_pos;\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (clear_page_dirty_for_io(pages[i]))\n\t\t\taccount_page_redirty(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tWARN_ON(!PageLocked(pages[i]));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_pages",
          "args": [
            "inode",
            "pages",
            "num_pages",
            "pos",
            "write_bytes",
            "force_page_uptodate"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1312-1354",
          "snippet": "static noinline int prepare_pages(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t num_pages, loff_t pos,\n\t\t\t\t  size_t write_bytes, bool force_uptodate)\n{\n\tint i;\n\tunsigned long index = pos >> PAGE_CACHE_SHIFT;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint err = 0;\n\tint faili;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = find_or_create_page(inode->i_mapping, index + i,\n\t\t\t\t\t       mask | __GFP_WRITE);\n\t\tif (!pages[i]) {\n\t\t\tfaili = i - 1;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\terr = prepare_uptodate_page(pages[i], pos,\n\t\t\t\t\t\t    force_uptodate);\n\t\tif (i == num_pages - 1)\n\t\t\terr = prepare_uptodate_page(pages[i],\n\t\t\t\t\t\t    pos + write_bytes, false);\n\t\tif (err) {\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tfaili = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\twait_on_page_writeback(pages[i]);\n\t}\n\n\treturn 0;\nfail:\n\twhile (faili >= 0) {\n\t\tunlock_page(pages[faili]);\n\t\tpage_cache_release(pages[faili]);\n\t\tfaili--;\n\t}\n\treturn err;\n\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int prepare_pages(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t num_pages, loff_t pos,\n\t\t\t\t  size_t write_bytes, bool force_uptodate)\n{\n\tint i;\n\tunsigned long index = pos >> PAGE_CACHE_SHIFT;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint err = 0;\n\tint faili;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = find_or_create_page(inode->i_mapping, index + i,\n\t\t\t\t\t       mask | __GFP_WRITE);\n\t\tif (!pages[i]) {\n\t\t\tfaili = i - 1;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\terr = prepare_uptodate_page(pages[i], pos,\n\t\t\t\t\t\t    force_uptodate);\n\t\tif (i == num_pages - 1)\n\t\t\terr = prepare_uptodate_page(pages[i],\n\t\t\t\t\t\t    pos + write_bytes, false);\n\t\tif (err) {\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tfaili = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\twait_on_page_writeback(pages[i]);\n\t}\n\n\treturn 0;\nfail:\n\twhile (faili >= 0) {\n\t\tunlock_page(pages[faili]);\n\t\tpage_cache_release(pages[faili]);\n\t\tfaili--;\n\t}\n\treturn err;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_reserved_data_space",
          "args": [
            "inode",
            "reserve_bytes"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_reserved_data_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3750-3765",
          "snippet": "void btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_reserve_metadata",
          "args": [
            "inode",
            "reserve_bytes"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5105-5261",
          "snippet": "int btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->delalloc_block_rsv;\n\tu64 to_reserve = 0;\n\tu64 csum_bytes;\n\tunsigned nr_extents = 0;\n\tint extra_reserve = 0;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_ALL;\n\tint ret = 0;\n\tbool delalloc_lock = true;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\t/* If we are a free space inode we need to not flush since we will be in\n\t * the middle of a transaction commit.  We also don't need the delalloc\n\t * mutex since we won't race with anybody.  We need this mostly to make\n\t * lockdep shut its filthy mouth.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\t\tdelalloc_lock = false;\n\t}\n\n\tif (flush != BTRFS_RESERVE_NO_FLUSH &&\n\t    btrfs_transaction_in_commit(root->fs_info))\n\t\tschedule_timeout(1);\n\n\tif (delalloc_lock)\n\t\tmutex_lock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tnr_extents = (unsigned)div64_u64(num_bytes +\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE);\n\tBTRFS_I(inode)->outstanding_extents += nr_extents;\n\tnr_extents = 0;\n\n\tif (BTRFS_I(inode)->outstanding_extents >\n\t    BTRFS_I(inode)->reserved_extents)\n\t\tnr_extents = BTRFS_I(inode)->outstanding_extents -\n\t\t\tBTRFS_I(inode)->reserved_extents;\n\n\t/*\n\t * Add an item to reserve for updating the inode when we complete the\n\t * delalloc io.\n\t */\n\tif (!test_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t      &BTRFS_I(inode)->runtime_flags)) {\n\t\tnr_extents++;\n\t\textra_reserve = 1;\n\t}\n\n\tto_reserve = btrfs_calc_trans_metadata_size(root, nr_extents);\n\tto_reserve += calc_csum_metadata_size(inode, num_bytes, 1);\n\tcsum_bytes = BTRFS_I(inode)->csum_bytes;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, num_bytes +\n\t\t\t\t\t   nr_extents * root->nodesize);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tret = reserve_metadata_bytes(root, block_rsv, to_reserve, flush);\n\tif (unlikely(ret)) {\n\t\tif (root->fs_info->quota_enabled)\n\t\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\t\tnr_extents * root->nodesize);\n\t\tgoto out_fail;\n\t}\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tif (extra_reserve) {\n\t\tset_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tnr_extents--;\n\t}\n\tBTRFS_I(inode)->reserved_extents += nr_extents;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tif (to_reserve)\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_reserve, 1);\n\tblock_rsv_add_bytes(block_rsv, to_reserve, 1);\n\n\treturn 0;\n\nout_fail:\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\t/*\n\t * If the inodes csum_bytes is the same as the original\n\t * csum_bytes then we know we haven't raced with any free()ers\n\t * so we can just reduce our inodes csum bytes and carry on.\n\t */\n\tif (BTRFS_I(inode)->csum_bytes == csum_bytes) {\n\t\tcalc_csum_metadata_size(inode, num_bytes, 0);\n\t} else {\n\t\tu64 orig_csum_bytes = BTRFS_I(inode)->csum_bytes;\n\t\tu64 bytes;\n\n\t\t/*\n\t\t * This is tricky, but first we need to figure out how much we\n\t\t * free'd from any free-ers that occured during this\n\t\t * reservation, so we reset ->csum_bytes to the csum_bytes\n\t\t * before we dropped our lock, and then call the free for the\n\t\t * number of bytes that were freed while we were trying our\n\t\t * reservation.\n\t\t */\n\t\tbytes = csum_bytes - BTRFS_I(inode)->csum_bytes;\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes;\n\t\tto_free = calc_csum_metadata_size(inode, bytes, 0);\n\n\n\t\t/*\n\t\t * Now we need to see how much we would have freed had we not\n\t\t * been making this reservation and our ->csum_bytes were not\n\t\t * artificially inflated.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes - num_bytes;\n\t\tbytes = csum_bytes - orig_csum_bytes;\n\t\tbytes = calc_csum_metadata_size(inode, bytes, 0);\n\n\t\t/*\n\t\t * Now reset ->csum_bytes to what it should be.  If bytes is\n\t\t * more than to_free then we would have free'd more space had we\n\t\t * not had an artificially high ->csum_bytes, so we need to free\n\t\t * the remainder.  If bytes is the same or less then we don't\n\t\t * need to do anything, the other free-ers did the correct\n\t\t * thing.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = orig_csum_bytes - num_bytes;\n\t\tif (bytes > to_free)\n\t\t\tto_free = bytes - to_free;\n\t\telse\n\t\t\tto_free = 0;\n\t}\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (to_free) {\n\t\tbtrfs_block_rsv_release(root, block_rsv, to_free);\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\t}\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->delalloc_block_rsv;\n\tu64 to_reserve = 0;\n\tu64 csum_bytes;\n\tunsigned nr_extents = 0;\n\tint extra_reserve = 0;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_ALL;\n\tint ret = 0;\n\tbool delalloc_lock = true;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\t/* If we are a free space inode we need to not flush since we will be in\n\t * the middle of a transaction commit.  We also don't need the delalloc\n\t * mutex since we won't race with anybody.  We need this mostly to make\n\t * lockdep shut its filthy mouth.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\t\tdelalloc_lock = false;\n\t}\n\n\tif (flush != BTRFS_RESERVE_NO_FLUSH &&\n\t    btrfs_transaction_in_commit(root->fs_info))\n\t\tschedule_timeout(1);\n\n\tif (delalloc_lock)\n\t\tmutex_lock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tnr_extents = (unsigned)div64_u64(num_bytes +\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE);\n\tBTRFS_I(inode)->outstanding_extents += nr_extents;\n\tnr_extents = 0;\n\n\tif (BTRFS_I(inode)->outstanding_extents >\n\t    BTRFS_I(inode)->reserved_extents)\n\t\tnr_extents = BTRFS_I(inode)->outstanding_extents -\n\t\t\tBTRFS_I(inode)->reserved_extents;\n\n\t/*\n\t * Add an item to reserve for updating the inode when we complete the\n\t * delalloc io.\n\t */\n\tif (!test_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t      &BTRFS_I(inode)->runtime_flags)) {\n\t\tnr_extents++;\n\t\textra_reserve = 1;\n\t}\n\n\tto_reserve = btrfs_calc_trans_metadata_size(root, nr_extents);\n\tto_reserve += calc_csum_metadata_size(inode, num_bytes, 1);\n\tcsum_bytes = BTRFS_I(inode)->csum_bytes;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, num_bytes +\n\t\t\t\t\t   nr_extents * root->nodesize);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tret = reserve_metadata_bytes(root, block_rsv, to_reserve, flush);\n\tif (unlikely(ret)) {\n\t\tif (root->fs_info->quota_enabled)\n\t\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\t\tnr_extents * root->nodesize);\n\t\tgoto out_fail;\n\t}\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tif (extra_reserve) {\n\t\tset_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tnr_extents--;\n\t}\n\tBTRFS_I(inode)->reserved_extents += nr_extents;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tif (to_reserve)\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_reserve, 1);\n\tblock_rsv_add_bytes(block_rsv, to_reserve, 1);\n\n\treturn 0;\n\nout_fail:\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\t/*\n\t * If the inodes csum_bytes is the same as the original\n\t * csum_bytes then we know we haven't raced with any free()ers\n\t * so we can just reduce our inodes csum bytes and carry on.\n\t */\n\tif (BTRFS_I(inode)->csum_bytes == csum_bytes) {\n\t\tcalc_csum_metadata_size(inode, num_bytes, 0);\n\t} else {\n\t\tu64 orig_csum_bytes = BTRFS_I(inode)->csum_bytes;\n\t\tu64 bytes;\n\n\t\t/*\n\t\t * This is tricky, but first we need to figure out how much we\n\t\t * free'd from any free-ers that occured during this\n\t\t * reservation, so we reset ->csum_bytes to the csum_bytes\n\t\t * before we dropped our lock, and then call the free for the\n\t\t * number of bytes that were freed while we were trying our\n\t\t * reservation.\n\t\t */\n\t\tbytes = csum_bytes - BTRFS_I(inode)->csum_bytes;\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes;\n\t\tto_free = calc_csum_metadata_size(inode, bytes, 0);\n\n\n\t\t/*\n\t\t * Now we need to see how much we would have freed had we not\n\t\t * been making this reservation and our ->csum_bytes were not\n\t\t * artificially inflated.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes - num_bytes;\n\t\tbytes = csum_bytes - orig_csum_bytes;\n\t\tbytes = calc_csum_metadata_size(inode, bytes, 0);\n\n\t\t/*\n\t\t * Now reset ->csum_bytes to what it should be.  If bytes is\n\t\t * more than to_free then we would have free'd more space had we\n\t\t * not had an artificially high ->csum_bytes, so we need to free\n\t\t * the remainder.  If bytes is the same or less then we don't\n\t\t * need to do anything, the other free-ers did the correct\n\t\t * thing.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = orig_csum_bytes - num_bytes;\n\t\tif (bytes > to_free)\n\t\t\tto_free = bytes - to_free;\n\t\telse\n\t\t\tto_free = 0;\n\t}\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (to_free) {\n\t\tbtrfs_block_rsv_release(root, block_rsv, to_free);\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\t}\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "write_bytes + offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_can_nocow",
          "args": [
            "inode",
            "pos",
            "&write_bytes"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "check_can_nocow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1422-1463",
          "snippet": "static noinline int check_can_nocow(struct inode *inode, loff_t pos,\n\t\t\t\t    size_t *write_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 lockstart, lockend;\n\tu64 num_bytes;\n\tint ret;\n\n\tret = btrfs_start_write_no_snapshoting(root);\n\tif (!ret)\n\t\treturn -ENOSPC;\n\n\tlockstart = round_down(pos, root->sectorsize);\n\tlockend = round_up(pos + *write_bytes, root->sectorsize) - 1;\n\n\twhile (1) {\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tordered = btrfs_lookup_ordered_range(inode, lockstart,\n\t\t\t\t\t\t     lockend - lockstart + 1);\n\t\tif (!ordered) {\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tnum_bytes = lockend - lockstart + 1;\n\tret = can_nocow_extent(inode, lockstart, &num_bytes, NULL, NULL, NULL);\n\tif (ret <= 0) {\n\t\tret = 0;\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t} else {\n\t\t*write_bytes = min_t(size_t, *write_bytes ,\n\t\t\t\t     num_bytes - pos + lockstart);\n\t}\n\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int check_can_nocow(struct inode *inode, loff_t pos,\n\t\t\t\t    size_t *write_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 lockstart, lockend;\n\tu64 num_bytes;\n\tint ret;\n\n\tret = btrfs_start_write_no_snapshoting(root);\n\tif (!ret)\n\t\treturn -ENOSPC;\n\n\tlockstart = round_down(pos, root->sectorsize);\n\tlockend = round_up(pos + *write_bytes, root->sectorsize) - 1;\n\n\twhile (1) {\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tordered = btrfs_lookup_ordered_range(inode, lockstart,\n\t\t\t\t\t\t     lockend - lockstart + 1);\n\t\tif (!ordered) {\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tnum_bytes = lockend - lockstart + 1;\n\tret = can_nocow_extent(inode, lockstart, &num_bytes, NULL, NULL, NULL);\n\tif (ret <= 0) {\n\t\tret = 0;\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t} else {\n\t\t*write_bytes = min_t(size_t, *write_bytes ,\n\t\t\t\t     num_bytes - pos + lockstart);\n\t}\n\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_data_free_space",
          "args": [
            "inode",
            "reserve_bytes"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_data_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3638-3745",
          "snippet": "int btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);\nstatic noinline struct;\n\nint btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "iov_iter_fault_in_readable(i, write_bytes)"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_fault_in_readable",
          "args": [
            "i",
            "write_bytes"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_pages > nrptrs"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "write_bytes + offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "iov_iter_count(i)",
            "nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nrptrs * sizeof(struct page *)",
            "GFP_KERNEL"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nrptrs",
            "8"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "iov_iter_count(i)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline ssize_t __btrfs_buffered_write(struct file *file,\n\t\t\t\t\t       struct iov_iter *i,\n\t\t\t\t\t       loff_t pos)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct page **pages = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tu64 release_bytes = 0;\n\tu64 lockstart;\n\tu64 lockend;\n\tunsigned long first_index;\n\tsize_t num_written = 0;\n\tint nrptrs;\n\tint ret = 0;\n\tbool only_release_metadata = false;\n\tbool force_page_uptodate = false;\n\tbool need_unlock;\n\n\tnrptrs = min(DIV_ROUND_UP(iov_iter_count(i), PAGE_CACHE_SIZE),\n\t\t\tPAGE_CACHE_SIZE / (sizeof(struct page *)));\n\tnrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);\n\tnrptrs = max(nrptrs, 8);\n\tpages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\tfirst_index = pos >> PAGE_CACHE_SHIFT;\n\n\twhile (iov_iter_count(i) > 0) {\n\t\tsize_t offset = pos & (PAGE_CACHE_SIZE - 1);\n\t\tsize_t write_bytes = min(iov_iter_count(i),\n\t\t\t\t\t nrptrs * (size_t)PAGE_CACHE_SIZE -\n\t\t\t\t\t offset);\n\t\tsize_t num_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\tsize_t reserve_bytes;\n\t\tsize_t dirty_pages;\n\t\tsize_t copied;\n\n\t\tWARN_ON(num_pages > nrptrs);\n\n\t\t/*\n\t\t * Fault pages before locking them in prepare_pages\n\t\t * to avoid recursive lock\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, write_bytes))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\tret = btrfs_check_data_free_space(inode, reserve_bytes);\n\t\tif (ret == -ENOSPC &&\n\t\t    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |\n\t\t\t\t\t      BTRFS_INODE_PREALLOC))) {\n\t\t\tret = check_can_nocow(inode, pos, &write_bytes);\n\t\t\tif (ret > 0) {\n\t\t\t\tonly_release_metadata = true;\n\t\t\t\t/*\n\t\t\t\t * our prealloc extent may be smaller than\n\t\t\t\t * write_bytes, so scale down.\n\t\t\t\t */\n\t\t\t\tnum_pages = DIV_ROUND_UP(write_bytes + offset,\n\t\t\t\t\t\t\t PAGE_CACHE_SIZE);\n\t\t\t\treserve_bytes = num_pages << PAGE_CACHE_SHIFT;\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\tret = -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);\n\t\tif (ret) {\n\t\t\tif (!only_release_metadata)\n\t\t\t\tbtrfs_free_reserved_data_space(inode,\n\t\t\t\t\t\t\t       reserve_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = reserve_bytes;\n\t\tneed_unlock = false;\nagain:\n\t\t/*\n\t\t * This is going to setup the pages array with the number of\n\t\t * pages we want, so we don't really need to worry about the\n\t\t * contents of pages from loop to loop\n\t\t */\n\t\tret = prepare_pages(inode, pages, num_pages,\n\t\t\t\t    pos, write_bytes,\n\t\t\t\t    force_page_uptodate);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,\n\t\t\t\t\t\t      pos, &lockstart, &lockend,\n\t\t\t\t\t\t      &cached_state);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t} else if (ret > 0) {\n\t\t\tneed_unlock = true;\n\t\t\tret = 0;\n\t\t}\n\n\t\tcopied = btrfs_copy_from_user(pos, num_pages,\n\t\t\t\t\t   write_bytes, pages, i);\n\n\t\t/*\n\t\t * if we have trouble faulting in the pages, fall\n\t\t * back to one page at a time\n\t\t */\n\t\tif (copied < write_bytes)\n\t\t\tnrptrs = 1;\n\n\t\tif (copied == 0) {\n\t\t\tforce_page_uptodate = true;\n\t\t\tdirty_pages = 0;\n\t\t} else {\n\t\t\tforce_page_uptodate = false;\n\t\t\tdirty_pages = DIV_ROUND_UP(copied + offset,\n\t\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\t}\n\n\t\t/*\n\t\t * If we had a short copy we need to release the excess delaloc\n\t\t * bytes we reserved.  We need to increment outstanding_extents\n\t\t * because btrfs_delalloc_release_space will decrement it, but\n\t\t * we still have an outstanding extent for the chunk we actually\n\t\t * managed to copy.\n\t\t */\n\t\tif (num_pages > dirty_pages) {\n\t\t\trelease_bytes = (num_pages - dirty_pages) <<\n\t\t\t\tPAGE_CACHE_SHIFT;\n\t\t\tif (copied > 0) {\n\t\t\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\t}\n\t\t\tif (only_release_metadata)\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\t\trelease_bytes);\n\t\t\telse\n\t\t\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t\t\t\t     release_bytes);\n\t\t}\n\n\t\trelease_bytes = dirty_pages << PAGE_CACHE_SHIFT;\n\n\t\tif (copied > 0)\n\t\t\tret = btrfs_dirty_pages(root, inode, pages,\n\t\t\t\t\t\tdirty_pages, pos, copied,\n\t\t\t\t\t\tNULL);\n\t\tif (need_unlock)\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     lockstart, lockend, &cached_state,\n\t\t\t\t\t     GFP_NOFS);\n\t\tif (ret) {\n\t\t\tbtrfs_drop_pages(pages, num_pages);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_bytes = 0;\n\t\tif (only_release_metadata)\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\n\t\tif (only_release_metadata && copied > 0) {\n\t\t\tu64 lockstart = round_down(pos, root->sectorsize);\n\t\t\tu64 lockend = lockstart +\n\t\t\t\t(dirty_pages << PAGE_CACHE_SHIFT) - 1;\n\n\t\t\tset_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,\n\t\t\t\t       lockend, EXTENT_NORESERVE, NULL,\n\t\t\t\t       NULL, GFP_NOFS);\n\t\t\tonly_release_metadata = false;\n\t\t}\n\n\t\tbtrfs_drop_pages(pages, num_pages);\n\n\t\tcond_resched();\n\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tif (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)\n\t\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tpos += copied;\n\t\tnum_written += copied;\n\t}\n\n\tkfree(pages);\n\n\tif (release_bytes) {\n\t\tif (only_release_metadata) {\n\t\t\tbtrfs_end_write_no_snapshoting(root);\n\t\t\tbtrfs_delalloc_release_metadata(inode, release_bytes);\n\t\t} else {\n\t\t\tbtrfs_delalloc_release_space(inode, release_bytes);\n\t\t}\n\t}\n\n\treturn num_written ? num_written : ret;\n}"
  },
  {
    "function_name": "check_can_nocow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1422-1463",
    "snippet": "static noinline int check_can_nocow(struct inode *inode, loff_t pos,\n\t\t\t\t    size_t *write_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 lockstart, lockend;\n\tu64 num_bytes;\n\tint ret;\n\n\tret = btrfs_start_write_no_snapshoting(root);\n\tif (!ret)\n\t\treturn -ENOSPC;\n\n\tlockstart = round_down(pos, root->sectorsize);\n\tlockend = round_up(pos + *write_bytes, root->sectorsize) - 1;\n\n\twhile (1) {\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tordered = btrfs_lookup_ordered_range(inode, lockstart,\n\t\t\t\t\t\t     lockend - lockstart + 1);\n\t\tif (!ordered) {\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tnum_bytes = lockend - lockstart + 1;\n\tret = can_nocow_extent(inode, lockstart, &num_bytes, NULL, NULL, NULL);\n\tif (ret <= 0) {\n\t\tret = 0;\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t} else {\n\t\t*write_bytes = min_t(size_t, *write_bytes ,\n\t\t\t\t     num_bytes - pos + lockstart);\n\t}\n\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "*write_bytes",
            "num_bytes - pos + lockstart"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_write_no_snapshoting",
          "args": [
            "root"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_write_no_snapshoting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9780-9790",
          "snippet": "void btrfs_end_write_no_snapshoting(struct btrfs_root *root)\n{\n\tpercpu_counter_dec(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we wake up\n\t * waiters.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&root->subv_writers->wait))\n\t\twake_up(&root->subv_writers->wait);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_write_no_snapshoting(struct btrfs_root *root)\n{\n\tpercpu_counter_dec(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we wake up\n\t * waiters.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&root->subv_writers->wait))\n\t\twake_up(&root->subv_writers->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_nocow_extent",
          "args": [
            "inode",
            "lockstart",
            "&num_bytes",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "can_nocow_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6908-7047",
          "snippet": "noinline int can_nocow_extent(struct inode *inode, u64 offset, u64 *len,\n\t\t\t      u64 *orig_start, u64 *orig_block_len,\n\t\t\t      u64 *ram_bytes)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 disk_bytenr;\n\tu64 backref_offset;\n\tu64 extent_end;\n\tu64 num_bytes;\n\tint slot;\n\tint found_type;\n\tbool nocow = (BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t       offset, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tslot = path->slots[0];\n\tif (ret == 1) {\n\t\tif (slot == 0) {\n\t\t\t/* can't find the item, must cow */\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tslot--;\n\t}\n\tret = 0;\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/* not our file or wrong item type, must cow */\n\t\tgoto out;\n\t}\n\n\tif (key.offset > offset) {\n\t\t/* Wrong offset, must cow */\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(leaf, fi);\n\tif (found_type != BTRFS_FILE_EXTENT_REG &&\n\t    found_type != BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t/* not a regular extent, must cow */\n\t\tgoto out;\n\t}\n\n\tif (!nocow && found_type == BTRFS_FILE_EXTENT_REG)\n\t\tgoto out;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif (extent_end <= offset)\n\t\tgoto out;\n\n\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tif (disk_bytenr == 0)\n\t\tgoto out;\n\n\tif (btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\tgoto out;\n\n\tbackref_offset = btrfs_file_extent_offset(leaf, fi);\n\n\tif (orig_start) {\n\t\t*orig_start = key.offset - backref_offset;\n\t\t*orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t*ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\t}\n\n\tif (btrfs_extent_readonly(root, disk_bytenr))\n\t\tgoto out;\n\n\tnum_bytes = min(offset + *len, extent_end) - offset;\n\tif (!nocow && found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 range_end;\n\n\t\trange_end = round_up(offset + num_bytes, root->sectorsize) - 1;\n\t\tret = test_range_bit(io_tree, offset, range_end,\n\t\t\t\t     EXTENT_DELALLOC, 0, NULL);\n\t\tif (ret) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\n\t/*\n\t * look for other files referencing this extent, if we\n\t * find any we must cow\n\t */\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_cross_ref_exist(trans, root, btrfs_ino(inode),\n\t\t\t\t    key.offset - backref_offset, disk_bytenr);\n\tbtrfs_end_transaction(trans, root);\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * adjust disk_bytenr and num_bytes to cover just the bytes\n\t * in this extent we are about to write.  If there\n\t * are any csums in that range we have to cow in order\n\t * to keep the csums correct\n\t */\n\tdisk_bytenr += backref_offset;\n\tdisk_bytenr += offset - key.offset;\n\tif (csum_exist_in_range(root, disk_bytenr, num_bytes))\n\t\t\t\tgoto out;\n\t/*\n\t * all of the above have passed, it is safe to overwrite this extent\n\t * without cow\n\t */\n\t*len = num_bytes;\n\tret = 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int can_nocow_extent(struct inode *inode, u64 offset, u64 *len,\n\t\t\t      u64 *orig_start, u64 *orig_block_len,\n\t\t\t      u64 *ram_bytes)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 disk_bytenr;\n\tu64 backref_offset;\n\tu64 extent_end;\n\tu64 num_bytes;\n\tint slot;\n\tint found_type;\n\tbool nocow = (BTRFS_I(inode)->flags & BTRFS_INODE_NODATACOW);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(inode),\n\t\t\t\t       offset, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tslot = path->slots[0];\n\tif (ret == 1) {\n\t\tif (slot == 0) {\n\t\t\t/* can't find the item, must cow */\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tslot--;\n\t}\n\tret = 0;\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != btrfs_ino(inode) ||\n\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/* not our file or wrong item type, must cow */\n\t\tgoto out;\n\t}\n\n\tif (key.offset > offset) {\n\t\t/* Wrong offset, must cow */\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(leaf, fi);\n\tif (found_type != BTRFS_FILE_EXTENT_REG &&\n\t    found_type != BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t/* not a regular extent, must cow */\n\t\tgoto out;\n\t}\n\n\tif (!nocow && found_type == BTRFS_FILE_EXTENT_REG)\n\t\tgoto out;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif (extent_end <= offset)\n\t\tgoto out;\n\n\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tif (disk_bytenr == 0)\n\t\tgoto out;\n\n\tif (btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\tgoto out;\n\n\tbackref_offset = btrfs_file_extent_offset(leaf, fi);\n\n\tif (orig_start) {\n\t\t*orig_start = key.offset - backref_offset;\n\t\t*orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t*ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\t}\n\n\tif (btrfs_extent_readonly(root, disk_bytenr))\n\t\tgoto out;\n\n\tnum_bytes = min(offset + *len, extent_end) - offset;\n\tif (!nocow && found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 range_end;\n\n\t\trange_end = round_up(offset + num_bytes, root->sectorsize) - 1;\n\t\tret = test_range_bit(io_tree, offset, range_end,\n\t\t\t\t     EXTENT_DELALLOC, 0, NULL);\n\t\tif (ret) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\n\t/*\n\t * look for other files referencing this extent, if we\n\t * find any we must cow\n\t */\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_cross_ref_exist(trans, root, btrfs_ino(inode),\n\t\t\t\t    key.offset - backref_offset, disk_bytenr);\n\tbtrfs_end_transaction(trans, root);\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * adjust disk_bytenr and num_bytes to cover just the bytes\n\t * in this extent we are about to write.  If there\n\t * are any csums in that range we have to cow in order\n\t * to keep the csums correct\n\t */\n\tdisk_bytenr += backref_offset;\n\tdisk_bytenr += offset - key.offset;\n\tif (csum_exist_in_range(root, disk_bytenr, num_bytes))\n\t\t\t\tgoto out;\n\t/*\n\t * all of the above have passed, it is safe to overwrite this extent\n\t * without cow\n\t */\n\t*len = num_bytes;\n\tret = 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_range",
          "args": [
            "inode",
            "lockstart",
            "lockend - lockstart + 1"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "803-839",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "lockstart",
            "lockend"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "pos + *write_bytes",
            "root->sectorsize"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "pos",
            "root->sectorsize"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_write_no_snapshoting",
          "args": [
            "root"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_write_no_snapshoting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9792-9807",
          "snippet": "int btrfs_start_write_no_snapshoting(struct btrfs_root *root)\n{\n\tif (atomic_read(&root->will_be_snapshoted))\n\t\treturn 0;\n\n\tpercpu_counter_inc(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we check for snapshot creation.\n\t */\n\tsmp_mb();\n\tif (atomic_read(&root->will_be_snapshoted)) {\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_start_write_no_snapshoting(struct btrfs_root *root)\n{\n\tif (atomic_read(&root->will_be_snapshoted))\n\t\treturn 0;\n\n\tpercpu_counter_inc(&root->subv_writers->counter);\n\t/*\n\t * Make sure counter is updated before we check for snapshot creation.\n\t */\n\tsmp_mb();\n\tif (atomic_read(&root->will_be_snapshoted)) {\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int check_can_nocow(struct inode *inode, loff_t pos,\n\t\t\t\t    size_t *write_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 lockstart, lockend;\n\tu64 num_bytes;\n\tint ret;\n\n\tret = btrfs_start_write_no_snapshoting(root);\n\tif (!ret)\n\t\treturn -ENOSPC;\n\n\tlockstart = round_down(pos, root->sectorsize);\n\tlockend = round_up(pos + *write_bytes, root->sectorsize) - 1;\n\n\twhile (1) {\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tordered = btrfs_lookup_ordered_range(inode, lockstart,\n\t\t\t\t\t\t     lockend - lockstart + 1);\n\t\tif (!ordered) {\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tnum_bytes = lockend - lockstart + 1;\n\tret = can_nocow_extent(inode, lockstart, &num_bytes, NULL, NULL, NULL);\n\tif (ret <= 0) {\n\t\tret = 0;\n\t\tbtrfs_end_write_no_snapshoting(root);\n\t} else {\n\t\t*write_bytes = min_t(size_t, *write_bytes ,\n\t\t\t\t     num_bytes - pos + lockstart);\n\t}\n\n\tunlock_extent(&BTRFS_I(inode)->io_tree, lockstart, lockend);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lock_and_cleanup_extent_if_need",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1366-1420",
    "snippet": "static noinline int\nlock_and_cleanup_extent_if_need(struct inode *inode, struct page **pages,\n\t\t\t\tsize_t num_pages, loff_t pos,\n\t\t\t\tu64 *lockstart, u64 *lockend,\n\t\t\t\tstruct extent_state **cached_state)\n{\n\tu64 start_pos;\n\tu64 last_pos;\n\tint i;\n\tint ret = 0;\n\n\tstart_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);\n\tlast_pos = start_pos + ((u64)num_pages << PAGE_CACHE_SHIFT) - 1;\n\n\tif (start_pos < inode->i_size) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t start_pos, last_pos, 0, cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start_pos,\n\t\t\t\t\t\t     last_pos - start_pos + 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > start_pos &&\n\t\t    ordered->file_offset <= last_pos) {\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     start_pos, last_pos,\n\t\t\t\t\t     cached_state, GFP_NOFS);\n\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\tunlock_page(pages[i]);\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t}\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, start_pos,\n\t\t\t\t  last_pos, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t\t  0, 0, cached_state, GFP_NOFS);\n\t\t*lockstart = start_pos;\n\t\t*lockend = last_pos;\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (clear_page_dirty_for_io(pages[i]))\n\t\t\taccount_page_redirty(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tWARN_ON(!PageLocked(pages[i]));\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageLocked(pages[i])"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "pages[i]"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "pages[i]"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_page_redirty",
          "args": [
            "pages[i]"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "pages[i]"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start_pos",
            "last_pos",
            "EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG",
            "0",
            "0",
            "cached_state",
            "GFP_NOFS"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start_pos",
            "last_pos",
            "cached_state",
            "GFP_NOFS"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_range",
          "args": [
            "inode",
            "start_pos",
            "last_pos - start_pos + 1"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "803-839",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start_pos",
            "last_pos",
            "0",
            "cached_state"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int\nlock_and_cleanup_extent_if_need(struct inode *inode, struct page **pages,\n\t\t\t\tsize_t num_pages, loff_t pos,\n\t\t\t\tu64 *lockstart, u64 *lockend,\n\t\t\t\tstruct extent_state **cached_state)\n{\n\tu64 start_pos;\n\tu64 last_pos;\n\tint i;\n\tint ret = 0;\n\n\tstart_pos = pos & ~((u64)PAGE_CACHE_SIZE - 1);\n\tlast_pos = start_pos + ((u64)num_pages << PAGE_CACHE_SHIFT) - 1;\n\n\tif (start_pos < inode->i_size) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t start_pos, last_pos, 0, cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, start_pos,\n\t\t\t\t\t\t     last_pos - start_pos + 1);\n\t\tif (ordered &&\n\t\t    ordered->file_offset + ordered->len > start_pos &&\n\t\t    ordered->file_offset <= last_pos) {\n\t\t\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t     start_pos, last_pos,\n\t\t\t\t\t     cached_state, GFP_NOFS);\n\t\t\tfor (i = 0; i < num_pages; i++) {\n\t\t\t\tunlock_page(pages[i]);\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t}\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\tclear_extent_bit(&BTRFS_I(inode)->io_tree, start_pos,\n\t\t\t\t  last_pos, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG,\n\t\t\t\t  0, 0, cached_state, GFP_NOFS);\n\t\t*lockstart = start_pos;\n\t\t*lockend = last_pos;\n\t\tret = 1;\n\t}\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (clear_page_dirty_for_io(pages[i]))\n\t\t\taccount_page_redirty(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tWARN_ON(!PageLocked(pages[i]));\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prepare_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1312-1354",
    "snippet": "static noinline int prepare_pages(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t num_pages, loff_t pos,\n\t\t\t\t  size_t write_bytes, bool force_uptodate)\n{\n\tint i;\n\tunsigned long index = pos >> PAGE_CACHE_SHIFT;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint err = 0;\n\tint faili;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = find_or_create_page(inode->i_mapping, index + i,\n\t\t\t\t\t       mask | __GFP_WRITE);\n\t\tif (!pages[i]) {\n\t\t\tfaili = i - 1;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\terr = prepare_uptodate_page(pages[i], pos,\n\t\t\t\t\t\t    force_uptodate);\n\t\tif (i == num_pages - 1)\n\t\t\terr = prepare_uptodate_page(pages[i],\n\t\t\t\t\t\t    pos + write_bytes, false);\n\t\tif (err) {\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tfaili = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\twait_on_page_writeback(pages[i]);\n\t}\n\n\treturn 0;\nfail:\n\twhile (faili >= 0) {\n\t\tunlock_page(pages[faili]);\n\t\tpage_cache_release(pages[faili]);\n\t\tfaili--;\n\t}\n\treturn err;\n\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[faili]"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[faili]"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "pages[i]"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_uptodate_page",
          "args": [
            "pages[i]",
            "pos + write_bytes",
            "false"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_uptodate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1290-1307",
          "snippet": "static int prepare_uptodate_page(struct page *page, u64 pos,\n\t\t\t\t bool force_uptodate)\n{\n\tint ret = 0;\n\n\tif (((pos & (PAGE_CACHE_SIZE - 1)) || force_uptodate) &&\n\t    !PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int prepare_uptodate_page(struct page *page, u64 pos,\n\t\t\t\t bool force_uptodate)\n{\n\tint ret = 0;\n\n\tif (((pos & (PAGE_CACHE_SIZE - 1)) || force_uptodate) &&\n\t    !PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index + i",
            "mask | __GFP_WRITE"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_write_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_write_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3292-3295",
          "snippet": "static inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int prepare_pages(struct inode *inode, struct page **pages,\n\t\t\t\t  size_t num_pages, loff_t pos,\n\t\t\t\t  size_t write_bytes, bool force_uptodate)\n{\n\tint i;\n\tunsigned long index = pos >> PAGE_CACHE_SHIFT;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint err = 0;\n\tint faili;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = find_or_create_page(inode->i_mapping, index + i,\n\t\t\t\t\t       mask | __GFP_WRITE);\n\t\tif (!pages[i]) {\n\t\t\tfaili = i - 1;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\terr = prepare_uptodate_page(pages[i], pos,\n\t\t\t\t\t\t    force_uptodate);\n\t\tif (i == num_pages - 1)\n\t\t\terr = prepare_uptodate_page(pages[i],\n\t\t\t\t\t\t    pos + write_bytes, false);\n\t\tif (err) {\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tfaili = i - 1;\n\t\t\tgoto fail;\n\t\t}\n\t\twait_on_page_writeback(pages[i]);\n\t}\n\n\treturn 0;\nfail:\n\twhile (faili >= 0) {\n\t\tunlock_page(pages[faili]);\n\t\tpage_cache_release(pages[faili]);\n\t\tfaili--;\n\t}\n\treturn err;\n\n}"
  },
  {
    "function_name": "prepare_uptodate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1290-1307",
    "snippet": "static int prepare_uptodate_page(struct page *page, u64 pos,\n\t\t\t\t bool force_uptodate)\n{\n\tint ret = 0;\n\n\tif (((pos & (PAGE_CACHE_SIZE - 1)) || force_uptodate) &&\n\t    !PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8212-8217",
          "snippet": "int btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int prepare_uptodate_page(struct page *page, u64 pos,\n\t\t\t\t bool force_uptodate)\n{\n\tint ret = 0;\n\n\tif (((pos & (PAGE_CACHE_SIZE - 1)) || force_uptodate) &&\n\t    !PageUptodate(page)) {\n\t\tret = btrfs_readpage(NULL, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_mark_extent_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1069-1284",
    "snippet": "int btrfs_mark_extent_written(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, u64 start, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 bytenr;\n\tu64 num_bytes;\n\tu64 extent_end;\n\tu64 orig_offset;\n\tu64 other_start;\n\tu64 other_end;\n\tu64 split;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint recow;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\trecow = 0;\n\tsplit = start;\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = split;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0)\n\t\tpath->slots[0]--;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tBUG_ON(key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY);\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tBUG_ON(btrfs_file_extent_type(leaf, fi) !=\n\t       BTRFS_FILE_EXTENT_PREALLOC);\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tBUG_ON(key.offset > start || extent_end < end);\n\n\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\torig_offset = key.offset - btrfs_file_extent_offset(leaf, fi);\n\tmemcpy(&new_key, &key, sizeof(new_key));\n\n\tif (start == key.offset && end < extent_end) {\n\t\tother_start = 0;\n\t\tother_end = start;\n\t\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     end - orig_offset);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tend - other_start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (start > key.offset && end == extent_end) {\n\t\tother_start = end;\n\t\tother_end = 0;\n\t\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tpath->slots[0]++;\n\t\t\tnew_key.offset = start;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tother_end - start);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     start - orig_offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (start > key.offset || end < extent_end) {\n\t\tif (key.offset == start)\n\t\t\tsplit = end;\n\n\t\tnew_key.offset = split;\n\t\tret = btrfs_duplicate_item(trans, root, path, &new_key);\n\t\tif (ret == -EAGAIN) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\tsplit - key.offset);\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, split - orig_offset);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - split);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\tret = btrfs_inc_extent_ref(trans, root, bytenr, num_bytes, 0,\n\t\t\t\t\t   root->root_key.objectid,\n\t\t\t\t\t   ino, orig_offset, 1);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\tif (split == start) {\n\t\t\tkey.offset = start;\n\t\t} else {\n\t\t\tBUG_ON(start != key.offset);\n\t\t\tpath->slots[0]--;\n\t\t\textent_end = end;\n\t\t}\n\t\trecow = 1;\n\t}\n\n\tother_start = end;\n\tother_end = 0;\n\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\textent_end = other_end;\n\t\tdel_slot = path->slots[0] + 1;\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\tino, orig_offset, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\tother_start = 0;\n\tother_end = start;\n\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tkey.offset = other_start;\n\t\tdel_slot = path->slots[0];\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\tino, orig_offset, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\tif (del_nr == 0) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\tfi = btrfs_item_ptr(leaf, del_slot - 1,\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - key.offset);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_items",
          "args": [
            "trans",
            "root",
            "path",
            "del_slot",
            "del_nr"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4930-5039",
          "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "extent_end - key.offset"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_type",
          "args": [
            "leaf",
            "fi",
            "BTRFS_FILE_EXTENT_REG"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "del_slot - 1",
            "structbtrfs_file_extent_item"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_type",
          "args": [
            "leaf",
            "fi",
            "BTRFS_FILE_EXTENT_REG"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_extent",
          "args": [
            "trans",
            "root",
            "bytenr",
            "num_bytes",
            "0",
            "root->root_key.objectid",
            "ino",
            "orig_offset",
            "0"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6249-6283",
          "snippet": "int btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_mergeable",
          "args": [
            "leaf",
            "path->slots[0] - 1",
            "ino",
            "bytenr",
            "orig_offset",
            "&other_start",
            "&other_end"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "extent_mergeable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1029-1060",
          "snippet": "static int extent_mergeable(struct extent_buffer *leaf, int slot,\n\t\t\t    u64 objectid, u64 bytenr, u64 orig_offset,\n\t\t\t    u64 *start, u64 *end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != objectid || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG ||\n\t    btrfs_file_extent_disk_bytenr(leaf, fi) != bytenr ||\n\t    btrfs_file_extent_offset(leaf, fi) != key.offset - orig_offset ||\n\t    btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif ((*start && *start != key.offset) || (*end && *end != extent_end))\n\t\treturn 0;\n\n\t*start = key.offset;\n\t*end = extent_end;\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int extent_mergeable(struct extent_buffer *leaf, int slot,\n\t\t\t    u64 objectid, u64 bytenr, u64 orig_offset,\n\t\t\t    u64 *start, u64 *end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != objectid || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG ||\n\t    btrfs_file_extent_disk_bytenr(leaf, fi) != bytenr ||\n\t    btrfs_file_extent_offset(leaf, fi) != key.offset - orig_offset ||\n\t    btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif ((*start && *start != key.offset) || (*end && *end != extent_end))\n\t\treturn 0;\n\n\t*start = key.offset;\n\t*end = extent_end;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start != key.offset"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "bytenr",
            "num_bytes",
            "0",
            "root->root_key.objectid",
            "ino",
            "orig_offset",
            "1"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "extent_end - split"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "split - orig_offset"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "split - key.offset"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0] - 1",
            "structbtrfs_file_extent_item"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_duplicate_item",
          "args": [
            "trans",
            "root",
            "path",
            "&new_key"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_duplicate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4501-4527",
          "snippet": "int btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "start - orig_offset"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "other_end - start"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key_safe",
          "args": [
            "root",
            "path",
            "&new_key"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "start - key.offset"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "end - other_start"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0] - 1",
            "structbtrfs_file_extent_item"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "end - orig_offset"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "extent_end - end"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_key",
            "&key",
            "sizeof(new_key)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "key.offset > start || extent_end < end"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_file_extent_type(leaf, fi) !=\n\t       BTRFS_FILE_EXTENT_PREALLOC"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_mark_extent_written(struct btrfs_trans_handle *trans,\n\t\t\t      struct inode *inode, u64 start, u64 end)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 bytenr;\n\tu64 num_bytes;\n\tu64 extent_end;\n\tu64 orig_offset;\n\tu64 other_start;\n\tu64 other_end;\n\tu64 split;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint recow;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\trecow = 0;\n\tsplit = start;\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = split;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0)\n\t\tpath->slots[0]--;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tBUG_ON(key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY);\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\tBUG_ON(btrfs_file_extent_type(leaf, fi) !=\n\t       BTRFS_FILE_EXTENT_PREALLOC);\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tBUG_ON(key.offset > start || extent_end < end);\n\n\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\torig_offset = key.offset - btrfs_file_extent_offset(leaf, fi);\n\tmemcpy(&new_key, &key, sizeof(new_key));\n\n\tif (start == key.offset && end < extent_end) {\n\t\tother_start = 0;\n\t\tother_end = start;\n\t\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     end - orig_offset);\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tend - other_start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (start > key.offset && end == extent_end) {\n\t\tother_start = end;\n\t\tother_end = 0;\n\t\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t\t     ino, bytenr, orig_offset,\n\t\t\t\t     &other_start, &other_end)) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tpath->slots[0]++;\n\t\t\tnew_key.offset = start;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_generation(leaf, fi,\n\t\t\t\t\t\t\t trans->transid);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tother_end - start);\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi,\n\t\t\t\t\t\t     start - orig_offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (start > key.offset || end < extent_end) {\n\t\tif (key.offset == start)\n\t\t\tsplit = end;\n\n\t\tnew_key.offset = split;\n\t\tret = btrfs_duplicate_item(trans, root, path, &new_key);\n\t\tif (ret == -EAGAIN) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\tsplit - key.offset);\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_offset(leaf, fi, split - orig_offset);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - split);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\tret = btrfs_inc_extent_ref(trans, root, bytenr, num_bytes, 0,\n\t\t\t\t\t   root->root_key.objectid,\n\t\t\t\t\t   ino, orig_offset, 1);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\tif (split == start) {\n\t\t\tkey.offset = start;\n\t\t} else {\n\t\t\tBUG_ON(start != key.offset);\n\t\t\tpath->slots[0]--;\n\t\t\textent_end = end;\n\t\t}\n\t\trecow = 1;\n\t}\n\n\tother_start = end;\n\tother_end = 0;\n\tif (extent_mergeable(leaf, path->slots[0] + 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\textent_end = other_end;\n\t\tdel_slot = path->slots[0] + 1;\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\tino, orig_offset, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\tother_start = 0;\n\tother_end = start;\n\tif (extent_mergeable(leaf, path->slots[0] - 1,\n\t\t\t     ino, bytenr, orig_offset,\n\t\t\t     &other_start, &other_end)) {\n\t\tif (recow) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t\tkey.offset = other_start;\n\t\tdel_slot = path->slots[0];\n\t\tdel_nr++;\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\tino, orig_offset, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\tif (del_nr == 0) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t} else {\n\t\tfi = btrfs_item_ptr(leaf, del_slot - 1,\n\t\t\t   struct btrfs_file_extent_item);\n\t\tbtrfs_set_file_extent_type(leaf, fi,\n\t\t\t\t\t   BTRFS_FILE_EXTENT_REG);\n\t\tbtrfs_set_file_extent_generation(leaf, fi, trans->transid);\n\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\textent_end - key.offset);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_mergeable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1029-1060",
    "snippet": "static int extent_mergeable(struct extent_buffer *leaf, int slot,\n\t\t\t    u64 objectid, u64 bytenr, u64 orig_offset,\n\t\t\t    u64 *start, u64 *end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != objectid || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG ||\n\t    btrfs_file_extent_disk_bytenr(leaf, fi) != bytenr ||\n\t    btrfs_file_extent_offset(leaf, fi) != key.offset - orig_offset ||\n\t    btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif ((*start && *start != key.offset) || (*end && *end != extent_end))\n\t\treturn 0;\n\n\t*start = key.offset;\n\t*end = extent_end;\n\treturn 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_other_encoding",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_encryption",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int extent_mergeable(struct extent_buffer *leaf, int slot,\n\t\t\t    u64 objectid, u64 bytenr, u64 orig_offset,\n\t\t\t    u64 *start, u64 *end)\n{\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tu64 extent_end;\n\n\tif (slot < 0 || slot >= btrfs_header_nritems(leaf))\n\t\treturn 0;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\tif (key.objectid != objectid || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\treturn 0;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_type(leaf, fi) != BTRFS_FILE_EXTENT_REG ||\n\t    btrfs_file_extent_disk_bytenr(leaf, fi) != bytenr ||\n\t    btrfs_file_extent_offset(leaf, fi) != key.offset - orig_offset ||\n\t    btrfs_file_extent_compression(leaf, fi) ||\n\t    btrfs_file_extent_encryption(leaf, fi) ||\n\t    btrfs_file_extent_other_encoding(leaf, fi))\n\t\treturn 0;\n\n\textent_end = key.offset + btrfs_file_extent_num_bytes(leaf, fi);\n\tif ((*start && *start != key.offset) || (*end && *end != extent_end))\n\t\treturn 0;\n\n\t*start = key.offset;\n\t*end = extent_end;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_drop_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "1013-1027",
    "snippet": "int btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_drop_extents",
          "args": [
            "trans",
            "root",
            "inode",
            "path",
            "start",
            "end",
            "NULL",
            "drop_cache",
            "0",
            "0",
            "NULL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_drop_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "695-1011",
          "snippet": "int __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_drop_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "695-1011",
    "snippet": "int __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "extent_end"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "path",
            "&key",
            "&extent_item_size",
            "extent_item_size",
            "sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size",
            "1"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&key",
            "&slot_key"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&slot_key",
            "path->slots[0]"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_items",
          "args": [
            "trans",
            "root",
            "path",
            "del_slot",
            "del_nr"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4930-5039",
          "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_sub_bytes",
          "args": [
            "inode",
            "extent_end - key.offset"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sub_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "482-487",
          "snippet": "void inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_sub_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_sub_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_extent",
          "args": [
            "trans",
            "root",
            "disk_bytenr",
            "num_bytes",
            "0",
            "root->root_key.objectid",
            "key.objectid",
            "key.offset -\n\t\t\t\t\t\textent_offset",
            "0"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6249-6283",
          "snippet": "int btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "extent_end",
            "root->sectorsize"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "del_slot + del_nr != path->slots[0]"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "start - key.offset"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "del_nr > 0"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "extent_end - end"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "extent_offset"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key_safe",
          "args": [
            "root",
            "path",
            "&new_key"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_key",
            "&key",
            "sizeof(new_key)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "disk_bytenr",
            "num_bytes",
            "0",
            "root->root_key.objectid",
            "new_key.objectid",
            "start - extent_offset",
            "1"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "extent_end - start"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "extent_offset"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "start - key.offset"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0] - 1",
            "structbtrfs_file_extent_item"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_duplicate_item",
          "args": [
            "trans",
            "root",
            "path",
            "&new_key"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_duplicate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4501-4527",
          "snippet": "int btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_key",
            "&key",
            "sizeof(new_key)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "del_nr > 0"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "key.offset",
            "start"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "leaf",
            "path->slots[0]",
            "fi"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "del_nr > 0"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_file_extent",
          "args": [
            "trans",
            "root",
            "path",
            "ino",
            "search_start",
            "modify_tree"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "139-154",
          "snippet": "int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "start",
            "end - 1",
            "0"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_drop_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "535-684",
    "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "split2"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_mapping",
          "args": [
            "em_tree",
            "em"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "430-440",
          "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_in_tree",
          "args": [
            "em"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "47-50",
          "snippet": "static inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret == 0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "split",
            "modified"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_extent_mapping",
          "args": [
            "em_tree",
            "em",
            "split",
            "modified"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "replace_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "442-455",
          "snippet": "void replace_extent_mapping(struct extent_map_tree *tree,\n\t\t\t    struct extent_map *cur,\n\t\t\t    struct extent_map *new,\n\t\t\t    int modified)\n{\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &cur->flags));\n\tASSERT(extent_map_in_tree(cur));\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &cur->flags))\n\t\tlist_del_init(&cur->list);\n\trb_replace_node(&cur->rb_node, &new->rb_node, &tree->map);\n\tRB_CLEAR_NODE(&cur->rb_node);\n\n\tsetup_extent_mapping(tree, new, modified);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid replace_extent_mapping(struct extent_map_tree *tree,\n\t\t\t    struct extent_map *cur,\n\t\t\t    struct extent_map *new,\n\t\t\t    int modified)\n{\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &cur->flags));\n\tASSERT(extent_map_in_tree(cur));\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &cur->flags))\n\t\tlist_del_init(&cur->list);\n\trb_replace_node(&cur->rb_node, &new->rb_node, &tree->map);\n\tRB_CLEAR_NODE(&cur->rb_node);\n\n\tsetup_extent_mapping(tree, new, modified);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "em->block_len",
            "em->orig_block_len"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_max_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "13-18",
          "snippet": "static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)\n{\n\treturn (sbi->s_sys_blocksize - offset -\n\t\tsizeof(struct omfs_extent)) /\n\t\tsizeof(struct omfs_extent_entry) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&em->list"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&flags"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_COMPRESSED",
            "&em->flags"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "start",
            "len"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "end < start"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
  },
  {
    "function_name": "btrfs_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "492-529",
    "snippet": "int btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "end_pos"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "p"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9538-9541",
          "snippet": "static int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "p"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_delalloc",
          "args": [
            "inode",
            "start_pos",
            "end_of_last_block",
            "cached"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_extent_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "1933-1939",
          "snippet": "int btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "write_bytes + pos - start_pos",
            "root->sectorsize"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_dirty_pages(struct btrfs_root *root, struct inode *inode,\n\t\t\t     struct page **pages, size_t num_pages,\n\t\t\t     loff_t pos, size_t write_bytes,\n\t\t\t     struct extent_state **cached)\n{\n\tint err = 0;\n\tint i;\n\tu64 num_bytes;\n\tu64 start_pos;\n\tu64 end_of_last_block;\n\tu64 end_pos = pos + write_bytes;\n\tloff_t isize = i_size_read(inode);\n\n\tstart_pos = pos & ~((u64)root->sectorsize - 1);\n\tnum_bytes = ALIGN(write_bytes + pos - start_pos, root->sectorsize);\n\n\tend_of_last_block = start_pos + num_bytes - 1;\n\terr = btrfs_set_extent_delalloc(inode, start_pos, end_of_last_block,\n\t\t\t\t\tcached);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = pages[i];\n\t\tSetPageUptodate(p);\n\t\tClearPageChecked(p);\n\t\tset_page_dirty(p);\n\t}\n\n\t/*\n\t * we've only changed i_size in ram, and we haven't updated\n\t * the disk i_size.  There is no need to log the inode\n\t * at this time.\n\t */\n\tif (end_pos > isize)\n\t\ti_size_write(inode, end_pos);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_drop_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "468-482",
    "snippet": "static void btrfs_drop_pages(struct page **pages, size_t num_pages)\n{\n\tsize_t i;\n\tfor (i = 0; i < num_pages; i++) {\n\t\t/* page checked is some magic around finding pages that\n\t\t * have been modified without going through btrfs_set_page_dirty\n\t\t * clear it here. There should be no need to mark the pages\n\t\t * accessed as prepare_pages should have marked them accessed\n\t\t * in prepare_pages via find_or_create_page()\n\t\t */\n\t\tClearPageChecked(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "pages[i]"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic void btrfs_drop_pages(struct page **pages, size_t num_pages)\n{\n\tsize_t i;\n\tfor (i = 0; i < num_pages; i++) {\n\t\t/* page checked is some magic around finding pages that\n\t\t * have been modified without going through btrfs_set_page_dirty\n\t\t * clear it here. There should be no need to mark the pages\n\t\t * accessed as prepare_pages should have marked them accessed\n\t\t * in prepare_pages via find_or_create_page()\n\t\t */\n\t\tClearPageChecked(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n}"
  },
  {
    "function_name": "btrfs_copy_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "413-463",
    "snippet": "static noinline int btrfs_copy_from_user(loff_t pos, int num_pages,\n\t\t\t\t\t size_t write_bytes,\n\t\t\t\t\t struct page **prepared_pages,\n\t\t\t\t\t struct iov_iter *i)\n{\n\tsize_t copied = 0;\n\tsize_t total_copied = 0;\n\tint pg = 0;\n\tint offset = pos & (PAGE_CACHE_SIZE - 1);\n\n\twhile (write_bytes > 0) {\n\t\tsize_t count = min_t(size_t,\n\t\t\t\t     PAGE_CACHE_SIZE - offset, write_bytes);\n\t\tstruct page *page = prepared_pages[pg];\n\t\t/*\n\t\t * Copy data from userspace to the current page\n\t\t */\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, count);\n\n\t\t/* Flush processor's dcache for this page */\n\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * if we get a partial write, we can end up with\n\t\t * partially up to date pages.  These add\n\t\t * a lot of complexity, so make sure they don't\n\t\t * happen by forcing this copy to be retried.\n\t\t *\n\t\t * The rest of the btrfs_file_write code will fall\n\t\t * back to page at a time copies after we return 0.\n\t\t */\n\t\tif (!PageUptodate(page) && copied < count)\n\t\t\tcopied = 0;\n\n\t\tiov_iter_advance(i, copied);\n\t\twrite_bytes -= copied;\n\t\ttotal_copied += copied;\n\n\t\t/* Return to btrfs_file_write_iter to fault page */\n\t\tif (unlikely(copied == 0))\n\t\t\tbreak;\n\n\t\tif (copied < PAGE_CACHE_SIZE - offset) {\n\t\t\toffset += copied;\n\t\t} else {\n\t\t\tpg++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn total_copied;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied == 0"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "i",
            "copied"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_copy_from_user_atomic",
          "args": [
            "page",
            "i",
            "offset",
            "count"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_CACHE_SIZE - offset",
            "write_bytes"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic noinline int btrfs_copy_from_user(loff_t pos, int num_pages,\n\t\t\t\t\t size_t write_bytes,\n\t\t\t\t\t struct page **prepared_pages,\n\t\t\t\t\t struct iov_iter *i)\n{\n\tsize_t copied = 0;\n\tsize_t total_copied = 0;\n\tint pg = 0;\n\tint offset = pos & (PAGE_CACHE_SIZE - 1);\n\n\twhile (write_bytes > 0) {\n\t\tsize_t count = min_t(size_t,\n\t\t\t\t     PAGE_CACHE_SIZE - offset, write_bytes);\n\t\tstruct page *page = prepared_pages[pg];\n\t\t/*\n\t\t * Copy data from userspace to the current page\n\t\t */\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, count);\n\n\t\t/* Flush processor's dcache for this page */\n\t\tflush_dcache_page(page);\n\n\t\t/*\n\t\t * if we get a partial write, we can end up with\n\t\t * partially up to date pages.  These add\n\t\t * a lot of complexity, so make sure they don't\n\t\t * happen by forcing this copy to be retried.\n\t\t *\n\t\t * The rest of the btrfs_file_write code will fall\n\t\t * back to page at a time copies after we return 0.\n\t\t */\n\t\tif (!PageUptodate(page) && copied < count)\n\t\t\tcopied = 0;\n\n\t\tiov_iter_advance(i, copied);\n\t\twrite_bytes -= copied;\n\t\ttotal_copied += copied;\n\n\t\t/* Return to btrfs_file_write_iter to fault page */\n\t\tif (unlikely(copied == 0))\n\t\t\tbreak;\n\n\t\tif (copied < PAGE_CACHE_SIZE - offset) {\n\t\t\toffset += copied;\n\t\t} else {\n\t\t\tpg++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn total_copied;\n}"
  },
  {
    "function_name": "btrfs_run_defrag_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "366-408",
    "snippet": "int btrfs_run_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tu64 first_ino = 0;\n\tu64 root_objectid = 0;\n\n\tatomic_inc(&fs_info->defrag_running);\n\twhile (1) {\n\t\t/* Pause the auto defragger. */\n\t\tif (test_bit(BTRFS_FS_STATE_REMOUNTING,\n\t\t\t     &fs_info->fs_state))\n\t\t\tbreak;\n\n\t\tif (!__need_auto_defrag(fs_info->tree_root))\n\t\t\tbreak;\n\n\t\t/* find an inode to defrag */\n\t\tdefrag = btrfs_pick_defrag_inode(fs_info, root_objectid,\n\t\t\t\t\t\t first_ino);\n\t\tif (!defrag) {\n\t\t\tif (root_objectid || first_ino) {\n\t\t\t\troot_objectid = 0;\n\t\t\t\tfirst_ino = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfirst_ino = defrag->ino + 1;\n\t\troot_objectid = defrag->root;\n\n\t\t__btrfs_run_defrag_inode(fs_info, defrag);\n\t}\n\tatomic_dec(&fs_info->defrag_running);\n\n\t/*\n\t * during unmount, we use the transaction_wait queue to\n\t * wait for the defragger to stop\n\t */\n\twake_up(&fs_info->transaction_wait);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&fs_info->transaction_wait"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&fs_info->defrag_running"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_run_defrag_inode",
          "args": [
            "fs_info",
            "defrag"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_run_defrag_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "289-360",
          "snippet": "static int __btrfs_run_defrag_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *inode_root;\n\tstruct inode *inode;\n\tstruct btrfs_key key;\n\tstruct btrfs_ioctl_defrag_range_args range;\n\tint num_defrag;\n\tint index;\n\tint ret;\n\n\t/* get the inode */\n\tkey.objectid = defrag->root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tinode_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(inode_root)) {\n\t\tret = PTR_ERR(inode_root);\n\t\tgoto cleanup;\n\t}\n\n\tkey.objectid = defrag->ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, inode_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto cleanup;\n\t}\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t/* do a chunk of defrag */\n\tclear_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\tmemset(&range, 0, sizeof(range));\n\trange.len = (u64)-1;\n\trange.start = defrag->last_offset;\n\n\tsb_start_write(fs_info->sb);\n\tnum_defrag = btrfs_defrag_file(inode, NULL, &range, defrag->transid,\n\t\t\t\t       BTRFS_DEFRAG_BATCH);\n\tsb_end_write(fs_info->sb);\n\t/*\n\t * if we filled the whole defrag batch, there\n\t * must be more work to do.  Queue this defrag\n\t * again\n\t */\n\tif (num_defrag == BTRFS_DEFRAG_BATCH) {\n\t\tdefrag->last_offset = range.start;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else if (defrag->last_offset && !defrag->cycled) {\n\t\t/*\n\t\t * we didn't fill our defrag batch, but\n\t\t * we didn't start at zero.  Make sure we loop\n\t\t * around to the start of the file.\n\t\t */\n\t\tdefrag->last_offset = 0;\n\t\tdefrag->cycled = 1;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\n\tiput(inode);\n\treturn 0;\ncleanup:\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define BTRFS_DEFRAG_BATCH\t1024"
          ],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define BTRFS_DEFRAG_BATCH\t1024\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nstatic int __btrfs_run_defrag_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *inode_root;\n\tstruct inode *inode;\n\tstruct btrfs_key key;\n\tstruct btrfs_ioctl_defrag_range_args range;\n\tint num_defrag;\n\tint index;\n\tint ret;\n\n\t/* get the inode */\n\tkey.objectid = defrag->root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tinode_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(inode_root)) {\n\t\tret = PTR_ERR(inode_root);\n\t\tgoto cleanup;\n\t}\n\n\tkey.objectid = defrag->ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, inode_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto cleanup;\n\t}\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t/* do a chunk of defrag */\n\tclear_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\tmemset(&range, 0, sizeof(range));\n\trange.len = (u64)-1;\n\trange.start = defrag->last_offset;\n\n\tsb_start_write(fs_info->sb);\n\tnum_defrag = btrfs_defrag_file(inode, NULL, &range, defrag->transid,\n\t\t\t\t       BTRFS_DEFRAG_BATCH);\n\tsb_end_write(fs_info->sb);\n\t/*\n\t * if we filled the whole defrag batch, there\n\t * must be more work to do.  Queue this defrag\n\t * again\n\t */\n\tif (num_defrag == BTRFS_DEFRAG_BATCH) {\n\t\tdefrag->last_offset = range.start;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else if (defrag->last_offset && !defrag->cycled) {\n\t\t/*\n\t\t * we didn't fill our defrag batch, but\n\t\t * we didn't start at zero.  Make sure we loop\n\t\t * around to the start of the file.\n\t\t */\n\t\tdefrag->last_offset = 0;\n\t\tdefrag->cycled = 1;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\n\tiput(inode);\n\treturn 0;\ncleanup:\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pick_defrag_inode",
          "args": [
            "fs_info",
            "root_objectid",
            "first_ino"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pick_defrag_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "223-262",
          "snippet": "static struct inode_defrag *\nbtrfs_pick_defrag_inode(struct btrfs_fs_info *fs_info, u64 root, u64 ino)\n{\n\tstruct inode_defrag *entry = NULL;\n\tstruct inode_defrag tmp;\n\tstruct rb_node *p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\ttmp.ino = ino;\n\ttmp.root = root;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tp = fs_info->defrag_inodes.rb_node;\n\twhile (p) {\n\t\tparent = p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(&tmp, entry);\n\t\tif (ret < 0)\n\t\t\tp = parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = parent->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (parent && __compare_inode_defrag(&tmp, entry) > 0) {\n\t\tparent = rb_next(parent);\n\t\tif (parent)\n\t\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\t\telse\n\t\t\tentry = NULL;\n\t}\nout:\n\tif (entry)\n\t\trb_erase(parent, &fs_info->defrag_inodes);\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct inode_defrag *\nbtrfs_pick_defrag_inode(struct btrfs_fs_info *fs_info, u64 root, u64 ino)\n{\n\tstruct inode_defrag *entry = NULL;\n\tstruct inode_defrag tmp;\n\tstruct rb_node *p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\ttmp.ino = ino;\n\ttmp.root = root;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tp = fs_info->defrag_inodes.rb_node;\n\twhile (p) {\n\t\tparent = p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(&tmp, entry);\n\t\tif (ret < 0)\n\t\t\tp = parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = parent->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (parent && __compare_inode_defrag(&tmp, entry) > 0) {\n\t\tparent = rb_next(parent);\n\t\tif (parent)\n\t\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\t\telse\n\t\t\tentry = NULL;\n\t}\nout:\n\tif (entry)\n\t\trb_erase(parent, &fs_info->defrag_inodes);\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_auto_defrag",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__need_auto_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "132-141",
          "snippet": "static inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_REMOUNTING",
            "&fs_info->fs_state"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_info->defrag_running"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_run_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tu64 first_ino = 0;\n\tu64 root_objectid = 0;\n\n\tatomic_inc(&fs_info->defrag_running);\n\twhile (1) {\n\t\t/* Pause the auto defragger. */\n\t\tif (test_bit(BTRFS_FS_STATE_REMOUNTING,\n\t\t\t     &fs_info->fs_state))\n\t\t\tbreak;\n\n\t\tif (!__need_auto_defrag(fs_info->tree_root))\n\t\t\tbreak;\n\n\t\t/* find an inode to defrag */\n\t\tdefrag = btrfs_pick_defrag_inode(fs_info, root_objectid,\n\t\t\t\t\t\t first_ino);\n\t\tif (!defrag) {\n\t\t\tif (root_objectid || first_ino) {\n\t\t\t\troot_objectid = 0;\n\t\t\t\tfirst_ino = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfirst_ino = defrag->ino + 1;\n\t\troot_objectid = defrag->root;\n\n\t\t__btrfs_run_defrag_inode(fs_info, defrag);\n\t}\n\tatomic_dec(&fs_info->defrag_running);\n\n\t/*\n\t * during unmount, we use the transaction_wait queue to\n\t * wait for the defragger to stop\n\t */\n\twake_up(&fs_info->transaction_wait);\n\treturn 0;\n}"
  },
  {
    "function_name": "__btrfs_run_defrag_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "289-360",
    "snippet": "static int __btrfs_run_defrag_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *inode_root;\n\tstruct inode *inode;\n\tstruct btrfs_key key;\n\tstruct btrfs_ioctl_defrag_range_args range;\n\tint num_defrag;\n\tint index;\n\tint ret;\n\n\t/* get the inode */\n\tkey.objectid = defrag->root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tinode_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(inode_root)) {\n\t\tret = PTR_ERR(inode_root);\n\t\tgoto cleanup;\n\t}\n\n\tkey.objectid = defrag->ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, inode_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto cleanup;\n\t}\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t/* do a chunk of defrag */\n\tclear_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\tmemset(&range, 0, sizeof(range));\n\trange.len = (u64)-1;\n\trange.start = defrag->last_offset;\n\n\tsb_start_write(fs_info->sb);\n\tnum_defrag = btrfs_defrag_file(inode, NULL, &range, defrag->transid,\n\t\t\t\t       BTRFS_DEFRAG_BATCH);\n\tsb_end_write(fs_info->sb);\n\t/*\n\t * if we filled the whole defrag batch, there\n\t * must be more work to do.  Queue this defrag\n\t * again\n\t */\n\tif (num_defrag == BTRFS_DEFRAG_BATCH) {\n\t\tdefrag->last_offset = range.start;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else if (defrag->last_offset && !defrag->cycled) {\n\t\t/*\n\t\t * we didn't fill our defrag batch, but\n\t\t * we didn't start at zero.  Make sure we loop\n\t\t * around to the start of the file.\n\t\t */\n\t\tdefrag->last_offset = 0;\n\t\tdefrag->cycled = 1;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\n\tiput(inode);\n\treturn 0;\ncleanup:\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define BTRFS_DEFRAG_BATCH\t1024"
    ],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_requeue_inode_defrag",
          "args": [
            "inode",
            "defrag"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_requeue_inode_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "196-217",
          "snippet": "static void btrfs_requeue_inode_defrag(struct inode *inode,\n\t\t\t\t       struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\tgoto out;\n\n\t/*\n\t * Here we don't check the IN_DEFRAG flag, because we need merge\n\t * them together.\n\t */\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tret = __btrfs_add_inode_defrag(inode, defrag);\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\tif (ret)\n\t\tgoto out;\n\treturn;\nout:\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nstatic void btrfs_requeue_inode_defrag(struct inode *inode,\n\t\t\t\t       struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\tgoto out;\n\n\t/*\n\t * Here we don't check the IN_DEFRAG flag, because we need merge\n\t * them together.\n\t */\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tret = __btrfs_add_inode_defrag(inode, defrag);\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\tif (ret)\n\t\tgoto out;\n\treturn;\nout:\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "fs_info->sb"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_file",
          "args": [
            "inode",
            "NULL",
            "&range",
            "defrag->transid",
            "BTRFS_DEFRAG_BATCH"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1231-1448",
          "snippet": "int btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write",
          "args": [
            "fs_info->sb"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&range",
            "0",
            "sizeof(range)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_INODE_IN_DEFRAG",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "fs_info->sb",
            "&key",
            "inode_root",
            "NULL"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode_root"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode_root"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&key"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define BTRFS_DEFRAG_BATCH\t1024\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nstatic int __btrfs_run_defrag_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *inode_root;\n\tstruct inode *inode;\n\tstruct btrfs_key key;\n\tstruct btrfs_ioctl_defrag_range_args range;\n\tint num_defrag;\n\tint index;\n\tint ret;\n\n\t/* get the inode */\n\tkey.objectid = defrag->root;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\tinode_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\tif (IS_ERR(inode_root)) {\n\t\tret = PTR_ERR(inode_root);\n\t\tgoto cleanup;\n\t}\n\n\tkey.objectid = defrag->ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(fs_info->sb, &key, inode_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto cleanup;\n\t}\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t/* do a chunk of defrag */\n\tclear_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\tmemset(&range, 0, sizeof(range));\n\trange.len = (u64)-1;\n\trange.start = defrag->last_offset;\n\n\tsb_start_write(fs_info->sb);\n\tnum_defrag = btrfs_defrag_file(inode, NULL, &range, defrag->transid,\n\t\t\t\t       BTRFS_DEFRAG_BATCH);\n\tsb_end_write(fs_info->sb);\n\t/*\n\t * if we filled the whole defrag batch, there\n\t * must be more work to do.  Queue this defrag\n\t * again\n\t */\n\tif (num_defrag == BTRFS_DEFRAG_BATCH) {\n\t\tdefrag->last_offset = range.start;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else if (defrag->last_offset && !defrag->cycled) {\n\t\t/*\n\t\t * we didn't fill our defrag batch, but\n\t\t * we didn't start at zero.  Make sure we loop\n\t\t * around to the start of the file.\n\t\t */\n\t\tdefrag->last_offset = 0;\n\t\tdefrag->cycled = 1;\n\t\tbtrfs_requeue_inode_defrag(inode, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\n\tiput(inode);\n\treturn 0;\ncleanup:\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_cleanup_defrag_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "264-285",
    "snippet": "void btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->defrag_inodes_lock"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&fs_info->defrag_inodes"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->defrag_inodes_lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structinode_defrag",
            "rb_node"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&fs_info->defrag_inodes"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&fs_info->defrag_inodes"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nvoid btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}"
  },
  {
    "function_name": "btrfs_pick_defrag_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "223-262",
    "snippet": "static struct inode_defrag *\nbtrfs_pick_defrag_inode(struct btrfs_fs_info *fs_info, u64 root, u64 ino)\n{\n\tstruct inode_defrag *entry = NULL;\n\tstruct inode_defrag tmp;\n\tstruct rb_node *p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\ttmp.ino = ino;\n\ttmp.root = root;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tp = fs_info->defrag_inodes.rb_node;\n\twhile (p) {\n\t\tparent = p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(&tmp, entry);\n\t\tif (ret < 0)\n\t\t\tp = parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = parent->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (parent && __compare_inode_defrag(&tmp, entry) > 0) {\n\t\tparent = rb_next(parent);\n\t\tif (parent)\n\t\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\t\telse\n\t\t\tentry = NULL;\n\t}\nout:\n\tif (entry)\n\t\trb_erase(parent, &fs_info->defrag_inodes);\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n\treturn entry;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->defrag_inodes_lock"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "parent",
            "&fs_info->defrag_inodes"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structinode_defrag",
            "rb_node"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "parent"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__compare_inode_defrag",
          "args": [
            "&tmp",
            "entry"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__compare_inode_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "71-84",
          "snippet": "static int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structinode_defrag",
            "rb_node"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->defrag_inodes_lock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct inode_defrag *\nbtrfs_pick_defrag_inode(struct btrfs_fs_info *fs_info, u64 root, u64 ino)\n{\n\tstruct inode_defrag *entry = NULL;\n\tstruct inode_defrag tmp;\n\tstruct rb_node *p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\ttmp.ino = ino;\n\ttmp.root = root;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tp = fs_info->defrag_inodes.rb_node;\n\twhile (p) {\n\t\tparent = p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(&tmp, entry);\n\t\tif (ret < 0)\n\t\t\tp = parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = parent->rb_right;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (parent && __compare_inode_defrag(&tmp, entry) > 0) {\n\t\tparent = rb_next(parent);\n\t\tif (parent)\n\t\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\t\telse\n\t\t\tentry = NULL;\n\t}\nout:\n\tif (entry)\n\t\trb_erase(parent, &fs_info->defrag_inodes);\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n\treturn entry;\n}"
  },
  {
    "function_name": "btrfs_requeue_inode_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "196-217",
    "snippet": "static void btrfs_requeue_inode_defrag(struct inode *inode,\n\t\t\t\t       struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\tgoto out;\n\n\t/*\n\t * Here we don't check the IN_DEFRAG flag, because we need merge\n\t * them together.\n\t */\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tret = __btrfs_add_inode_defrag(inode, defrag);\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\tif (ret)\n\t\tgoto out;\n\treturn;\nout:\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->defrag_inodes_lock"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_add_inode_defrag",
          "args": [
            "inode",
            "defrag"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_inode_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "95-130",
          "snippet": "static int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->defrag_inodes_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_auto_defrag",
          "args": [
            "root"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__need_auto_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "132-141",
          "snippet": "static inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nstatic void btrfs_requeue_inode_defrag(struct inode *inode,\n\t\t\t\t       struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\tgoto out;\n\n\t/*\n\t * Here we don't check the IN_DEFRAG flag, because we need merge\n\t * them together.\n\t */\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tret = __btrfs_add_inode_defrag(inode, defrag);\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\tif (ret)\n\t\tgoto out;\n\treturn;\nout:\n\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n}"
  },
  {
    "function_name": "btrfs_add_inode_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "147-189",
    "snippet": "int btrfs_add_inode_defrag(struct btrfs_trans_handle *trans,\n\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *defrag;\n\tu64 transid;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\treturn 0;\n\n\tif (test_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags))\n\t\treturn 0;\n\n\tif (trans)\n\t\ttransid = trans->transid;\n\telse\n\t\ttransid = BTRFS_I(inode)->root->last_trans;\n\n\tdefrag = kmem_cache_zalloc(btrfs_inode_defrag_cachep, GFP_NOFS);\n\tif (!defrag)\n\t\treturn -ENOMEM;\n\n\tdefrag->ino = btrfs_ino(inode);\n\tdefrag->transid = transid;\n\tdefrag->root = root->root_key.objectid;\n\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tif (!test_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags)) {\n\t\t/*\n\t\t * If we set IN_DEFRAG flag and evict the inode from memory,\n\t\t * and then re-read this inode, this new inode doesn't have\n\t\t * IN_DEFRAG flag. At the case, we may find the existed defrag.\n\t\t */\n\t\tret = __btrfs_add_inode_defrag(inode, defrag);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_inode_defrag_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->defrag_inodes_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_inode_defrag_cachep",
            "defrag"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_add_inode_defrag",
          "args": [
            "inode",
            "defrag"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_inode_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "95-130",
          "snippet": "static int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_IN_DEFRAG",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->defrag_inodes_lock"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_inode_defrag_cachep",
            "GFP_NOFS"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__need_auto_defrag",
          "args": [
            "root"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__need_auto_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "132-141",
          "snippet": "static inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nint btrfs_add_inode_defrag(struct btrfs_trans_handle *trans,\n\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *defrag;\n\tu64 transid;\n\tint ret;\n\n\tif (!__need_auto_defrag(root))\n\t\treturn 0;\n\n\tif (test_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags))\n\t\treturn 0;\n\n\tif (trans)\n\t\ttransid = trans->transid;\n\telse\n\t\ttransid = BTRFS_I(inode)->root->last_trans;\n\n\tdefrag = kmem_cache_zalloc(btrfs_inode_defrag_cachep, GFP_NOFS);\n\tif (!defrag)\n\t\treturn -ENOMEM;\n\n\tdefrag->ino = btrfs_ino(inode);\n\tdefrag->transid = transid;\n\tdefrag->root = root->root_key.objectid;\n\n\tspin_lock(&root->fs_info->defrag_inodes_lock);\n\tif (!test_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags)) {\n\t\t/*\n\t\t * If we set IN_DEFRAG flag and evict the inode from memory,\n\t\t * and then re-read this inode, this new inode doesn't have\n\t\t * IN_DEFRAG flag. At the case, we may find the existed defrag.\n\t\t */\n\t\tret = __btrfs_add_inode_defrag(inode, defrag);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t} else {\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\t}\n\tspin_unlock(&root->fs_info->defrag_inodes_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__need_auto_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "132-141",
    "snippet": "static inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "root->fs_info"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "AUTO_DEFRAG"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline int __need_auto_defrag(struct btrfs_root *root)\n{\n\tif (!btrfs_test_opt(root, AUTO_DEFRAG))\n\t\treturn 0;\n\n\tif (btrfs_fs_closing(root->fs_info))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__btrfs_add_inode_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "95-130",
    "snippet": "static int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&defrag->rb_node",
            "&root->fs_info->defrag_inodes"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&defrag->rb_node",
            "parent",
            "p"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_IN_DEFRAG",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__compare_inode_defrag",
          "args": [
            "defrag",
            "entry"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__compare_inode_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "71-84",
          "snippet": "static int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structinode_defrag",
            "rb_node"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_add_inode_defrag(struct inode *inode,\n\t\t\t\t    struct inode_defrag *defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct inode_defrag *entry;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tint ret;\n\n\tp = &root->fs_info->defrag_inodes.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct inode_defrag, rb_node);\n\n\t\tret = __compare_inode_defrag(defrag, entry);\n\t\tif (ret < 0)\n\t\t\tp = &parent->rb_left;\n\t\telse if (ret > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse {\n\t\t\t/* if we're reinserting an entry for\n\t\t\t * an old defrag run, make sure to\n\t\t\t * lower the transid of our existing record\n\t\t\t */\n\t\t\tif (defrag->transid < entry->transid)\n\t\t\t\tentry->transid = defrag->transid;\n\t\t\tif (defrag->last_offset > entry->last_offset)\n\t\t\t\tentry->last_offset = defrag->last_offset;\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tset_bit(BTRFS_INODE_IN_DEFRAG, &BTRFS_I(inode)->runtime_flags);\n\trb_link_node(&defrag->rb_node, parent, p);\n\trb_insert_color(&defrag->rb_node, &root->fs_info->defrag_inodes);\n\treturn 0;\n}"
  },
  {
    "function_name": "__compare_inode_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
    "lines": "71-84",
    "snippet": "static int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"volumes.h\"",
      "#include \"locking.h\"",
      "#include \"tree-log.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int __compare_inode_defrag(struct inode_defrag *defrag1,\n\t\t\t\t  struct inode_defrag *defrag2)\n{\n\tif (defrag1->root > defrag2->root)\n\t\treturn 1;\n\telse if (defrag1->root < defrag2->root)\n\t\treturn -1;\n\telse if (defrag1->ino > defrag2->ino)\n\t\treturn 1;\n\telse if (defrag1->ino < defrag2->ino)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}"
  }
]