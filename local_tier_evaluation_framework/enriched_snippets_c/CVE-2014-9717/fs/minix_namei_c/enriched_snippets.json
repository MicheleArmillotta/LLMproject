[
  {
    "function_name": "minix_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "187-253",
    "snippet": "static int minix_rename(struct inode * old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode * new_dir, struct dentry *new_dentry)\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct minix_dir_entry * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct minix_dir_entry * old_de;\n\tint err = -ENOENT;\n\n\told_de = minix_find_entry(old_dentry, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = minix_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page * new_page;\n\t\tstruct minix_dir_entry * new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !minix_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = minix_find_entry(new_dentry, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tminix_set_link(new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = minix_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\tminix_delete_entry(old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tminix_set_link(dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "old_page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "old_page"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dir_page"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dir_page"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "old_dir"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_set_link",
          "args": [
            "dir_de",
            "dir_page",
            "new_dir"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "416-440",
          "snippet": "void minix_set_link(struct minix_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = inode->i_ino;\n\t\telse\n\t\t\tde->inode = inode->i_ino;\n\t\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nvoid minix_set_link(struct minix_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = inode->i_ino;\n\t\telse\n\t\t\tde->inode = inode->i_ino;\n\t\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_delete_entry",
          "args": [
            "old_de",
            "old_page"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "minix_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "293-317",
          "snippet": "int minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "new_dir"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "minix_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "204-291",
          "snippet": "int minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_find_entry",
          "args": [
            "new_dentry",
            "&new_page"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "155-202",
          "snippet": "minix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nminix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "minix_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "365-413",
          "snippet": "int minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_dotdot",
          "args": [
            "old_inode",
            "&dir_page"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "minix_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "442-453",
          "snippet": "struct minix_dir_entry * minix_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tstruct minix_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = minix_next_entry(page_address(page), sbi);\n\t\t*p = page;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix_dir_entry * minix_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct minix_sb_info *sbi = minix_sb(dir->i_sb);\n\tstruct minix_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = minix_next_entry(page_address(page), sbi);\n\t\t*p = page;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_rename(struct inode * old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode * new_dir, struct dentry *new_dentry)\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct minix_dir_entry * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct minix_dir_entry * old_de;\n\tint err = -ENOENT;\n\n\told_de = minix_find_entry(old_dentry, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = minix_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page * new_page;\n\t\tstruct minix_dir_entry * new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !minix_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = minix_find_entry(new_dentry, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tminix_set_link(new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = minix_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\tminix_delete_entry(old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tminix_set_link(dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "minix_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "172-185",
    "snippet": "static int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "minix_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "151-170",
          "snippet": "static int minix_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint err = -ENOENT;\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct minix_dir_entry * de;\n\n\tde = minix_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto end_unlink;\n\n\terr = minix_delete_entry(de, page);\n\tif (err)\n\t\tgoto end_unlink;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nend_unlink:\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint err = -ENOENT;\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct minix_dir_entry * de;\n\n\tde = minix_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto end_unlink;\n\n\terr = minix_delete_entry(de, page);\n\tif (err)\n\t\tgoto end_unlink;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nend_unlink:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_empty_dir",
          "args": [
            "inode"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "minix_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "365-413",
          "snippet": "int minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_empty_dir(struct inode * inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *name;\n\t__u32 inumber;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *p, *kaddr, *limit;\n\n\t\tpage = dir_get_page(inode, i);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(inode, i) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tname = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tname = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\n\t\t\tif (inumber != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (!name[1]) {\n\t\t\t\t\tif (inumber != inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\telse if (name[2])\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "minix_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "151-170",
    "snippet": "static int minix_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint err = -ENOENT;\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct minix_dir_entry * de;\n\n\tde = minix_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto end_unlink;\n\n\terr = minix_delete_entry(de, page);\n\tif (err)\n\t\tgoto end_unlink;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nend_unlink:\n\treturn err;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_delete_entry",
          "args": [
            "de",
            "page"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "minix_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "293-317",
          "snippet": "int minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_delete_entry(struct minix_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = page_address(page);\n\tloff_t pos = page_offset(page) + (char*)de - kaddr;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tunsigned len = sbi->s_dirsize;\n\tint err;\n\n\tlock_page(page);\n\terr = minix_prepare_chunk(page, pos, len);\n\tif (err == 0) {\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t((minix3_dirent *) de)->inode = 0;\n\t\telse\n\t\t\tde->inode = 0;\n\t\terr = dir_commit_chunk(page, pos, len);\n\t} else {\n\t\tunlock_page(page);\n\t}\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_find_entry",
          "args": [
            "dentry",
            "&page"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "155-202",
          "snippet": "minix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nminix_dirent *minix_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tunsigned long n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tchar *p;\n\n\tchar *namx;\n\t__u32 inumber;\n\t*res_page = NULL;\n\n\tfor (n = 0; n < npages; n++) {\n\t\tchar *kaddr, *limit;\n\n\t\tpage = dir_get_page(dir, n);\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char*)page_address(page);\n\t\tlimit = kaddr + minix_last_byte(dir, n) - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tminix3_dirent *de3 = (minix3_dirent *)p;\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n \t\t\t} else {\n\t\t\t\tminix_dirent *de = (minix_dirent *)p;\n\t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tcontinue;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto found;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\treturn (minix_dirent *)p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_unlink(struct inode * dir, struct dentry *dentry)\n{\n\tint err = -ENOENT;\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct minix_dir_entry * de;\n\n\tde = minix_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto end_unlink;\n\n\terr = minix_delete_entry(de, page);\n\tif (err)\n\t\tgoto end_unlink;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nend_unlink:\n\treturn err;\n}"
  },
  {
    "function_name": "minix_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "115-149",
    "snippet": "static int minix_mkdir(struct inode * dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = minix_new_inode(dir, S_IFDIR | mode, &err);\n\tif (!inode)\n\t\tgoto out_dir;\n\n\tminix_set_inode(inode, 0);\n\n\tinode_inc_link_count(inode);\n\n\terr = minix_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = minix_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "minix_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "204-291",
          "snippet": "int minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_make_empty",
          "args": [
            "inode",
            "dir"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "minix_make_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "319-360",
          "snippet": "int minix_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *kaddr;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = minix_prepare_chunk(page, 0, 2 * sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, PAGE_CACHE_SIZE);\n\n\tif (sbi->s_version == MINIX_V3) {\n\t\tminix3_dirent *de3 = (minix3_dirent *)kaddr;\n\n\t\tde3->inode = inode->i_ino;\n\t\tstrcpy(de3->name, \".\");\n\t\tde3 = minix_next_entry(de3, sbi);\n\t\tde3->inode = dir->i_ino;\n\t\tstrcpy(de3->name, \"..\");\n\t} else {\n\t\tminix_dirent *de = (minix_dirent *)kaddr;\n\n\t\tde->inode = inode->i_ino;\n\t\tstrcpy(de->name, \".\");\n\t\tde = minix_next_entry(de, sbi);\n\t\tde->inode = dir->i_ino;\n\t\tstrcpy(de->name, \"..\");\n\t}\n\tkunmap_atomic(kaddr);\n\n\terr = dir_commit_chunk(page, 0, 2 * sbi->s_dirsize);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tchar *kaddr;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = minix_prepare_chunk(page, 0, 2 * sbi->s_dirsize);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr, 0, PAGE_CACHE_SIZE);\n\n\tif (sbi->s_version == MINIX_V3) {\n\t\tminix3_dirent *de3 = (minix3_dirent *)kaddr;\n\n\t\tde3->inode = inode->i_ino;\n\t\tstrcpy(de3->name, \".\");\n\t\tde3 = minix_next_entry(de3, sbi);\n\t\tde3->inode = dir->i_ino;\n\t\tstrcpy(de3->name, \"..\");\n\t} else {\n\t\tminix_dirent *de = (minix_dirent *)kaddr;\n\n\t\tde->inode = inode->i_ino;\n\t\tstrcpy(de->name, \".\");\n\t\tde = minix_next_entry(de, sbi);\n\t\tde->inode = dir->i_ino;\n\t\tstrcpy(de->name, \"..\");\n\t}\n\tkunmap_atomic(kaddr);\n\n\terr = dir_commit_chunk(page, 0, 2 * sbi->s_dirsize);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_new_inode",
          "args": [
            "dir",
            "S_IFDIR | mode",
            "&err"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "minix_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "212-264",
          "snippet": "struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "dir"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_mkdir(struct inode * dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = minix_new_inode(dir, S_IFDIR | mode, &err);\n\tif (!inode)\n\t\tgoto out_dir;\n\n\tminix_set_inode(inode, 0);\n\n\tinode_inc_link_count(inode);\n\n\terr = minix_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = minix_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n\td_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}"
  },
  {
    "function_name": "minix_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "104-113",
    "snippet": "static int minix_link(struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\treturn add_nondir(dentry, inode);\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "9-19",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_link(struct dentry * old_dentry, struct inode * dir,\n\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\treturn add_nondir(dentry, inode);\n}"
  },
  {
    "function_name": "minix_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "75-102",
    "snippet": "static int minix_symlink(struct inode * dir, struct dentry *dentry,\n\t  const char * symname)\n{\n\tint err = -ENAMETOOLONG;\n\tint i = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (i > dir->i_sb->s_blocksize)\n\t\tgoto out;\n\n\tinode = minix_new_inode(dir, S_IFLNK | 0777, &err);\n\tif (!inode)\n\t\tgoto out;\n\n\tminix_set_inode(inode, 0);\n\terr = page_symlink(inode, symname, i);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\tgoto out;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "9-19",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "i"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_new_inode",
          "args": [
            "dir",
            "S_IFLNK | 0777",
            "&err"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "minix_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "212-264",
          "snippet": "struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_symlink(struct inode * dir, struct dentry *dentry,\n\t  const char * symname)\n{\n\tint err = -ENAMETOOLONG;\n\tint i = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (i > dir->i_sb->s_blocksize)\n\t\tgoto out;\n\n\tinode = minix_new_inode(dir, S_IFLNK | 0777, &err);\n\tif (!inode)\n\t\tgoto out;\n\n\tminix_set_inode(inode, 0);\n\terr = page_symlink(inode, symname, i);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "minix_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "69-73",
    "snippet": "static int minix_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn minix_mknod(dir, dentry, mode, 0);\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minix_mknod",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "minix_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "39-55",
          "snippet": "static int minix_mknod(struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tint error;\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = minix_new_inode(dir, mode, &error);\n\n\tif (inode) {\n\t\tminix_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terror = add_nondir(dentry, inode);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_mknod(struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tint error;\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = minix_new_inode(dir, mode, &error);\n\n\tif (inode) {\n\t\tminix_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terror = add_nondir(dentry, inode);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn minix_mknod(dir, dentry, mode, 0);\n}"
  },
  {
    "function_name": "minix_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "57-67",
    "snippet": "static int minix_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error;\n\tstruct inode *inode = minix_new_inode(dir, mode, &error);\n\tif (inode) {\n\t\tminix_set_inode(inode, 0);\n\t\tmark_inode_dirty(inode);\n\t\td_tmpfile(dentry, inode);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_new_inode",
          "args": [
            "dir",
            "mode",
            "&error"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "minix_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "212-264",
          "snippet": "struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error;\n\tstruct inode *inode = minix_new_inode(dir, mode, &error);\n\tif (inode) {\n\t\tminix_set_inode(inode, 0);\n\t\tmark_inode_dirty(inode);\n\t\td_tmpfile(dentry, inode);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "minix_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "39-55",
    "snippet": "static int minix_mknod(struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tint error;\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = minix_new_inode(dir, mode, &error);\n\n\tif (inode) {\n\t\tminix_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terror = add_nondir(dentry, inode);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "9-19",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "rdev"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_new_inode",
          "args": [
            "dir",
            "mode",
            "&error"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "minix_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "212-264",
          "snippet": "struct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct buffer_head * bh;\n\tint bits_per_zone = 8 * sb->s_blocksize;\n\tunsigned long j;\n\tint i;\n\n\tif (!inode) {\n\t\t*error = -ENOMEM;\n\t\treturn NULL;\n\t}\n\tj = bits_per_zone;\n\tbh = NULL;\n\t*error = -ENOSPC;\n\tspin_lock(&bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_blocks; i++) {\n\t\tbh = sbi->s_imap[i];\n\t\tj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\n\t\tif (j < bits_per_zone)\n\t\t\tbreak;\n\t}\n\tif (!bh || j >= bits_per_zone) {\n\t\tspin_unlock(&bitmap_lock);\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (minix_test_and_set_bit(j, bh->b_data)) {\t/* shouldn't happen */\n\t\tspin_unlock(&bitmap_lock);\n\t\tprintk(\"minix_new_inode: bit already set\\n\");\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n\tj += i * bits_per_zone;\n\tif (!j || j > sbi->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = j;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\t*error = 0;\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_mknod(struct inode * dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tint error;\n\tstruct inode *inode;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = minix_new_inode(dir, mode, &error);\n\n\tif (inode) {\n\t\tminix_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terror = add_nondir(dentry, inode);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "minix_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "21-37",
    "snippet": "static struct dentry *minix_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\n\tif (dentry->d_name.len > minix_sb(dir->i_sb)->s_namelen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = minix_inode_by_name(dentry);\n\tif (ino) {\n\t\tinode = minix_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "531-545",
          "snippet": "struct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstruct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_inode_by_name",
          "args": [
            "dentry"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "minix_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "455-473",
          "snippet": "ino_t minix_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\tres = ((minix3_dirent *) de)->inode;\n\t\telse\n\t\t\tres = de->inode;\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nino_t minix_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct minix_dir_entry *de = minix_find_entry(dentry, &page);\n\tino_t res = 0;\n\n\tif (de) {\n\t\tstruct address_space *mapping = page->mapping;\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\n\t\tif (sbi->s_version == MINIX_V3)\n\t\t\tres = ((minix3_dirent *) de)->inode;\n\t\telse\n\t\t\tres = de->inode;\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic struct dentry *minix_lookup(struct inode * dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\n\tif (dentry->d_name.len > minix_sb(dir->i_sb)->s_namelen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tino = minix_inode_by_name(dentry);\n\tif (ino) {\n\t\tinode = minix_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
    "lines": "9-19",
    "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"minix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 11
        },
        "resolved": true,
        "details": {
          "function_name": "minix_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/dir.c",
          "lines": "204-291",
          "snippet": "int minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
          "includes": [
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nint minix_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct super_block * sb = dir->i_sb;\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct page *page = NULL;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr, *p;\n\tminix_dirent *de;\n\tminix3_dirent *de3;\n\tloff_t pos;\n\tint err;\n\tchar *namx = NULL;\n\t__u32 inumber;\n\n\t/*\n\t * We take care of directory expansion in the same loop\n\t * This code plays outside i_size, so it locks the page\n\t * to protect that region.\n\t */\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *limit, *dir_end;\n\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = (char*)page_address(page);\n\t\tdir_end = kaddr + minix_last_byte(dir, n);\n\t\tlimit = kaddr + PAGE_CACHE_SIZE - sbi->s_dirsize;\n\t\tfor (p = kaddr; p <= limit; p = minix_next_entry(p, sbi)) {\n\t\t\tde = (minix_dirent *)p;\n\t\t\tde3 = (minix3_dirent *)p;\n\t\t\tif (sbi->s_version == MINIX_V3) {\n\t\t\t\tnamx = de3->name;\n\t\t\t\tinumber = de3->inode;\n\t\t \t} else {\n  \t\t\t\tnamx = de->name;\n\t\t\t\tinumber = de->inode;\n\t\t\t}\n\t\t\tif (p == dir_end) {\n\t\t\t\t/* We hit i_size */\n\t\t\t\tif (sbi->s_version == MINIX_V3)\n\t\t\t\t\tde3->inode = 0;\n\t\t \t\telse\n\t\t\t\t\tde->inode = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (!inumber)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, sbi->s_namelen, name, namx))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tunlock_page(page);\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) + p - (char *)page_address(page);\n\terr = minix_prepare_chunk(page, pos, sbi->s_dirsize);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (namx, name, namelen);\n\tif (sbi->s_version == MINIX_V3) {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 4);\n\t\tde3->inode = inode->i_ino;\n\t} else {\n\t\tmemset (namx + namelen, 0, sbi->s_dirsize - namelen - 2);\n\t\tde->inode = inode->i_ino;\n\t}\n\terr = dir_commit_chunk(page, pos, sbi->s_dirsize);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_put:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"minix.h\"\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = minix_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
  }
]