[
  {
    "function_name": "nfsd_reply_cache_stats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "630-633",
    "snippet": "int nfsd_reply_cache_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nfsd_reply_cache_stats_show, NULL);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "nfsd_reply_cache_stats_show",
            "NULL"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nint nfsd_reply_cache_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nfsd_reply_cache_stats_show, NULL);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_stats_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "614-628",
    "snippet": "static int nfsd_reply_cache_stats_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"max entries:           %u\\n\", max_drc_entries);\n\tseq_printf(m, \"num entries:           %u\\n\",\n\t\t\tatomic_read(&num_drc_entries));\n\tseq_printf(m, \"hash buckets:          %u\\n\", 1 << maskbits);\n\tseq_printf(m, \"mem usage:             %u\\n\", drc_mem_usage);\n\tseq_printf(m, \"cache hits:            %u\\n\", nfsdstats.rchits);\n\tseq_printf(m, \"cache misses:          %u\\n\", nfsdstats.rcmisses);\n\tseq_printf(m, \"not cached:            %u\\n\", nfsdstats.rcnocache);\n\tseq_printf(m, \"payload misses:        %u\\n\", payload_misses);\n\tseq_printf(m, \"longest chain len:     %u\\n\", longest_chain);\n\tseq_printf(m, \"cachesize at longest:  %u\\n\", longest_chain_cachesize);\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmax_drc_entries;",
      "static unsigned int\t\tmaskbits;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tpayload_misses;",
      "static unsigned int\t\tdrc_mem_usage;",
      "static unsigned int\t\tlongest_chain;",
      "static unsigned int\t\tlongest_chain_cachesize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"cachesize at longest:  %u\\n\"",
            "longest_chain_cachesize"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic unsigned int\t\tmaskbits;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tpayload_misses;\nstatic unsigned int\t\tdrc_mem_usage;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic int nfsd_reply_cache_stats_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"max entries:           %u\\n\", max_drc_entries);\n\tseq_printf(m, \"num entries:           %u\\n\",\n\t\t\tatomic_read(&num_drc_entries));\n\tseq_printf(m, \"hash buckets:          %u\\n\", 1 << maskbits);\n\tseq_printf(m, \"mem usage:             %u\\n\", drc_mem_usage);\n\tseq_printf(m, \"cache hits:            %u\\n\", nfsdstats.rchits);\n\tseq_printf(m, \"cache misses:          %u\\n\", nfsdstats.rcmisses);\n\tseq_printf(m, \"not cached:            %u\\n\", nfsdstats.rcnocache);\n\tseq_printf(m, \"payload misses:        %u\\n\", payload_misses);\n\tseq_printf(m, \"longest chain len:     %u\\n\", longest_chain);\n\tseq_printf(m, \"cachesize at longest:  %u\\n\", longest_chain_cachesize);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_cache_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "594-607",
    "snippet": "static int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)vec->iov_base + vec->iov_len",
            "data->iov_base",
            "data->iov_len"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\"",
            "data->iov_len"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);\n\nstatic int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfsd_cache_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "533-587",
    "snippet": "void\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_put_end",
          "args": [
            "b",
            "rp"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "lru_put_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "226-232",
          "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free",
          "args": [
            "b",
            "rp"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "156-162",
          "snippet": "static void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cachv->iov_base",
            "statp",
            "bufsize"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bufsize",
            "GFP_KERNEL"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: RC_REPLSTAT/reply len %d!\\n\"",
            "len"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_hash",
          "args": [
            "rp->c_xid"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "123-127",
          "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmaskbits;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_mem_usage;\n\nvoid\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}"
  },
  {
    "function_name": "nfsd_cache_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "404-515",
    "snippet": "int\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "143-154",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: bad repcache type %d\\n\"",
            "rp->c_type"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_append",
          "args": [
            "rqstp",
            "&rp->c_replvec"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "594-607",
          "snippet": "static int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);\n\nstatic int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_putu32",
          "args": [
            "&rqstp->rq_res.head[0]",
            "rp->c_replstat"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_put_end",
          "args": [
            "b",
            "rp"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "lru_put_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "226-232",
          "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp->c_replvec.iov_base"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_set_port",
          "args": [
            "(struct sockaddr *)&rp->c_addr",
            "rpc_get_port(svc_addr(rqstp))"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "svc_addr(rqstp)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *)&rp->c_addr",
            "svc_addr(rqstp)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: unable to allocate DRC entry!\\n\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_search",
          "args": [
            "b",
            "rqstp",
            "csum"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "367-395",
          "snippet": "static struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tlongest_chain;",
            "static unsigned int\t\tlongest_chain_cachesize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_bucket",
          "args": [
            "b"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "prune_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "234-254",
          "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmax_drc_entries;",
            "static atomic_t\t\t\tnum_drc_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&num_drc_entries"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_alloc",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "129-141",
          "snippet": "static struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\n\nstatic struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_csum",
          "args": [
            "rqstp"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "308-336",
          "snippet": "static __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_hash",
          "args": [
            "xid"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "123-127",
          "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmaskbits;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nint\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd_cache_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "367-395",
    "snippet": "static struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tlongest_chain;",
      "static unsigned int\t\tlongest_chain_cachesize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "longest_chain_cachesize",
            "atomic_read(&num_drc_entries)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_match",
          "args": [
            "rqstp",
            "csum",
            "rp"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "338-360",
          "snippet": "static bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tpayload_misses;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tpayload_misses;\n\nstatic bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rp",
            "rh",
            "c_lru"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_cache_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "338-360",
    "snippet": "static bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tpayload_misses;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "(struct sockaddr *)&rp->c_addr"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "svc_addr(rqstp)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "svc_addr(rqstp)",
            "(struct sockaddr *)&rp->c_addr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tpayload_misses;\n\nstatic bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "nfsd_cache_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "308-336",
    "snippet": "static __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "csum_partial",
          "args": [
            "p",
            "len",
            "csum"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - base",
            "csum_len"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "buf->pages[idx]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csum_partial",
          "args": [
            "p",
            "len",
            "0"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "buf->head[0].iov_len",
            "csum_len"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfssvc.c",
          "lines": "152-169",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "buf->head[0].iov_len + buf->page_len",
            "RC_CSUMLEN"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}"
  },
  {
    "function_name": "nfsd_reply_cache_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "300-304",
    "snippet": "static unsigned long\nnfsd_reply_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn prune_cache_entries();\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);",
      "static unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prune_cache_entries",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "prune_cache_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "260-286",
          "snippet": "static long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static unsigned int\t\tdrc_hashsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_hashsize;\n\nstatic long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);\nstatic unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);\n\nstatic unsigned long\nnfsd_reply_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn prune_cache_entries();\n}"
  },
  {
    "function_name": "nfsd_reply_cache_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "294-298",
    "snippet": "static unsigned long\nnfsd_reply_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn atomic_read(&num_drc_entries);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);",
      "static unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);\nstatic unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);\n\nstatic unsigned long\nnfsd_reply_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn atomic_read(&num_drc_entries);\n}"
  },
  {
    "function_name": "cache_cleaner_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "288-292",
    "snippet": "static void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tcache_cleaner_func(struct work_struct *unused);",
      "static DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prune_cache_entries",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "prune_cache_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "260-286",
          "snippet": "static long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static unsigned int\t\tdrc_hashsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_hashsize;\n\nstatic long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\tcache_cleaner_func(struct work_struct *unused);\nstatic DECLARE_DELAYED_WORK(cache_cleaner, cache_cleaner_func);\n\nstatic void\ncache_cleaner_func(struct work_struct *unused)\n{\n\tprune_cache_entries();\n}"
  },
  {
    "function_name": "prune_cache_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "260-286",
    "snippet": "static long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static unsigned int\t\tdrc_hashsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "system_wq",
            "&cache_cleaner",
            "RC_EXPIRE"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&b->lru_head"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_bucket",
          "args": [
            "b"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "prune_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "234-254",
          "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmax_drc_entries;",
            "static atomic_t\t\t\tnum_drc_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_hashsize;\n\nstatic long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\tbool cancel = true;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tif (!list_empty(&b->lru_head))\n\t\t\tcancel = false;\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\n\t/*\n\t * Conditionally rearm the job to run in RC_EXPIRE since we just\n\t * ran the pruner.\n\t */\n\tif (!cancel)\n\t\tmod_delayed_work(system_wq, &cache_cleaner, RC_EXPIRE);\n\treturn freed;\n}"
  },
  {
    "function_name": "prune_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "234-254",
    "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmax_drc_entries;",
      "static atomic_t\t\t\tnum_drc_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "143-154",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "rp->c_timestamp + RC_EXPIRE"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rp",
            "tmp",
            "&b->lru_head",
            "c_lru"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
  },
  {
    "function_name": "lru_put_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "226-232",
    "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&cache_cleaner",
            "RC_EXPIRE"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&rp->c_lru",
            "&b->lru_head"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n\tschedule_delayed_work(&cache_cleaner, RC_EXPIRE);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "196-220",
    "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\tcancel_delayed_work_sync(&cache_cleaner);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tif (drc_slab) {\n\t\tkmem_cache_destroy(drc_slab);\n\t\tdrc_slab = NULL;\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static struct kmem_cache\t*drc_slab;",
      "static unsigned int\t\tdrc_hashsize;",
      "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "drc_slab"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "drc_hashtbl"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "143-154",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structsvc_cacherep",
            "c_lru"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&cache_cleaner"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&nfsd_reply_cache_shrinker"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\tcancel_delayed_work_sync(&cache_cleaner);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tif (drc_slab) {\n\t\tkmem_cache_destroy(drc_slab);\n\t\tdrc_slab = NULL;\n\t}\n}"
  },
  {
    "function_name": "nfsd_reply_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "164-194",
    "snippet": "int nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tregister_shrinker(&nfsd_reply_cache_shrinker);\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static struct kmem_cache\t*drc_slab;",
      "static unsigned int\t\tmax_drc_entries;",
      "static unsigned int\t\tmaskbits;",
      "static unsigned int\t\tdrc_hashsize;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_shutdown",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "196-220",
          "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\tcancel_delayed_work_sync(&cache_cleaner);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tif (drc_slab) {\n\t\tkmem_cache_destroy(drc_slab);\n\t\tdrc_slab = NULL;\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static struct kmem_cache\t*drc_slab;",
            "static unsigned int\t\tdrc_hashsize;",
            "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\tcancel_delayed_work_sync(&cache_cleaner);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tif (drc_slab) {\n\t\tkmem_cache_destroy(drc_slab);\n\t\tdrc_slab = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nfsd: failed to allocate reply cache\\n\""
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&drc_hashtbl[i].cache_lock"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&drc_hashtbl[i].lru_head"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "hashsize",
            "sizeof(*drc_hashtbl)",
            "GFP_KERNEL"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd_drc\"",
            "sizeof(struct svc_cacherep)",
            "0",
            "0",
            "NULL"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&nfsd_reply_cache_shrinker"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "hashsize"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_hashsize",
          "args": [
            "max_drc_entries"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_hashsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "117-121",
          "snippet": "static unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define TARGET_BUCKET_SIZE\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\n#define TARGET_BUCKET_SIZE\t64\n\nstatic unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&num_drc_entries",
            "0"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_size_limit",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_size_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "103-111",
          "snippet": "static unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tmax_drc_entries;\nstatic unsigned int\t\tmaskbits;\nstatic unsigned int\t\tdrc_hashsize;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nint nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tregister_shrinker(&nfsd_reply_cache_shrinker);\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfsd_reply_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "156-162",
    "snippet": "static void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
          "lines": "143-154",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_free_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "143-154",
    "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*drc_slab;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "drc_slab",
            "rp"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&num_drc_entries"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rp->c_lru"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp->c_replvec.iov_base"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "129-141",
    "snippet": "static struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*drc_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rp->c_lru"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "drc_slab",
            "GFP_KERNEL"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\n\nstatic struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}"
  },
  {
    "function_name": "nfsd_cache_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "123-127",
    "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmaskbits;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "be32_to_cpu(xid)",
            "maskbits"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "xid"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
  },
  {
    "function_name": "nfsd_hashsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "117-121",
    "snippet": "static unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define TARGET_BUCKET_SIZE\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "limit / TARGET_BUCKET_SIZE"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\n#define TARGET_BUCKET_SIZE\t64\n\nstatic unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}"
  },
  {
    "function_name": "nfsd_cache_size_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfscache.c",
    "lines": "103-111",
    "snippet": "static unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "limit",
            "256*1024"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "low_pages"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}"
  }
]