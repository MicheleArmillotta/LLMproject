[
  {
    "function_name": "reiserfs_free_bitmap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1462-1468",
    "snippet": "void reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "sb"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "SB_AP_BITMAP(sb)"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "sb"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "sb"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_bitmap_cache(struct super_block *sb)\n{\n\tif (SB_AP_BITMAP(sb)) {\n\t\tvfree(SB_AP_BITMAP(sb));\n\t\tSB_AP_BITMAP(sb) = NULL;\n\t}\n}"
  },
  {
    "function_name": "reiserfs_init_bitmap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1446-1460",
    "snippet": "int reiserfs_init_bitmap_cache(struct super_block *sb)\n{\n\tstruct reiserfs_bitmap_info *bitmap;\n\tunsigned int bmap_nr = reiserfs_bmap_count(sb);\n\n\tbitmap = vmalloc(sizeof(*bitmap) * bmap_nr);\n\tif (bitmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(bitmap, 0xff, sizeof(*bitmap) * bmap_nr);\n\n\tSB_AP_BITMAP(sb) = bitmap;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "sb"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bitmap",
            "0xff",
            "sizeof(*bitmap) * bmap_nr"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "sizeof(*bitmap) * bmap_nr"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "sb"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_init_bitmap_cache(struct super_block *sb)\n{\n\tstruct reiserfs_bitmap_info *bitmap;\n\tunsigned int bmap_nr = reiserfs_bmap_count(sb);\n\n\tbitmap = vmalloc(sizeof(*bitmap) * bmap_nr);\n\tif (bitmap == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(bitmap, 0xff, sizeof(*bitmap) * bmap_nr);\n\n\tSB_AP_BITMAP(sb) = bitmap;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_read_bitmap_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1407-1444",
    "snippet": "struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_cache_bitmap_metadata",
          "args": [
            "sb",
            "bh",
            "info"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cache_bitmap_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1385-1405",
          "snippet": "void reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&bh->b_count) == 0"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "scan_bitmap.wait"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\"",
            "__func__",
            "block"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "REISERFS_OLD_FORMAT",
            "&REISERFS_SB(sb)->s_properties"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "sb"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}"
  },
  {
    "function_name": "reiserfs_cache_bitmap_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1385-1405",
    "snippet": "void reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hweight_long",
          "args": [
            "*cur"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "sb",
            "\"reiserfs-2025\"",
            "\"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\"",
            "bh->b_blocknr"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_test_le_bit",
          "args": [
            "0",
            "(unsigned long *)bh->b_data"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_cache_bitmap_metadata(struct super_block *sb,\n                                    struct buffer_head *bh,\n                                    struct reiserfs_bitmap_info *info)\n{\n\tunsigned long *cur = (unsigned long *)(bh->b_data + bh->b_size);\n\n\t/* The first bit must ALWAYS be 1 */\n\tif (!reiserfs_test_le_bit(0, (unsigned long *)bh->b_data))\n\t\treiserfs_error(sb, \"reiserfs-2025\", \"bitmap block %lu is \"\n\t\t\t       \"corrupted: first bit must be 1\", bh->b_blocknr);\n\n\tinfo->free_count = 0;\n\n\twhile (--cur >= (unsigned long *)bh->b_data) {\n\t\t/* 0 and ~0 are special, we can optimize for them */\n\t\tif (*cur == 0)\n\t\t\tinfo->free_count += BITS_PER_LONG;\n\t\telse if (*cur != ~0L)\t/* A mix, investigate */\n\t\t\tinfo->free_count += BITS_PER_LONG - hweight_long(*cur);\n\t}\n}"
  },
  {
    "function_name": "reiserfs_allocate_blocknrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1326-1383",
    "snippet": "int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "hint->th",
            "hint->inode",
            "*(--new_blocknrs)",
            "1"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocknrs_and_prealloc_arrays_from_search_start",
          "args": [
            "hint",
            "new_blocknrs",
            "amount_needed"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "blocknrs_and_prealloc_arrays_from_search_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1186-1298",
          "snippet": "static inline int blocknrs_and_prealloc_arrays_from_search_start\n    (reiserfs_blocknr_hint_t * hint, b_blocknr_t * new_blocknrs,\n     int amount_needed) {\n\tstruct super_block *s = hint->th->t_super;\n\tb_blocknr_t start = hint->search_start;\n\tb_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;\n\tint passno = 0;\n\tint nr_allocated = 0;\n\tint depth;\n\n\tdetermine_prealloc_size(hint);\n\tif (!hint->formatted_node) {\n\t\tint quota_ret;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: allocating %d blocks id=%u\",\n\t\t\t       amount_needed, hint->inode->i_uid);\n#endif\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tquota_ret =\n\t\t    dquot_alloc_block_nodirty(hint->inode, amount_needed);\n\t\tif (quota_ret) {\t/* Quota exceeded? */\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\treturn QUOTA_EXCEEDED;\n\t\t}\n\t\tif (hint->preallocate && hint->prealloc_size) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"reiserquota: allocating (prealloc) %d blocks id=%u\",\n\t\t\t\t       hint->prealloc_size, hint->inode->i_uid);\n#endif\n\t\t\tquota_ret = dquot_prealloc_block_nodirty(hint->inode,\n\t\t\t\t\t\t\t hint->prealloc_size);\n\t\t\tif (quota_ret)\n\t\t\t\thint->preallocate = hint->prealloc_size = 0;\n\t\t}\n\t\t/* for unformatted nodes, force large allocations */\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\tdo {\n\t\tswitch (passno++) {\n\t\tcase 0:\t/* Search from hint->search_start to end of disk */\n\t\t\tstart = hint->search_start;\n\t\t\tfinish = SB_BLOCK_COUNT(s) - 1;\n\t\t\tbreak;\n\t\tcase 1:\t/* Search from hint->beg to hint->search_start */\n\t\t\tstart = hint->beg;\n\t\t\tfinish = hint->search_start;\n\t\t\tbreak;\n\t\tcase 2:\t/* Last chance: Search from 0 to hint->beg */\n\t\t\tstart = 0;\n\t\t\tfinish = hint->beg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* We've tried searching everywhere, not enough space */\n\t\t\t/* Free the blocks */\n\t\t\tif (!hint->formatted_node) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota: freeing (nospace) %d blocks id=%u\",\n\t\t\t\t\t       amount_needed +\n\t\t\t\t\t       hint->prealloc_size -\n\t\t\t\t\t       nr_allocated,\n\t\t\t\t\t       hint->inode->i_uid);\n#endif\n\t\t\t\t/* Free not allocated blocks */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\tdquot_free_block_nodirty(hint->inode,\n\t\t\t\t\tamount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\twhile (nr_allocated--)\n\t\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t\t    new_blocknrs[nr_allocated],\n\t\t\t\t\t\t    !hint->formatted_node);\n\n\t\t\treturn NO_DISK_SPACE;\n\t\t}\n\t} while ((nr_allocated += allocate_without_wrapping_disk(hint,\n\t\t\t\t\t\t\t\t new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t start, finish,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t hint->\n\t\t\t\t\t\t\t\t prealloc_size))\n\t\t < amount_needed);\n\tif (!hint->formatted_node &&\n\t    amount_needed + hint->prealloc_size >\n\t    nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {\n\t\t/* Some of preallocation blocks were not allocated */\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: freeing (failed prealloc) %d blocks id=%u\",\n\t\t\t       amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count,\n\t\t\t       hint->inode->i_uid);\n#endif\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(hint->inode, amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int blocknrs_and_prealloc_arrays_from_search_start\n    (reiserfs_blocknr_hint_t * hint, b_blocknr_t * new_blocknrs,\n     int amount_needed) {\n\tstruct super_block *s = hint->th->t_super;\n\tb_blocknr_t start = hint->search_start;\n\tb_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;\n\tint passno = 0;\n\tint nr_allocated = 0;\n\tint depth;\n\n\tdetermine_prealloc_size(hint);\n\tif (!hint->formatted_node) {\n\t\tint quota_ret;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: allocating %d blocks id=%u\",\n\t\t\t       amount_needed, hint->inode->i_uid);\n#endif\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tquota_ret =\n\t\t    dquot_alloc_block_nodirty(hint->inode, amount_needed);\n\t\tif (quota_ret) {\t/* Quota exceeded? */\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\treturn QUOTA_EXCEEDED;\n\t\t}\n\t\tif (hint->preallocate && hint->prealloc_size) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"reiserquota: allocating (prealloc) %d blocks id=%u\",\n\t\t\t\t       hint->prealloc_size, hint->inode->i_uid);\n#endif\n\t\t\tquota_ret = dquot_prealloc_block_nodirty(hint->inode,\n\t\t\t\t\t\t\t hint->prealloc_size);\n\t\t\tif (quota_ret)\n\t\t\t\thint->preallocate = hint->prealloc_size = 0;\n\t\t}\n\t\t/* for unformatted nodes, force large allocations */\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\tdo {\n\t\tswitch (passno++) {\n\t\tcase 0:\t/* Search from hint->search_start to end of disk */\n\t\t\tstart = hint->search_start;\n\t\t\tfinish = SB_BLOCK_COUNT(s) - 1;\n\t\t\tbreak;\n\t\tcase 1:\t/* Search from hint->beg to hint->search_start */\n\t\t\tstart = hint->beg;\n\t\t\tfinish = hint->search_start;\n\t\t\tbreak;\n\t\tcase 2:\t/* Last chance: Search from 0 to hint->beg */\n\t\t\tstart = 0;\n\t\t\tfinish = hint->beg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* We've tried searching everywhere, not enough space */\n\t\t\t/* Free the blocks */\n\t\t\tif (!hint->formatted_node) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota: freeing (nospace) %d blocks id=%u\",\n\t\t\t\t\t       amount_needed +\n\t\t\t\t\t       hint->prealloc_size -\n\t\t\t\t\t       nr_allocated,\n\t\t\t\t\t       hint->inode->i_uid);\n#endif\n\t\t\t\t/* Free not allocated blocks */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\tdquot_free_block_nodirty(hint->inode,\n\t\t\t\t\tamount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\twhile (nr_allocated--)\n\t\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t\t    new_blocknrs[nr_allocated],\n\t\t\t\t\t\t    !hint->formatted_node);\n\n\t\t\treturn NO_DISK_SPACE;\n\t\t}\n\t} while ((nr_allocated += allocate_without_wrapping_disk(hint,\n\t\t\t\t\t\t\t\t new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t start, finish,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t hint->\n\t\t\t\t\t\t\t\t prealloc_size))\n\t\t < amount_needed);\n\tif (!hint->formatted_node &&\n\t    amount_needed + hint->prealloc_size >\n\t    nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {\n\t\t/* Some of preallocation blocks were not allocated */\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: freeing (failed prealloc) %d blocks id=%u\",\n\t\t\t       amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count,\n\t\t\t       hint->inode->i_uid);\n#endif\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(hint->inode, amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "determine_search_start",
          "args": [
            "hint",
            "amount_needed"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "determine_search_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1010-1120",
          "snippet": "static void determine_search_start(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t   int amount_needed)\n{\n\tstruct super_block *s = hint->th->t_super;\n\tint unfm_hint;\n\n\thint->beg = 0;\n\thint->end = SB_BLOCK_COUNT(s) - 1;\n\n\t/* This is former border algorithm. Now with tunable border offset */\n\tif (concentrating_formatted_nodes(s))\n\t\tset_border_in_hint(s, hint);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * whenever we create a new directory, we displace it.  At first\n\t * we will hash for location, later we might look for a moderately\n\t * empty place for it\n\t */\n\tif (displacing_new_packing_localities(s)\n\t    && hint->th->displace_new_blocks) {\n\t\tdisplace_new_packing_locality(hint);\n\n\t\t/*\n\t\t * we do not continue determine_search_start,\n\t\t * if new packing locality is being displaced\n\t\t */\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * all persons should feel encouraged to add more special cases\n\t * here and test them\n\t */\n\n\tif (displacing_large_files(s) && !hint->formatted_node\n\t    && this_blocknr_allocation_would_make_it_a_large_file(hint)) {\n\t\tdisplace_large_file(hint);\n\t\treturn;\n\t}\n\n\t/*\n\t * if none of our special cases is relevant, use the left\n\t * neighbor in the tree order of the new node we are allocating for\n\t */\n\tif (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\thash_formatted_node(hint);\n\t\treturn;\n\t}\n\n\tunfm_hint = get_left_neighbor(hint);\n\n\t/*\n\t * Mimic old block allocator behaviour, that is if VFS allowed for\n\t * preallocation, new blocks are displaced based on directory ID.\n\t * Also, if suggested search_start is less than last preallocated\n\t * block, we start searching from it, assuming that HDD dataflow\n\t * is faster in forward direction\n\t */\n\tif (TEST_OPTION(old_way, s)) {\n\t\tif (!hint->formatted_node) {\n\t\t\tif (!reiserfs_hashed_relocation(s))\n\t\t\t\told_way(hint);\n\t\t\telse if (!reiserfs_no_unhashed_relocation(s))\n\t\t\t\told_hashed_relocation(hint);\n\n\t\t\tif (hint->inode\n\t\t\t    && hint->search_start <\n\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block)\n\t\t\t\thint->search_start =\n\t\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an approach proposed by Hans */\n\tif (TEST_OPTION(hundredth_slices, s)\n\t    && !(displacing_large_files(s) && !hint->formatted_node)) {\n\t\thundredth_slices(hint);\n\t\treturn;\n\t}\n\n\t/* old_hashed_relocation only works on unformatted */\n\tif (!unfm_hint && !hint->formatted_node &&\n\t    TEST_OPTION(old_hashed_relocation, s)) {\n\t\told_hashed_relocation(hint);\n\t}\n\n\t/* new_hashed_relocation works with both formatted/unformatted nodes */\n\tif ((!unfm_hint || hint->formatted_node) &&\n\t    TEST_OPTION(new_hashed_relocation, s)) {\n\t\tnew_hashed_relocation(hint);\n\t}\n\n\t/* dirid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#endif\n\n\t/* oid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups, s)) {\n\t\toid_groups(hint);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void determine_search_start(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t   int amount_needed)\n{\n\tstruct super_block *s = hint->th->t_super;\n\tint unfm_hint;\n\n\thint->beg = 0;\n\thint->end = SB_BLOCK_COUNT(s) - 1;\n\n\t/* This is former border algorithm. Now with tunable border offset */\n\tif (concentrating_formatted_nodes(s))\n\t\tset_border_in_hint(s, hint);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * whenever we create a new directory, we displace it.  At first\n\t * we will hash for location, later we might look for a moderately\n\t * empty place for it\n\t */\n\tif (displacing_new_packing_localities(s)\n\t    && hint->th->displace_new_blocks) {\n\t\tdisplace_new_packing_locality(hint);\n\n\t\t/*\n\t\t * we do not continue determine_search_start,\n\t\t * if new packing locality is being displaced\n\t\t */\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * all persons should feel encouraged to add more special cases\n\t * here and test them\n\t */\n\n\tif (displacing_large_files(s) && !hint->formatted_node\n\t    && this_blocknr_allocation_would_make_it_a_large_file(hint)) {\n\t\tdisplace_large_file(hint);\n\t\treturn;\n\t}\n\n\t/*\n\t * if none of our special cases is relevant, use the left\n\t * neighbor in the tree order of the new node we are allocating for\n\t */\n\tif (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\thash_formatted_node(hint);\n\t\treturn;\n\t}\n\n\tunfm_hint = get_left_neighbor(hint);\n\n\t/*\n\t * Mimic old block allocator behaviour, that is if VFS allowed for\n\t * preallocation, new blocks are displaced based on directory ID.\n\t * Also, if suggested search_start is less than last preallocated\n\t * block, we start searching from it, assuming that HDD dataflow\n\t * is faster in forward direction\n\t */\n\tif (TEST_OPTION(old_way, s)) {\n\t\tif (!hint->formatted_node) {\n\t\t\tif (!reiserfs_hashed_relocation(s))\n\t\t\t\told_way(hint);\n\t\t\telse if (!reiserfs_no_unhashed_relocation(s))\n\t\t\t\told_hashed_relocation(hint);\n\n\t\t\tif (hint->inode\n\t\t\t    && hint->search_start <\n\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block)\n\t\t\t\thint->search_start =\n\t\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an approach proposed by Hans */\n\tif (TEST_OPTION(hundredth_slices, s)\n\t    && !(displacing_large_files(s) && !hint->formatted_node)) {\n\t\thundredth_slices(hint);\n\t\treturn;\n\t}\n\n\t/* old_hashed_relocation only works on unformatted */\n\tif (!unfm_hint && !hint->formatted_node &&\n\t    TEST_OPTION(old_hashed_relocation, s)) {\n\t\told_hashed_relocation(hint);\n\t}\n\n\t/* new_hashed_relocation works with both formatted/unformatted nodes */\n\tif ((!unfm_hint || hint->formatted_node) &&\n\t    TEST_OPTION(new_hashed_relocation, s)) {\n\t\tnew_hashed_relocation(hint);\n\t}\n\n\t/* dirid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#endif\n\n\t/* oid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups, s)) {\n\t\toid_groups(hint);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "use_preallocated_list_if_available",
          "args": [
            "hint",
            "new_blocknrs",
            "amount_needed"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "use_preallocated_list_if_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1302-1324",
          "snippet": "static int use_preallocated_list_if_available(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t      b_blocknr_t * new_blocknrs,\n\t\t\t\t\t      int amount_needed)\n{\n\tstruct inode *inode = hint->inode;\n\n\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\twhile (amount_needed) {\n\n\t\t\t*new_blocknrs++ = REISERFS_I(inode)->i_prealloc_block++;\n\t\t\tREISERFS_I(inode)->i_prealloc_count--;\n\n\t\t\tamount_needed--;\n\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\t\t\tlist_del(&REISERFS_I(inode)->i_prealloc_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return amount still needed after using preallocated blocks */\n\treturn amount_needed;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int use_preallocated_list_if_available(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t      b_blocknr_t * new_blocknrs,\n\t\t\t\t\t      int amount_needed)\n{\n\tstruct inode *inode = hint->inode;\n\n\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\twhile (amount_needed) {\n\n\t\t\t*new_blocknrs++ = REISERFS_I(inode)->i_prealloc_block++;\n\t\t\tREISERFS_I(inode)->i_prealloc_count--;\n\n\t\t\tamount_needed--;\n\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\t\t\tlist_del(&REISERFS_I(inode)->i_prealloc_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return amount still needed after using preallocated blocks */\n\treturn amount_needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_FREE_BLOCKS",
          "args": [
            "s"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *hint,\n\t\t\t       b_blocknr_t *new_blocknrs,\n\t\t\t       int amount_needed,\n\t\t\t       /* Amount of blocks we have already reserved */\n\t\t\t       int reserved_by_us)\n{\n\tint initial_amount_needed = amount_needed;\n\tint ret;\n\tstruct super_block *s = hint->th->t_super;\n\n\t/* Check if there is enough space, taking into account reserved space */\n\tif (SB_FREE_BLOCKS(s) - REISERFS_SB(s)->reserved_blocks <\n\t    amount_needed - reserved_by_us)\n\t\treturn NO_DISK_SPACE;\n\t/* should this be if !hint->inode &&  hint->preallocate? */\n\t/* do you mean hint->formatted_node can be removed ? - Zam */\n\t/*\n\t * hint->formatted_node cannot be removed because we try to access\n\t * inode information here, and there is often no inode associated with\n\t * metadata allocations - green\n\t */\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tamount_needed = use_preallocated_list_if_available\n\t\t    (hint, new_blocknrs, amount_needed);\n\n\t\t/*\n\t\t * We have all the block numbers we need from the\n\t\t * prealloc list\n\t\t */\n\t\tif (amount_needed == 0)\n\t\t\treturn CARRY_ON;\n\t\tnew_blocknrs += (initial_amount_needed - amount_needed);\n\t}\n\n\t/* find search start and save it in hint structure */\n\tdetermine_search_start(hint, amount_needed);\n\tif (hint->search_start >= SB_BLOCK_COUNT(s))\n\t\thint->search_start = SB_BLOCK_COUNT(s) - 1;\n\n\t/* allocation itself; fill new_blocknrs and preallocation arrays */\n\tret = blocknrs_and_prealloc_arrays_from_search_start\n\t    (hint, new_blocknrs, amount_needed);\n\n\t/*\n\t * We used prealloc. list to fill (partially) new_blocknrs array.\n\t * If final allocation fails we need to return blocks back to\n\t * prealloc. list or just free them. -- Zam (I chose second\n\t * variant)\n\t */\n\tif (ret != CARRY_ON) {\n\t\twhile (amount_needed++ < initial_amount_needed) {\n\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t    *(--new_blocknrs), 1);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "use_preallocated_list_if_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1302-1324",
    "snippet": "static int use_preallocated_list_if_available(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t      b_blocknr_t * new_blocknrs,\n\t\t\t\t\t      int amount_needed)\n{\n\tstruct inode *inode = hint->inode;\n\n\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\twhile (amount_needed) {\n\n\t\t\t*new_blocknrs++ = REISERFS_I(inode)->i_prealloc_block++;\n\t\t\tREISERFS_I(inode)->i_prealloc_count--;\n\n\t\t\tamount_needed--;\n\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\t\t\tlist_del(&REISERFS_I(inode)->i_prealloc_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return amount still needed after using preallocated blocks */\n\treturn amount_needed;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&REISERFS_I(inode)->i_prealloc_list"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int use_preallocated_list_if_available(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t      b_blocknr_t * new_blocknrs,\n\t\t\t\t\t      int amount_needed)\n{\n\tstruct inode *inode = hint->inode;\n\n\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\twhile (amount_needed) {\n\n\t\t\t*new_blocknrs++ = REISERFS_I(inode)->i_prealloc_block++;\n\t\t\tREISERFS_I(inode)->i_prealloc_count--;\n\n\t\t\tamount_needed--;\n\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count <= 0) {\n\t\t\t\tlist_del(&REISERFS_I(inode)->i_prealloc_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* return amount still needed after using preallocated blocks */\n\treturn amount_needed;\n}"
  },
  {
    "function_name": "blocknrs_and_prealloc_arrays_from_search_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1186-1298",
    "snippet": "static inline int blocknrs_and_prealloc_arrays_from_search_start\n    (reiserfs_blocknr_hint_t * hint, b_blocknr_t * new_blocknrs,\n     int amount_needed) {\n\tstruct super_block *s = hint->th->t_super;\n\tb_blocknr_t start = hint->search_start;\n\tb_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;\n\tint passno = 0;\n\tint nr_allocated = 0;\n\tint depth;\n\n\tdetermine_prealloc_size(hint);\n\tif (!hint->formatted_node) {\n\t\tint quota_ret;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: allocating %d blocks id=%u\",\n\t\t\t       amount_needed, hint->inode->i_uid);\n#endif\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tquota_ret =\n\t\t    dquot_alloc_block_nodirty(hint->inode, amount_needed);\n\t\tif (quota_ret) {\t/* Quota exceeded? */\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\treturn QUOTA_EXCEEDED;\n\t\t}\n\t\tif (hint->preallocate && hint->prealloc_size) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"reiserquota: allocating (prealloc) %d blocks id=%u\",\n\t\t\t\t       hint->prealloc_size, hint->inode->i_uid);\n#endif\n\t\t\tquota_ret = dquot_prealloc_block_nodirty(hint->inode,\n\t\t\t\t\t\t\t hint->prealloc_size);\n\t\t\tif (quota_ret)\n\t\t\t\thint->preallocate = hint->prealloc_size = 0;\n\t\t}\n\t\t/* for unformatted nodes, force large allocations */\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\tdo {\n\t\tswitch (passno++) {\n\t\tcase 0:\t/* Search from hint->search_start to end of disk */\n\t\t\tstart = hint->search_start;\n\t\t\tfinish = SB_BLOCK_COUNT(s) - 1;\n\t\t\tbreak;\n\t\tcase 1:\t/* Search from hint->beg to hint->search_start */\n\t\t\tstart = hint->beg;\n\t\t\tfinish = hint->search_start;\n\t\t\tbreak;\n\t\tcase 2:\t/* Last chance: Search from 0 to hint->beg */\n\t\t\tstart = 0;\n\t\t\tfinish = hint->beg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* We've tried searching everywhere, not enough space */\n\t\t\t/* Free the blocks */\n\t\t\tif (!hint->formatted_node) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota: freeing (nospace) %d blocks id=%u\",\n\t\t\t\t\t       amount_needed +\n\t\t\t\t\t       hint->prealloc_size -\n\t\t\t\t\t       nr_allocated,\n\t\t\t\t\t       hint->inode->i_uid);\n#endif\n\t\t\t\t/* Free not allocated blocks */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\tdquot_free_block_nodirty(hint->inode,\n\t\t\t\t\tamount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\twhile (nr_allocated--)\n\t\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t\t    new_blocknrs[nr_allocated],\n\t\t\t\t\t\t    !hint->formatted_node);\n\n\t\t\treturn NO_DISK_SPACE;\n\t\t}\n\t} while ((nr_allocated += allocate_without_wrapping_disk(hint,\n\t\t\t\t\t\t\t\t new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t start, finish,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t hint->\n\t\t\t\t\t\t\t\t prealloc_size))\n\t\t < amount_needed);\n\tif (!hint->formatted_node &&\n\t    amount_needed + hint->prealloc_size >\n\t    nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {\n\t\t/* Some of preallocation blocks were not allocated */\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: freeing (failed prealloc) %d blocks id=%u\",\n\t\t\t       amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count,\n\t\t\t       hint->inode->i_uid);\n#endif\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(hint->inode, amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "hint->inode",
            "amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "hint->inode"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_debug",
          "args": [
            "s",
            "REISERFS_DEBUG_CODE",
            "\"reiserquota: freeing (failed prealloc) %d blocks id=%u\"",
            "amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count",
            "hint->inode->i_uid"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "297-307",
          "snippet": "void reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_without_wrapping_disk",
          "args": [
            "hint",
            "new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated",
            "start",
            "finish",
            "1",
            "amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated",
            "hint->\n\t\t\t\t\t\t\t\t prealloc_size"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_without_wrapping_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1142-1184",
          "snippet": "static inline int allocate_without_wrapping_disk(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t\t b_blocknr_t * new_blocknrs,\n\t\t\t\t\t\t b_blocknr_t start,\n\t\t\t\t\t\t b_blocknr_t finish, int min,\n\t\t\t\t\t\t int amount_needed,\n\t\t\t\t\t\t int prealloc_size)\n{\n\tint rest = amount_needed;\n\tint nr_allocated;\n\n\twhile (rest > 0 && start <= finish) {\n\t\tnr_allocated = scan_bitmap(hint->th, &start, finish, min,\n\t\t\t\t\t   rest + prealloc_size,\n\t\t\t\t\t   !hint->formatted_node, hint->block);\n\n\t\tif (nr_allocated == 0)\t/* no new blocks allocated, return */\n\t\t\tbreak;\n\n\t\t/* fill free_blocknrs array first */\n\t\twhile (rest > 0 && nr_allocated > 0) {\n\t\t\t*new_blocknrs++ = start++;\n\t\t\trest--;\n\t\t\tnr_allocated--;\n\t\t}\n\n\t\t/* do we have something to fill prealloc. array also ? */\n\t\tif (nr_allocated > 0) {\n\t\t\t/*\n\t\t\t * it means prealloc_size was greater that 0 and\n\t\t\t * we do preallocation\n\t\t\t */\n\t\t\tlist_add(&REISERFS_I(hint->inode)->i_prealloc_list,\n\t\t\t\t &SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list);\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_block = start;\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_count =\n\t\t\t    nr_allocated;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (amount_needed - rest);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int allocate_without_wrapping_disk(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t\t b_blocknr_t * new_blocknrs,\n\t\t\t\t\t\t b_blocknr_t start,\n\t\t\t\t\t\t b_blocknr_t finish, int min,\n\t\t\t\t\t\t int amount_needed,\n\t\t\t\t\t\t int prealloc_size)\n{\n\tint rest = amount_needed;\n\tint nr_allocated;\n\n\twhile (rest > 0 && start <= finish) {\n\t\tnr_allocated = scan_bitmap(hint->th, &start, finish, min,\n\t\t\t\t\t   rest + prealloc_size,\n\t\t\t\t\t   !hint->formatted_node, hint->block);\n\n\t\tif (nr_allocated == 0)\t/* no new blocks allocated, return */\n\t\t\tbreak;\n\n\t\t/* fill free_blocknrs array first */\n\t\twhile (rest > 0 && nr_allocated > 0) {\n\t\t\t*new_blocknrs++ = start++;\n\t\t\trest--;\n\t\t\tnr_allocated--;\n\t\t}\n\n\t\t/* do we have something to fill prealloc. array also ? */\n\t\tif (nr_allocated > 0) {\n\t\t\t/*\n\t\t\t * it means prealloc_size was greater that 0 and\n\t\t\t * we do preallocation\n\t\t\t */\n\t\t\tlist_add(&REISERFS_I(hint->inode)->i_prealloc_list,\n\t\t\t\t &SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list);\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_block = start;\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_count =\n\t\t\t    nr_allocated;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (amount_needed - rest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "hint->th",
            "hint->inode",
            "new_blocknrs[nr_allocated]",
            "!hint->formatted_node"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "hint->inode",
            "amount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_prealloc_block_nodirty",
          "args": [
            "hint->inode",
            "hint->prealloc_size"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block_nodirty",
          "args": [
            "hint->inode",
            "amount_needed"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "determine_prealloc_size",
          "args": [
            "hint"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "determine_prealloc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1122-1140",
          "snippet": "static int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)\n{\n\t/* make minimum size a mount option and benchmark both ways */\n\t/* we preallocate blocks only for regular files, specific size */\n\t/* benchmark preallocating always and see what happens */\n\n\thint->prealloc_size = 0;\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tif (S_ISREG(hint->inode->i_mode)\n\t\t    && hint->inode->i_size >=\n\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t    preallocmin * hint->inode->i_sb->s_blocksize)\n\t\t\thint->prealloc_size =\n\t\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t\t    preallocsize - 1;\n\t}\n\treturn CARRY_ON;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)\n{\n\t/* make minimum size a mount option and benchmark both ways */\n\t/* we preallocate blocks only for regular files, specific size */\n\t/* benchmark preallocating always and see what happens */\n\n\thint->prealloc_size = 0;\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tif (S_ISREG(hint->inode->i_mode)\n\t\t    && hint->inode->i_size >=\n\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t    preallocmin * hint->inode->i_sb->s_blocksize)\n\t\t\thint->prealloc_size =\n\t\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t\t    preallocsize - 1;\n\t}\n\treturn CARRY_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int blocknrs_and_prealloc_arrays_from_search_start\n    (reiserfs_blocknr_hint_t * hint, b_blocknr_t * new_blocknrs,\n     int amount_needed) {\n\tstruct super_block *s = hint->th->t_super;\n\tb_blocknr_t start = hint->search_start;\n\tb_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;\n\tint passno = 0;\n\tint nr_allocated = 0;\n\tint depth;\n\n\tdetermine_prealloc_size(hint);\n\tif (!hint->formatted_node) {\n\t\tint quota_ret;\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: allocating %d blocks id=%u\",\n\t\t\t       amount_needed, hint->inode->i_uid);\n#endif\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tquota_ret =\n\t\t    dquot_alloc_block_nodirty(hint->inode, amount_needed);\n\t\tif (quota_ret) {\t/* Quota exceeded? */\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\treturn QUOTA_EXCEEDED;\n\t\t}\n\t\tif (hint->preallocate && hint->prealloc_size) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"reiserquota: allocating (prealloc) %d blocks id=%u\",\n\t\t\t\t       hint->prealloc_size, hint->inode->i_uid);\n#endif\n\t\t\tquota_ret = dquot_prealloc_block_nodirty(hint->inode,\n\t\t\t\t\t\t\t hint->prealloc_size);\n\t\t\tif (quota_ret)\n\t\t\t\thint->preallocate = hint->prealloc_size = 0;\n\t\t}\n\t\t/* for unformatted nodes, force large allocations */\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\tdo {\n\t\tswitch (passno++) {\n\t\tcase 0:\t/* Search from hint->search_start to end of disk */\n\t\t\tstart = hint->search_start;\n\t\t\tfinish = SB_BLOCK_COUNT(s) - 1;\n\t\t\tbreak;\n\t\tcase 1:\t/* Search from hint->beg to hint->search_start */\n\t\t\tstart = hint->beg;\n\t\t\tfinish = hint->search_start;\n\t\t\tbreak;\n\t\tcase 2:\t/* Last chance: Search from 0 to hint->beg */\n\t\t\tstart = 0;\n\t\t\tfinish = hint->beg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* We've tried searching everywhere, not enough space */\n\t\t\t/* Free the blocks */\n\t\t\tif (!hint->formatted_node) {\n#ifdef REISERQUOTA_DEBUG\n\t\t\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"reiserquota: freeing (nospace) %d blocks id=%u\",\n\t\t\t\t\t       amount_needed +\n\t\t\t\t\t       hint->prealloc_size -\n\t\t\t\t\t       nr_allocated,\n\t\t\t\t\t       hint->inode->i_uid);\n#endif\n\t\t\t\t/* Free not allocated blocks */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\tdquot_free_block_nodirty(hint->inode,\n\t\t\t\t\tamount_needed + hint->prealloc_size -\n\t\t\t\t\tnr_allocated);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\twhile (nr_allocated--)\n\t\t\t\treiserfs_free_block(hint->th, hint->inode,\n\t\t\t\t\t\t    new_blocknrs[nr_allocated],\n\t\t\t\t\t\t    !hint->formatted_node);\n\n\t\t\treturn NO_DISK_SPACE;\n\t\t}\n\t} while ((nr_allocated += allocate_without_wrapping_disk(hint,\n\t\t\t\t\t\t\t\t new_blocknrs +\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t start, finish,\n\t\t\t\t\t\t\t\t 1,\n\t\t\t\t\t\t\t\t amount_needed -\n\t\t\t\t\t\t\t\t nr_allocated,\n\t\t\t\t\t\t\t\t hint->\n\t\t\t\t\t\t\t\t prealloc_size))\n\t\t < amount_needed);\n\tif (!hint->formatted_node &&\n\t    amount_needed + hint->prealloc_size >\n\t    nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {\n\t\t/* Some of preallocation blocks were not allocated */\n#ifdef REISERQUOTA_DEBUG\n\t\treiserfs_debug(s, REISERFS_DEBUG_CODE,\n\t\t\t       \"reiserquota: freeing (failed prealloc) %d blocks id=%u\",\n\t\t\t       amount_needed + hint->prealloc_size -\n\t\t\t       nr_allocated -\n\t\t\t       REISERFS_I(hint->inode)->i_prealloc_count,\n\t\t\t       hint->inode->i_uid);\n#endif\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(hint->inode, amount_needed +\n\t\t\t\t\t hint->prealloc_size - nr_allocated -\n\t\t\t\t\t REISERFS_I(hint->inode)->\n\t\t\t\t\t i_prealloc_count);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "allocate_without_wrapping_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1142-1184",
    "snippet": "static inline int allocate_without_wrapping_disk(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t\t b_blocknr_t * new_blocknrs,\n\t\t\t\t\t\t b_blocknr_t start,\n\t\t\t\t\t\t b_blocknr_t finish, int min,\n\t\t\t\t\t\t int amount_needed,\n\t\t\t\t\t\t int prealloc_size)\n{\n\tint rest = amount_needed;\n\tint nr_allocated;\n\n\twhile (rest > 0 && start <= finish) {\n\t\tnr_allocated = scan_bitmap(hint->th, &start, finish, min,\n\t\t\t\t\t   rest + prealloc_size,\n\t\t\t\t\t   !hint->formatted_node, hint->block);\n\n\t\tif (nr_allocated == 0)\t/* no new blocks allocated, return */\n\t\t\tbreak;\n\n\t\t/* fill free_blocknrs array first */\n\t\twhile (rest > 0 && nr_allocated > 0) {\n\t\t\t*new_blocknrs++ = start++;\n\t\t\trest--;\n\t\t\tnr_allocated--;\n\t\t}\n\n\t\t/* do we have something to fill prealloc. array also ? */\n\t\tif (nr_allocated > 0) {\n\t\t\t/*\n\t\t\t * it means prealloc_size was greater that 0 and\n\t\t\t * we do preallocation\n\t\t\t */\n\t\t\tlist_add(&REISERFS_I(hint->inode)->i_prealloc_list,\n\t\t\t\t &SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list);\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_block = start;\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_count =\n\t\t\t    nr_allocated;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (amount_needed - rest);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "hint->inode"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&REISERFS_I(hint->inode)->i_prealloc_list",
            "&SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "hint->th->t_super"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_bitmap",
          "args": [
            "hint->th",
            "&start",
            "finish",
            "min",
            "rest + prealloc_size",
            "!hint->formatted_node",
            "hint->block"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "scan_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "347-414",
          "snippet": "static int scan_bitmap(struct reiserfs_transaction_handle *th,\n\t\t       b_blocknr_t * start, b_blocknr_t finish,\n\t\t       int min, int max, int unfm, sector_t file_block)\n{\n\tint nr_allocated = 0;\n\tstruct super_block *s = th->t_super;\n\tunsigned int bm, off;\n\tunsigned int end_bm, end_off;\n\tunsigned int off_max = s->s_blocksize << 3;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, scan_bitmap.call);\n\n\t/* No point in looking for more free blocks */\n\tif (SB_FREE_BLOCKS(s) <= 0)\n\t\treturn 0;\n\n\tget_bit_address(s, *start, &bm, &off);\n\tget_bit_address(s, finish, &end_bm, &end_off);\n\tif (bm > reiserfs_bmap_count(s))\n\t\treturn 0;\n\tif (end_bm > reiserfs_bmap_count(s))\n\t\tend_bm = reiserfs_bmap_count(s);\n\n\t/*\n\t * When the bitmap is more than 10% free, anyone can allocate.\n\t * When it's less than 10% free, only files that already use the\n\t * bitmap are allowed. Once we pass 80% full, this restriction\n\t * is lifted.\n\t *\n\t * We do this so that files that grow later still have space close to\n\t * their original allocation. This improves locality, and presumably\n\t * performance as a result.\n\t *\n\t * This is only an allocation policy and does not make up for getting a\n\t * bad hint. Decent hinting must be implemented for this to work well.\n\t */\n\tif (TEST_OPTION(skip_busy, s)\n\t    && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s) / 20) {\n\t\tfor (; bm < end_bm; bm++, off = 0) {\n\t\t\tif ((off && (!unfm || (file_block != 0)))\n\t\t\t    || SB_AP_BITMAP(s)[bm].free_count >\n\t\t\t    (s->s_blocksize << 3) / 10)\n\t\t\t\tnr_allocated =\n\t\t\t\t    scan_bitmap_block(th, bm, &off, off_max,\n\t\t\t\t\t\t      min, max, unfm);\n\t\t\tif (nr_allocated)\n\t\t\t\tgoto ret;\n\t\t}\n\t\t/* we know from above that start is a reasonable number */\n\t\tget_bit_address(s, *start, &bm, &off);\n\t}\n\n\tfor (; bm < end_bm; bm++, off = 0) {\n\t\tnr_allocated =\n\t\t    scan_bitmap_block(th, bm, &off, off_max, min, max, unfm);\n\t\tif (nr_allocated)\n\t\t\tgoto ret;\n\t}\n\n\tnr_allocated =\n\t    scan_bitmap_block(th, bm, &off, end_off + 1, min, max, unfm);\n\nret:\n\t*start = bm * off_max + off;\n\treturn nr_allocated;\n\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int scan_bitmap(struct reiserfs_transaction_handle *th,\n\t\t       b_blocknr_t * start, b_blocknr_t finish,\n\t\t       int min, int max, int unfm, sector_t file_block)\n{\n\tint nr_allocated = 0;\n\tstruct super_block *s = th->t_super;\n\tunsigned int bm, off;\n\tunsigned int end_bm, end_off;\n\tunsigned int off_max = s->s_blocksize << 3;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, scan_bitmap.call);\n\n\t/* No point in looking for more free blocks */\n\tif (SB_FREE_BLOCKS(s) <= 0)\n\t\treturn 0;\n\n\tget_bit_address(s, *start, &bm, &off);\n\tget_bit_address(s, finish, &end_bm, &end_off);\n\tif (bm > reiserfs_bmap_count(s))\n\t\treturn 0;\n\tif (end_bm > reiserfs_bmap_count(s))\n\t\tend_bm = reiserfs_bmap_count(s);\n\n\t/*\n\t * When the bitmap is more than 10% free, anyone can allocate.\n\t * When it's less than 10% free, only files that already use the\n\t * bitmap are allowed. Once we pass 80% full, this restriction\n\t * is lifted.\n\t *\n\t * We do this so that files that grow later still have space close to\n\t * their original allocation. This improves locality, and presumably\n\t * performance as a result.\n\t *\n\t * This is only an allocation policy and does not make up for getting a\n\t * bad hint. Decent hinting must be implemented for this to work well.\n\t */\n\tif (TEST_OPTION(skip_busy, s)\n\t    && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s) / 20) {\n\t\tfor (; bm < end_bm; bm++, off = 0) {\n\t\t\tif ((off && (!unfm || (file_block != 0)))\n\t\t\t    || SB_AP_BITMAP(s)[bm].free_count >\n\t\t\t    (s->s_blocksize << 3) / 10)\n\t\t\t\tnr_allocated =\n\t\t\t\t    scan_bitmap_block(th, bm, &off, off_max,\n\t\t\t\t\t\t      min, max, unfm);\n\t\t\tif (nr_allocated)\n\t\t\t\tgoto ret;\n\t\t}\n\t\t/* we know from above that start is a reasonable number */\n\t\tget_bit_address(s, *start, &bm, &off);\n\t}\n\n\tfor (; bm < end_bm; bm++, off = 0) {\n\t\tnr_allocated =\n\t\t    scan_bitmap_block(th, bm, &off, off_max, min, max, unfm);\n\t\tif (nr_allocated)\n\t\t\tgoto ret;\n\t}\n\n\tnr_allocated =\n\t    scan_bitmap_block(th, bm, &off, end_off + 1, min, max, unfm);\n\nret:\n\t*start = bm * off_max + off;\n\treturn nr_allocated;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int allocate_without_wrapping_disk(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t\t\t b_blocknr_t * new_blocknrs,\n\t\t\t\t\t\t b_blocknr_t start,\n\t\t\t\t\t\t b_blocknr_t finish, int min,\n\t\t\t\t\t\t int amount_needed,\n\t\t\t\t\t\t int prealloc_size)\n{\n\tint rest = amount_needed;\n\tint nr_allocated;\n\n\twhile (rest > 0 && start <= finish) {\n\t\tnr_allocated = scan_bitmap(hint->th, &start, finish, min,\n\t\t\t\t\t   rest + prealloc_size,\n\t\t\t\t\t   !hint->formatted_node, hint->block);\n\n\t\tif (nr_allocated == 0)\t/* no new blocks allocated, return */\n\t\t\tbreak;\n\n\t\t/* fill free_blocknrs array first */\n\t\twhile (rest > 0 && nr_allocated > 0) {\n\t\t\t*new_blocknrs++ = start++;\n\t\t\trest--;\n\t\t\tnr_allocated--;\n\t\t}\n\n\t\t/* do we have something to fill prealloc. array also ? */\n\t\tif (nr_allocated > 0) {\n\t\t\t/*\n\t\t\t * it means prealloc_size was greater that 0 and\n\t\t\t * we do preallocation\n\t\t\t */\n\t\t\tlist_add(&REISERFS_I(hint->inode)->i_prealloc_list,\n\t\t\t\t &SB_JOURNAL(hint->th->t_super)->\n\t\t\t\t j_prealloc_list);\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_block = start;\n\t\t\tREISERFS_I(hint->inode)->i_prealloc_count =\n\t\t\t    nr_allocated;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (amount_needed - rest);\n}"
  },
  {
    "function_name": "determine_prealloc_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1122-1140",
    "snippet": "static int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)\n{\n\t/* make minimum size a mount option and benchmark both ways */\n\t/* we preallocate blocks only for regular files, specific size */\n\t/* benchmark preallocating always and see what happens */\n\n\thint->prealloc_size = 0;\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tif (S_ISREG(hint->inode->i_mode)\n\t\t    && hint->inode->i_size >=\n\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t    preallocmin * hint->inode->i_sb->s_blocksize)\n\t\t\thint->prealloc_size =\n\t\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t\t    preallocsize - 1;\n\t}\n\treturn CARRY_ON;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "hint->th->t_super"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "hint->inode->i_mode"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int determine_prealloc_size(reiserfs_blocknr_hint_t * hint)\n{\n\t/* make minimum size a mount option and benchmark both ways */\n\t/* we preallocate blocks only for regular files, specific size */\n\t/* benchmark preallocating always and see what happens */\n\n\thint->prealloc_size = 0;\n\n\tif (!hint->formatted_node && hint->preallocate) {\n\t\tif (S_ISREG(hint->inode->i_mode)\n\t\t    && hint->inode->i_size >=\n\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t    preallocmin * hint->inode->i_sb->s_blocksize)\n\t\t\thint->prealloc_size =\n\t\t\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.\n\t\t\t    preallocsize - 1;\n\t}\n\treturn CARRY_ON;\n}"
  },
  {
    "function_name": "determine_search_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "1010-1120",
    "snippet": "static void determine_search_start(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t   int amount_needed)\n{\n\tstruct super_block *s = hint->th->t_super;\n\tint unfm_hint;\n\n\thint->beg = 0;\n\thint->end = SB_BLOCK_COUNT(s) - 1;\n\n\t/* This is former border algorithm. Now with tunable border offset */\n\tif (concentrating_formatted_nodes(s))\n\t\tset_border_in_hint(s, hint);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * whenever we create a new directory, we displace it.  At first\n\t * we will hash for location, later we might look for a moderately\n\t * empty place for it\n\t */\n\tif (displacing_new_packing_localities(s)\n\t    && hint->th->displace_new_blocks) {\n\t\tdisplace_new_packing_locality(hint);\n\n\t\t/*\n\t\t * we do not continue determine_search_start,\n\t\t * if new packing locality is being displaced\n\t\t */\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * all persons should feel encouraged to add more special cases\n\t * here and test them\n\t */\n\n\tif (displacing_large_files(s) && !hint->formatted_node\n\t    && this_blocknr_allocation_would_make_it_a_large_file(hint)) {\n\t\tdisplace_large_file(hint);\n\t\treturn;\n\t}\n\n\t/*\n\t * if none of our special cases is relevant, use the left\n\t * neighbor in the tree order of the new node we are allocating for\n\t */\n\tif (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\thash_formatted_node(hint);\n\t\treturn;\n\t}\n\n\tunfm_hint = get_left_neighbor(hint);\n\n\t/*\n\t * Mimic old block allocator behaviour, that is if VFS allowed for\n\t * preallocation, new blocks are displaced based on directory ID.\n\t * Also, if suggested search_start is less than last preallocated\n\t * block, we start searching from it, assuming that HDD dataflow\n\t * is faster in forward direction\n\t */\n\tif (TEST_OPTION(old_way, s)) {\n\t\tif (!hint->formatted_node) {\n\t\t\tif (!reiserfs_hashed_relocation(s))\n\t\t\t\told_way(hint);\n\t\t\telse if (!reiserfs_no_unhashed_relocation(s))\n\t\t\t\told_hashed_relocation(hint);\n\n\t\t\tif (hint->inode\n\t\t\t    && hint->search_start <\n\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block)\n\t\t\t\thint->search_start =\n\t\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an approach proposed by Hans */\n\tif (TEST_OPTION(hundredth_slices, s)\n\t    && !(displacing_large_files(s) && !hint->formatted_node)) {\n\t\thundredth_slices(hint);\n\t\treturn;\n\t}\n\n\t/* old_hashed_relocation only works on unformatted */\n\tif (!unfm_hint && !hint->formatted_node &&\n\t    TEST_OPTION(old_hashed_relocation, s)) {\n\t\told_hashed_relocation(hint);\n\t}\n\n\t/* new_hashed_relocation works with both formatted/unformatted nodes */\n\tif ((!unfm_hint || hint->formatted_node) &&\n\t    TEST_OPTION(new_hashed_relocation, s)) {\n\t\tnew_hashed_relocation(hint);\n\t}\n\n\t/* dirid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#endif\n\n\t/* oid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups, s)) {\n\t\toid_groups(hint);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oid_groups",
          "args": [
            "hint"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "oid_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "817-840",
          "snippet": "static void oid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tif (hint->inode) {\n\t\tunsigned long hash;\n\t\t__u32 oid;\n\t\t__u32 dirid;\n\t\tint bm;\n\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\n\t\t/*\n\t\t * keep the root dir and it's first set of subdirs close to\n\t\t * the start of the disk\n\t\t */\n\t\tif (dirid <= 2)\n\t\t\thash = (hint->inode->i_sb->s_blocksize << 3);\n\t\telse {\n\t\t\toid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);\n\t\t\tbm = bmap_hash_id(hint->inode->i_sb, oid);\n\t\t\thash = bm * (hint->inode->i_sb->s_blocksize << 3);\n\t\t}\n\t\thint->search_start = hash;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void oid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tif (hint->inode) {\n\t\tunsigned long hash;\n\t\t__u32 oid;\n\t\t__u32 dirid;\n\t\tint bm;\n\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\n\t\t/*\n\t\t * keep the root dir and it's first set of subdirs close to\n\t\t * the start of the disk\n\t\t */\n\t\tif (dirid <= 2)\n\t\t\thash = (hint->inode->i_sb->s_blocksize << 3);\n\t\telse {\n\t\t\toid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);\n\t\t\tbm = bmap_hash_id(hint->inode->i_sb, oid);\n\t\t\thash = bm * (hint->inode->i_sb->s_blocksize << 3);\n\t\t}\n\t\thint->search_start = hash;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "oid_groups",
            "s"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirid_groups",
          "args": [
            "hint"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "dirid_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "791-811",
          "snippet": "static void dirid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tunsigned long hash;\n\t__u32 dirid = 0;\n\tint bm = 0;\n\tstruct super_block *sb = hint->th->t_super;\n\n\tif (hint->inode)\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\telse if (hint->formatted_node)\n\t\tdirid = hint->key.k_dir_id;\n\n\tif (dirid) {\n\t\tbm = bmap_hash_id(sb, dirid);\n\t\thash = bm * (sb->s_blocksize << 3);\n\t\t/* give a portion of the block group to metadata */\n\t\tif (hint->inode)\n\t\t\thash += sb->s_blocksize / 2;\n\t\thint->search_start = hash;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void dirid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tunsigned long hash;\n\t__u32 dirid = 0;\n\tint bm = 0;\n\tstruct super_block *sb = hint->th->t_super;\n\n\tif (hint->inode)\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\telse if (hint->formatted_node)\n\t\tdirid = hint->key.k_dir_id;\n\n\tif (dirid) {\n\t\tbm = bmap_hash_id(sb, dirid);\n\t\thash = bm * (sb->s_blocksize << 3);\n\t\t/* give a portion of the block group to metadata */\n\t\tif (hint->inode)\n\t\t\thash += sb->s_blocksize / 2;\n\t\thint->search_start = hash;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "dirid_groups",
            "s"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "dirid_groups",
            "s"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_hashed_relocation",
          "args": [
            "hint"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "new_hashed_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "765-785",
          "snippet": "static inline void new_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (hint->formatted_node) {\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\t} else {\n\t\tif (!hint->inode) {\n\t\t\t/*hint->search_start = hint->beg;*/\n\t\t\thash_in = (char *)&hint->key.k_dir_id;\n\t\t} else\n\t\t    if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\t\telse\n\t\t\thash_in =\n\t\t\t    (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\t}\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void new_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (hint->formatted_node) {\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\t} else {\n\t\tif (!hint->inode) {\n\t\t\t/*hint->search_start = hint->beg;*/\n\t\t\thash_in = (char *)&hint->key.k_dir_id;\n\t\t} else\n\t\t    if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\t\telse\n\t\t\thash_in =\n\t\t\t    (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\t}\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "new_hashed_relocation",
            "s"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_hashed_relocation",
          "args": [
            "hint"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "old_hashed_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "960-977",
          "snippet": "static inline int old_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\tu32 hash_in;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\thash_in = le32_to_cpu((INODE_PKEY(hint->inode))->k_dir_id);\n\tborder =\n\t    hint->beg + (u32) keyed_hash(((char *)(&hash_in)),\n\t\t\t\t\t 4) % (hint->end - hint->beg - 1);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int old_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\tu32 hash_in;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\thash_in = le32_to_cpu((INODE_PKEY(hint->inode))->k_dir_id);\n\tborder =\n\t    hint->beg + (u32) keyed_hash(((char *)(&hash_in)),\n\t\t\t\t\t 4) % (hint->end - hint->beg - 1);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "old_hashed_relocation",
            "s"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hundredth_slices",
          "args": [
            "hint"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "hundredth_slices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "997-1008",
          "snippet": "static inline void hundredth_slices(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\tb_blocknr_t slice_start;\n\n\tslice_start =\n\t    (keyed_hash((char *)(&key->k_dir_id), 4) % 100) * (hint->end / 100);\n\tif (slice_start > hint->search_start\n\t    || slice_start + (hint->end / 100) <= hint->search_start) {\n\t\thint->search_start = slice_start;\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void hundredth_slices(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\tb_blocknr_t slice_start;\n\n\tslice_start =\n\t    (keyed_hash((char *)(&key->k_dir_id), 4) % 100) * (hint->end / 100);\n\tif (slice_start > hint->search_start\n\t    || slice_start + (hint->end / 100) <= hint->search_start) {\n\t\thint->search_start = slice_start;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "displacing_large_files",
          "args": [
            "s"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "hundredth_slices",
            "s"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "hint->inode"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_no_unhashed_relocation",
          "args": [
            "s"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_way",
          "args": [
            "hint"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "old_way",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "979-995",
          "snippet": "static inline int old_way(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\tborder =\n\t    hint->beg +\n\t    le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id) % (hint->end -\n\t\t\t\t\t\t\t      hint->beg);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int old_way(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\tborder =\n\t    hint->beg +\n\t    le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id) % (hint->end -\n\t\t\t\t\t\t\t      hint->beg);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_hashed_relocation",
          "args": [
            "s"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "old_way",
            "s"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_left_neighbor",
          "args": [
            "hint"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "846-891",
          "snippet": "static int get_left_neighbor(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct treepath *path;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\tint pos_in_item;\n\t__le32 *item;\n\tint ret = 0;\n\n\t/*\n\t * reiserfs code can call this function w/o pointer to path\n\t * structure supplied; then we rely on supplied search_start\n\t */\n\tif (!hint->path)\n\t\treturn 0;\n\n\tpath = hint->path;\n\tbh = get_last_bh(path);\n\tRFALSE(!bh, \"green-4002: Illegal path specified to get_left_neighbor\");\n\tih = tp_item_head(path);\n\tpos_in_item = path->pos_in_item;\n\titem = tp_item_body(path);\n\n\thint->search_start = bh->b_blocknr;\n\n\t/*\n\t * for indirect item: go to left and look for the first non-hole entry\n\t * in the indirect item\n\t */\n\tif (!hint->formatted_node && is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item == I_UNFM_NUM(ih))\n\t\t\tpos_in_item--;\n\t\twhile (pos_in_item >= 0) {\n\t\t\tint t = get_block_num(item, pos_in_item);\n\t\t\tif (t) {\n\t\t\t\thint->search_start = t;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos_in_item--;\n\t\t}\n\t}\n\n\t/* does result value fit into specified region? */\n\treturn ret;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int get_left_neighbor(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct treepath *path;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\tint pos_in_item;\n\t__le32 *item;\n\tint ret = 0;\n\n\t/*\n\t * reiserfs code can call this function w/o pointer to path\n\t * structure supplied; then we rely on supplied search_start\n\t */\n\tif (!hint->path)\n\t\treturn 0;\n\n\tpath = hint->path;\n\tbh = get_last_bh(path);\n\tRFALSE(!bh, \"green-4002: Illegal path specified to get_left_neighbor\");\n\tih = tp_item_head(path);\n\tpos_in_item = path->pos_in_item;\n\titem = tp_item_body(path);\n\n\thint->search_start = bh->b_blocknr;\n\n\t/*\n\t * for indirect item: go to left and look for the first non-hole entry\n\t * in the indirect item\n\t */\n\tif (!hint->formatted_node && is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item == I_UNFM_NUM(ih))\n\t\t\tpos_in_item--;\n\t\twhile (pos_in_item >= 0) {\n\t\t\tint t = get_block_num(item, pos_in_item);\n\t\t\tif (t) {\n\t\t\t\thint->search_start = t;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos_in_item--;\n\t\t}\n\t}\n\n\t/* does result value fit into specified region? */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_formatted_node",
          "args": [
            "hint"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "hash_formatted_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "925-938",
          "snippet": "static inline void hash_formatted_node(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (!hint->inode)\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\telse if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\telse\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void hash_formatted_node(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (!hint->inode)\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\telse if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\telse\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "hashed_formatted_nodes",
            "s"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "displace_large_file",
          "args": [
            "hint"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "displace_large_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "911-923",
          "snippet": "static inline void displace_large_file(reiserfs_blocknr_hint_t * hint)\n{\n\tif (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_dir_id),\n\t\t\t       4) % (hint->end - hint->beg);\n\telse\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_objectid),\n\t\t\t       4) % (hint->end - hint->beg);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void displace_large_file(reiserfs_blocknr_hint_t * hint)\n{\n\tif (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_dir_id),\n\t\t\t       4) % (hint->end - hint->beg);\n\telse\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_objectid),\n\t\t\t       4) % (hint->end - hint->beg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_blocknr_allocation_would_make_it_a_large_file",
          "args": [
            "hint"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "this_blocknr_allocation_would_make_it_a_large_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "940-946",
          "snippet": "static inline int\nthis_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *\n\t\t\t\t\t\t   hint)\n{\n\treturn hint->block ==\n\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int\nthis_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *\n\t\t\t\t\t\t   hint)\n{\n\treturn hint->block ==\n\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "displacing_large_files",
          "args": [
            "s"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "displace_new_packing_locality",
          "args": [
            "hint"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "displace_new_packing_locality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "949-957",
          "snippet": "static inline void displace_new_packing_locality(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\n\thint->th->displace_new_blocks = 0;\n\thint->search_start =\n\t    hint->beg + keyed_hash((char *)(&key->k_objectid),\n\t\t\t\t   4) % (hint->end - hint->beg);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void displace_new_packing_locality(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\n\thint->th->displace_new_blocks = 0;\n\thint->search_start =\n\t    hint->beg + keyed_hash((char *)(&key->k_objectid),\n\t\t\t\t   4) % (hint->end - hint->beg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "displacing_new_packing_localities",
          "args": [
            "s"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_border_in_hint",
          "args": [
            "s",
            "hint"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "set_border_in_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "899-909",
          "snippet": "static inline void set_border_in_hint(struct super_block *s,\n\t\t\t\t      reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border =\n\t    SB_BLOCK_COUNT(s) / REISERFS_SB(s)->s_alloc_options.border;\n\n\tif (hint->formatted_node)\n\t\thint->end = border - 1;\n\telse\n\t\thint->beg = border;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void set_border_in_hint(struct super_block *s,\n\t\t\t\t      reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border =\n\t    SB_BLOCK_COUNT(s) / REISERFS_SB(s)->s_alloc_options.border;\n\n\tif (hint->formatted_node)\n\t\thint->end = border - 1;\n\telse\n\t\thint->beg = border;\n}"
        }
      },
      {
        "call_info": {
          "callee": "concentrating_formatted_nodes",
          "args": [
            "s"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void determine_search_start(reiserfs_blocknr_hint_t * hint,\n\t\t\t\t   int amount_needed)\n{\n\tstruct super_block *s = hint->th->t_super;\n\tint unfm_hint;\n\n\thint->beg = 0;\n\thint->end = SB_BLOCK_COUNT(s) - 1;\n\n\t/* This is former border algorithm. Now with tunable border offset */\n\tif (concentrating_formatted_nodes(s))\n\t\tset_border_in_hint(s, hint);\n\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\t/*\n\t * whenever we create a new directory, we displace it.  At first\n\t * we will hash for location, later we might look for a moderately\n\t * empty place for it\n\t */\n\tif (displacing_new_packing_localities(s)\n\t    && hint->th->displace_new_blocks) {\n\t\tdisplace_new_packing_locality(hint);\n\n\t\t/*\n\t\t * we do not continue determine_search_start,\n\t\t * if new packing locality is being displaced\n\t\t */\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * all persons should feel encouraged to add more special cases\n\t * here and test them\n\t */\n\n\tif (displacing_large_files(s) && !hint->formatted_node\n\t    && this_blocknr_allocation_would_make_it_a_large_file(hint)) {\n\t\tdisplace_large_file(hint);\n\t\treturn;\n\t}\n\n\t/*\n\t * if none of our special cases is relevant, use the left\n\t * neighbor in the tree order of the new node we are allocating for\n\t */\n\tif (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\thash_formatted_node(hint);\n\t\treturn;\n\t}\n\n\tunfm_hint = get_left_neighbor(hint);\n\n\t/*\n\t * Mimic old block allocator behaviour, that is if VFS allowed for\n\t * preallocation, new blocks are displaced based on directory ID.\n\t * Also, if suggested search_start is less than last preallocated\n\t * block, we start searching from it, assuming that HDD dataflow\n\t * is faster in forward direction\n\t */\n\tif (TEST_OPTION(old_way, s)) {\n\t\tif (!hint->formatted_node) {\n\t\t\tif (!reiserfs_hashed_relocation(s))\n\t\t\t\told_way(hint);\n\t\t\telse if (!reiserfs_no_unhashed_relocation(s))\n\t\t\t\told_hashed_relocation(hint);\n\n\t\t\tif (hint->inode\n\t\t\t    && hint->search_start <\n\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block)\n\t\t\t\thint->search_start =\n\t\t\t\t    REISERFS_I(hint->inode)->i_prealloc_block;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* This is an approach proposed by Hans */\n\tif (TEST_OPTION(hundredth_slices, s)\n\t    && !(displacing_large_files(s) && !hint->formatted_node)) {\n\t\thundredth_slices(hint);\n\t\treturn;\n\t}\n\n\t/* old_hashed_relocation only works on unformatted */\n\tif (!unfm_hint && !hint->formatted_node &&\n\t    TEST_OPTION(old_hashed_relocation, s)) {\n\t\told_hashed_relocation(hint);\n\t}\n\n\t/* new_hashed_relocation works with both formatted/unformatted nodes */\n\tif ((!unfm_hint || hint->formatted_node) &&\n\t    TEST_OPTION(new_hashed_relocation, s)) {\n\t\tnew_hashed_relocation(hint);\n\t}\n\n\t/* dirid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#ifdef DISPLACE_NEW_PACKING_LOCALITIES\n\tif (hint->formatted_node && TEST_OPTION(dirid_groups, s)) {\n\t\tdirid_groups(hint);\n\t}\n#endif\n\n\t/* oid grouping works only on unformatted nodes */\n\tif (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups, s)) {\n\t\toid_groups(hint);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "hundredth_slices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "997-1008",
    "snippet": "static inline void hundredth_slices(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\tb_blocknr_t slice_start;\n\n\tslice_start =\n\t    (keyed_hash((char *)(&key->k_dir_id), 4) % 100) * (hint->end / 100);\n\tif (slice_start > hint->search_start\n\t    || slice_start + (hint->end / 100) <= hint->search_start) {\n\t\thint->search_start = slice_start;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "(char *)(&key->k_dir_id)",
            "4"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void hundredth_slices(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\tb_blocknr_t slice_start;\n\n\tslice_start =\n\t    (keyed_hash((char *)(&key->k_dir_id), 4) % 100) * (hint->end / 100);\n\tif (slice_start > hint->search_start\n\t    || slice_start + (hint->end / 100) <= hint->search_start) {\n\t\thint->search_start = slice_start;\n\t}\n}"
  },
  {
    "function_name": "old_way",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "979-995",
    "snippet": "static inline int old_way(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\tborder =\n\t    hint->beg +\n\t    le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id) % (hint->end -\n\t\t\t\t\t\t\t      hint->beg);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(hint->inode)->k_dir_id"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int old_way(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\tborder =\n\t    hint->beg +\n\t    le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id) % (hint->end -\n\t\t\t\t\t\t\t      hint->beg);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "old_hashed_relocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "960-977",
    "snippet": "static inline int old_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\tu32 hash_in;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\thash_in = le32_to_cpu((INODE_PKEY(hint->inode))->k_dir_id);\n\tborder =\n\t    hint->beg + (u32) keyed_hash(((char *)(&hash_in)),\n\t\t\t\t\t 4) % (hint->end - hint->beg - 1);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "((char *)(&hash_in))",
            "4"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "(INODE_PKEY(hint->inode))->k_dir_id"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int old_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border;\n\tu32 hash_in;\n\n\tif (hint->formatted_node || hint->inode == NULL) {\n\t\treturn 0;\n\t}\n\n\thash_in = le32_to_cpu((INODE_PKEY(hint->inode))->k_dir_id);\n\tborder =\n\t    hint->beg + (u32) keyed_hash(((char *)(&hash_in)),\n\t\t\t\t\t 4) % (hint->end - hint->beg - 1);\n\tif (border > hint->search_start)\n\t\thint->search_start = border;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "displace_new_packing_locality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "949-957",
    "snippet": "static inline void displace_new_packing_locality(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\n\thint->th->displace_new_blocks = 0;\n\thint->search_start =\n\t    hint->beg + keyed_hash((char *)(&key->k_objectid),\n\t\t\t\t   4) % (hint->end - hint->beg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "(char *)(&key->k_objectid)",
            "4"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void displace_new_packing_locality(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct in_core_key *key = &hint->key;\n\n\thint->th->displace_new_blocks = 0;\n\thint->search_start =\n\t    hint->beg + keyed_hash((char *)(&key->k_objectid),\n\t\t\t\t   4) % (hint->end - hint->beg);\n}"
  },
  {
    "function_name": "this_blocknr_allocation_would_make_it_a_large_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "940-946",
    "snippet": "static inline int\nthis_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *\n\t\t\t\t\t\t   hint)\n{\n\treturn hint->block ==\n\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "hint->th->t_super"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int\nthis_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *\n\t\t\t\t\t\t   hint)\n{\n\treturn hint->block ==\n\t    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;\n}"
  },
  {
    "function_name": "hash_formatted_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "925-938",
    "snippet": "static inline void hash_formatted_node(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (!hint->inode)\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\telse if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\telse\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "hash_in",
            "4"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displace_based_on_dirid",
            "hint->th->t_super"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void hash_formatted_node(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (!hint->inode)\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\telse if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\telse\n\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}"
  },
  {
    "function_name": "displace_large_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "911-923",
    "snippet": "static inline void displace_large_file(reiserfs_blocknr_hint_t * hint)\n{\n\tif (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_dir_id),\n\t\t\t       4) % (hint->end - hint->beg);\n\telse\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_objectid),\n\t\t\t       4) % (hint->end - hint->beg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "(char *)(&INODE_PKEY(hint->inode)->k_objectid)",
            "4"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displace_based_on_dirid",
            "hint->th->t_super"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void displace_large_file(reiserfs_blocknr_hint_t * hint)\n{\n\tif (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_dir_id),\n\t\t\t       4) % (hint->end - hint->beg);\n\telse\n\t\thint->search_start =\n\t\t    hint->beg +\n\t\t    keyed_hash((char *)(&INODE_PKEY(hint->inode)->k_objectid),\n\t\t\t       4) % (hint->end - hint->beg);\n}"
  },
  {
    "function_name": "set_border_in_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "899-909",
    "snippet": "static inline void set_border_in_hint(struct super_block *s,\n\t\t\t\t      reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border =\n\t    SB_BLOCK_COUNT(s) / REISERFS_SB(s)->s_alloc_options.border;\n\n\tif (hint->formatted_node)\n\t\thint->end = border - 1;\n\telse\n\t\thint->beg = border;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void set_border_in_hint(struct super_block *s,\n\t\t\t\t      reiserfs_blocknr_hint_t * hint)\n{\n\tb_blocknr_t border =\n\t    SB_BLOCK_COUNT(s) / REISERFS_SB(s)->s_alloc_options.border;\n\n\tif (hint->formatted_node)\n\t\thint->end = border - 1;\n\telse\n\t\thint->beg = border;\n}"
  },
  {
    "function_name": "get_left_neighbor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "846-891",
    "snippet": "static int get_left_neighbor(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct treepath *path;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\tint pos_in_item;\n\t__le32 *item;\n\tint ret = 0;\n\n\t/*\n\t * reiserfs code can call this function w/o pointer to path\n\t * structure supplied; then we rely on supplied search_start\n\t */\n\tif (!hint->path)\n\t\treturn 0;\n\n\tpath = hint->path;\n\tbh = get_last_bh(path);\n\tRFALSE(!bh, \"green-4002: Illegal path specified to get_left_neighbor\");\n\tih = tp_item_head(path);\n\tpos_in_item = path->pos_in_item;\n\titem = tp_item_body(path);\n\n\thint->search_start = bh->b_blocknr;\n\n\t/*\n\t * for indirect item: go to left and look for the first non-hole entry\n\t * in the indirect item\n\t */\n\tif (!hint->formatted_node && is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item == I_UNFM_NUM(ih))\n\t\t\tpos_in_item--;\n\t\twhile (pos_in_item >= 0) {\n\t\t\tint t = get_block_num(item, pos_in_item);\n\t\t\tif (t) {\n\t\t\t\thint->search_start = t;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos_in_item--;\n\t\t}\n\t}\n\n\t/* does result value fit into specified region? */\n\treturn ret;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_block_num",
          "args": [
            "item",
            "pos_in_item"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_UNFM_NUM",
          "args": [
            "ih"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_body",
          "args": [
            "path"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2230-2233",
          "snippet": "static inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline void *tp_item_body(const struct treepath *path)\n{\n\treturn item_body(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_item_head",
          "args": [
            "path"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "tp_item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2225-2228",
          "snippet": "static inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int comp_items(const struct item_head *stored_ih, const struct treepath *path);",
            "int search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint comp_items(const struct item_head *stored_ih, const struct treepath *path);\nint search_by_key(struct super_block *, const struct cpu_key *,\n\t\t  struct treepath *, int);\n\nstatic inline struct item_head *tp_item_head(const struct treepath *path)\n{\n\treturn item_head(PATH_PLAST_BUFFER(path), PATH_LAST_POSITION(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!bh",
            "\"green-4002: Illegal path specified to get_left_neighbor\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_last_bh",
          "args": [
            "path"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int get_left_neighbor(reiserfs_blocknr_hint_t * hint)\n{\n\tstruct treepath *path;\n\tstruct buffer_head *bh;\n\tstruct item_head *ih;\n\tint pos_in_item;\n\t__le32 *item;\n\tint ret = 0;\n\n\t/*\n\t * reiserfs code can call this function w/o pointer to path\n\t * structure supplied; then we rely on supplied search_start\n\t */\n\tif (!hint->path)\n\t\treturn 0;\n\n\tpath = hint->path;\n\tbh = get_last_bh(path);\n\tRFALSE(!bh, \"green-4002: Illegal path specified to get_left_neighbor\");\n\tih = tp_item_head(path);\n\tpos_in_item = path->pos_in_item;\n\titem = tp_item_body(path);\n\n\thint->search_start = bh->b_blocknr;\n\n\t/*\n\t * for indirect item: go to left and look for the first non-hole entry\n\t * in the indirect item\n\t */\n\tif (!hint->formatted_node && is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item == I_UNFM_NUM(ih))\n\t\t\tpos_in_item--;\n\t\twhile (pos_in_item >= 0) {\n\t\t\tint t = get_block_num(item, pos_in_item);\n\t\t\tif (t) {\n\t\t\t\thint->search_start = t;\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos_in_item--;\n\t\t}\n\t}\n\n\t/* does result value fit into specified region? */\n\treturn ret;\n}"
  },
  {
    "function_name": "oid_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "817-840",
    "snippet": "static void oid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tif (hint->inode) {\n\t\tunsigned long hash;\n\t\t__u32 oid;\n\t\t__u32 dirid;\n\t\tint bm;\n\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\n\t\t/*\n\t\t * keep the root dir and it's first set of subdirs close to\n\t\t * the start of the disk\n\t\t */\n\t\tif (dirid <= 2)\n\t\t\thash = (hint->inode->i_sb->s_blocksize << 3);\n\t\telse {\n\t\t\toid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);\n\t\t\tbm = bmap_hash_id(hint->inode->i_sb, oid);\n\t\t\thash = bm * (hint->inode->i_sb->s_blocksize << 3);\n\t\t}\n\t\thint->search_start = hash;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bmap_hash_id",
          "args": [
            "hint->inode->i_sb",
            "oid"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_hash_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "274-293",
          "snippet": "static int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(hint->inode)->k_objectid"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void oid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tif (hint->inode) {\n\t\tunsigned long hash;\n\t\t__u32 oid;\n\t\t__u32 dirid;\n\t\tint bm;\n\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\n\t\t/*\n\t\t * keep the root dir and it's first set of subdirs close to\n\t\t * the start of the disk\n\t\t */\n\t\tif (dirid <= 2)\n\t\t\thash = (hint->inode->i_sb->s_blocksize << 3);\n\t\telse {\n\t\t\toid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);\n\t\t\tbm = bmap_hash_id(hint->inode->i_sb, oid);\n\t\t\thash = bm * (hint->inode->i_sb->s_blocksize << 3);\n\t\t}\n\t\thint->search_start = hash;\n\t}\n}"
  },
  {
    "function_name": "dirid_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "791-811",
    "snippet": "static void dirid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tunsigned long hash;\n\t__u32 dirid = 0;\n\tint bm = 0;\n\tstruct super_block *sb = hint->th->t_super;\n\n\tif (hint->inode)\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\telse if (hint->formatted_node)\n\t\tdirid = hint->key.k_dir_id;\n\n\tif (dirid) {\n\t\tbm = bmap_hash_id(sb, dirid);\n\t\thash = bm * (sb->s_blocksize << 3);\n\t\t/* give a portion of the block group to metadata */\n\t\tif (hint->inode)\n\t\t\thash += sb->s_blocksize / 2;\n\t\thint->search_start = hash;\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bmap_hash_id",
          "args": [
            "sb",
            "dirid"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_hash_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "274-293",
          "snippet": "static int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(hint->inode)->k_dir_id"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void dirid_groups(reiserfs_blocknr_hint_t * hint)\n{\n\tunsigned long hash;\n\t__u32 dirid = 0;\n\tint bm = 0;\n\tstruct super_block *sb = hint->th->t_super;\n\n\tif (hint->inode)\n\t\tdirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);\n\telse if (hint->formatted_node)\n\t\tdirid = hint->key.k_dir_id;\n\n\tif (dirid) {\n\t\tbm = bmap_hash_id(sb, dirid);\n\t\thash = bm * (sb->s_blocksize << 3);\n\t\t/* give a portion of the block group to metadata */\n\t\tif (hint->inode)\n\t\t\thash += sb->s_blocksize / 2;\n\t\thint->search_start = hash;\n\t}\n}"
  },
  {
    "function_name": "new_hashed_relocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "765-785",
    "snippet": "static inline void new_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (hint->formatted_node) {\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\t} else {\n\t\tif (!hint->inode) {\n\t\t\t/*hint->search_start = hint->beg;*/\n\t\t\thash_in = (char *)&hint->key.k_dir_id;\n\t\t} else\n\t\t    if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\t\telse\n\t\t\thash_in =\n\t\t\t    (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\t}\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "hash_in",
            "4"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "hint->inode"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displace_based_on_dirid",
            "hint->th->t_super"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void new_hashed_relocation(reiserfs_blocknr_hint_t * hint)\n{\n\tchar *hash_in;\n\n\tif (hint->formatted_node) {\n\t\thash_in = (char *)&hint->key.k_dir_id;\n\t} else {\n\t\tif (!hint->inode) {\n\t\t\t/*hint->search_start = hint->beg;*/\n\t\t\thash_in = (char *)&hint->key.k_dir_id;\n\t\t} else\n\t\t    if (TEST_OPTION(displace_based_on_dirid, hint->th->t_super))\n\t\t\thash_in = (char *)(&INODE_PKEY(hint->inode)->k_dir_id);\n\t\telse\n\t\t\thash_in =\n\t\t\t    (char *)(&INODE_PKEY(hint->inode)->k_objectid);\n\t}\n\n\thint->search_start =\n\t    hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);\n}"
  },
  {
    "function_name": "show_alloc_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "683-763",
    "snippet": "void show_alloc_options(struct seq_file *seq, struct super_block *s)\n{\n\tint first = 1;\n\n\tif (SB_ALLOC_OPTS(s) == ((1 << _ALLOC_skip_busy) |\n\t\t(1 << _ALLOC_dirid_groups) | (1 << _ALLOC_packing_groups)))\n\t\treturn;\n\n\tseq_puts(seq, \",alloc=\");\n\n\tif (TEST_OPTION(concentrating_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.border != 10) {\n\t\t\tseq_printf(seq, \"concentrating_formatted_nodes=%d\",\n\t\t\t\t100 / REISERFS_SB(s)->s_alloc_options.border);\n\t\t} else\n\t\t\tseq_puts(seq, \"concentrating_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(displacing_large_files, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.large_file_size != 16) {\n\t\t\tseq_printf(seq, \"displacing_large_files=%lu\",\n\t\t\t    REISERFS_SB(s)->s_alloc_options.large_file_size);\n\t\t} else\n\t\t\tseq_puts(seq, \"displacing_large_files\");\n\t}\n\tif (TEST_OPTION(displacing_new_packing_localities, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displacing_new_packing_localities\");\n\t}\n\tif (TEST_OPTION(old_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(new_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"new_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(dirid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"dirid_groups\");\n\t}\n\tif (TEST_OPTION(oid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"oid_groups\");\n\t}\n\tif (TEST_OPTION(packing_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"packing_groups\");\n\t}\n\tif (TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hashed_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(skip_busy, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"skip_busy\");\n\t}\n\tif (TEST_OPTION(hundredth_slices, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hundredth_slices\");\n\t}\n\tif (TEST_OPTION(old_way, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_way\");\n\t}\n\tif (TEST_OPTION(displace_based_on_dirid, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displace_based_on_dirid\");\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocmin != 0) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocmin=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin);\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocsize != 17) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocsize=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define  _ALLOC_packing_groups 12",
      "#define  _ALLOC_dirid_groups 10",
      "#define  _ALLOC_skip_busy 5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"preallocsize=%d\"",
            "REISERFS_SB(s)->s_alloc_options.preallocsize"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_sep",
          "args": [
            "seq",
            "&first"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "print_sep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "675-681",
          "snippet": "static void print_sep(struct seq_file *seq, int *first)\n{\n\tif (!*first)\n\t\tseq_puts(seq, \":\");\n\telse\n\t\t*first = 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void print_sep(struct seq_file *seq, int *first)\n{\n\tif (!*first)\n\t\tseq_puts(seq, \":\");\n\telse\n\t\t*first = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"displace_based_on_dirid\""
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displace_based_on_dirid",
            "s"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "old_way",
            "s"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "hundredth_slices",
            "s"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "skip_busy",
            "s"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "hashed_formatted_nodes",
            "s"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "packing_groups",
            "s"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "oid_groups",
            "s"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "dirid_groups",
            "s"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "new_hashed_relocation",
            "s"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "old_hashed_relocation",
            "s"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displacing_new_packing_localities",
            "s"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "displacing_large_files",
            "s"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "concentrating_formatted_nodes",
            "s"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ALLOC_OPTS",
          "args": [
            "s"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define  _ALLOC_packing_groups 12\n#define  _ALLOC_dirid_groups 10\n#define  _ALLOC_skip_busy 5\n\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s)\n{\n\tint first = 1;\n\n\tif (SB_ALLOC_OPTS(s) == ((1 << _ALLOC_skip_busy) |\n\t\t(1 << _ALLOC_dirid_groups) | (1 << _ALLOC_packing_groups)))\n\t\treturn;\n\n\tseq_puts(seq, \",alloc=\");\n\n\tif (TEST_OPTION(concentrating_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.border != 10) {\n\t\t\tseq_printf(seq, \"concentrating_formatted_nodes=%d\",\n\t\t\t\t100 / REISERFS_SB(s)->s_alloc_options.border);\n\t\t} else\n\t\t\tseq_puts(seq, \"concentrating_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(displacing_large_files, s)) {\n\t\tprint_sep(seq, &first);\n\t\tif (REISERFS_SB(s)->s_alloc_options.large_file_size != 16) {\n\t\t\tseq_printf(seq, \"displacing_large_files=%lu\",\n\t\t\t    REISERFS_SB(s)->s_alloc_options.large_file_size);\n\t\t} else\n\t\t\tseq_puts(seq, \"displacing_large_files\");\n\t}\n\tif (TEST_OPTION(displacing_new_packing_localities, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displacing_new_packing_localities\");\n\t}\n\tif (TEST_OPTION(old_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(new_hashed_relocation, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"new_hashed_relocation\");\n\t}\n\tif (TEST_OPTION(dirid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"dirid_groups\");\n\t}\n\tif (TEST_OPTION(oid_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"oid_groups\");\n\t}\n\tif (TEST_OPTION(packing_groups, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"packing_groups\");\n\t}\n\tif (TEST_OPTION(hashed_formatted_nodes, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hashed_formatted_nodes\");\n\t}\n\tif (TEST_OPTION(skip_busy, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"skip_busy\");\n\t}\n\tif (TEST_OPTION(hundredth_slices, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"hundredth_slices\");\n\t}\n\tif (TEST_OPTION(old_way, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"old_way\");\n\t}\n\tif (TEST_OPTION(displace_based_on_dirid, s)) {\n\t\tprint_sep(seq, &first);\n\t\tseq_puts(seq, \"displace_based_on_dirid\");\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocmin != 0) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocmin=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin);\n\t}\n\tif (REISERFS_SB(s)->s_alloc_options.preallocsize != 17) {\n\t\tprint_sep(seq, &first);\n\t\tseq_printf(seq, \"preallocsize=%d\",\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize);\n\t}\n}"
  },
  {
    "function_name": "print_sep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "675-681",
    "snippet": "static void print_sep(struct seq_file *seq, int *first)\n{\n\tif (!*first)\n\t\tseq_puts(seq, \":\");\n\telse\n\t\t*first = 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\":\""
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void print_sep(struct seq_file *seq, int *first)\n{\n\tif (!*first)\n\t\tseq_puts(seq, \":\");\n\telse\n\t\t*first = 0;\n}"
  },
  {
    "function_name": "reiserfs_parse_alloc_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "566-673",
    "snippet": "int reiserfs_parse_alloc_options(struct super_block *s, char *options)\n{\n\tchar *this_char, *value;\n\n\t/* clear default settings */\n\tREISERFS_SB(s)->s_alloc_options.bits = 0;\n\n\twhile ((this_char = strsep(&options, \":\")) != NULL) {\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, \"concentrating_formatted_nodes\")) {\n\t\t\tint temp;\n\t\t\tSET_OPTION(concentrating_formatted_nodes);\n\t\t\ttemp = (value\n\t\t\t\t&& *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t    0) : 10;\n\t\t\tif (temp <= 0 || temp > 100) {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border = 10;\n\t\t\t} else {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border =\n\t\t\t\t    100 / temp;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_large_files\")) {\n\t\t\tSET_OPTION(displacing_large_files);\n\t\t\tREISERFS_SB(s)->s_alloc_options.large_file_size =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 16;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_new_packing_localities\")) {\n\t\t\tSET_OPTION(displacing_new_packing_localities);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_hashed_relocation\")) {\n\t\t\tSET_OPTION(old_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"new_hashed_relocation\")) {\n\t\t\tSET_OPTION(new_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"dirid_groups\")) {\n\t\t\tSET_OPTION(dirid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"oid_groups\")) {\n\t\t\tSET_OPTION(oid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"packing_groups\")) {\n\t\t\tSET_OPTION(packing_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"hashed_formatted_nodes\")) {\n\t\t\tSET_OPTION(hashed_formatted_nodes);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"skip_busy\")) {\n\t\t\tSET_OPTION(skip_busy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"hundredth_slices\")) {\n\t\t\tSET_OPTION(hundredth_slices);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_way\")) {\n\t\t\tSET_OPTION(old_way);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"displace_based_on_dirid\")) {\n\t\t\tSET_OPTION(displace_based_on_dirid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocmin\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocsize\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t 0) :\n\t\t\t    PREALLOCATION_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\treiserfs_warning(s, \"zam-4001\", \"unknown option - %s\",\n\t\t\t\t this_char);\n\t\treturn 1;\n\t}\n\n\treiserfs_info(s, \"allocator options = [%08x]\\n\", SB_ALLOC_OPTS(s));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define PREALLOCATION_SIZE 9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "s",
            "\"allocator options = [%08x]\\n\"",
            "SB_ALLOC_OPTS(s)"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ALLOC_OPTS",
          "args": [
            "s"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"zam-4001\"",
            "\"unknown option - %s\"",
            "this_char"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "value",
            "&value",
            "0"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "this_char",
            "\"preallocsize\""
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "value",
            "&value",
            "0"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "displace_based_on_dirid"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "old_way"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "hundredth_slices"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "skip_busy"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "hashed_formatted_nodes"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "packing_groups"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "oid_groups"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "dirid_groups"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "new_hashed_relocation"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "old_hashed_relocation"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "displacing_new_packing_localities"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "value",
            "&value",
            "0"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "displacing_large_files"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "value",
            "&value",
            "0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_OPTION",
          "args": [
            "concentrating_formatted_nodes"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "this_char",
            "'='"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\":\""
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define PREALLOCATION_SIZE 9\n\nint reiserfs_parse_alloc_options(struct super_block *s, char *options)\n{\n\tchar *this_char, *value;\n\n\t/* clear default settings */\n\tREISERFS_SB(s)->s_alloc_options.bits = 0;\n\n\twhile ((this_char = strsep(&options, \":\")) != NULL) {\n\t\tif ((value = strchr(this_char, '=')) != NULL)\n\t\t\t*value++ = 0;\n\n\t\tif (!strcmp(this_char, \"concentrating_formatted_nodes\")) {\n\t\t\tint temp;\n\t\t\tSET_OPTION(concentrating_formatted_nodes);\n\t\t\ttemp = (value\n\t\t\t\t&& *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t    0) : 10;\n\t\t\tif (temp <= 0 || temp > 100) {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border = 10;\n\t\t\t} else {\n\t\t\t\tREISERFS_SB(s)->s_alloc_options.border =\n\t\t\t\t    100 / temp;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_large_files\")) {\n\t\t\tSET_OPTION(displacing_large_files);\n\t\t\tREISERFS_SB(s)->s_alloc_options.large_file_size =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 16;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"displacing_new_packing_localities\")) {\n\t\t\tSET_OPTION(displacing_new_packing_localities);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_hashed_relocation\")) {\n\t\t\tSET_OPTION(old_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"new_hashed_relocation\")) {\n\t\t\tSET_OPTION(new_hashed_relocation);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"dirid_groups\")) {\n\t\t\tSET_OPTION(dirid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"oid_groups\")) {\n\t\t\tSET_OPTION(oid_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"packing_groups\")) {\n\t\t\tSET_OPTION(packing_groups);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(this_char, \"hashed_formatted_nodes\")) {\n\t\t\tSET_OPTION(hashed_formatted_nodes);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"skip_busy\")) {\n\t\t\tSET_OPTION(skip_busy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"hundredth_slices\")) {\n\t\t\tSET_OPTION(hundredth_slices);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"old_way\")) {\n\t\t\tSET_OPTION(old_way);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"displace_based_on_dirid\")) {\n\t\t\tSET_OPTION(displace_based_on_dirid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocmin\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocmin =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value, 0) : 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(this_char, \"preallocsize\")) {\n\t\t\tREISERFS_SB(s)->s_alloc_options.preallocsize =\n\t\t\t    (value\n\t\t\t     && *value) ? simple_strtoul(value, &value,\n\t\t\t\t\t\t\t 0) :\n\t\t\t    PREALLOCATION_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\treiserfs_warning(s, \"zam-4001\", \"unknown option - %s\",\n\t\t\t\t this_char);\n\t\treturn 1;\n\t}\n\n\treiserfs_info(s, \"allocator options = [%08x]\\n\", SB_ALLOC_OPTS(s));\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_init_alloc_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "558-563",
    "snippet": "void reiserfs_init_alloc_options(struct super_block *s)\n{\n\tset_bit(_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define  _ALLOC_packing_groups 12",
      "#define  _ALLOC_dirid_groups 10",
      "#define  _ALLOC_skip_busy 5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "_ALLOC_packing_groups",
            "&SB_ALLOC_OPTS(s)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "97-100",
          "snippet": "static inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_set_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ALLOC_OPTS",
          "args": [
            "s"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ALLOC_OPTS",
          "args": [
            "s"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ALLOC_OPTS",
          "args": [
            "s"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n#define  _ALLOC_packing_groups 12\n#define  _ALLOC_dirid_groups 10\n#define  _ALLOC_skip_busy 5\n\nvoid reiserfs_init_alloc_options(struct super_block *s)\n{\n\tset_bit(_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));\n\tset_bit(_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));\n}"
  },
  {
    "function_name": "reiserfs_discard_all_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "538-556",
    "snippet": "void reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th)\n{\n\tstruct list_head *plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;\n\n\tBUG_ON(!th->t_trans_id);\n\twhile (!list_empty(plist)) {\n\t\tstruct reiserfs_inode_info *ei;\n\t\tei = list_entry(plist->next, struct reiserfs_inode_info,\n\t\t\t\ti_prealloc_list);\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!ei->i_prealloc_count) {\n\t\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t\t       \"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\");\n\t\t}\n#endif\n\t\t__discard_prealloc(th, ei);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__discard_prealloc",
          "args": [
            "th",
            "ei"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__discard_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "502-525",
          "snippet": "static void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "th->t_super",
            "\"zam-4001\"",
            "\"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "plist->next",
            "structreiserfs_inode_info",
            "i_prealloc_list"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "plist"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "th->t_super"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th)\n{\n\tstruct list_head *plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;\n\n\tBUG_ON(!th->t_trans_id);\n\twhile (!list_empty(plist)) {\n\t\tstruct reiserfs_inode_info *ei;\n\t\tei = list_entry(plist->next, struct reiserfs_inode_info,\n\t\t\t\ti_prealloc_list);\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!ei->i_prealloc_count) {\n\t\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t\t       \"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\");\n\t\t}\n#endif\n\t\t__discard_prealloc(th, ei);\n\t}\n}"
  },
  {
    "function_name": "reiserfs_discard_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "528-536",
    "snippet": "void reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__discard_prealloc",
          "args": [
            "th",
            "ei"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__discard_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "502-525",
          "snippet": "static void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct inode *inode)\n{\n\tstruct reiserfs_inode_info *ei = REISERFS_I(inode);\n\n\tBUG_ON(!th->t_trans_id);\n\tif (ei->i_prealloc_count)\n\t\t__discard_prealloc(th, ei);\n}"
  },
  {
    "function_name": "__discard_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "502-525",
    "snippet": "static void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ei->i_prealloc_list"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_update_sd",
          "args": [
            "th",
            "inode"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_sd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "3096-3100",
          "snippet": "static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,\n\t\t\t\t      struct inode *inode)\n{\n\treiserfs_update_sd_size(th, inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_free_prealloc_block",
          "args": [
            "th",
            "inode",
            "ei->i_prealloc_block"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_prealloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "491-500",
          "snippet": "static void reiserfs_free_prealloc_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, b_blocknr_t block)\n{\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!th->t_super,\n\t       \"vs-4060: trying to free block on nonexistent device\");\n\tif (!is_reusable(th->t_super, block, 1))\n\t\treturn;\n\t_reiserfs_free_block(th, inode, block, 1);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void reiserfs_free_prealloc_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, b_blocknr_t block)\n{\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!th->t_super,\n\t       \"vs-4060: trying to free block on nonexistent device\");\n\tif (!is_reusable(th->t_super, block, 1))\n\t\treturn;\n\t_reiserfs_free_block(th, inode, block, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "th->t_super",
            "\"zam-4001\"",
            "\"inode has negative prealloc blocks count.\""
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void __discard_prealloc(struct reiserfs_transaction_handle *th,\n\t\t\t       struct reiserfs_inode_info *ei)\n{\n\tunsigned long save = ei->i_prealloc_block;\n\tint dirty = 0;\n\tstruct inode *inode = &ei->vfs_inode;\n\n\tBUG_ON(!th->t_trans_id);\n#ifdef CONFIG_REISERFS_CHECK\n\tif (ei->i_prealloc_count < 0)\n\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t       \"inode has negative prealloc blocks count.\");\n#endif\n\twhile (ei->i_prealloc_count > 0) {\n\t\treiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);\n\t\tei->i_prealloc_block++;\n\t\tei->i_prealloc_count--;\n\t\tdirty = 1;\n\t}\n\tif (dirty)\n\t\treiserfs_update_sd(th, inode);\n\tei->i_prealloc_block = save;\n\tlist_del_init(&ei->i_prealloc_list);\n}"
  },
  {
    "function_name": "reiserfs_free_prealloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "491-500",
    "snippet": "static void reiserfs_free_prealloc_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, b_blocknr_t block)\n{\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!th->t_super,\n\t       \"vs-4060: trying to free block on nonexistent device\");\n\tif (!is_reusable(th->t_super, block, 1))\n\t\treturn;\n\t_reiserfs_free_block(th, inode, block, 1);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_reiserfs_free_block",
          "args": [
            "th",
            "inode",
            "block",
            "1"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "_reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "416-465",
          "snippet": "static void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reusable",
          "args": [
            "th->t_super",
            "block",
            "1"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "is_reusable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "62-113",
          "snippet": "int is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!th->t_super",
            "\"vs-4060: trying to free block on nonexistent device\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void reiserfs_free_prealloc_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t\t struct inode *inode, b_blocknr_t block)\n{\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!th->t_super,\n\t       \"vs-4060: trying to free block on nonexistent device\");\n\tif (!is_reusable(th->t_super, block, 1))\n\t\treturn;\n\t_reiserfs_free_block(th, inode, block, 1);\n}"
  },
  {
    "function_name": "reiserfs_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "467-488",
    "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_reiserfs_free_block",
          "args": [
            "th",
            "inode",
            "block",
            "for_unformatted"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "_reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "416-465",
          "snippet": "static void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_freed",
          "args": [
            "th",
            "s",
            "block"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3736-3825",
          "snippet": "int journal_mark_freed(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb, b_blocknr_t blocknr)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\tint cleaned = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (cn && cn->bh) {\n\t\tbh = cn->bh;\n\t\tget_bh(bh);\n\t}\n\t/* if it is journal new, we just remove it from this transaction */\n\tif (bh && buffer_journal_new(bh)) {\n\t\tclear_buffer_journal_new(bh);\n\t\tclear_prepared_bits(bh);\n\t\treiserfs_clean_and_file_buffer(bh);\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\t} else {\n\t\t/*\n\t\t * set the bit for this block in the journal bitmap\n\t\t * for this transaction\n\t\t */\n\t\tjb = journal->j_current_jl->j_list_bitmap;\n\t\tif (!jb) {\n\t\t\treiserfs_panic(sb, \"journal-1702\",\n\t\t\t\t       \"journal_list_bitmap is NULL\");\n\t\t}\n\t\tset_bit_in_list_bitmap(sb, blocknr, jb);\n\n\t\t/* Note, the entire while loop is not allowed to schedule.  */\n\n\t\tif (bh) {\n\t\t\tclear_prepared_bits(bh);\n\t\t\treiserfs_clean_and_file_buffer(bh);\n\t\t}\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\n\t\t/*\n\t\t * find all older transactions with this block,\n\t\t * make sure they don't try to write it out\n\t\t */\n\t\tcn = get_journal_hash_dev(sb, journal->j_list_hash_table,\n\t\t\t\t\t  blocknr);\n\t\twhile (cn) {\n\t\t\tif (sb == cn->sb && blocknr == cn->blocknr) {\n\t\t\t\tset_bit(BLOCK_FREED, &cn->state);\n\t\t\t\tif (cn->bh) {\n\t\t\t\t\t/*\n\t\t\t\t\t * remove_from_transaction will brelse\n\t\t\t\t\t * the buffer if it was in the current\n\t\t\t\t\t * trans\n\t\t\t\t\t */\n\t\t\t\t\tif (!cleaned) {\n\t\t\t\t\t\tclear_buffer_journal_dirty(cn->\n\t\t\t\t\t\t\t\t\t   bh);\n\t\t\t\t\t\tclear_buffer_dirty(cn->bh);\n\t\t\t\t\t\tclear_buffer_journal_test(cn->\n\t\t\t\t\t\t\t\t\t  bh);\n\t\t\t\t\t\tcleaned = 1;\n\t\t\t\t\t\tput_bh(cn->bh);\n\t\t\t\t\t\tif (atomic_read\n\t\t\t\t\t\t    (&cn->bh->b_count) < 0) {\n\t\t\t\t\t\t\treiserfs_warning(sb,\n\t\t\t\t\t\t\t\t \"journal-2138\",\n\t\t\t\t\t\t\t\t \"cn->bh->b_count < 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * since we are clearing the bh,\n\t\t\t\t\t * we MUST dec nonzerolen\n\t\t\t\t\t */\n\t\t\t\t\tif (cn->jlist) {\n\t\t\t\t\t\tatomic_dec(&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen);\n\t\t\t\t\t}\n\t\t\t\t\tcn->bh = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcn = cn->hnext;\n\t\t}\n\t}\n\n\tif (bh)\n\t\trelease_buffer_page(bh); /* get_hash grabs the buffer */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define BLOCK_FREED 2"
          ],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BLOCK_FREED 2\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_freed(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb, b_blocknr_t blocknr)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\tint cleaned = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (cn && cn->bh) {\n\t\tbh = cn->bh;\n\t\tget_bh(bh);\n\t}\n\t/* if it is journal new, we just remove it from this transaction */\n\tif (bh && buffer_journal_new(bh)) {\n\t\tclear_buffer_journal_new(bh);\n\t\tclear_prepared_bits(bh);\n\t\treiserfs_clean_and_file_buffer(bh);\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\t} else {\n\t\t/*\n\t\t * set the bit for this block in the journal bitmap\n\t\t * for this transaction\n\t\t */\n\t\tjb = journal->j_current_jl->j_list_bitmap;\n\t\tif (!jb) {\n\t\t\treiserfs_panic(sb, \"journal-1702\",\n\t\t\t\t       \"journal_list_bitmap is NULL\");\n\t\t}\n\t\tset_bit_in_list_bitmap(sb, blocknr, jb);\n\n\t\t/* Note, the entire while loop is not allowed to schedule.  */\n\n\t\tif (bh) {\n\t\t\tclear_prepared_bits(bh);\n\t\t\treiserfs_clean_and_file_buffer(bh);\n\t\t}\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\n\t\t/*\n\t\t * find all older transactions with this block,\n\t\t * make sure they don't try to write it out\n\t\t */\n\t\tcn = get_journal_hash_dev(sb, journal->j_list_hash_table,\n\t\t\t\t\t  blocknr);\n\t\twhile (cn) {\n\t\t\tif (sb == cn->sb && blocknr == cn->blocknr) {\n\t\t\t\tset_bit(BLOCK_FREED, &cn->state);\n\t\t\t\tif (cn->bh) {\n\t\t\t\t\t/*\n\t\t\t\t\t * remove_from_transaction will brelse\n\t\t\t\t\t * the buffer if it was in the current\n\t\t\t\t\t * trans\n\t\t\t\t\t */\n\t\t\t\t\tif (!cleaned) {\n\t\t\t\t\t\tclear_buffer_journal_dirty(cn->\n\t\t\t\t\t\t\t\t\t   bh);\n\t\t\t\t\t\tclear_buffer_dirty(cn->bh);\n\t\t\t\t\t\tclear_buffer_journal_test(cn->\n\t\t\t\t\t\t\t\t\t  bh);\n\t\t\t\t\t\tcleaned = 1;\n\t\t\t\t\t\tput_bh(cn->bh);\n\t\t\t\t\t\tif (atomic_read\n\t\t\t\t\t\t    (&cn->bh->b_count) < 0) {\n\t\t\t\t\t\t\treiserfs_warning(sb,\n\t\t\t\t\t\t\t\t \"journal-2138\",\n\t\t\t\t\t\t\t\t \"cn->bh->b_count < 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * since we are clearing the bh,\n\t\t\t\t\t * we MUST dec nonzerolen\n\t\t\t\t\t */\n\t\t\t\t\tif (cn->jlist) {\n\t\t\t\t\t\tatomic_dec(&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen);\n\t\t\t\t\t}\n\t\t\t\t\tcn->bh = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcn = cn->hnext;\n\t\t}\n\t}\n\n\tif (bh)\n\t\trelease_buffer_page(bh); /* get_hash grabs the buffer */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "th->t_super",
            "\"bitmap-4072\"",
            "\"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\"",
            "block",
            "sb_block_count(REISERFS_SB(s)->s_rs)"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_block_count",
          "args": [
            "REISERFS_SB(s)->s_rs"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_block_count",
          "args": [
            "REISERFS_SB(s)->s_rs"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_reusable",
          "args": [
            "s",
            "block",
            "1"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "is_reusable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "62-113",
          "snippet": "int is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!s",
            "\"vs-4061: trying to free block on nonexistent device\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
  },
  {
    "function_name": "_reiserfs_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "416-465",
    "snippet": "static void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "1"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "sbh"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sb_free_blocks",
          "args": [
            "rs",
            "sb_free_blocks(rs) + 1"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_free_blocks",
          "args": [
            "rs"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "sbh",
            "1"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bmbh"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "s",
            "\"vs-4080\"",
            "\"block %lu: bit already cleared\"",
            "block"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_test_and_clear_le_bit",
          "args": [
            "offset",
            "bmbh->b_data"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_read_bitmap_block",
          "args": [
            "s",
            "nr"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_bitmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1407-1444",
          "snippet": "struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bit_address",
          "args": [
            "s",
            "block",
            "&nr",
            "&offset"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "get_bit_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "48-60",
          "snippet": "static inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "free_block"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic void _reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs;\n\tstruct buffer_head *sbh, *bmbh;\n\tstruct reiserfs_bitmap_info *apbi;\n\tunsigned int nr, offset;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, free_block);\n\trs = SB_DISK_SUPER_BLOCK(s);\n\tsbh = SB_BUFFER_WITH_SB(s);\n\tapbi = SB_AP_BITMAP(s);\n\n\tget_bit_address(s, block, &nr, &offset);\n\n\tif (nr >= reiserfs_bmap_count(s)) {\n\t\treiserfs_error(s, \"vs-4075\", \"block %lu is out of range\",\n\t\t\t       block);\n\t\treturn;\n\t}\n\n\tbmbh = reiserfs_read_bitmap_block(s, nr);\n\tif (!bmbh)\n\t\treturn;\n\n\treiserfs_prepare_for_journal(s, bmbh, 1);\n\n\t/* clear bit for the given block in bit map */\n\tif (!reiserfs_test_and_clear_le_bit(offset, bmbh->b_data)) {\n\t\treiserfs_error(s, \"vs-4080\",\n\t\t\t       \"block %lu: bit already cleared\", block);\n\t}\n\tapbi[nr].free_count++;\n\tjournal_mark_dirty(th, bmbh);\n\tbrelse(bmbh);\n\n\treiserfs_prepare_for_journal(s, sbh, 1);\n\t/* update super block */\n\tset_sb_free_blocks(rs, sb_free_blocks(rs) + 1);\n\n\tjournal_mark_dirty(th, sbh);\n\tif (for_unformatted) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
  },
  {
    "function_name": "scan_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "347-414",
    "snippet": "static int scan_bitmap(struct reiserfs_transaction_handle *th,\n\t\t       b_blocknr_t * start, b_blocknr_t finish,\n\t\t       int min, int max, int unfm, sector_t file_block)\n{\n\tint nr_allocated = 0;\n\tstruct super_block *s = th->t_super;\n\tunsigned int bm, off;\n\tunsigned int end_bm, end_off;\n\tunsigned int off_max = s->s_blocksize << 3;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, scan_bitmap.call);\n\n\t/* No point in looking for more free blocks */\n\tif (SB_FREE_BLOCKS(s) <= 0)\n\t\treturn 0;\n\n\tget_bit_address(s, *start, &bm, &off);\n\tget_bit_address(s, finish, &end_bm, &end_off);\n\tif (bm > reiserfs_bmap_count(s))\n\t\treturn 0;\n\tif (end_bm > reiserfs_bmap_count(s))\n\t\tend_bm = reiserfs_bmap_count(s);\n\n\t/*\n\t * When the bitmap is more than 10% free, anyone can allocate.\n\t * When it's less than 10% free, only files that already use the\n\t * bitmap are allowed. Once we pass 80% full, this restriction\n\t * is lifted.\n\t *\n\t * We do this so that files that grow later still have space close to\n\t * their original allocation. This improves locality, and presumably\n\t * performance as a result.\n\t *\n\t * This is only an allocation policy and does not make up for getting a\n\t * bad hint. Decent hinting must be implemented for this to work well.\n\t */\n\tif (TEST_OPTION(skip_busy, s)\n\t    && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s) / 20) {\n\t\tfor (; bm < end_bm; bm++, off = 0) {\n\t\t\tif ((off && (!unfm || (file_block != 0)))\n\t\t\t    || SB_AP_BITMAP(s)[bm].free_count >\n\t\t\t    (s->s_blocksize << 3) / 10)\n\t\t\t\tnr_allocated =\n\t\t\t\t    scan_bitmap_block(th, bm, &off, off_max,\n\t\t\t\t\t\t      min, max, unfm);\n\t\t\tif (nr_allocated)\n\t\t\t\tgoto ret;\n\t\t}\n\t\t/* we know from above that start is a reasonable number */\n\t\tget_bit_address(s, *start, &bm, &off);\n\t}\n\n\tfor (; bm < end_bm; bm++, off = 0) {\n\t\tnr_allocated =\n\t\t    scan_bitmap_block(th, bm, &off, off_max, min, max, unfm);\n\t\tif (nr_allocated)\n\t\t\tgoto ret;\n\t}\n\n\tnr_allocated =\n\t    scan_bitmap_block(th, bm, &off, end_off + 1, min, max, unfm);\n\nret:\n\t*start = bm * off_max + off;\n\treturn nr_allocated;\n\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scan_bitmap_block",
          "args": [
            "th",
            "bm",
            "&off",
            "end_off + 1",
            "min",
            "max",
            "unfm"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "scan_bitmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "143-272",
          "snippet": "static int scan_bitmap_block(struct reiserfs_transaction_handle *th,\n\t\t\t     unsigned int bmap_n, int *beg, int boundary,\n\t\t\t     int min, int max, int unfm)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_bitmap_info *bi = &SB_AP_BITMAP(s)[bmap_n];\n\tstruct buffer_head *bh;\n\tint end, next;\n\tint org = *beg;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(bmap_n >= reiserfs_bmap_count(s), \"Bitmap %u is out of \"\n\t       \"range (0..%u)\", bmap_n, reiserfs_bmap_count(s) - 1);\n\tPROC_INFO_INC(s, scan_bitmap.bmap);\n\n\tif (!bi) {\n\t\treiserfs_error(s, \"jdm-4055\", \"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\", bmap_n);\n\t\treturn 0;\n\t}\n\n\tbh = reiserfs_read_bitmap_block(s, bmap_n);\n\tif (bh == NULL)\n\t\treturn 0;\n\n\twhile (1) {\ncont:\n\t\tif (bi->free_count < min) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\t/* No free blocks in this bitmap */\n\t\t}\n\n\t\t/* search for a first zero bit -- beginning of a window */\n\t\t*beg = reiserfs_find_next_zero_le_bit\n\t\t    ((unsigned long *)(bh->b_data), boundary, *beg);\n\n\t\t/*\n\t\t * search for a zero bit fails or the rest of bitmap block\n\t\t * cannot contain a zero window of minimum size\n\t\t */\n\t\tif (*beg + min > boundary) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unfm && is_block_in_journal(s, bmap_n, *beg, beg))\n\t\t\tcontinue;\n\t\t/* first zero bit found; we check next bits */\n\t\tfor (end = *beg + 1;; end++) {\n\t\t\tif (end >= *beg + max || end >= boundary\n\t\t\t    || reiserfs_test_le_bit(end, bh->b_data)) {\n\t\t\t\tnext = end;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * finding the other end of zero bit window requires\n\t\t\t * looking into journal structures (in case of\n\t\t\t * searching for free blocks for unformatted nodes)\n\t\t\t */\n\t\t\tif (unfm && is_block_in_journal(s, bmap_n, end, &next))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * now (*beg) points to beginning of zero bits window,\n\t\t * (end) points to one bit after the window end\n\t\t */\n\n\t\t/* found window of proper size */\n\t\tif (end - *beg >= min) {\n\t\t\tint i;\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t/*\n\t\t\t * try to set all blocks used checking are\n\t\t\t * they still free\n\t\t\t */\n\t\t\tfor (i = *beg; i < end; i++) {\n\t\t\t\t/* Don't check in journal again. */\n\t\t\t\tif (reiserfs_test_and_set_le_bit\n\t\t\t\t    (i, bh->b_data)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * bit was set by another process while\n\t\t\t\t\t * we slept in prepare_for_journal()\n\t\t\t\t\t */\n\t\t\t\t\tPROC_INFO_INC(s, scan_bitmap.stolen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we can continue with smaller set\n\t\t\t\t\t * of allocated blocks, if length of\n\t\t\t\t\t * this set is more or equal to `min'\n\t\t\t\t\t */\n\t\t\t\t\tif (i >= *beg + min) {\n\t\t\t\t\t\tend = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * otherwise we clear all bit\n\t\t\t\t\t * were set ...\n\t\t\t\t\t */\n\t\t\t\t\twhile (--i >= *beg)\n\t\t\t\t\t\treiserfs_clear_le_bit\n\t\t\t\t\t\t    (i, bh->b_data);\n\t\t\t\t\treiserfs_restore_prepared_buffer(s, bh);\n\t\t\t\t\t*beg = org;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Search again in current block\n\t\t\t\t\t * from beginning\n\t\t\t\t\t */\n\t\t\t\t\tgoto cont;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbi->free_count -= (end - *beg);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\tbrelse(bh);\n\n\t\t\t/* free block count calculation */\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tPUT_SB_FREE_BLOCKS(s, SB_FREE_BLOCKS(s) - (end - *beg));\n\t\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t\t\treturn end - (*beg);\n\t\t} else {\n\t\t\t*beg = next;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int scan_bitmap_block(struct reiserfs_transaction_handle *th,\n\t\t\t     unsigned int bmap_n, int *beg, int boundary,\n\t\t\t     int min, int max, int unfm)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_bitmap_info *bi = &SB_AP_BITMAP(s)[bmap_n];\n\tstruct buffer_head *bh;\n\tint end, next;\n\tint org = *beg;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(bmap_n >= reiserfs_bmap_count(s), \"Bitmap %u is out of \"\n\t       \"range (0..%u)\", bmap_n, reiserfs_bmap_count(s) - 1);\n\tPROC_INFO_INC(s, scan_bitmap.bmap);\n\n\tif (!bi) {\n\t\treiserfs_error(s, \"jdm-4055\", \"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\", bmap_n);\n\t\treturn 0;\n\t}\n\n\tbh = reiserfs_read_bitmap_block(s, bmap_n);\n\tif (bh == NULL)\n\t\treturn 0;\n\n\twhile (1) {\ncont:\n\t\tif (bi->free_count < min) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\t/* No free blocks in this bitmap */\n\t\t}\n\n\t\t/* search for a first zero bit -- beginning of a window */\n\t\t*beg = reiserfs_find_next_zero_le_bit\n\t\t    ((unsigned long *)(bh->b_data), boundary, *beg);\n\n\t\t/*\n\t\t * search for a zero bit fails or the rest of bitmap block\n\t\t * cannot contain a zero window of minimum size\n\t\t */\n\t\tif (*beg + min > boundary) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unfm && is_block_in_journal(s, bmap_n, *beg, beg))\n\t\t\tcontinue;\n\t\t/* first zero bit found; we check next bits */\n\t\tfor (end = *beg + 1;; end++) {\n\t\t\tif (end >= *beg + max || end >= boundary\n\t\t\t    || reiserfs_test_le_bit(end, bh->b_data)) {\n\t\t\t\tnext = end;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * finding the other end of zero bit window requires\n\t\t\t * looking into journal structures (in case of\n\t\t\t * searching for free blocks for unformatted nodes)\n\t\t\t */\n\t\t\tif (unfm && is_block_in_journal(s, bmap_n, end, &next))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * now (*beg) points to beginning of zero bits window,\n\t\t * (end) points to one bit after the window end\n\t\t */\n\n\t\t/* found window of proper size */\n\t\tif (end - *beg >= min) {\n\t\t\tint i;\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t/*\n\t\t\t * try to set all blocks used checking are\n\t\t\t * they still free\n\t\t\t */\n\t\t\tfor (i = *beg; i < end; i++) {\n\t\t\t\t/* Don't check in journal again. */\n\t\t\t\tif (reiserfs_test_and_set_le_bit\n\t\t\t\t    (i, bh->b_data)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * bit was set by another process while\n\t\t\t\t\t * we slept in prepare_for_journal()\n\t\t\t\t\t */\n\t\t\t\t\tPROC_INFO_INC(s, scan_bitmap.stolen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we can continue with smaller set\n\t\t\t\t\t * of allocated blocks, if length of\n\t\t\t\t\t * this set is more or equal to `min'\n\t\t\t\t\t */\n\t\t\t\t\tif (i >= *beg + min) {\n\t\t\t\t\t\tend = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * otherwise we clear all bit\n\t\t\t\t\t * were set ...\n\t\t\t\t\t */\n\t\t\t\t\twhile (--i >= *beg)\n\t\t\t\t\t\treiserfs_clear_le_bit\n\t\t\t\t\t\t    (i, bh->b_data);\n\t\t\t\t\treiserfs_restore_prepared_buffer(s, bh);\n\t\t\t\t\t*beg = org;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Search again in current block\n\t\t\t\t\t * from beginning\n\t\t\t\t\t */\n\t\t\t\t\tgoto cont;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbi->free_count -= (end - *beg);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\tbrelse(bh);\n\n\t\t\t/* free block count calculation */\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tPUT_SB_FREE_BLOCKS(s, SB_FREE_BLOCKS(s) - (end - *beg));\n\t\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t\t\treturn end - (*beg);\n\t\t} else {\n\t\t\t*beg = next;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bit_address",
          "args": [
            "s",
            "*start",
            "&bm",
            "&off"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "get_bit_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "48-60",
          "snippet": "static inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_FREE_BLOCKS",
          "args": [
            "s"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "skip_busy",
            "s"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_FREE_BLOCKS",
          "args": [
            "s"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.call"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int scan_bitmap(struct reiserfs_transaction_handle *th,\n\t\t       b_blocknr_t * start, b_blocknr_t finish,\n\t\t       int min, int max, int unfm, sector_t file_block)\n{\n\tint nr_allocated = 0;\n\tstruct super_block *s = th->t_super;\n\tunsigned int bm, off;\n\tunsigned int end_bm, end_off;\n\tunsigned int off_max = s->s_blocksize << 3;\n\n\tBUG_ON(!th->t_trans_id);\n\tPROC_INFO_INC(s, scan_bitmap.call);\n\n\t/* No point in looking for more free blocks */\n\tif (SB_FREE_BLOCKS(s) <= 0)\n\t\treturn 0;\n\n\tget_bit_address(s, *start, &bm, &off);\n\tget_bit_address(s, finish, &end_bm, &end_off);\n\tif (bm > reiserfs_bmap_count(s))\n\t\treturn 0;\n\tif (end_bm > reiserfs_bmap_count(s))\n\t\tend_bm = reiserfs_bmap_count(s);\n\n\t/*\n\t * When the bitmap is more than 10% free, anyone can allocate.\n\t * When it's less than 10% free, only files that already use the\n\t * bitmap are allowed. Once we pass 80% full, this restriction\n\t * is lifted.\n\t *\n\t * We do this so that files that grow later still have space close to\n\t * their original allocation. This improves locality, and presumably\n\t * performance as a result.\n\t *\n\t * This is only an allocation policy and does not make up for getting a\n\t * bad hint. Decent hinting must be implemented for this to work well.\n\t */\n\tif (TEST_OPTION(skip_busy, s)\n\t    && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s) / 20) {\n\t\tfor (; bm < end_bm; bm++, off = 0) {\n\t\t\tif ((off && (!unfm || (file_block != 0)))\n\t\t\t    || SB_AP_BITMAP(s)[bm].free_count >\n\t\t\t    (s->s_blocksize << 3) / 10)\n\t\t\t\tnr_allocated =\n\t\t\t\t    scan_bitmap_block(th, bm, &off, off_max,\n\t\t\t\t\t\t      min, max, unfm);\n\t\t\tif (nr_allocated)\n\t\t\t\tgoto ret;\n\t\t}\n\t\t/* we know from above that start is a reasonable number */\n\t\tget_bit_address(s, *start, &bm, &off);\n\t}\n\n\tfor (; bm < end_bm; bm++, off = 0) {\n\t\tnr_allocated =\n\t\t    scan_bitmap_block(th, bm, &off, off_max, min, max, unfm);\n\t\tif (nr_allocated)\n\t\t\tgoto ret;\n\t}\n\n\tnr_allocated =\n\t    scan_bitmap_block(th, bm, &off, end_off + 1, min, max, unfm);\n\nret:\n\t*start = bm * off_max + off;\n\treturn nr_allocated;\n\n}"
  },
  {
    "function_name": "reiserfs_choose_packing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "325-341",
    "snippet": "__le32 reiserfs_choose_packing(struct inode * dir)\n{\n\t__le32 packing;\n\tif (TEST_OPTION(packing_groups, dir->i_sb)) {\n\t\tu32 parent_dir = le32_to_cpu(INODE_PKEY(dir)->k_dir_id);\n\t\t/*\n\t\t * some versions of reiserfsck expect packing locality 1 to be\n\t\t * special\n\t\t */\n\t\tif (parent_dir == 1 || block_group_used(dir->i_sb, parent_dir))\n\t\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\t\telse\n\t\t\tpacking = INODE_PKEY(dir)->k_dir_id;\n\t} else\n\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\treturn packing;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_group_used",
          "args": [
            "dir->i_sb",
            "parent_dir"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "block_group_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "299-320",
          "snippet": "static inline int block_group_used(struct super_block *s, u32 id)\n{\n\tint bm = bmap_hash_id(s, id);\n\tstruct reiserfs_bitmap_info *info = &SB_AP_BITMAP(s)[bm];\n\n\t/*\n\t * If we don't have cached information on this bitmap block, we're\n\t * going to have to load it later anyway. Loading it here allows us\n\t * to make a better decision. This favors long-term performance gain\n\t * with a better on-disk layout vs. a short term gain of skipping the\n\t * read and potentially having a bad placement.\n\t */\n\tif (info->free_count == UINT_MAX) {\n\t\tstruct buffer_head *bh = reiserfs_read_bitmap_block(s, bm);\n\t\tbrelse(bh);\n\t}\n\n\tif (info->free_count > ((s->s_blocksize << 3) * 60 / 100)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int block_group_used(struct super_block *s, u32 id)\n{\n\tint bm = bmap_hash_id(s, id);\n\tstruct reiserfs_bitmap_info *info = &SB_AP_BITMAP(s)[bm];\n\n\t/*\n\t * If we don't have cached information on this bitmap block, we're\n\t * going to have to load it later anyway. Loading it here allows us\n\t * to make a better decision. This favors long-term performance gain\n\t * with a better on-disk layout vs. a short term gain of skipping the\n\t * read and potentially having a bad placement.\n\t */\n\tif (info->free_count == UINT_MAX) {\n\t\tstruct buffer_head *bh = reiserfs_read_bitmap_block(s, bm);\n\t\tbrelse(bh);\n\t}\n\n\tif (info->free_count > ((s->s_blocksize << 3) * 60 / 100)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(dir)->k_dir_id"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "dir"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEST_OPTION",
          "args": [
            "packing_groups",
            "dir->i_sb"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\n__le32 reiserfs_choose_packing(struct inode * dir)\n{\n\t__le32 packing;\n\tif (TEST_OPTION(packing_groups, dir->i_sb)) {\n\t\tu32 parent_dir = le32_to_cpu(INODE_PKEY(dir)->k_dir_id);\n\t\t/*\n\t\t * some versions of reiserfsck expect packing locality 1 to be\n\t\t * special\n\t\t */\n\t\tif (parent_dir == 1 || block_group_used(dir->i_sb, parent_dir))\n\t\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\t\telse\n\t\t\tpacking = INODE_PKEY(dir)->k_dir_id;\n\t} else\n\t\tpacking = INODE_PKEY(dir)->k_objectid;\n\treturn packing;\n}"
  },
  {
    "function_name": "block_group_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "299-320",
    "snippet": "static inline int block_group_used(struct super_block *s, u32 id)\n{\n\tint bm = bmap_hash_id(s, id);\n\tstruct reiserfs_bitmap_info *info = &SB_AP_BITMAP(s)[bm];\n\n\t/*\n\t * If we don't have cached information on this bitmap block, we're\n\t * going to have to load it later anyway. Loading it here allows us\n\t * to make a better decision. This favors long-term performance gain\n\t * with a better on-disk layout vs. a short term gain of skipping the\n\t * read and potentially having a bad placement.\n\t */\n\tif (info->free_count == UINT_MAX) {\n\t\tstruct buffer_head *bh = reiserfs_read_bitmap_block(s, bm);\n\t\tbrelse(bh);\n\t}\n\n\tif (info->free_count > ((s->s_blocksize << 3) * 60 / 100)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_read_bitmap_block",
          "args": [
            "s",
            "bm"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_bitmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1407-1444",
          "snippet": "struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap_hash_id",
          "args": [
            "s",
            "id"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_hash_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "274-293",
          "snippet": "static int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int block_group_used(struct super_block *s, u32 id)\n{\n\tint bm = bmap_hash_id(s, id);\n\tstruct reiserfs_bitmap_info *info = &SB_AP_BITMAP(s)[bm];\n\n\t/*\n\t * If we don't have cached information on this bitmap block, we're\n\t * going to have to load it later anyway. Loading it here allows us\n\t * to make a better decision. This favors long-term performance gain\n\t * with a better on-disk layout vs. a short term gain of skipping the\n\t * read and potentially having a bad placement.\n\t */\n\tif (info->free_count == UINT_MAX) {\n\t\tstruct buffer_head *bh = reiserfs_read_bitmap_block(s, bm);\n\t\tbrelse(bh);\n\t}\n\n\tif (info->free_count > ((s->s_blocksize << 3) * 60 / 100)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "bmap_hash_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "274-293",
    "snippet": "static int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyed_hash",
          "args": [
            "hash_in",
            "4"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "keyed_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
          "lines": "44-122",
          "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
          "includes": [
            "#include <asm/types.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
            "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int bmap_hash_id(struct super_block *s, u32 id)\n{\n\tchar *hash_in = NULL;\n\tunsigned long hash;\n\tunsigned bm;\n\n\tif (id <= 2) {\n\t\tbm = 1;\n\t} else {\n\t\thash_in = (char *)(&id);\n\t\thash = keyed_hash(hash_in, 4);\n\t\tbm = hash % reiserfs_bmap_count(s);\n\t\tif (!bm)\n\t\t\tbm = 1;\n\t}\n\t/* this can only be true when SB_BMAP_NR = 1 */\n\tif (bm >= reiserfs_bmap_count(s))\n\t\tbm = 0;\n\treturn bm;\n}"
  },
  {
    "function_name": "scan_bitmap_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "143-272",
    "snippet": "static int scan_bitmap_block(struct reiserfs_transaction_handle *th,\n\t\t\t     unsigned int bmap_n, int *beg, int boundary,\n\t\t\t     int min, int max, int unfm)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_bitmap_info *bi = &SB_AP_BITMAP(s)[bmap_n];\n\tstruct buffer_head *bh;\n\tint end, next;\n\tint org = *beg;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(bmap_n >= reiserfs_bmap_count(s), \"Bitmap %u is out of \"\n\t       \"range (0..%u)\", bmap_n, reiserfs_bmap_count(s) - 1);\n\tPROC_INFO_INC(s, scan_bitmap.bmap);\n\n\tif (!bi) {\n\t\treiserfs_error(s, \"jdm-4055\", \"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\", bmap_n);\n\t\treturn 0;\n\t}\n\n\tbh = reiserfs_read_bitmap_block(s, bmap_n);\n\tif (bh == NULL)\n\t\treturn 0;\n\n\twhile (1) {\ncont:\n\t\tif (bi->free_count < min) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\t/* No free blocks in this bitmap */\n\t\t}\n\n\t\t/* search for a first zero bit -- beginning of a window */\n\t\t*beg = reiserfs_find_next_zero_le_bit\n\t\t    ((unsigned long *)(bh->b_data), boundary, *beg);\n\n\t\t/*\n\t\t * search for a zero bit fails or the rest of bitmap block\n\t\t * cannot contain a zero window of minimum size\n\t\t */\n\t\tif (*beg + min > boundary) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unfm && is_block_in_journal(s, bmap_n, *beg, beg))\n\t\t\tcontinue;\n\t\t/* first zero bit found; we check next bits */\n\t\tfor (end = *beg + 1;; end++) {\n\t\t\tif (end >= *beg + max || end >= boundary\n\t\t\t    || reiserfs_test_le_bit(end, bh->b_data)) {\n\t\t\t\tnext = end;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * finding the other end of zero bit window requires\n\t\t\t * looking into journal structures (in case of\n\t\t\t * searching for free blocks for unformatted nodes)\n\t\t\t */\n\t\t\tif (unfm && is_block_in_journal(s, bmap_n, end, &next))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * now (*beg) points to beginning of zero bits window,\n\t\t * (end) points to one bit after the window end\n\t\t */\n\n\t\t/* found window of proper size */\n\t\tif (end - *beg >= min) {\n\t\t\tint i;\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t/*\n\t\t\t * try to set all blocks used checking are\n\t\t\t * they still free\n\t\t\t */\n\t\t\tfor (i = *beg; i < end; i++) {\n\t\t\t\t/* Don't check in journal again. */\n\t\t\t\tif (reiserfs_test_and_set_le_bit\n\t\t\t\t    (i, bh->b_data)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * bit was set by another process while\n\t\t\t\t\t * we slept in prepare_for_journal()\n\t\t\t\t\t */\n\t\t\t\t\tPROC_INFO_INC(s, scan_bitmap.stolen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we can continue with smaller set\n\t\t\t\t\t * of allocated blocks, if length of\n\t\t\t\t\t * this set is more or equal to `min'\n\t\t\t\t\t */\n\t\t\t\t\tif (i >= *beg + min) {\n\t\t\t\t\t\tend = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * otherwise we clear all bit\n\t\t\t\t\t * were set ...\n\t\t\t\t\t */\n\t\t\t\t\twhile (--i >= *beg)\n\t\t\t\t\t\treiserfs_clear_le_bit\n\t\t\t\t\t\t    (i, bh->b_data);\n\t\t\t\t\treiserfs_restore_prepared_buffer(s, bh);\n\t\t\t\t\t*beg = org;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Search again in current block\n\t\t\t\t\t * from beginning\n\t\t\t\t\t */\n\t\t\t\t\tgoto cont;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbi->free_count -= (end - *beg);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\tbrelse(bh);\n\n\t\t\t/* free block count calculation */\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tPUT_SB_FREE_BLOCKS(s, SB_FREE_BLOCKS(s) - (end - *beg));\n\t\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t\t\treturn end - (*beg);\n\t\t} else {\n\t\t\t*beg = next;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_SB_FREE_BLOCKS",
          "args": [
            "s",
            "SB_FREE_BLOCKS(s) - (end - *beg)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_FREE_BLOCKS",
          "args": [
            "s"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "s",
            "bh"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_clear_le_bit",
          "args": [
            "i",
            "bh->b_data"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.stolen"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_test_and_set_le_bit",
          "args": [
            "i",
            "bh->b_data"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_block_in_journal",
          "args": [
            "s",
            "bmap_n",
            "end",
            "&next"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "is_block_in_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "120-137",
          "snippet": "static inline int is_block_in_journal(struct super_block *s, unsigned int bmap,\n\t\t\t\t      int off, int *next)\n{\n\tb_blocknr_t tmp;\n\n\tif (reiserfs_in_journal(s, bmap, off, 1, &tmp)) {\n\t\tif (tmp) {\t/* hint supplied */\n\t\t\t*next = tmp;\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_hint);\n\t\t} else {\n\t\t\t(*next) = off + 1;  /* inc offset to avoid looping. */\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_nohint);\n\t\t}\n\t\tPROC_INFO_INC(s, scan_bitmap.retry);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int is_block_in_journal(struct super_block *s, unsigned int bmap,\n\t\t\t\t      int off, int *next)\n{\n\tb_blocknr_t tmp;\n\n\tif (reiserfs_in_journal(s, bmap, off, 1, &tmp)) {\n\t\tif (tmp) {\t/* hint supplied */\n\t\t\t*next = tmp;\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_hint);\n\t\t} else {\n\t\t\t(*next) = off + 1;  /* inc offset to avoid looping. */\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_nohint);\n\t\t}\n\t\tPROC_INFO_INC(s, scan_bitmap.retry);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_test_le_bit",
          "args": [
            "end",
            "bh->b_data"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_find_next_zero_le_bit",
          "args": [
            "(unsigned long *)(bh->b_data)",
            "boundary",
            "*beg"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_read_bitmap_block",
          "args": [
            "s",
            "bmap_n"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_read_bitmap_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "1407-1444",
          "snippet": "struct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstruct buffer_head *reiserfs_read_bitmap_block(struct super_block *sb,\n                                               unsigned int bitmap)\n{\n\tb_blocknr_t block = (sb->s_blocksize << 3) * bitmap;\n\tstruct reiserfs_bitmap_info *info = SB_AP_BITMAP(sb) + bitmap;\n\tstruct buffer_head *bh;\n\n\t/*\n\t * Way old format filesystems had the bitmaps packed up front.\n\t * I doubt there are any of these left, but just in case...\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(sb)->s_properties)))\n\t\tblock = REISERFS_SB(sb)->s_sbh->b_blocknr + 1 + bitmap;\n\telse if (bitmap == 0)\n\t\tblock = (REISERFS_DISK_OFFSET_IN_BYTES >> sb->s_blocksize_bits) + 1;\n\n\tbh = sb_bread(sb, block);\n\tif (bh == NULL)\n\t\treiserfs_warning(sb, \"sh-2029: %s: bitmap block (#%u) \"\n\t\t                 \"reading failed\", __func__, block);\n\telse {\n\t\tif (buffer_locked(bh)) {\n\t\t\tint depth;\n\t\t\tPROC_INFO_INC(sb, scan_bitmap.wait);\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(atomic_read(&bh->b_count) == 0);\n\n\t\tif (info->free_count == UINT_MAX)\n\t\t\treiserfs_cache_bitmap_metadata(sb, bh, info);\n\t}\n\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "s",
            "\"jdm-4055\"",
            "\"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\"",
            "bmap_n"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.bmap"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bmap_n >= reiserfs_bmap_count(s)",
            "\"Bitmap %u is out of \"\n\t       \"range (0..%u)\"",
            "bmap_n",
            "reiserfs_bmap_count(s) - 1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_AP_BITMAP",
          "args": [
            "s"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic int scan_bitmap_block(struct reiserfs_transaction_handle *th,\n\t\t\t     unsigned int bmap_n, int *beg, int boundary,\n\t\t\t     int min, int max, int unfm)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_bitmap_info *bi = &SB_AP_BITMAP(s)[bmap_n];\n\tstruct buffer_head *bh;\n\tint end, next;\n\tint org = *beg;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(bmap_n >= reiserfs_bmap_count(s), \"Bitmap %u is out of \"\n\t       \"range (0..%u)\", bmap_n, reiserfs_bmap_count(s) - 1);\n\tPROC_INFO_INC(s, scan_bitmap.bmap);\n\n\tif (!bi) {\n\t\treiserfs_error(s, \"jdm-4055\", \"NULL bitmap info pointer \"\n\t\t\t       \"for bitmap %d\", bmap_n);\n\t\treturn 0;\n\t}\n\n\tbh = reiserfs_read_bitmap_block(s, bmap_n);\n\tif (bh == NULL)\n\t\treturn 0;\n\n\twhile (1) {\ncont:\n\t\tif (bi->free_count < min) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\t/* No free blocks in this bitmap */\n\t\t}\n\n\t\t/* search for a first zero bit -- beginning of a window */\n\t\t*beg = reiserfs_find_next_zero_le_bit\n\t\t    ((unsigned long *)(bh->b_data), boundary, *beg);\n\n\t\t/*\n\t\t * search for a zero bit fails or the rest of bitmap block\n\t\t * cannot contain a zero window of minimum size\n\t\t */\n\t\tif (*beg + min > boundary) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unfm && is_block_in_journal(s, bmap_n, *beg, beg))\n\t\t\tcontinue;\n\t\t/* first zero bit found; we check next bits */\n\t\tfor (end = *beg + 1;; end++) {\n\t\t\tif (end >= *beg + max || end >= boundary\n\t\t\t    || reiserfs_test_le_bit(end, bh->b_data)) {\n\t\t\t\tnext = end;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * finding the other end of zero bit window requires\n\t\t\t * looking into journal structures (in case of\n\t\t\t * searching for free blocks for unformatted nodes)\n\t\t\t */\n\t\t\tif (unfm && is_block_in_journal(s, bmap_n, end, &next))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * now (*beg) points to beginning of zero bits window,\n\t\t * (end) points to one bit after the window end\n\t\t */\n\n\t\t/* found window of proper size */\n\t\tif (end - *beg >= min) {\n\t\t\tint i;\n\t\t\treiserfs_prepare_for_journal(s, bh, 1);\n\t\t\t/*\n\t\t\t * try to set all blocks used checking are\n\t\t\t * they still free\n\t\t\t */\n\t\t\tfor (i = *beg; i < end; i++) {\n\t\t\t\t/* Don't check in journal again. */\n\t\t\t\tif (reiserfs_test_and_set_le_bit\n\t\t\t\t    (i, bh->b_data)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * bit was set by another process while\n\t\t\t\t\t * we slept in prepare_for_journal()\n\t\t\t\t\t */\n\t\t\t\t\tPROC_INFO_INC(s, scan_bitmap.stolen);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * we can continue with smaller set\n\t\t\t\t\t * of allocated blocks, if length of\n\t\t\t\t\t * this set is more or equal to `min'\n\t\t\t\t\t */\n\t\t\t\t\tif (i >= *beg + min) {\n\t\t\t\t\t\tend = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * otherwise we clear all bit\n\t\t\t\t\t * were set ...\n\t\t\t\t\t */\n\t\t\t\t\twhile (--i >= *beg)\n\t\t\t\t\t\treiserfs_clear_le_bit\n\t\t\t\t\t\t    (i, bh->b_data);\n\t\t\t\t\treiserfs_restore_prepared_buffer(s, bh);\n\t\t\t\t\t*beg = org;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Search again in current block\n\t\t\t\t\t * from beginning\n\t\t\t\t\t */\n\t\t\t\t\tgoto cont;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbi->free_count -= (end - *beg);\n\t\t\tjournal_mark_dirty(th, bh);\n\t\t\tbrelse(bh);\n\n\t\t\t/* free block count calculation */\n\t\t\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s),\n\t\t\t\t\t\t     1);\n\t\t\tPUT_SB_FREE_BLOCKS(s, SB_FREE_BLOCKS(s) - (end - *beg));\n\t\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t\t\treturn end - (*beg);\n\t\t} else {\n\t\t\t*beg = next;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "is_block_in_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "120-137",
    "snippet": "static inline int is_block_in_journal(struct super_block *s, unsigned int bmap,\n\t\t\t\t      int off, int *next)\n{\n\tb_blocknr_t tmp;\n\n\tif (reiserfs_in_journal(s, bmap, off, 1, &tmp)) {\n\t\tif (tmp) {\t/* hint supplied */\n\t\t\t*next = tmp;\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_hint);\n\t\t} else {\n\t\t\t(*next) = off + 1;  /* inc offset to avoid looping. */\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_nohint);\n\t\t}\n\t\tPROC_INFO_INC(s, scan_bitmap.retry);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.retry"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.in_journal_nohint"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "scan_bitmap.in_journal_hint"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_in_journal",
          "args": [
            "s",
            "bmap",
            "off",
            "1",
            "&tmp"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_in_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "459-514",
          "snippet": "int reiserfs_in_journal(struct super_block *sb,\n\t\t\tunsigned int bmap_nr, int bit_nr, int search_all,\n\t\t\tb_blocknr_t * next_zero_bit)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_list_bitmap *jb;\n\tint i;\n\tunsigned long bl;\n\n\t*next_zero_bit = 0;\t/* always start this at zero. */\n\n\tPROC_INFO_INC(sb, journal.in_journal);\n\t/*\n\t * If we aren't doing a search_all, this is a metablock, and it\n\t * will be logged before use.  if we crash before the transaction\n\t * that freed it commits,  this transaction won't have committed\n\t * either, and the block will never be written\n\t */\n\tif (search_all) {\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tPROC_INFO_INC(sb, journal.in_journal_bitmap);\n\t\t\tjb = journal->j_list_bitmap + i;\n\t\t\tif (jb->journal_list && jb->bitmaps[bmap_nr] &&\n\t\t\t    test_bit(bit_nr,\n\t\t\t\t     (unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data)) {\n\t\t\t\t*next_zero_bit =\n\t\t\t\t    find_next_zero_bit((unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata),\n\t\t\t\t\t\t       sb->s_blocksize << 3,\n\t\t\t\t\t\t       bit_nr + 1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\n\t/* is it in any old transactions? */\n\tif (search_all\n\t    && (cn =\n\t\tget_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\n\t\treturn 1;\n\t}\n\n\t/* is it in the current transaction.  This should never happen */\n\tif ((cn = get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tPROC_INFO_INC(sb, journal.in_journal_reusable);\n\t/* safe for reuse */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_in_journal(struct super_block *sb,\n\t\t\tunsigned int bmap_nr, int bit_nr, int search_all,\n\t\t\tb_blocknr_t * next_zero_bit)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_list_bitmap *jb;\n\tint i;\n\tunsigned long bl;\n\n\t*next_zero_bit = 0;\t/* always start this at zero. */\n\n\tPROC_INFO_INC(sb, journal.in_journal);\n\t/*\n\t * If we aren't doing a search_all, this is a metablock, and it\n\t * will be logged before use.  if we crash before the transaction\n\t * that freed it commits,  this transaction won't have committed\n\t * either, and the block will never be written\n\t */\n\tif (search_all) {\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tPROC_INFO_INC(sb, journal.in_journal_bitmap);\n\t\t\tjb = journal->j_list_bitmap + i;\n\t\t\tif (jb->journal_list && jb->bitmaps[bmap_nr] &&\n\t\t\t    test_bit(bit_nr,\n\t\t\t\t     (unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data)) {\n\t\t\t\t*next_zero_bit =\n\t\t\t\t    find_next_zero_bit((unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata),\n\t\t\t\t\t\t       sb->s_blocksize << 3,\n\t\t\t\t\t\t       bit_nr + 1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\n\t/* is it in any old transactions? */\n\tif (search_all\n\t    && (cn =\n\t\tget_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\n\t\treturn 1;\n\t}\n\n\t/* is it in the current transaction.  This should never happen */\n\tif ((cn = get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tPROC_INFO_INC(sb, journal.in_journal_reusable);\n\t/* safe for reuse */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline int is_block_in_journal(struct super_block *s, unsigned int bmap,\n\t\t\t\t      int off, int *next)\n{\n\tb_blocknr_t tmp;\n\n\tif (reiserfs_in_journal(s, bmap, off, 1, &tmp)) {\n\t\tif (tmp) {\t/* hint supplied */\n\t\t\t*next = tmp;\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_hint);\n\t\t} else {\n\t\t\t(*next) = off + 1;  /* inc offset to avoid looping. */\n\t\t\tPROC_INFO_INC(s, scan_bitmap.in_journal_nohint);\n\t\t}\n\t\tPROC_INFO_INC(s, scan_bitmap.retry);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "is_reusable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "62-113",
    "snippet": "int is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "s",
            "\"vs-4050\"",
            "\"this is root block (%u), \"\n\t\t\t       \"it must be busy\"",
            "SB_ROOT_BLOCK(s)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "s"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ROOT_BLOCK",
          "args": [
            "s"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "REISERFS_OLD_FORMAT",
            "&REISERFS_SB(s)->s_properties"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bit_address",
          "args": [
            "s",
            "block",
            "&bmap",
            "&offset"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "get_bit_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "48-60",
          "snippet": "static inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "s"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "s"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_bit_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
    "lines": "48-60",
    "snippet": "static inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}",
    "includes": [
      "#include <linux/seq_file.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nstatic inline void get_bit_address(struct super_block *s,\n\t\t\t\t   b_blocknr_t block,\n\t\t\t\t   unsigned int *bmap_nr,\n\t\t\t\t   unsigned int *offset)\n{\n\t/*\n\t * It is in the bitmap block number equal to the block\n\t * number divided by the number of bits in a block.\n\t */\n\t*bmap_nr = block >> (s->s_blocksize_bits + 3);\n\t/* Within that bitmap block it is located at bit offset *offset. */\n\t*offset = block & ((s->s_blocksize << 3) - 1);\n}"
  }
]