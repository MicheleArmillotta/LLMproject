[
  {
    "function_name": "gfs2_quota_lock_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
    "lines": "40-55",
    "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/list_lru.h>"
    ],
    "macros_used": [
      "#define NO_GID_QUOTA_CHANGE INVALID_GID",
      "#define NO_UID_QUOTA_CHANGE INVALID_UID"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_check",
          "args": [
            "ip",
            "ip->i_inode.i_uid",
            "ip->i_inode.i_gid"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1097-1143",
          "snippet": "int gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nint gfs2_quota_check(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\ts64 value;\n\tunsigned int x;\n\tint error = 0;\n\n\tif (!test_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\treturn 0;\n\n        if (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n                return 0;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\n\t\tif (!(qid_eq(qd->qd_id, make_kqid_uid(uid)) ||\n\t\t      qid_eq(qd->qd_id, make_kqid_gid(gid))))\n\t\t\tcontinue;\n\n\t\tvalue = (s64)be64_to_cpu(qd->qd_qb.qb_value);\n\t\tspin_lock(&qd_lock);\n\t\tvalue += qd->qd_change;\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (be64_to_cpu(qd->qd_qb.qb_limit) && (s64)be64_to_cpu(qd->qd_qb.qb_limit) < value) {\n\t\t\tprint_message(qd, \"exceeded\");\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BHARDWARN);\n\n\t\t\terror = -EDQUOT;\n\t\t\tbreak;\n\t\t} else if (be64_to_cpu(qd->qd_qb.qb_warn) &&\n\t\t\t   (s64)be64_to_cpu(qd->qd_qb.qb_warn) < value &&\n\t\t\t   time_after_eq(jiffies, qd->qd_last_warn +\n\t\t\t\t\t gfs2_tune_get(sdp,\n\t\t\t\t\t\tgt_quota_warn_period) * HZ)) {\n\t\t\tquota_send_warning(qd->qd_id,\n\t\t\t\t\t   sdp->sd_vfs->s_dev, QUOTA_NL_BSOFTWARN);\n\t\t\terror = print_message(qd, \"warning\");\n\t\t\tqd->qd_last_warn = jiffies;\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock",
          "args": [
            "ip",
            "NO_UID_QUOTA_CHANGE",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "958-995",
          "snippet": "int gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_lock(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qd;\n\tunsigned int x;\n\tint error = 0;\n\n\terror = gfs2_quota_hold(ip, uid, gid);\n\tif (error)\n\t\treturn error;\n\n\tif (capable(CAP_SYS_RESOURCE) ||\n\t    sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\n\tsort(ip->i_res->rs_qa_qd, ip->i_res->rs_qa_qd_num,\n\t     sizeof(struct gfs2_quota_data *), sort_qd, NULL);\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tint force = NO_FORCE;\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tif (test_and_clear_bit(QDF_REFRESH, &qd->qd_flags))\n\t\t\tforce = FORCE;\n\t\terror = do_glock(qd, force, &ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\tif (!error)\n\t\tset_bit(GIF_QD_LOCKED, &ip->i_flags);\n\telse {\n\t\twhile (x--)\n\t\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tgfs2_quota_unhold(ip);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
  }
]