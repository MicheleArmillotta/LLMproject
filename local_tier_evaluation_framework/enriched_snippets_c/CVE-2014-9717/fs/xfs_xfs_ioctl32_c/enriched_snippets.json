[
  {
    "function_name": "xfs_file_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "525-680",
    "snippet": "long\nxfs_file_compat_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_compat_ioctl(ip);\n\n\tswitch (cmd) {\n\t/* No size or alignment issues on any arch */\n\tcase XFS_IOC_DIOINFO:\n\tcase XFS_IOC_FSGEOMETRY:\n\tcase XFS_IOC_FSGETXATTR:\n\tcase XFS_IOC_FSSETXATTR:\n\tcase XFS_IOC_FSGETXATTRA:\n\tcase XFS_IOC_FSSETDM:\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\tcase XFS_IOC_GETBMAPX:\n\tcase XFS_IOC_FSCOUNTS:\n\tcase XFS_IOC_SET_RESBLKS:\n\tcase XFS_IOC_GET_RESBLKS:\n\tcase XFS_IOC_FSGROWFSLOG:\n\tcase XFS_IOC_GOINGDOWN:\n\tcase XFS_IOC_ERROR_INJECTION:\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n#ifndef BROKEN_X86_ALIGNMENT\n\t/* These are handled fine if no alignment issues */\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\tcase XFS_IOC_FSGROWFSDATA:\n\tcase XFS_IOC_FSGROWFSRT:\n\tcase XFS_IOC_ZERO_RANGE:\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n#else\n\tcase XFS_IOC_ALLOCSP_32:\n\tcase XFS_IOC_FREESP_32:\n\tcase XFS_IOC_ALLOCSP64_32:\n\tcase XFS_IOC_FREESP64_32:\n\tcase XFS_IOC_RESVSP_32:\n\tcase XFS_IOC_UNRESVSP_32:\n\tcase XFS_IOC_RESVSP64_32:\n\tcase XFS_IOC_UNRESVSP64_32:\n\tcase XFS_IOC_ZERO_RANGE_32: {\n\t\tstruct xfs_flock64\tbf;\n\n\t\tif (xfs_compat_flock64_copyin(&bf, arg))\n\t\t\treturn -EFAULT;\n\t\tcmd = _NATIVE_IOC(cmd, struct xfs_flock64);\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_FSGEOMETRY_V1_32:\n\t\treturn xfs_compat_ioc_fsgeometry_v1(mp, arg);\n\tcase XFS_IOC_FSGROWFSDATA_32: {\n\t\tstruct xfs_growfs_data\tin;\n\n\t\tif (xfs_compat_growfs_data_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSGROWFSRT_32: {\n\t\tstruct xfs_growfs_rt\tin;\n\n\t\tif (xfs_compat_growfs_rt_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n#endif\n\t/* long changes size, but xfs only copiese out 32 bits */\n\tcase XFS_IOC_GETXFLAGS_32:\n\tcase XFS_IOC_SETXFLAGS_32:\n\tcase XFS_IOC_GETVERSION_32:\n\t\tcmd = _NATIVE_IOC(cmd, long);\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n\tcase XFS_IOC_SWAPEXT_32: {\n\t\tstruct xfs_swapext\t  sxp;\n\t\tstruct compat_xfs_swapext __user *sxu = arg;\n\n\t\t/* Bulk copy in up to the sx_stat field, then copy bstat */\n\t\tif (copy_from_user(&sxp, sxu,\n\t\t\t\t   offsetof(struct xfs_swapext, sx_stat)) ||\n\t\t    xfs_ioctl32_bstat_copyin(&sxp.sx_stat, &sxu->sx_stat))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSBULKSTAT_32:\n\tcase XFS_IOC_FSBULKSTAT_SINGLE_32:\n\tcase XFS_IOC_FSINUMBERS_32:\n\t\treturn xfs_compat_ioc_bulkstat(mp, cmd, arg);\n\tcase XFS_IOC_FD_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_FSHANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\tcmd = _NATIVE_IOC(cmd, struct xfs_fsop_handlereq);\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_READLINK_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE_32:\n\t\treturn xfs_compat_attrlist_by_handle(filp, arg);\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE_32:\n\t\treturn xfs_compat_attrmulti_by_handle(filp, arg);\n\tcase XFS_IOC_FSSETDM_BY_HANDLE_32:\n\t\treturn xfs_compat_fssetdm_by_handle(filp, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_compat_fssetdm_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_fssetdm_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "487-523",
          "snippet": "STATIC int\nxfs_compat_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\tcompat_xfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, compat_ptr(dmhreq.data), sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\tcompat_xfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, compat_ptr(dmhreq.data), sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_attrmulti_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_attrmulti_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "393-485",
          "snippet": "STATIC int\nxfs_compat_attrmulti_by_handle(\n\tstruct file\t\t\t\t*parfilp,\n\tvoid\t\t\t\t\t__user *arg)\n{\n\tint\t\t\t\t\terror;\n\tcompat_xfs_attr_multiop_t\t\t*ops;\n\tcompat_xfs_fsop_attrmulti_handlereq_t\tam_hreq;\n\tstruct dentry\t\t\t\t*dentry;\n\tunsigned int\t\t\t\ti, size;\n\tunsigned char\t\t\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(compat_ptr(am_hreq.ops), size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tcompat_ptr(ops[i].am_attrname),\n\t\t\t\tMAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\tops[i].am_length, ops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_attrmulti_by_handle(\n\tstruct file\t\t\t\t*parfilp,\n\tvoid\t\t\t\t\t__user *arg)\n{\n\tint\t\t\t\t\terror;\n\tcompat_xfs_attr_multiop_t\t\t*ops;\n\tcompat_xfs_fsop_attrmulti_handlereq_t\tam_hreq;\n\tstruct dentry\t\t\t\t*dentry;\n\tunsigned int\t\t\t\ti, size;\n\tunsigned char\t\t\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(compat_ptr(am_hreq.ops), size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tcompat_ptr(ops[i].am_attrname),\n\t\t\t\tMAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\tops[i].am_length, ops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_attrlist_by_handle",
          "args": [
            "filp",
            "arg"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_attrlist_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "342-391",
          "snippet": "STATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readlink_by_handle",
          "args": [
            "filp",
            "&hreq"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readlink_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "272-318",
          "snippet": "int\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_readlink_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tstruct dentry\t\t*dentry;\n\t__u32\t\t\tolen;\n\tvoid\t\t\t*link;\n\tint\t\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\t/* Restrict this handle operation to symlinks only. */\n\tif (!d_is_symlink(dentry)) {\n\t\terror = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tif (copy_from_user(&olen, hreq->ohandlen, sizeof(__u32))) {\n\t\terror = -EFAULT;\n\t\tgoto out_dput;\n\t}\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link) {\n\t\terror = -ENOMEM;\n\t\tgoto out_dput;\n\t}\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (error)\n\t\tgoto out_kfree;\n\terror = readlink_copy(hreq->ohandle, olen, link);\n\tif (error)\n\t\tgoto out_kfree;\n\n out_kfree:\n\tkfree(link);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_handlereq_copyin",
          "args": [
            "&hreq",
            "arg"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_handlereq_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "312-331",
          "snippet": "STATIC int\nxfs_compat_handlereq_copyin(\n\txfs_fsop_handlereq_t\t\t*hreq,\n\tcompat_xfs_fsop_handlereq_t\t__user *arg32)\n{\n\tcompat_xfs_fsop_handlereq_t\threq32;\n\n\tif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\n\t\treturn -EFAULT;\n\n\threq->fd = hreq32.fd;\n\threq->path = compat_ptr(hreq32.path);\n\threq->oflags = hreq32.oflags;\n\threq->ihandle = compat_ptr(hreq32.ihandle);\n\threq->ihandlen = hreq32.ihandlen;\n\threq->ohandle = compat_ptr(hreq32.ohandle);\n\threq->ohandlen = compat_ptr(hreq32.ohandlen);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_compat_handlereq_copyin(\n\txfs_fsop_handlereq_t\t\t*hreq,\n\tcompat_xfs_fsop_handlereq_t\t__user *arg32)\n{\n\tcompat_xfs_fsop_handlereq_t\threq32;\n\n\tif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\n\t\treturn -EFAULT;\n\n\threq->fd = hreq32.fd;\n\threq->path = compat_ptr(hreq32.path);\n\threq->oflags = hreq32.oflags;\n\threq->ihandle = compat_ptr(hreq32.ihandle);\n\threq->ihandlen = hreq32.ihandlen;\n\threq->ohandle = compat_ptr(hreq32.ohandle);\n\threq->ohandlen = compat_ptr(hreq32.ohandlen);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_open_by_handle",
          "args": [
            "filp",
            "&hreq"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_open_by_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "192-270",
          "snippet": "int\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_open_by_handle(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tconst struct cred\t*cred = current_cred();\n\tint\t\t\terror;\n\tint\t\t\tfd;\n\tint\t\t\tpermflag;\n\tstruct file\t\t*filp;\n\tstruct inode\t\t*inode;\n\tstruct dentry\t\t*dentry;\n\tfmode_t\t\t\tfmode;\n\tstruct path\t\tpath;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdentry = xfs_handlereq_to_dentry(parfilp, hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tinode = dentry->d_inode;\n\n\t/* Restrict xfs_open_by_handle to directories & regular files. */\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n#if BITS_PER_LONG != 32\n\threq->oflags |= O_LARGEFILE;\n#endif\n\n\tpermflag = hreq->oflags;\n\tfmode = OPEN_FMODE(permflag);\n\tif ((!(permflag & O_APPEND) || (permflag & O_TRUNC)) &&\n\t    (fmode & FMODE_WRITE) && IS_APPEND(inode)) {\n\t\terror = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\tif ((fmode & FMODE_WRITE) && IS_IMMUTABLE(inode)) {\n\t\terror = -EACCES;\n\t\tgoto out_dput;\n\t}\n\n\t/* Can't write directories. */\n\tif (S_ISDIR(inode->i_mode) && (fmode & FMODE_WRITE)) {\n\t\terror = -EISDIR;\n\t\tgoto out_dput;\n\t}\n\n\tfd = get_unused_fd_flags(0);\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_dput;\n\t}\n\n\tpath.mnt = parfilp->f_path.mnt;\n\tpath.dentry = dentry;\n\tfilp = dentry_open(&path, hreq->oflags, cred);\n\tdput(dentry);\n\tif (IS_ERR(filp)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tfilp->f_flags |= O_NOATIME;\n\t\tfilp->f_mode |= FMODE_NOCMTIME;\n\t}\n\n\tfd_install(fd, filp);\n\treturn fd;\n\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_find_handle",
          "args": [
            "cmd",
            "&hreq"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_find_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "63-135",
          "snippet": "int\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_find_handle(\n\tunsigned int\t\tcmd,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\tint\t\t\thsize;\n\txfs_handle_t\t\thandle;\n\tstruct inode\t\t*inode;\n\tstruct fd\t\tf = {NULL};\n\tstruct path\t\tpath;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*ip;\n\n\tif (cmd == XFS_IOC_FD_TO_HANDLE) {\n\t\tf = fdget(hreq->fd);\n\t\tif (!f.file)\n\t\t\treturn -EBADF;\n\t\tinode = file_inode(f.file);\n\t} else {\n\t\terror = user_lpath((const char __user *)hreq->path, &path);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinode = path.dentry->d_inode;\n\t}\n\tip = XFS_I(inode);\n\n\t/*\n\t * We can only generate handles for inodes residing on a XFS filesystem,\n\t * and only for regular files, directories or symbolic links.\n\t */\n\terror = -EINVAL;\n\tif (inode->i_sb->s_magic != XFS_SB_MAGIC)\n\t\tgoto out_put;\n\n\terror = -EBADF;\n\tif (!S_ISREG(inode->i_mode) &&\n\t    !S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode))\n\t\tgoto out_put;\n\n\n\tmemcpy(&handle.ha_fsid, ip->i_mount->m_fixedfsid, sizeof(xfs_fsid_t));\n\n\tif (cmd == XFS_IOC_PATH_TO_FSHANDLE) {\n\t\t/*\n\t\t * This handle only contains an fsid, zero the rest.\n\t\t */\n\t\tmemset(&handle.ha_fid, 0, sizeof(handle.ha_fid));\n\t\thsize = sizeof(xfs_fsid_t);\n\t} else {\n\t\thandle.ha_fid.fid_len = sizeof(xfs_fid_t) -\n\t\t\t\t\tsizeof(handle.ha_fid.fid_len);\n\t\thandle.ha_fid.fid_pad = 0;\n\t\thandle.ha_fid.fid_gen = ip->i_d.di_gen;\n\t\thandle.ha_fid.fid_ino = ip->i_ino;\n\n\t\thsize = XFS_HSIZE(handle);\n\t}\n\n\terror = -EFAULT;\n\tif (copy_to_user(hreq->ohandle, &handle, hsize) ||\n\t    copy_to_user(hreq->ohandlen, &hsize, sizeof(__s32)))\n\t\tgoto out_put;\n\n\terror = 0;\n\n out_put:\n\tif (cmd == XFS_IOC_FD_TO_HANDLE)\n\t\tfdput(f);\n\telse\n\t\tpath_put(&path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_NATIVE_IOC",
          "args": [
            "cmd",
            "structxfs_fsop_handlereq"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_compat_ioc_bulkstat",
          "args": [
            "mp",
            "cmd",
            "arg"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_ioc_bulkstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "241-310",
          "snippet": "STATIC int\nxfs_compat_ioc_bulkstat(\n\txfs_mount_t\t\t  *mp,\n\tunsigned int\t\t  cmd,\n\tcompat_xfs_fsop_bulkreq_t __user *p32)\n{\n\tu32\t\t\taddr;\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (get_user(addr, &p32->lastip))\n\t\treturn -EFAULT;\n\tbulkreq.lastip = compat_ptr(addr);\n\tif (get_user(bulkreq.icount, &p32->icount) ||\n\t    get_user(addr, &p32->ubuffer))\n\t\treturn -EFAULT;\n\tbulkreq.ubuffer = compat_ptr(addr);\n\tif (get_user(addr, &p32->ocount))\n\t\treturn -EFAULT;\n\tbulkreq.ocount = compat_ptr(addr);\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS_32) {\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt_compat);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\n\t\tint res;\n\n\t\terror = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,\n\t\t\t\tsizeof(compat_xfs_bstat_t), NULL, &res);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\n\t\terror = xfs_bulkstat(mp, &inlast, &count,\n\t\t\txfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),\n\t\t\tbulkreq.ubuffer, &done);\n\t} else\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [
            "#define xfs_inumbers_fmt_compat xfs_inumbers_fmt"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\n#define xfs_inumbers_fmt_compat xfs_inumbers_fmt\n\nSTATIC int\nxfs_compat_ioc_bulkstat(\n\txfs_mount_t\t\t  *mp,\n\tunsigned int\t\t  cmd,\n\tcompat_xfs_fsop_bulkreq_t __user *p32)\n{\n\tu32\t\t\taddr;\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (get_user(addr, &p32->lastip))\n\t\treturn -EFAULT;\n\tbulkreq.lastip = compat_ptr(addr);\n\tif (get_user(bulkreq.icount, &p32->icount) ||\n\t    get_user(addr, &p32->ubuffer))\n\t\treturn -EFAULT;\n\tbulkreq.ubuffer = compat_ptr(addr);\n\tif (get_user(addr, &p32->ocount))\n\t\treturn -EFAULT;\n\tbulkreq.ocount = compat_ptr(addr);\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS_32) {\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt_compat);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\n\t\tint res;\n\n\t\terror = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,\n\t\t\t\tsizeof(compat_xfs_bstat_t), NULL, &res);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\n\t\terror = xfs_bulkstat(mp, &inlast, &count,\n\t\t\txfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),\n\t\t\tbulkreq.ubuffer, &done);\n\t} else\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_swapext",
          "args": [
            "&sxp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_swapext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1433-1500",
          "snippet": "int\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_swapext(\n\txfs_swapext_t\t*sxp)\n{\n\txfs_inode_t     *ip, *tip;\n\tstruct fd\tf, tmp;\n\tint\t\terror = 0;\n\n\t/* Pull information for the target fd */\n\tf = fdget((int)sxp->sx_fdtarget);\n\tif (!f.file) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(f.file->f_mode & FMODE_WRITE) ||\n\t    !(f.file->f_mode & FMODE_READ) ||\n\t    (f.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_file;\n\t}\n\n\ttmp = fdget((int)sxp->sx_fdtmp);\n\tif (!tmp.file) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_file;\n\t}\n\n\tif (!(tmp.file->f_mode & FMODE_WRITE) ||\n\t    !(tmp.file->f_mode & FMODE_READ) ||\n\t    (tmp.file->f_flags & O_APPEND)) {\n\t\terror = -EBADF;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (IS_SWAPFILE(file_inode(f.file)) ||\n\t    IS_SWAPFILE(file_inode(tmp.file))) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tip = XFS_I(file_inode(f.file));\n\ttip = XFS_I(file_inode(tmp.file));\n\n\tif (ip->i_mount != tip->i_mount) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (ip->i_ino == tip->i_ino) {\n\t\terror = -EINVAL;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\terror = -EIO;\n\t\tgoto out_put_tmp_file;\n\t}\n\n\terror = xfs_swap_extents(ip, tip, sxp);\n\n out_put_tmp_file:\n\tfdput(tmp);\n out_put_file:\n\tfdput(f);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl32_bstat_copyin",
          "args": [
            "&sxp.sx_stat",
            "&sxu->sx_stat"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl32_bstat_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "138-167",
          "snippet": "STATIC int\nxfs_ioctl32_bstat_copyin(\n\txfs_bstat_t\t\t*bstat,\n\tcompat_xfs_bstat_t\t__user *bstat32)\n{\n\tif (get_user(bstat->bs_ino,\t&bstat32->bs_ino)\t||\n\t    get_user(bstat->bs_mode,\t&bstat32->bs_mode)\t||\n\t    get_user(bstat->bs_nlink,\t&bstat32->bs_nlink)\t||\n\t    get_user(bstat->bs_uid,\t&bstat32->bs_uid)\t||\n\t    get_user(bstat->bs_gid,\t&bstat32->bs_gid)\t||\n\t    get_user(bstat->bs_rdev,\t&bstat32->bs_rdev)\t||\n\t    get_user(bstat->bs_blksize,\t&bstat32->bs_blksize)\t||\n\t    get_user(bstat->bs_size,\t&bstat32->bs_size)\t||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\n\t    get_user(bstat->bs_blocks,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_xflags,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_extsize,\t&bstat32->bs_extsize)\t||\n\t    get_user(bstat->bs_extents,\t&bstat32->bs_extents)\t||\n\t    get_user(bstat->bs_gen,\t&bstat32->bs_gen)\t||\n\t    get_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\n\t    get_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\n\t    get_user(bstat->bs_forkoff,\t&bstat32->bs_forkoff)\t||\n\t    get_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask)\t||\n\t    get_user(bstat->bs_dmstate,\t&bstat32->bs_dmstate)\t||\n\t    get_user(bstat->bs_aextents, &bstat32->bs_aextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_ioctl32_bstat_copyin(\n\txfs_bstat_t\t\t*bstat,\n\tcompat_xfs_bstat_t\t__user *bstat32)\n{\n\tif (get_user(bstat->bs_ino,\t&bstat32->bs_ino)\t||\n\t    get_user(bstat->bs_mode,\t&bstat32->bs_mode)\t||\n\t    get_user(bstat->bs_nlink,\t&bstat32->bs_nlink)\t||\n\t    get_user(bstat->bs_uid,\t&bstat32->bs_uid)\t||\n\t    get_user(bstat->bs_gid,\t&bstat32->bs_gid)\t||\n\t    get_user(bstat->bs_rdev,\t&bstat32->bs_rdev)\t||\n\t    get_user(bstat->bs_blksize,\t&bstat32->bs_blksize)\t||\n\t    get_user(bstat->bs_size,\t&bstat32->bs_size)\t||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\n\t    get_user(bstat->bs_blocks,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_xflags,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_extsize,\t&bstat32->bs_extsize)\t||\n\t    get_user(bstat->bs_extents,\t&bstat32->bs_extents)\t||\n\t    get_user(bstat->bs_gen,\t&bstat32->bs_gen)\t||\n\t    get_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\n\t    get_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\n\t    get_user(bstat->bs_forkoff,\t&bstat32->bs_forkoff)\t||\n\t    get_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask)\t||\n\t    get_user(bstat->bs_dmstate,\t&bstat32->bs_dmstate)\t||\n\t    get_user(bstat->bs_aextents, &bstat32->bs_aextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&sxp",
            "sxu",
            "offsetof(struct xfs_swapext, sx_stat)"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_file_ioctl",
          "args": [
            "filp",
            "cmd",
            "p"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_file_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "1508-1803",
          "snippet": "long\nxfs_file_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned int\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_ioctl(ip);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn xfs_ioc_trim(mp, arg);\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_ZERO_RANGE: {\n\t\txfs_flock64_t\t\tbf;\n\n\t\tif (copy_from_user(&bf, arg, sizeof(bf)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_DIOINFO: {\n\t\tstruct dioattr\tda;\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t\tda.d_mem =  da.d_miniosz = target->bt_logical_sectorsize;\n\t\tda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\n\n\t\tif (copy_to_user(arg, &da, sizeof(da)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSBULKSTAT_SINGLE:\n\tcase XFS_IOC_FSBULKSTAT:\n\tcase XFS_IOC_FSINUMBERS:\n\t\treturn xfs_ioc_bulkstat(mp, cmd, arg);\n\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\t\treturn xfs_ioc_fsgeometry_v1(mp, arg);\n\n\tcase XFS_IOC_FSGEOMETRY:\n\t\treturn xfs_ioc_fsgeometry(mp, arg);\n\n\tcase XFS_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *)arg);\n\n\tcase XFS_IOC_FSGETXATTR:\n\t\treturn xfs_ioc_fsgetxattr(ip, 0, arg);\n\tcase XFS_IOC_FSGETXATTRA:\n\t\treturn xfs_ioc_fsgetxattr(ip, 1, arg);\n\tcase XFS_IOC_FSSETXATTR:\n\t\treturn xfs_ioc_fssetxattr(ip, filp, arg);\n\tcase XFS_IOC_GETXFLAGS:\n\t\treturn xfs_ioc_getxflags(ip, arg);\n\tcase XFS_IOC_SETXFLAGS:\n\t\treturn xfs_ioc_setxflags(ip, filp, arg);\n\n\tcase XFS_IOC_FSSETDM: {\n\t\tstruct fsdmidata\tdmi;\n\n\t\tif (copy_from_user(&dmi, arg, sizeof(dmi)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_set_dmattrs(ip, dmi.fsd_dmevmask,\n\t\t\t\tdmi.fsd_dmstate);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\t\treturn xfs_ioc_getbmap(ip, ioflags, cmd, arg);\n\n\tcase XFS_IOC_GETBMAPX:\n\t\treturn xfs_ioc_getbmapx(ip, arg);\n\n\tcase XFS_IOC_FD_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_FSHANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(hreq)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_FSSETDM_BY_HANDLE:\n\t\treturn xfs_fssetdm_by_handle(filp, arg);\n\n\tcase XFS_IOC_READLINK_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE:\n\t\treturn xfs_attrlist_by_handle(filp, arg);\n\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE:\n\t\treturn xfs_attrmulti_by_handle(filp, arg);\n\n\tcase XFS_IOC_SWAPEXT: {\n\t\tstruct xfs_swapext\tsxp;\n\n\t\tif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSCOUNTS: {\n\t\txfs_fsop_counts_t out;\n\n\t\terror = xfs_fs_counts(mp, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_SET_RESBLKS: {\n\t\txfs_fsop_resblks_t inout;\n\t\t__uint64_t\t   in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&inout, arg, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* input parameter is passed in resblks field of structure */\n\t\tin = inout.resblks;\n\t\terror = xfs_reserve_blocks(mp, &in, &inout);\n\t\tmnt_drop_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &inout, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_GET_RESBLKS: {\n\t\txfs_fsop_resblks_t out;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terror = xfs_reserve_blocks(mp, NULL, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSGROWFSDATA: {\n\t\txfs_growfs_data_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSLOG: {\n\t\txfs_growfs_log_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_log(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSRT: {\n\t\txfs_growfs_rt_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GOINGDOWN: {\n\t\t__uint32_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(in, (__uint32_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_fs_goingdown(mp, in);\n\t}\n\n\tcase XFS_IOC_ERROR_INJECTION: {\n\t\txfs_error_injection_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_errortag_add(in.errtag, mp);\n\t}\n\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn xfs_errortag_clearall(mp, 1);\n\n\tcase XFS_IOC_FREE_EOFBLOCKS: {\n\t\tstruct xfs_fs_eofblocks eofb;\n\t\tstruct xfs_eofblocks keofb;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&eofb, arg, sizeof(eofb)))\n\t\t\treturn -EFAULT;\n\n\t\terror = xfs_fs_eofblocks_from_user(&eofb, &keofb);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn xfs_icache_free_eofblocks(mp, &keofb);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nlong\nxfs_file_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned int\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_ioctl(ip);\n\n\tswitch (cmd) {\n\tcase FITRIM:\n\t\treturn xfs_ioc_trim(mp, arg);\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_ZERO_RANGE: {\n\t\txfs_flock64_t\t\tbf;\n\n\t\tif (copy_from_user(&bf, arg, sizeof(bf)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_DIOINFO: {\n\t\tstruct dioattr\tda;\n\t\txfs_buftarg_t\t*target =\n\t\t\tXFS_IS_REALTIME_INODE(ip) ?\n\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp;\n\n\t\tda.d_mem =  da.d_miniosz = target->bt_logical_sectorsize;\n\t\tda.d_maxiosz = INT_MAX & ~(da.d_miniosz - 1);\n\n\t\tif (copy_to_user(arg, &da, sizeof(da)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSBULKSTAT_SINGLE:\n\tcase XFS_IOC_FSBULKSTAT:\n\tcase XFS_IOC_FSINUMBERS:\n\t\treturn xfs_ioc_bulkstat(mp, cmd, arg);\n\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\t\treturn xfs_ioc_fsgeometry_v1(mp, arg);\n\n\tcase XFS_IOC_FSGEOMETRY:\n\t\treturn xfs_ioc_fsgeometry(mp, arg);\n\n\tcase XFS_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *)arg);\n\n\tcase XFS_IOC_FSGETXATTR:\n\t\treturn xfs_ioc_fsgetxattr(ip, 0, arg);\n\tcase XFS_IOC_FSGETXATTRA:\n\t\treturn xfs_ioc_fsgetxattr(ip, 1, arg);\n\tcase XFS_IOC_FSSETXATTR:\n\t\treturn xfs_ioc_fssetxattr(ip, filp, arg);\n\tcase XFS_IOC_GETXFLAGS:\n\t\treturn xfs_ioc_getxflags(ip, arg);\n\tcase XFS_IOC_SETXFLAGS:\n\t\treturn xfs_ioc_setxflags(ip, filp, arg);\n\n\tcase XFS_IOC_FSSETDM: {\n\t\tstruct fsdmidata\tdmi;\n\n\t\tif (copy_from_user(&dmi, arg, sizeof(dmi)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_set_dmattrs(ip, dmi.fsd_dmevmask,\n\t\t\t\tdmi.fsd_dmstate);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\t\treturn xfs_ioc_getbmap(ip, ioflags, cmd, arg);\n\n\tcase XFS_IOC_GETBMAPX:\n\t\treturn xfs_ioc_getbmapx(ip, arg);\n\n\tcase XFS_IOC_FD_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_HANDLE:\n\tcase XFS_IOC_PATH_TO_FSHANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(hreq)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_FSSETDM_BY_HANDLE:\n\t\treturn xfs_fssetdm_by_handle(filp, arg);\n\n\tcase XFS_IOC_READLINK_BY_HANDLE: {\n\t\txfs_fsop_handlereq_t\threq;\n\n\t\tif (copy_from_user(&hreq, arg, sizeof(xfs_fsop_handlereq_t)))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE:\n\t\treturn xfs_attrlist_by_handle(filp, arg);\n\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE:\n\t\treturn xfs_attrmulti_by_handle(filp, arg);\n\n\tcase XFS_IOC_SWAPEXT: {\n\t\tstruct xfs_swapext\tsxp;\n\n\t\tif (copy_from_user(&sxp, arg, sizeof(xfs_swapext_t)))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSCOUNTS: {\n\t\txfs_fsop_counts_t out;\n\n\t\terror = xfs_fs_counts(mp, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_SET_RESBLKS: {\n\t\txfs_fsop_resblks_t inout;\n\t\t__uint64_t\t   in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&inout, arg, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* input parameter is passed in resblks field of structure */\n\t\tin = inout.resblks;\n\t\terror = xfs_reserve_blocks(mp, &in, &inout);\n\t\tmnt_drop_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &inout, sizeof(inout)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_GET_RESBLKS: {\n\t\txfs_fsop_resblks_t out;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\terror = xfs_reserve_blocks(mp, NULL, &out);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (copy_to_user(arg, &out, sizeof(out)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase XFS_IOC_FSGROWFSDATA: {\n\t\txfs_growfs_data_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSLOG: {\n\t\txfs_growfs_log_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_log(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_FSGROWFSRT: {\n\t\txfs_growfs_rt_t in;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\n\tcase XFS_IOC_GOINGDOWN: {\n\t\t__uint32_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(in, (__uint32_t __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_fs_goingdown(mp, in);\n\t}\n\n\tcase XFS_IOC_ERROR_INJECTION: {\n\t\txfs_error_injection_t in;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&in, arg, sizeof(in)))\n\t\t\treturn -EFAULT;\n\n\t\treturn xfs_errortag_add(in.errtag, mp);\n\t}\n\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\treturn xfs_errortag_clearall(mp, 1);\n\n\tcase XFS_IOC_FREE_EOFBLOCKS: {\n\t\tstruct xfs_fs_eofblocks eofb;\n\t\tstruct xfs_eofblocks keofb;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (copy_from_user(&eofb, arg, sizeof(eofb)))\n\t\t\treturn -EFAULT;\n\n\t\terror = xfs_fs_eofblocks_from_user(&eofb, &keofb);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\treturn xfs_icache_free_eofblocks(mp, &keofb);\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_NATIVE_IOC",
          "args": [
            "cmd",
            "long"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_growfs_rt",
          "args": [
            "mp",
            "&in"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_rt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "884-1090",
          "snippet": "int\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_rt(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_growfs_rt_t\t*in)\t\t/* growfs rt input struct */\n{\n\txfs_rtblock_t\tbmbno;\t\t/* bitmap block number */\n\txfs_buf_t\t*bp;\t\t/* temporary buffer */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*nmp;\t\t/* new (fake) mount structure */\n\txfs_rfsblock_t\tnrblocks;\t/* new number of realtime blocks */\n\txfs_extlen_t\tnrbmblocks;\t/* new number of rt bitmap blocks */\n\txfs_rtblock_t\tnrextents;\t/* new number of realtime extents */\n\tuint8_t\t\tnrextslog;\t/* new log2 of sb_rextents */\n\txfs_extlen_t\tnrsumblocks;\t/* new number of summary blocks */\n\tuint\t\tnrsumlevels;\t/* new rt summary levels */\n\tuint\t\tnrsumsize;\t/* new size of rt summary, bytes */\n\txfs_sb_t\t*nsbp;\t\t/* new superblock */\n\txfs_extlen_t\trbmblocks;\t/* current number of rt bitmap blocks */\n\txfs_extlen_t\trsumblocks;\t/* current number of rt summary blks */\n\txfs_sb_t\t*sbp;\t\t/* old superblock */\n\txfs_fsblock_t\tsumbno;\t\t/* summary block number */\n\n\tsbp = &mp->m_sb;\n\t/*\n\t * Initial error checking.\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (mp->m_rtdev_targp == NULL || mp->m_rbmip == NULL ||\n\t    (nrblocks = in->newblocks) <= sbp->sb_rblocks ||\n\t    (sbp->sb_rblocks && (in->extsize != sbp->sb_rextsize)))\n\t\treturn -EINVAL;\n\tif ((error = xfs_sb_validate_fsb_count(sbp, nrblocks)))\n\t\treturn error;\n\t/*\n\t * Read in the last block of the device, make sure it exists.\n\t */\n\terror = xfs_buf_read_uncached(mp->m_rtdev_targp,\n\t\t\t\tXFS_FSB_TO_BB(mp, nrblocks - 1),\n\t\t\t\tXFS_FSB_TO_BB(mp, 1), 0, &bp, NULL);\n\tif (error)\n\t\treturn error;\n\txfs_buf_relse(bp);\n\n\t/*\n\t * Calculate new parameters.  These are the final values to be reached.\n\t */\n\tnrextents = nrblocks;\n\tdo_div(nrextents, in->extsize);\n\tnrbmblocks = howmany_64(nrextents, NBBY * sbp->sb_blocksize);\n\tnrextslog = xfs_highbit32(nrextents);\n\tnrsumlevels = nrextslog + 1;\n\tnrsumsize = (uint)sizeof(xfs_suminfo_t) * nrsumlevels * nrbmblocks;\n\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\tnrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t/*\n\t * New summary size can't be more than half the size of\n\t * the log.  This prevents us from getting a log overflow,\n\t * since we'll log basically the whole summary file at once.\n\t */\n\tif (nrsumblocks > (mp->m_sb.sb_logblocks >> 1))\n\t\treturn -EINVAL;\n\t/*\n\t * Get the old block counts for bitmap and summary inodes.\n\t * These can't change since other growfs callers are locked out.\n\t */\n\trbmblocks = XFS_B_TO_FSB(mp, mp->m_rbmip->i_d.di_size);\n\trsumblocks = XFS_B_TO_FSB(mp, mp->m_rsumip->i_d.di_size);\n\t/*\n\t * Allocate space to the bitmap and summary files, as necessary.\n\t */\n\terror = xfs_growfs_rt_alloc(mp, rbmblocks, nrbmblocks, mp->m_rbmip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_growfs_rt_alloc(mp, rsumblocks, nrsumblocks, mp->m_rsumip);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Allocate a new (fake) mount/sb.\n\t */\n\tnmp = kmem_alloc(sizeof(*nmp), KM_SLEEP);\n\t/*\n\t * Loop over the bitmap blocks.\n\t * We will do everything one bitmap block at a time.\n\t * Skip the current block if it is exactly full.\n\t * This also deals with the case where there were no rtextents before.\n\t */\n\tfor (bmbno = sbp->sb_rbmblocks -\n\t\t     ((sbp->sb_rextents & ((1 << mp->m_blkbit_log) - 1)) != 0);\n\t     bmbno < nrbmblocks;\n\t     bmbno++) {\n\t\txfs_trans_t\t*tp;\n\t\tint\t\tcancelflags = 0;\n\n\t\t*nmp = *mp;\n\t\tnsbp = &nmp->m_sb;\n\t\t/*\n\t\t * Calculate new sb and mount fields for this round.\n\t\t */\n\t\tnsbp->sb_rextsize = in->extsize;\n\t\tnsbp->sb_rbmblocks = bmbno + 1;\n\t\tnsbp->sb_rblocks =\n\t\t\tXFS_RTMIN(nrblocks,\n\t\t\t\t  nsbp->sb_rbmblocks * NBBY *\n\t\t\t\t  nsbp->sb_blocksize * nsbp->sb_rextsize);\n\t\tnsbp->sb_rextents = nsbp->sb_rblocks;\n\t\tdo_div(nsbp->sb_rextents, nsbp->sb_rextsize);\n\t\tASSERT(nsbp->sb_rextents != 0);\n\t\tnsbp->sb_rextslog = xfs_highbit32(nsbp->sb_rextents);\n\t\tnrsumlevels = nmp->m_rsumlevels = nsbp->sb_rextslog + 1;\n\t\tnrsumsize =\n\t\t\t(uint)sizeof(xfs_suminfo_t) * nrsumlevels *\n\t\t\tnsbp->sb_rbmblocks;\n\t\tnrsumblocks = XFS_B_TO_FSB(mp, nrsumsize);\n\t\tnmp->m_rsumsize = nrsumsize = XFS_FSB_TO_B(mp, nrsumblocks);\n\t\t/*\n\t\t * Start a transaction, get the log reservation.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_GROWFSRT_FREE);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_growrtfree,\n\t\t\t\t\t  0, 0);\n\t\tif (error)\n\t\t\tgoto error_cancel;\n\t\t/*\n\t\t * Lock out other callers by grabbing the bitmap inode lock.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the bitmap inode's size.\n\t\t */\n\t\tmp->m_rbmip->i_d.di_size =\n\t\t\tnsbp->sb_rbmblocks * nsbp->sb_blocksize;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\t/*\n\t\t * Get the summary inode into the transaction.\n\t\t */\n\t\txfs_ilock(mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rsumip, XFS_ILOCK_EXCL);\n\t\t/*\n\t\t * Update the summary inode's size.\n\t\t */\n\t\tmp->m_rsumip->i_d.di_size = nmp->m_rsumsize;\n\t\txfs_trans_log_inode(tp, mp->m_rsumip, XFS_ILOG_CORE);\n\t\t/*\n\t\t * Copy summary data from old to new sizes.\n\t\t * Do this when the real size (not block-aligned) changes.\n\t\t */\n\t\tif (sbp->sb_rbmblocks != nsbp->sb_rbmblocks ||\n\t\t    mp->m_rsumlevels != nmp->m_rsumlevels) {\n\t\t\terror = xfs_rtcopy_summary(mp, nmp, tp);\n\t\t\tif (error)\n\t\t\t\tgoto error_cancel;\n\t\t}\n\t\t/*\n\t\t * Update superblock fields.\n\t\t */\n\t\tif (nsbp->sb_rextsize != sbp->sb_rextsize)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSIZE,\n\t\t\t\tnsbp->sb_rextsize - sbp->sb_rextsize);\n\t\tif (nsbp->sb_rbmblocks != sbp->sb_rbmblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBMBLOCKS,\n\t\t\t\tnsbp->sb_rbmblocks - sbp->sb_rbmblocks);\n\t\tif (nsbp->sb_rblocks != sbp->sb_rblocks)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RBLOCKS,\n\t\t\t\tnsbp->sb_rblocks - sbp->sb_rblocks);\n\t\tif (nsbp->sb_rextents != sbp->sb_rextents)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTENTS,\n\t\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\tif (nsbp->sb_rextslog != sbp->sb_rextslog)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_REXTSLOG,\n\t\t\t\tnsbp->sb_rextslog - sbp->sb_rextslog);\n\t\t/*\n\t\t * Free new extent.\n\t\t */\n\t\tbp = NULL;\n\t\terror = xfs_rtfree_range(nmp, tp, sbp->sb_rextents,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents, &bp, &sumbno);\n\t\tif (error) {\nerror_cancel:\n\t\t\txfs_trans_cancel(tp, cancelflags);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Mark more blocks free in the superblock.\n\t\t */\n\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS,\n\t\t\tnsbp->sb_rextents - sbp->sb_rextents);\n\t\t/*\n\t\t * Update mp values into the real mp structure.\n\t\t */\n\t\tmp->m_rsumlevels = nrsumlevels;\n\t\tmp->m_rsumsize = nrsumsize;\n\n\t\terror = xfs_trans_commit(tp, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Free the fake mp structure.\n\t */\n\tkmem_free(nmp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_growfs_rt_copyin",
          "args": [
            "&in",
            "arg"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_growfs_rt_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "88-97",
          "snippet": "STATIC int\nxfs_compat_growfs_rt_copyin(\n\tstruct xfs_growfs_rt\t *in,\n\tcompat_xfs_growfs_rt_t\t__user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->extsize,   &arg32->extsize))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_growfs_rt_copyin(\n\tstruct xfs_growfs_rt\t *in,\n\tcompat_xfs_growfs_rt_t\t__user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->extsize,   &arg32->extsize))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_growfs_data",
          "args": [
            "mp",
            "&in"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_growfs_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "593-613",
          "snippet": "int\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_growfs_data(\n\txfs_mount_t\t\t*mp,\n\txfs_growfs_data_t\t*in)\n{\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!mutex_trylock(&mp->m_growlock))\n\t\treturn -EWOULDBLOCK;\n\terror = xfs_growfs_data_private(mp, in);\n\t/*\n\t * Increment the generation unconditionally, the error could be from\n\t * updating the secondary superblocks, in which case the new size\n\t * is live already.\n\t */\n\tmp->m_generation++;\n\tmutex_unlock(&mp->m_growlock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_growfs_data_copyin",
          "args": [
            "&in",
            "arg"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_growfs_data_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "77-86",
          "snippet": "STATIC int\nxfs_compat_growfs_data_copyin(\n\tstruct xfs_growfs_data\t *in,\n\tcompat_xfs_growfs_data_t __user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->imaxpct,   &arg32->imaxpct))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_growfs_data_copyin(\n\tstruct xfs_growfs_data\t *in,\n\tcompat_xfs_growfs_data_t __user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->imaxpct,   &arg32->imaxpct))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_compat_ioc_fsgeometry_v1",
          "args": [
            "mp",
            "arg"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_ioc_fsgeometry_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "60-75",
          "snippet": "STATIC int\nxfs_compat_ioc_fsgeometry_v1(\n\tstruct xfs_mount\t  *mp,\n\tcompat_xfs_fsop_geom_v1_t __user *arg32)\n{\n\txfs_fsop_geom_t\t\t  fsgeo;\n\tint\t\t\t  error;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\t/* The 32-bit variant simply has some padding at the end */\n\tif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_ioc_fsgeometry_v1(\n\tstruct xfs_mount\t  *mp,\n\tcompat_xfs_fsop_geom_v1_t __user *arg32)\n{\n\txfs_fsop_geom_t\t\t  fsgeo;\n\tint\t\t\t  error;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\t/* The 32-bit variant simply has some padding at the end */\n\tif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioc_space",
          "args": [
            "ip",
            "inode",
            "filp",
            "ioflags",
            "cmd",
            "&bf"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioc_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "601-736",
          "snippet": "int\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_ioc_space(\n\tstruct xfs_inode\t*ip,\n\tstruct inode\t\t*inode,\n\tstruct file\t\t*filp,\n\tint\t\t\tioflags,\n\tunsigned int\t\tcmd,\n\txfs_flock64_t\t\t*bf)\n{\n\tstruct iattr\t\tiattr;\n\tenum xfs_prealloc_flags\tflags = 0;\n\tuint\t\t\tiolock = XFS_IOLOCK_EXCL;\n\tint\t\t\terror;\n\n\t/*\n\t * Only allow the sys admin to reserve space unless\n\t * unwritten extents are enabled.\n\t */\n\tif (!xfs_sb_version_hasextflgbit(&ip->i_mount->m_sb) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND))\n\t\treturn -EPERM;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (filp->f_flags & O_DSYNC)\n\t\tflags |= XFS_PREALLOC_SYNC;\n\tif (ioflags & XFS_IO_INVIS)\t\n\t\tflags |= XFS_PREALLOC_INVISIBLE;\n\n\terror = mnt_want_write_file(filp);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(ip, iolock);\n\terror = xfs_break_layouts(inode, &iolock);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tswitch (bf->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tbf->l_start += filp->f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tbf->l_start += XFS_ISIZE(ip);\n\t\tbreak;\n\tdefault:\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * length of <= 0 for resv/unresv/zero is invalid.  length for\n\t * alloc/free is ignored completely and we have no idea what userspace\n\t * might have set it to, so set it to zero to allow range\n\t * checks to pass.\n\t */\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\tif (bf->l_len <= 0) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbf->l_len = 0;\n\t\tbreak;\n\t}\n\n\tif (bf->l_start < 0 ||\n\t    bf->l_start > inode->i_sb->s_maxbytes ||\n\t    bf->l_start + bf->l_len < 0 ||\n\t    bf->l_start + bf->l_len >= inode->i_sb->s_maxbytes) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (cmd) {\n\tcase XFS_IOC_ZERO_RANGE:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_zero_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_RESVSP64:\n\t\tflags |= XFS_PREALLOC_SET;\n\t\terror = xfs_alloc_file_space(ip, bf->l_start, bf->l_len,\n\t\t\t\t\t\tXFS_BMAPI_PREALLOC);\n\t\tbreak;\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_UNRESVSP64:\n\t\terror = xfs_free_file_space(ip, bf->l_start, bf->l_len);\n\t\tbreak;\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_FREESP64:\n\t\tflags |= XFS_PREALLOC_CLEAR;\n\t\tif (bf->l_start > XFS_ISIZE(ip)) {\n\t\t\terror = xfs_alloc_file_space(ip, XFS_ISIZE(ip),\n\t\t\t\t\tbf->l_start - XFS_ISIZE(ip), 0);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiattr.ia_valid = ATTR_SIZE;\n\t\tiattr.ia_size = bf->l_start;\n\n\t\terror = xfs_setattr_size(ip, &iattr);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t}\n\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = xfs_update_prealloc_flags(ip, flags);\n\nout_unlock:\n\txfs_iunlock(ip, iolock);\n\tmnt_drop_write_file(filp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_NATIVE_IOC",
          "args": [
            "cmd",
            "structxfs_flock64"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_compat_flock64_copyin",
          "args": [
            "&bf",
            "arg"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_flock64_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "44-58",
          "snippet": "STATIC int\nxfs_compat_flock64_copyin(\n\txfs_flock64_t\t\t*bf,\n\tcompat_xfs_flock64_t\t__user *arg32)\n{\n\tif (get_user(bf->l_type,\t&arg32->l_type) ||\n\t    get_user(bf->l_whence,\t&arg32->l_whence) ||\n\t    get_user(bf->l_start,\t&arg32->l_start) ||\n\t    get_user(bf->l_len,\t\t&arg32->l_len) ||\n\t    get_user(bf->l_sysid,\t&arg32->l_sysid) ||\n\t    get_user(bf->l_pid,\t\t&arg32->l_pid) ||\n\t    copy_from_user(bf->l_pad,\t&arg32->l_pad,\t4*sizeof(u32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_compat_flock64_copyin(\n\txfs_flock64_t\t\t*bf,\n\tcompat_xfs_flock64_t\t__user *arg32)\n{\n\tif (get_user(bf->l_type,\t&arg32->l_type) ||\n\t    get_user(bf->l_whence,\t&arg32->l_whence) ||\n\t    get_user(bf->l_start,\t&arg32->l_start) ||\n\t    get_user(bf->l_len,\t\t&arg32->l_len) ||\n\t    get_user(bf->l_sysid,\t&arg32->l_sysid) ||\n\t    get_user(bf->l_pid,\t\t&arg32->l_pid) ||\n\t    copy_from_user(bf->l_pad,\t&arg32->l_pad,\t4*sizeof(u32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_file_compat_ioctl",
          "args": [
            "ip"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nlong\nxfs_file_compat_ioctl(\n\tstruct file\t\t*filp,\n\tunsigned\t\tcmd,\n\tunsigned long\t\tp)\n{\n\tstruct inode\t\t*inode = file_inode(filp);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tvoid\t\t\t__user *arg = (void __user *)p;\n\tint\t\t\tioflags = 0;\n\tint\t\t\terror;\n\n\tif (filp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= XFS_IO_INVIS;\n\n\ttrace_xfs_file_compat_ioctl(ip);\n\n\tswitch (cmd) {\n\t/* No size or alignment issues on any arch */\n\tcase XFS_IOC_DIOINFO:\n\tcase XFS_IOC_FSGEOMETRY:\n\tcase XFS_IOC_FSGETXATTR:\n\tcase XFS_IOC_FSSETXATTR:\n\tcase XFS_IOC_FSGETXATTRA:\n\tcase XFS_IOC_FSSETDM:\n\tcase XFS_IOC_GETBMAP:\n\tcase XFS_IOC_GETBMAPA:\n\tcase XFS_IOC_GETBMAPX:\n\tcase XFS_IOC_FSCOUNTS:\n\tcase XFS_IOC_SET_RESBLKS:\n\tcase XFS_IOC_GET_RESBLKS:\n\tcase XFS_IOC_FSGROWFSLOG:\n\tcase XFS_IOC_GOINGDOWN:\n\tcase XFS_IOC_ERROR_INJECTION:\n\tcase XFS_IOC_ERROR_CLEARALL:\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n#ifndef BROKEN_X86_ALIGNMENT\n\t/* These are handled fine if no alignment issues */\n\tcase XFS_IOC_ALLOCSP:\n\tcase XFS_IOC_FREESP:\n\tcase XFS_IOC_RESVSP:\n\tcase XFS_IOC_UNRESVSP:\n\tcase XFS_IOC_ALLOCSP64:\n\tcase XFS_IOC_FREESP64:\n\tcase XFS_IOC_RESVSP64:\n\tcase XFS_IOC_UNRESVSP64:\n\tcase XFS_IOC_FSGEOMETRY_V1:\n\tcase XFS_IOC_FSGROWFSDATA:\n\tcase XFS_IOC_FSGROWFSRT:\n\tcase XFS_IOC_ZERO_RANGE:\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n#else\n\tcase XFS_IOC_ALLOCSP_32:\n\tcase XFS_IOC_FREESP_32:\n\tcase XFS_IOC_ALLOCSP64_32:\n\tcase XFS_IOC_FREESP64_32:\n\tcase XFS_IOC_RESVSP_32:\n\tcase XFS_IOC_UNRESVSP_32:\n\tcase XFS_IOC_RESVSP64_32:\n\tcase XFS_IOC_UNRESVSP64_32:\n\tcase XFS_IOC_ZERO_RANGE_32: {\n\t\tstruct xfs_flock64\tbf;\n\n\t\tif (xfs_compat_flock64_copyin(&bf, arg))\n\t\t\treturn -EFAULT;\n\t\tcmd = _NATIVE_IOC(cmd, struct xfs_flock64);\n\t\treturn xfs_ioc_space(ip, inode, filp, ioflags, cmd, &bf);\n\t}\n\tcase XFS_IOC_FSGEOMETRY_V1_32:\n\t\treturn xfs_compat_ioc_fsgeometry_v1(mp, arg);\n\tcase XFS_IOC_FSGROWFSDATA_32: {\n\t\tstruct xfs_growfs_data\tin;\n\n\t\tif (xfs_compat_growfs_data_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_data(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSGROWFSRT_32: {\n\t\tstruct xfs_growfs_rt\tin;\n\n\t\tif (xfs_compat_growfs_rt_copyin(&in, arg))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_growfs_rt(mp, &in);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n#endif\n\t/* long changes size, but xfs only copiese out 32 bits */\n\tcase XFS_IOC_GETXFLAGS_32:\n\tcase XFS_IOC_SETXFLAGS_32:\n\tcase XFS_IOC_GETVERSION_32:\n\t\tcmd = _NATIVE_IOC(cmd, long);\n\t\treturn xfs_file_ioctl(filp, cmd, p);\n\tcase XFS_IOC_SWAPEXT_32: {\n\t\tstruct xfs_swapext\t  sxp;\n\t\tstruct compat_xfs_swapext __user *sxu = arg;\n\n\t\t/* Bulk copy in up to the sx_stat field, then copy bstat */\n\t\tif (copy_from_user(&sxp, sxu,\n\t\t\t\t   offsetof(struct xfs_swapext, sx_stat)) ||\n\t\t    xfs_ioctl32_bstat_copyin(&sxp.sx_stat, &sxu->sx_stat))\n\t\t\treturn -EFAULT;\n\t\terror = mnt_want_write_file(filp);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_ioc_swapext(&sxp);\n\t\tmnt_drop_write_file(filp);\n\t\treturn error;\n\t}\n\tcase XFS_IOC_FSBULKSTAT_32:\n\tcase XFS_IOC_FSBULKSTAT_SINGLE_32:\n\tcase XFS_IOC_FSINUMBERS_32:\n\t\treturn xfs_compat_ioc_bulkstat(mp, cmd, arg);\n\tcase XFS_IOC_FD_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_HANDLE_32:\n\tcase XFS_IOC_PATH_TO_FSHANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\tcmd = _NATIVE_IOC(cmd, struct xfs_fsop_handlereq);\n\t\treturn xfs_find_handle(cmd, &hreq);\n\t}\n\tcase XFS_IOC_OPEN_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_open_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_READLINK_BY_HANDLE_32: {\n\t\tstruct xfs_fsop_handlereq\threq;\n\n\t\tif (xfs_compat_handlereq_copyin(&hreq, arg))\n\t\t\treturn -EFAULT;\n\t\treturn xfs_readlink_by_handle(filp, &hreq);\n\t}\n\tcase XFS_IOC_ATTRLIST_BY_HANDLE_32:\n\t\treturn xfs_compat_attrlist_by_handle(filp, arg);\n\tcase XFS_IOC_ATTRMULTI_BY_HANDLE_32:\n\t\treturn xfs_compat_attrmulti_by_handle(filp, arg);\n\tcase XFS_IOC_FSSETDM_BY_HANDLE_32:\n\t\treturn xfs_compat_fssetdm_by_handle(filp, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}"
  },
  {
    "function_name": "xfs_compat_fssetdm_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "487-523",
    "snippet": "STATIC int\nxfs_compat_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\tcompat_xfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, compat_ptr(dmhreq.data), sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\nout:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_dmattrs",
          "args": [
            "XFS_I(dentry->d_inode)",
            "fsd.fsd_dmevmask",
            "fsd.fsd_dmstate"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_dmattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "320-352",
          "snippet": "int\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_set_dmattrs(\n\txfs_inode_t     *ip,\n\tu_int\t\tevmask,\n\tu_int16_t\tstate)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SET_DMATTRS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\tip->i_d.di_dmevmask = evmask;\n\tip->i_d.di_dmstate  = state;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(tp, 0);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&fsd",
            "compat_ptr(dmhreq.data)",
            "sizeof(fsd)"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "dmhreq.data"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "dentry->d_inode"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_compat_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&dmhreq.hreq"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "333-340",
          "snippet": "dentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\ndentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_MKNOD"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_fssetdm_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tstruct fsdmidata\tfsd;\n\tcompat_xfs_fsop_setdm_handlereq_t dmhreq;\n\tstruct dentry\t\t*dentry;\n\n\tif (!capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\tif (copy_from_user(&dmhreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_setdm_handlereq_t)))\n\t\treturn -EFAULT;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &dmhreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (IS_IMMUTABLE(dentry->d_inode) || IS_APPEND(dentry->d_inode)) {\n\t\terror = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&fsd, compat_ptr(dmhreq.data), sizeof(fsd))) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terror = xfs_set_dmattrs(XFS_I(dentry->d_inode), fsd.fsd_dmevmask,\n\t\t\t\t fsd.fsd_dmstate);\n\nout:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_compat_attrmulti_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "393-485",
    "snippet": "STATIC int\nxfs_compat_attrmulti_by_handle(\n\tstruct file\t\t\t\t*parfilp,\n\tvoid\t\t\t\t\t__user *arg)\n{\n\tint\t\t\t\t\terror;\n\tcompat_xfs_attr_multiop_t\t\t*ops;\n\tcompat_xfs_fsop_attrmulti_handlereq_t\tam_hreq;\n\tstruct dentry\t\t\t\t*dentry;\n\tunsigned int\t\t\t\ti, size;\n\tunsigned char\t\t\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(compat_ptr(am_hreq.ops), size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tcompat_ptr(ops[i].am_attrname),\n\t\t\t\tMAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\tops[i].am_length, ops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ops"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr_name"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "compat_ptr(am_hreq.ops)",
            "ops",
            "size"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "am_hreq.ops"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "parfilp"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_remove",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "ops[i].am_flags"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "498-507",
          "snippet": "int\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_remove(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\t__uint32_t\t\tflags)\n{\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\treturn xfs_attr_remove(XFS_I(inode), name, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "parfilp"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_set",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "compat_ptr(ops[i].am_attrvalue)",
            "ops[i].am_length",
            "ops[i].am_flags"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "476-496",
          "snippet": "int\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\t__uint32_t\t\tlen,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\n\tkbuf = memdup_user(ubuf, len);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\treturn xfs_attr_set(XFS_I(inode), name, kbuf, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "ops[i].am_attrvalue"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attrmulti_attr_get",
          "args": [
            "dentry->d_inode",
            "attr_name",
            "compat_ptr(ops[i].am_attrvalue)",
            "&ops[i].am_length",
            "ops[i].am_flags"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attrmulti_attr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "447-474",
          "snippet": "int\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_attrmulti_attr_get(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tunsigned char\t\t__user *ubuf,\n\t__uint32_t\t\t*len,\n\t__uint32_t\t\tflags)\n{\n\tunsigned char\t\t*kbuf;\n\tint\t\t\terror = -EFAULT;\n\n\tif (*len > XATTR_SIZE_MAX)\n\t\treturn -EINVAL;\n\tkbuf = kmem_zalloc_large(*len, KM_SLEEP);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_attr_get(XFS_I(inode), name, kbuf, (int *)len, flags);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(ubuf, kbuf, *len))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "ops[i].am_attrvalue"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "(char *)attr_name",
            "compat_ptr(ops[i].am_attrname)",
            "MAXNAMELEN"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "ops[i].am_attrname"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAXNAMELEN",
            "GFP_KERNEL"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ops"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ops"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "compat_ptr(am_hreq.ops)",
            "size"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "am_hreq.ops"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_compat_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&am_hreq.hreq"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "333-340",
          "snippet": "dentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\ndentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&am_hreq",
            "arg",
            "sizeof(compat_xfs_fsop_attrmulti_handlereq_t)"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_attrmulti_by_handle(\n\tstruct file\t\t\t\t*parfilp,\n\tvoid\t\t\t\t\t__user *arg)\n{\n\tint\t\t\t\t\terror;\n\tcompat_xfs_attr_multiop_t\t\t*ops;\n\tcompat_xfs_fsop_attrmulti_handlereq_t\tam_hreq;\n\tstruct dentry\t\t\t\t*dentry;\n\tunsigned int\t\t\t\ti, size;\n\tunsigned char\t\t\t\t*attr_name;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&am_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrmulti_handlereq_t)))\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (am_hreq.opcount >= INT_MAX / sizeof(compat_xfs_attr_multiop_t))\n\t\treturn -E2BIG;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &am_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -E2BIG;\n\tsize = am_hreq.opcount * sizeof(compat_xfs_attr_multiop_t);\n\tif (!size || size > 16 * PAGE_SIZE)\n\t\tgoto out_dput;\n\n\tops = memdup_user(compat_ptr(am_hreq.ops), size);\n\tif (IS_ERR(ops)) {\n\t\terror = PTR_ERR(ops);\n\t\tgoto out_dput;\n\t}\n\n\terror = -ENOMEM;\n\tattr_name = kmalloc(MAXNAMELEN, GFP_KERNEL);\n\tif (!attr_name)\n\t\tgoto out_kfree_ops;\n\n\terror = 0;\n\tfor (i = 0; i < am_hreq.opcount; i++) {\n\t\tops[i].am_error = strncpy_from_user((char *)attr_name,\n\t\t\t\tcompat_ptr(ops[i].am_attrname),\n\t\t\t\tMAXNAMELEN);\n\t\tif (ops[i].am_error == 0 || ops[i].am_error == MAXNAMELEN)\n\t\t\terror = -ERANGE;\n\t\tif (ops[i].am_error < 0)\n\t\t\tbreak;\n\n\t\tswitch (ops[i].am_opcode) {\n\t\tcase ATTR_OP_GET:\n\t\t\tops[i].am_error = xfs_attrmulti_attr_get(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\t&ops[i].am_length, ops[i].am_flags);\n\t\t\tbreak;\n\t\tcase ATTR_OP_SET:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_set(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tcompat_ptr(ops[i].am_attrvalue),\n\t\t\t\t\tops[i].am_length, ops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tcase ATTR_OP_REMOVE:\n\t\t\tops[i].am_error = mnt_want_write_file(parfilp);\n\t\t\tif (ops[i].am_error)\n\t\t\t\tbreak;\n\t\t\tops[i].am_error = xfs_attrmulti_attr_remove(\n\t\t\t\t\tdentry->d_inode, attr_name,\n\t\t\t\t\tops[i].am_flags);\n\t\t\tmnt_drop_write_file(parfilp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tops[i].am_error = -EINVAL;\n\t\t}\n\t}\n\n\tif (copy_to_user(compat_ptr(am_hreq.ops), ops, size))\n\t\terror = -EFAULT;\n\n\tkfree(attr_name);\n out_kfree_ops:\n\tkfree(ops);\n out_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_compat_attrlist_by_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "342-391",
    "snippet": "STATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "kbuf"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "compat_ptr(al_hreq.buffer)",
            "kbuf",
            "al_hreq.buflen"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "al_hreq.buffer"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_attr_list",
          "args": [
            "XFS_I(dentry->d_inode)",
            "kbuf",
            "al_hreq.buflen",
            "al_hreq.flags",
            "cursor"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_attr_list.c",
          "lines": "600-650",
          "snippet": "int\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_list(\n\txfs_inode_t\t*dp,\n\tchar\t\t*buffer,\n\tint\t\tbufsize,\n\tint\t\tflags,\n\tattrlist_cursor_kern_t *cursor)\n{\n\txfs_attr_list_context_t context;\n\tstruct attrlist *alist;\n\tint error;\n\n\t/*\n\t * Validate the cursor.\n\t */\n\tif (cursor->pad1 || cursor->pad2)\n\t\treturn -EINVAL;\n\tif ((cursor->initted == 0) &&\n\t    (cursor->hashval || cursor->blkno || cursor->offset))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Check for a properly aligned buffer.\n\t */\n\tif (((long)buffer) & (sizeof(int)-1))\n\t\treturn -EFAULT;\n\tif (flags & ATTR_KERNOVAL)\n\t\tbufsize = 0;\n\n\t/*\n\t * Initialize the output buffer.\n\t */\n\tmemset(&context, 0, sizeof(context));\n\tcontext.dp = dp;\n\tcontext.cursor = cursor;\n\tcontext.resynch = 1;\n\tcontext.flags = flags;\n\tcontext.alist = buffer;\n\tcontext.bufsize = (bufsize & ~(sizeof(int)-1));  /* align */\n\tcontext.firstu = context.bufsize;\n\tcontext.put_listent = xfs_attr_put_listent;\n\n\talist = (struct attrlist *)context.alist;\n\talist->al_count = 0;\n\talist->al_more = 0;\n\talist->al_offset[0] = context.bufsize;\n\n\terror = xfs_attr_list_int(&context);\n\tASSERT(error <= 0);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "al_hreq.buflen",
            "KM_SLEEP"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_compat_handlereq_to_dentry",
          "args": [
            "parfilp",
            "&al_hreq.hreq"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_compat_handlereq_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "333-340",
          "snippet": "dentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\ndentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&al_hreq",
            "arg",
            "sizeof(compat_xfs_fsop_attrlist_handlereq_t)"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror;\n\tattrlist_cursor_kern_t\t*cursor;\n\tcompat_xfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&al_hreq, arg,\n\t\t\t   sizeof(compat_xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -EFAULT;\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -EINVAL;\n\n\tdentry = xfs_compat_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terror = -ENOMEM;\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\n\tif (copy_to_user(compat_ptr(al_hreq.buffer), kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\n\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_compat_handlereq_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "333-340",
    "snippet": "dentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_handle_to_dentry",
          "args": [
            "parfilp",
            "compat_ptr(hreq->ihandle)",
            "hreq->ihandlen"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_handle_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl.c",
          "lines": "152-182",
          "snippet": "struct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_export.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_export.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct dentry *\nxfs_handle_to_dentry(\n\tstruct file\t\t*parfilp,\n\tvoid __user\t\t*uhandle,\n\tu32\t\t\thlen)\n{\n\txfs_handle_t\t\thandle;\n\tstruct xfs_fid64\tfid;\n\n\t/*\n\t * Only allow handle opens under a directory.\n\t */\n\tif (!S_ISDIR(file_inode(parfilp)->i_mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (hlen != sizeof(xfs_handle_t))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (copy_from_user(&handle, uhandle, hlen))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (handle.ha_fid.fid_len !=\n\t    sizeof(handle.ha_fid) - sizeof(handle.ha_fid.fid_len))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemset(&fid, 0, sizeof(struct fid));\n\tfid.ino = handle.ha_fid.fid_ino;\n\tfid.gen = handle.ha_fid.fid_gen;\n\n\treturn exportfs_decode_fh(parfilp->f_path.mnt, (struct fid *)&fid, 3,\n\t\t\tFILEID_INO32_GEN | XFS_FILEID_TYPE_64FLAG,\n\t\t\txfs_handle_acceptable, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "hreq->ihandle"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\ndentry *\nxfs_compat_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\tcompat_xfs_fsop_handlereq_t *hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp,\n\t\t\tcompat_ptr(hreq->ihandle), hreq->ihandlen);\n}"
  },
  {
    "function_name": "xfs_compat_handlereq_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "312-331",
    "snippet": "STATIC int\nxfs_compat_handlereq_copyin(\n\txfs_fsop_handlereq_t\t\t*hreq,\n\tcompat_xfs_fsop_handlereq_t\t__user *arg32)\n{\n\tcompat_xfs_fsop_handlereq_t\threq32;\n\n\tif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\n\t\treturn -EFAULT;\n\n\threq->fd = hreq32.fd;\n\threq->path = compat_ptr(hreq32.path);\n\threq->oflags = hreq32.oflags;\n\threq->ihandle = compat_ptr(hreq32.ihandle);\n\threq->ihandlen = hreq32.ihandlen;\n\threq->ohandle = compat_ptr(hreq32.ohandle);\n\threq->ohandlen = compat_ptr(hreq32.ohandlen);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "hreq32.ohandlen"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "hreq32.ohandle"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "hreq32.ihandle"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "hreq32.path"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&hreq32",
            "arg32",
            "sizeof(compat_xfs_fsop_handlereq_t)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_compat_handlereq_copyin(\n\txfs_fsop_handlereq_t\t\t*hreq,\n\tcompat_xfs_fsop_handlereq_t\t__user *arg32)\n{\n\tcompat_xfs_fsop_handlereq_t\threq32;\n\n\tif (copy_from_user(&hreq32, arg32, sizeof(compat_xfs_fsop_handlereq_t)))\n\t\treturn -EFAULT;\n\n\threq->fd = hreq32.fd;\n\threq->path = compat_ptr(hreq32.path);\n\threq->oflags = hreq32.oflags;\n\threq->ihandle = compat_ptr(hreq32.ihandle);\n\threq->ihandlen = hreq32.ihandlen;\n\threq->ohandle = compat_ptr(hreq32.ohandle);\n\threq->ohandlen = compat_ptr(hreq32.ohandlen);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_compat_ioc_bulkstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "241-310",
    "snippet": "STATIC int\nxfs_compat_ioc_bulkstat(\n\txfs_mount_t\t\t  *mp,\n\tunsigned int\t\t  cmd,\n\tcompat_xfs_fsop_bulkreq_t __user *p32)\n{\n\tu32\t\t\taddr;\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (get_user(addr, &p32->lastip))\n\t\treturn -EFAULT;\n\tbulkreq.lastip = compat_ptr(addr);\n\tif (get_user(bulkreq.icount, &p32->icount) ||\n\t    get_user(addr, &p32->ubuffer))\n\t\treturn -EFAULT;\n\tbulkreq.ubuffer = compat_ptr(addr);\n\tif (get_user(addr, &p32->ocount))\n\t\treturn -EFAULT;\n\tbulkreq.ocount = compat_ptr(addr);\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS_32) {\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt_compat);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\n\t\tint res;\n\n\t\terror = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,\n\t\t\t\tsizeof(compat_xfs_bstat_t), NULL, &res);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\n\t\terror = xfs_bulkstat(mp, &inlast, &count,\n\t\t\txfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),\n\t\t\tbulkreq.ubuffer, &done);\n\t} else\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [
      "#define xfs_inumbers_fmt_compat xfs_inumbers_fmt"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "bulkreq.ocount",
            "&count",
            "sizeof(count)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "bulkreq.lastip",
            "&inlast",
            "sizeof(xfs_ino_t)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat",
          "args": [
            "mp",
            "&inlast",
            "&count",
            "xfs_bulkstat_one_compat",
            "sizeof(compat_xfs_bstat_t)",
            "bulkreq.ubuffer",
            "&done"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "340-531",
          "snippet": "int\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat_one_compat",
          "args": [
            "mp",
            "inlast",
            "bulkreq.ubuffer",
            "sizeof(compat_xfs_bstat_t)",
            "NULL",
            "&res"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_one_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "226-238",
          "snippet": "STATIC int\nxfs_bulkstat_one_compat(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt_compat,\n\t\t\t\t    ubused, stat);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_bulkstat_one_compat(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt_compat,\n\t\t\t\t    ubused, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inumbers",
          "args": [
            "mp",
            "&inlast",
            "&count",
            "bulkreq.ubuffer",
            "xfs_inumbers_fmt_compat"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inumbers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "549-652",
          "snippet": "int\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_inumbers(\n\tstruct xfs_mount\t*mp,/* mount point for filesystem */\n\txfs_ino_t\t\t*lastino,/* last inode returned */\n\tint\t\t\t*count,/* size of buffer/count returned */\n\tvoid\t\t\t__user *ubuffer,/* buffer with inode descriptions */\n\tinumbers_fmt_pf\t\tformatter)\n{\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, *lastino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, *lastino);\n\tstruct xfs_btree_cur\t*cur = NULL;\n\tstruct xfs_buf\t\t*agbp = NULL;\n\tstruct xfs_inogrp\t*buffer;\n\tint\t\t\tbcount;\n\tint\t\t\tleft = *count;\n\tint\t\t\tbufidx = 0;\n\tint\t\t\terror = 0;\n\n\t*count = 0;\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastino != XFS_AGINO_TO_INO(mp, agno, agino))\n\t\treturn error;\n\n\tbcount = MIN(left, (int)(PAGE_SIZE / sizeof(*buffer)));\n\tbuffer = kmem_alloc(bcount * sizeof(*buffer), KM_SLEEP);\n\tdo {\n\t\tstruct xfs_inobt_rec_incore\tr;\n\t\tint\t\t\t\tstat;\n\n\t\tif (!agbp) {\n\t\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t\t    XFS_BTNUM_INO);\n\t\t\terror = xfs_inobt_lookup(cur, agino, XFS_LOOKUP_GE,\n\t\t\t\t\t\t &stat);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tif (!stat)\n\t\t\t\tgoto next_ag;\n\t\t}\n\n\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (!stat)\n\t\t\tgoto next_ag;\n\n\t\tagino = r.ir_startino + XFS_INODES_PER_CHUNK - 1;\n\t\tbuffer[bufidx].xi_startino =\n\t\t\tXFS_AGINO_TO_INO(mp, agno, r.ir_startino);\n\t\tbuffer[bufidx].xi_alloccount =\n\t\t\tXFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\tbuffer[bufidx].xi_allocmask = ~r.ir_free;\n\t\tif (++bufidx == bcount) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tubuffer += written;\n\t\t\t*count += bufidx;\n\t\t\tbufidx = 0;\n\t\t}\n\t\tif (!--left)\n\t\t\tbreak;\n\n\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\tif (error)\n\t\t\tbreak;\n\t\tif (stat)\n\t\t\tcontinue;\n\nnext_ag:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\tcur = NULL;\n\t\txfs_buf_relse(agbp);\n\t\tagbp = NULL;\n\t\tagino = 0;\n\t\tagno++;\n\t} while (agno < mp->m_sb.sb_agcount);\n\n\tif (!error) {\n\t\tif (bufidx) {\n\t\t\tlong\twritten;\n\n\t\t\terror = formatter(ubuffer, buffer, bufidx, &written);\n\t\t\tif (!error)\n\t\t\t\t*count += bufidx;\n\t\t}\n\t\t*lastino = XFS_AGINO_TO_INO(mp, agno, agino);\n\t}\n\n\tkmem_free(buffer);\n\tif (cur)\n\t\txfs_btree_del_cursor(cur, (error ? XFS_BTREE_ERROR :\n\t\t\t\t\t   XFS_BTREE_NOERROR));\n\tif (agbp)\n\t\txfs_buf_relse(agbp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&inlast",
            "bulkreq.lastip",
            "sizeof(__s64)"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "addr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "addr",
            "&p32->ocount"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "addr"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "addr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\n#define xfs_inumbers_fmt_compat xfs_inumbers_fmt\n\nSTATIC int\nxfs_compat_ioc_bulkstat(\n\txfs_mount_t\t\t  *mp,\n\tunsigned int\t\t  cmd,\n\tcompat_xfs_fsop_bulkreq_t __user *p32)\n{\n\tu32\t\t\taddr;\n\txfs_fsop_bulkreq_t\tbulkreq;\n\tint\t\t\tcount;\t/* # of records returned */\n\txfs_ino_t\t\tinlast;\t/* last inode number */\n\tint\t\t\tdone;\n\tint\t\t\terror;\n\n\t/* done = 1 if there are more stats to get and if bulkstat */\n\t/* should be called again (unused here, but used in dmapi) */\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tif (get_user(addr, &p32->lastip))\n\t\treturn -EFAULT;\n\tbulkreq.lastip = compat_ptr(addr);\n\tif (get_user(bulkreq.icount, &p32->icount) ||\n\t    get_user(addr, &p32->ubuffer))\n\t\treturn -EFAULT;\n\tbulkreq.ubuffer = compat_ptr(addr);\n\tif (get_user(addr, &p32->ocount))\n\t\treturn -EFAULT;\n\tbulkreq.ocount = compat_ptr(addr);\n\n\tif (copy_from_user(&inlast, bulkreq.lastip, sizeof(__s64)))\n\t\treturn -EFAULT;\n\n\tif ((count = bulkreq.icount) <= 0)\n\t\treturn -EINVAL;\n\n\tif (bulkreq.ubuffer == NULL)\n\t\treturn -EINVAL;\n\n\tif (cmd == XFS_IOC_FSINUMBERS_32) {\n\t\terror = xfs_inumbers(mp, &inlast, &count,\n\t\t\t\tbulkreq.ubuffer, xfs_inumbers_fmt_compat);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_SINGLE_32) {\n\t\tint res;\n\n\t\terror = xfs_bulkstat_one_compat(mp, inlast, bulkreq.ubuffer,\n\t\t\t\tsizeof(compat_xfs_bstat_t), NULL, &res);\n\t} else if (cmd == XFS_IOC_FSBULKSTAT_32) {\n\t\terror = xfs_bulkstat(mp, &inlast, &count,\n\t\t\txfs_bulkstat_one_compat, sizeof(compat_xfs_bstat_t),\n\t\t\tbulkreq.ubuffer, &done);\n\t} else\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\tif (bulkreq.ocount != NULL) {\n\t\tif (copy_to_user(bulkreq.lastip, &inlast,\n\t\t\t\t\t\tsizeof(xfs_ino_t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_to_user(bulkreq.ocount, &count, sizeof(count)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bulkstat_one_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "226-238",
    "snippet": "STATIC int\nxfs_bulkstat_one_compat(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt_compat,\n\t\t\t\t    ubused, stat);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bulkstat_one_int",
          "args": [
            "mp",
            "ino",
            "buffer",
            "ubsize",
            "xfs_bulkstat_one_fmt_compat",
            "ubused",
            "stat"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat_one_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "48-139",
          "snippet": "int\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bulkstat_one_int(\n\tstruct xfs_mount\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\t\tino,\t\t/* inode to get data for */\n\tvoid __user\t\t*buffer,\t/* buffer to place output in */\n\tint\t\t\tubsize,\t\t/* size of buffer */\n\tbulkstat_one_fmt_pf\tformatter,\t/* formatter, copy to user */\n\tint\t\t\t*ubused,\t/* bytes used by me */\n\tint\t\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\tstruct xfs_icdinode\t*dic;\t\t/* dinode core info pointer */\n\tstruct xfs_inode\t*ip;\t\t/* incore inode pointer */\n\tstruct xfs_bstat\t*buf;\t\t/* return buffer */\n\tint\t\t\terror = 0;\t/* error value */\n\n\t*stat = BULKSTAT_RV_NOTHING;\n\n\tif (!buffer || xfs_internal_inum(mp, ino))\n\t\treturn -EINVAL;\n\n\tbuf = kmem_alloc(sizeof(*buf), KM_SLEEP | KM_MAYFAIL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\terror = xfs_iget(mp, NULL, ino,\n\t\t\t (XFS_IGET_DONTCACHE | XFS_IGET_UNTRUSTED),\n\t\t\t XFS_ILOCK_SHARED, &ip);\n\tif (error)\n\t\tgoto out_free;\n\n\tASSERT(ip != NULL);\n\tASSERT(ip->i_imap.im_blkno != 0);\n\n\tdic = &ip->i_d;\n\n\t/* xfs_iget returns the following without needing\n\t * further change.\n\t */\n\tbuf->bs_nlink = dic->di_nlink;\n\tbuf->bs_projid_lo = dic->di_projid_lo;\n\tbuf->bs_projid_hi = dic->di_projid_hi;\n\tbuf->bs_ino = ino;\n\tbuf->bs_mode = dic->di_mode;\n\tbuf->bs_uid = dic->di_uid;\n\tbuf->bs_gid = dic->di_gid;\n\tbuf->bs_size = dic->di_size;\n\tbuf->bs_atime.tv_sec = dic->di_atime.t_sec;\n\tbuf->bs_atime.tv_nsec = dic->di_atime.t_nsec;\n\tbuf->bs_mtime.tv_sec = dic->di_mtime.t_sec;\n\tbuf->bs_mtime.tv_nsec = dic->di_mtime.t_nsec;\n\tbuf->bs_ctime.tv_sec = dic->di_ctime.t_sec;\n\tbuf->bs_ctime.tv_nsec = dic->di_ctime.t_nsec;\n\tbuf->bs_xflags = xfs_ip2xflags(ip);\n\tbuf->bs_extsize = dic->di_extsize << mp->m_sb.sb_blocklog;\n\tbuf->bs_extents = dic->di_nextents;\n\tbuf->bs_gen = dic->di_gen;\n\tmemset(buf->bs_pad, 0, sizeof(buf->bs_pad));\n\tbuf->bs_dmevmask = dic->di_dmevmask;\n\tbuf->bs_dmstate = dic->di_dmstate;\n\tbuf->bs_aextents = dic->di_anextents;\n\tbuf->bs_forkoff = XFS_IFORK_BOFF(ip);\n\n\tswitch (dic->di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tbuf->bs_rdev = ip->i_df.if_u2.if_rdev;\n\t\tbuf->bs_blksize = BLKDEV_IOSIZE;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_UUID:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = 0;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tbuf->bs_rdev = 0;\n\t\tbuf->bs_blksize = mp->m_sb.sb_blocksize;\n\t\tbuf->bs_blocks = dic->di_nblocks + ip->i_delayed_blks;\n\t\tbreak;\n\t}\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\tIRELE(ip);\n\n\terror = formatter(buffer, ubsize, ubused, buf);\n\tif (!error)\n\t\t*stat = BULKSTAT_RV_DIDONE;\n\n out_free:\n\tkmem_free(buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_bulkstat_one_compat(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* buffer to place output in */\n\tint\t\tubsize,\t\t/* size of buffer */\n\tint\t\t*ubused,\t/* bytes used by me */\n\tint\t\t*stat)\t\t/* BULKSTAT_RV_... */\n{\n\treturn xfs_bulkstat_one_int(mp, ino, buffer, ubsize,\n\t\t\t\t    xfs_bulkstat_one_fmt_compat,\n\t\t\t\t    ubused, stat);\n}"
  },
  {
    "function_name": "xfs_bulkstat_one_fmt_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "186-224",
    "snippet": "STATIC int\nxfs_bulkstat_one_fmt_compat(\n\tvoid\t\t\t__user *ubuffer,\n\tint\t\t\tubsize,\n\tint\t\t\t*ubused,\n\tconst xfs_bstat_t\t*buffer)\n{\n\tcompat_xfs_bstat_t\t__user *p32 = ubuffer;\n\n\tif (ubsize < sizeof(*p32))\n\t\treturn -ENOMEM;\n\n\tif (put_user(buffer->bs_ino,\t  &p32->bs_ino)\t\t||\n\t    put_user(buffer->bs_mode,\t  &p32->bs_mode)\t||\n\t    put_user(buffer->bs_nlink,\t  &p32->bs_nlink)\t||\n\t    put_user(buffer->bs_uid,\t  &p32->bs_uid)\t\t||\n\t    put_user(buffer->bs_gid,\t  &p32->bs_gid)\t\t||\n\t    put_user(buffer->bs_rdev,\t  &p32->bs_rdev)\t||\n\t    put_user(buffer->bs_blksize,  &p32->bs_blksize)\t||\n\t    put_user(buffer->bs_size,\t  &p32->bs_size)\t||\n\t    xfs_bstime_store_compat(&p32->bs_atime, &buffer->bs_atime) ||\n\t    xfs_bstime_store_compat(&p32->bs_mtime, &buffer->bs_mtime) ||\n\t    xfs_bstime_store_compat(&p32->bs_ctime, &buffer->bs_ctime) ||\n\t    put_user(buffer->bs_blocks,\t  &p32->bs_blocks)\t||\n\t    put_user(buffer->bs_xflags,\t  &p32->bs_xflags)\t||\n\t    put_user(buffer->bs_extsize,  &p32->bs_extsize)\t||\n\t    put_user(buffer->bs_extents,  &p32->bs_extents)\t||\n\t    put_user(buffer->bs_gen,\t  &p32->bs_gen)\t\t||\n\t    put_user(buffer->bs_projid,\t  &p32->bs_projid)\t||\n\t    put_user(buffer->bs_projid_hi,\t&p32->bs_projid_hi)\t||\n\t    put_user(buffer->bs_forkoff,  &p32->bs_forkoff)\t||\n\t    put_user(buffer->bs_dmevmask, &p32->bs_dmevmask)\t||\n\t    put_user(buffer->bs_dmstate,  &p32->bs_dmstate)\t||\n\t    put_user(buffer->bs_aextents, &p32->bs_aextents))\n\t\treturn -EFAULT;\n\tif (ubused)\n\t\t*ubused = sizeof(*p32);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_aextents",
            "&p32->bs_aextents"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_dmstate",
            "&p32->bs_dmstate"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_dmevmask",
            "&p32->bs_dmevmask"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_forkoff",
            "&p32->bs_forkoff"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_projid_hi",
            "&p32->bs_projid_hi"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_projid",
            "&p32->bs_projid"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_gen",
            "&p32->bs_gen"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_extents",
            "&p32->bs_extents"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_extsize",
            "&p32->bs_extsize"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_xflags",
            "&p32->bs_xflags"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_blocks",
            "&p32->bs_blocks"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bstime_store_compat",
          "args": [
            "&p32->bs_ctime",
            "&buffer->bs_ctime"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bstime_store_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "171-183",
          "snippet": "STATIC int\nxfs_bstime_store_compat(\n\tcompat_xfs_bstime_t\t__user *p32,\n\tconst xfs_bstime_t\t*p)\n{\n\t__s32\t\t\tsec32;\n\n\tsec32 = p->tv_sec;\n\tif (put_user(sec32, &p32->tv_sec) ||\n\t    put_user(p->tv_nsec, &p32->tv_nsec))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_bstime_store_compat(\n\tcompat_xfs_bstime_t\t__user *p32,\n\tconst xfs_bstime_t\t*p)\n{\n\t__s32\t\t\tsec32;\n\n\tsec32 = p->tv_sec;\n\tif (put_user(sec32, &p32->tv_sec) ||\n\t    put_user(p->tv_nsec, &p32->tv_nsec))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_size",
            "&p32->bs_size"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_blksize",
            "&p32->bs_blksize"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_rdev",
            "&p32->bs_rdev"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_gid",
            "&p32->bs_gid"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_uid",
            "&p32->bs_uid"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_nlink",
            "&p32->bs_nlink"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_mode",
            "&p32->bs_mode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer->bs_ino",
            "&p32->bs_ino"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_bulkstat_one_fmt_compat(\n\tvoid\t\t\t__user *ubuffer,\n\tint\t\t\tubsize,\n\tint\t\t\t*ubused,\n\tconst xfs_bstat_t\t*buffer)\n{\n\tcompat_xfs_bstat_t\t__user *p32 = ubuffer;\n\n\tif (ubsize < sizeof(*p32))\n\t\treturn -ENOMEM;\n\n\tif (put_user(buffer->bs_ino,\t  &p32->bs_ino)\t\t||\n\t    put_user(buffer->bs_mode,\t  &p32->bs_mode)\t||\n\t    put_user(buffer->bs_nlink,\t  &p32->bs_nlink)\t||\n\t    put_user(buffer->bs_uid,\t  &p32->bs_uid)\t\t||\n\t    put_user(buffer->bs_gid,\t  &p32->bs_gid)\t\t||\n\t    put_user(buffer->bs_rdev,\t  &p32->bs_rdev)\t||\n\t    put_user(buffer->bs_blksize,  &p32->bs_blksize)\t||\n\t    put_user(buffer->bs_size,\t  &p32->bs_size)\t||\n\t    xfs_bstime_store_compat(&p32->bs_atime, &buffer->bs_atime) ||\n\t    xfs_bstime_store_compat(&p32->bs_mtime, &buffer->bs_mtime) ||\n\t    xfs_bstime_store_compat(&p32->bs_ctime, &buffer->bs_ctime) ||\n\t    put_user(buffer->bs_blocks,\t  &p32->bs_blocks)\t||\n\t    put_user(buffer->bs_xflags,\t  &p32->bs_xflags)\t||\n\t    put_user(buffer->bs_extsize,  &p32->bs_extsize)\t||\n\t    put_user(buffer->bs_extents,  &p32->bs_extents)\t||\n\t    put_user(buffer->bs_gen,\t  &p32->bs_gen)\t\t||\n\t    put_user(buffer->bs_projid,\t  &p32->bs_projid)\t||\n\t    put_user(buffer->bs_projid_hi,\t&p32->bs_projid_hi)\t||\n\t    put_user(buffer->bs_forkoff,  &p32->bs_forkoff)\t||\n\t    put_user(buffer->bs_dmevmask, &p32->bs_dmevmask)\t||\n\t    put_user(buffer->bs_dmstate,  &p32->bs_dmstate)\t||\n\t    put_user(buffer->bs_aextents, &p32->bs_aextents))\n\t\treturn -EFAULT;\n\tif (ubused)\n\t\t*ubused = sizeof(*p32);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bstime_store_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "171-183",
    "snippet": "STATIC int\nxfs_bstime_store_compat(\n\tcompat_xfs_bstime_t\t__user *p32,\n\tconst xfs_bstime_t\t*p)\n{\n\t__s32\t\t\tsec32;\n\n\tsec32 = p->tv_sec;\n\tif (put_user(sec32, &p32->tv_sec) ||\n\t    put_user(p->tv_nsec, &p32->tv_nsec))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "p->tv_nsec",
            "&p32->tv_nsec"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sec32",
            "&p32->tv_sec"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_bstime_store_compat(\n\tcompat_xfs_bstime_t\t__user *p32,\n\tconst xfs_bstime_t\t*p)\n{\n\t__s32\t\t\tsec32;\n\n\tsec32 = p->tv_sec;\n\tif (put_user(sec32, &p32->tv_sec) ||\n\t    put_user(p->tv_nsec, &p32->tv_nsec))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioctl32_bstat_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "138-167",
    "snippet": "STATIC int\nxfs_ioctl32_bstat_copyin(\n\txfs_bstat_t\t\t*bstat,\n\tcompat_xfs_bstat_t\t__user *bstat32)\n{\n\tif (get_user(bstat->bs_ino,\t&bstat32->bs_ino)\t||\n\t    get_user(bstat->bs_mode,\t&bstat32->bs_mode)\t||\n\t    get_user(bstat->bs_nlink,\t&bstat32->bs_nlink)\t||\n\t    get_user(bstat->bs_uid,\t&bstat32->bs_uid)\t||\n\t    get_user(bstat->bs_gid,\t&bstat32->bs_gid)\t||\n\t    get_user(bstat->bs_rdev,\t&bstat32->bs_rdev)\t||\n\t    get_user(bstat->bs_blksize,\t&bstat32->bs_blksize)\t||\n\t    get_user(bstat->bs_size,\t&bstat32->bs_size)\t||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\n\t    get_user(bstat->bs_blocks,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_xflags,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_extsize,\t&bstat32->bs_extsize)\t||\n\t    get_user(bstat->bs_extents,\t&bstat32->bs_extents)\t||\n\t    get_user(bstat->bs_gen,\t&bstat32->bs_gen)\t||\n\t    get_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\n\t    get_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\n\t    get_user(bstat->bs_forkoff,\t&bstat32->bs_forkoff)\t||\n\t    get_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask)\t||\n\t    get_user(bstat->bs_dmstate,\t&bstat32->bs_dmstate)\t||\n\t    get_user(bstat->bs_aextents, &bstat32->bs_aextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "bstat->bs_aextents",
            "&bstat32->bs_aextents"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ioctl32_bstime_copyin",
          "args": [
            "&bstat->bs_ctime",
            "&bstat32->bs_ctime"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ioctl32_bstime_copyin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
          "lines": "123-135",
          "snippet": "STATIC int\nxfs_ioctl32_bstime_copyin(\n\txfs_bstime_t\t\t*bstime,\n\tcompat_xfs_bstime_t\t__user *bstime32)\n{\n\tcompat_time_t\t\tsec32;\t/* tv_sec differs on 64 vs. 32 */\n\n\tif (get_user(sec32,\t\t&bstime32->tv_sec)\t||\n\t    get_user(bstime->tv_nsec,\t&bstime32->tv_nsec))\n\t\treturn -EFAULT;\n\tbstime->tv_sec = sec32;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl32.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_ioctl32_bstime_copyin(\n\txfs_bstime_t\t\t*bstime,\n\tcompat_xfs_bstime_t\t__user *bstime32)\n{\n\tcompat_time_t\t\tsec32;\t/* tv_sec differs on 64 vs. 32 */\n\n\tif (get_user(sec32,\t\t&bstime32->tv_sec)\t||\n\t    get_user(bstime->tv_nsec,\t&bstime32->tv_nsec))\n\t\treturn -EFAULT;\n\tbstime->tv_sec = sec32;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_ioctl32_bstat_copyin(\n\txfs_bstat_t\t\t*bstat,\n\tcompat_xfs_bstat_t\t__user *bstat32)\n{\n\tif (get_user(bstat->bs_ino,\t&bstat32->bs_ino)\t||\n\t    get_user(bstat->bs_mode,\t&bstat32->bs_mode)\t||\n\t    get_user(bstat->bs_nlink,\t&bstat32->bs_nlink)\t||\n\t    get_user(bstat->bs_uid,\t&bstat32->bs_uid)\t||\n\t    get_user(bstat->bs_gid,\t&bstat32->bs_gid)\t||\n\t    get_user(bstat->bs_rdev,\t&bstat32->bs_rdev)\t||\n\t    get_user(bstat->bs_blksize,\t&bstat32->bs_blksize)\t||\n\t    get_user(bstat->bs_size,\t&bstat32->bs_size)\t||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_atime, &bstat32->bs_atime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_mtime, &bstat32->bs_mtime) ||\n\t    xfs_ioctl32_bstime_copyin(&bstat->bs_ctime, &bstat32->bs_ctime) ||\n\t    get_user(bstat->bs_blocks,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_xflags,\t&bstat32->bs_size)\t||\n\t    get_user(bstat->bs_extsize,\t&bstat32->bs_extsize)\t||\n\t    get_user(bstat->bs_extents,\t&bstat32->bs_extents)\t||\n\t    get_user(bstat->bs_gen,\t&bstat32->bs_gen)\t||\n\t    get_user(bstat->bs_projid_lo, &bstat32->bs_projid_lo) ||\n\t    get_user(bstat->bs_projid_hi, &bstat32->bs_projid_hi) ||\n\t    get_user(bstat->bs_forkoff,\t&bstat32->bs_forkoff)\t||\n\t    get_user(bstat->bs_dmevmask, &bstat32->bs_dmevmask)\t||\n\t    get_user(bstat->bs_dmstate,\t&bstat32->bs_dmstate)\t||\n\t    get_user(bstat->bs_aextents, &bstat32->bs_aextents))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_ioctl32_bstime_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "123-135",
    "snippet": "STATIC int\nxfs_ioctl32_bstime_copyin(\n\txfs_bstime_t\t\t*bstime,\n\tcompat_xfs_bstime_t\t__user *bstime32)\n{\n\tcompat_time_t\t\tsec32;\t/* tv_sec differs on 64 vs. 32 */\n\n\tif (get_user(sec32,\t\t&bstime32->tv_sec)\t||\n\t    get_user(bstime->tv_nsec,\t&bstime32->tv_nsec))\n\t\treturn -EFAULT;\n\tbstime->tv_sec = sec32;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "bstime->tv_nsec",
            "&bstime32->tv_nsec"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_ioctl32_bstime_copyin(\n\txfs_bstime_t\t\t*bstime,\n\tcompat_xfs_bstime_t\t__user *bstime32)\n{\n\tcompat_time_t\t\tsec32;\t/* tv_sec differs on 64 vs. 32 */\n\n\tif (get_user(sec32,\t\t&bstime32->tv_sec)\t||\n\t    get_user(bstime->tv_nsec,\t&bstime32->tv_nsec))\n\t\treturn -EFAULT;\n\tbstime->tv_sec = sec32;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_inumbers_fmt_compat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "99-117",
    "snippet": "STATIC int\nxfs_inumbers_fmt_compat(\n\tvoid\t\t\t__user *ubuffer,\n\tconst struct xfs_inogrp\t*buffer,\n\tlong\t\t\tcount,\n\tlong\t\t\t*written)\n{\n\tcompat_xfs_inogrp_t\t__user *p32 = ubuffer;\n\tlong\t\t\ti;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (put_user(buffer[i].xi_startino,   &p32[i].xi_startino) ||\n\t\t    put_user(buffer[i].xi_alloccount, &p32[i].xi_alloccount) ||\n\t\t    put_user(buffer[i].xi_allocmask,  &p32[i].xi_allocmask))\n\t\t\treturn -EFAULT;\n\t}\n\t*written = count * sizeof(*p32);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [
      "#define xfs_inumbers_fmt_compat xfs_inumbers_fmt"
    ],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer[i].xi_allocmask",
            "&p32[i].xi_allocmask"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer[i].xi_alloccount",
            "&p32[i].xi_alloccount"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "buffer[i].xi_startino",
            "&p32[i].xi_startino"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\n#define xfs_inumbers_fmt_compat xfs_inumbers_fmt\n\nSTATIC struct;\n\nSTATIC int\nxfs_inumbers_fmt_compat(\n\tvoid\t\t\t__user *ubuffer,\n\tconst struct xfs_inogrp\t*buffer,\n\tlong\t\t\tcount,\n\tlong\t\t\t*written)\n{\n\tcompat_xfs_inogrp_t\t__user *p32 = ubuffer;\n\tlong\t\t\ti;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (put_user(buffer[i].xi_startino,   &p32[i].xi_startino) ||\n\t\t    put_user(buffer[i].xi_alloccount, &p32[i].xi_alloccount) ||\n\t\t    put_user(buffer[i].xi_allocmask,  &p32[i].xi_allocmask))\n\t\t\treturn -EFAULT;\n\t}\n\t*written = count * sizeof(*p32);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_compat_growfs_rt_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "88-97",
    "snippet": "STATIC int\nxfs_compat_growfs_rt_copyin(\n\tstruct xfs_growfs_rt\t *in,\n\tcompat_xfs_growfs_rt_t\t__user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->extsize,   &arg32->extsize))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "in->extsize",
            "&arg32->extsize"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_growfs_rt_copyin(\n\tstruct xfs_growfs_rt\t *in,\n\tcompat_xfs_growfs_rt_t\t__user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->extsize,   &arg32->extsize))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_compat_growfs_data_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "77-86",
    "snippet": "STATIC int\nxfs_compat_growfs_data_copyin(\n\tstruct xfs_growfs_data\t *in,\n\tcompat_xfs_growfs_data_t __user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->imaxpct,   &arg32->imaxpct))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "in->imaxpct",
            "&arg32->imaxpct"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_growfs_data_copyin(\n\tstruct xfs_growfs_data\t *in,\n\tcompat_xfs_growfs_data_t __user *arg32)\n{\n\tif (get_user(in->newblocks, &arg32->newblocks) ||\n\t    get_user(in->imaxpct,   &arg32->imaxpct))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_compat_ioc_fsgeometry_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "60-75",
    "snippet": "STATIC int\nxfs_compat_ioc_fsgeometry_v1(\n\tstruct xfs_mount\t  *mp,\n\tcompat_xfs_fsop_geom_v1_t __user *arg32)\n{\n\txfs_fsop_geom_t\t\t  fsgeo;\n\tint\t\t\t  error;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\t/* The 32-bit variant simply has some padding at the end */\n\tif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg32",
            "&fsgeo",
            "sizeof(struct compat_xfs_fsop_geom_v1)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fs_geometry",
          "args": [
            "mp",
            "&fsgeo",
            "3"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fs_geometry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_fsops.c",
          "lines": "48-117",
          "snippet": "int\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_fs_geometry(\n\txfs_mount_t\t\t*mp,\n\txfs_fsop_geom_t\t\t*geo,\n\tint\t\t\tnew_version)\n{\n\n\tmemset(geo, 0, sizeof(*geo));\n\n\tgeo->blocksize = mp->m_sb.sb_blocksize;\n\tgeo->rtextsize = mp->m_sb.sb_rextsize;\n\tgeo->agblocks = mp->m_sb.sb_agblocks;\n\tgeo->agcount = mp->m_sb.sb_agcount;\n\tgeo->logblocks = mp->m_sb.sb_logblocks;\n\tgeo->sectsize = mp->m_sb.sb_sectsize;\n\tgeo->inodesize = mp->m_sb.sb_inodesize;\n\tgeo->imaxpct = mp->m_sb.sb_imax_pct;\n\tgeo->datablocks = mp->m_sb.sb_dblocks;\n\tgeo->rtblocks = mp->m_sb.sb_rblocks;\n\tgeo->rtextents = mp->m_sb.sb_rextents;\n\tgeo->logstart = mp->m_sb.sb_logstart;\n\tASSERT(sizeof(geo->uuid)==sizeof(mp->m_sb.sb_uuid));\n\tmemcpy(geo->uuid, &mp->m_sb.sb_uuid, sizeof(mp->m_sb.sb_uuid));\n\tif (new_version >= 2) {\n\t\tgeo->sunit = mp->m_sb.sb_unit;\n\t\tgeo->swidth = mp->m_sb.sb_width;\n\t}\n\tif (new_version >= 3) {\n\t\tgeo->version = XFS_FSOP_GEOM_VERSION;\n\t\tgeo->flags = XFS_FSOP_GEOM_FLAGS_NLINK |\n\t\t\t     XFS_FSOP_GEOM_FLAGS_DIRV2 |\n\t\t\t(xfs_sb_version_hasattr(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR : 0) |\n\t\t\t(xfs_sb_version_hasquota(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_QUOTA : 0) |\n\t\t\t(xfs_sb_version_hasalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_IALIGN : 0) |\n\t\t\t(xfs_sb_version_hasdalign(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DALIGN : 0) |\n\t\t\t(xfs_sb_version_hasextflgbit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_EXTFLG : 0) |\n\t\t\t(xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_SECTOR : 0) |\n\t\t\t(xfs_sb_version_hasasciici(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_DIRV2CI : 0) |\n\t\t\t(xfs_sb_version_haslazysbcount(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LAZYSB : 0) |\n\t\t\t(xfs_sb_version_hasattr2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_ATTR2 : 0) |\n\t\t\t(xfs_sb_version_hasprojid32bit(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_PROJID32 : 0) |\n\t\t\t(xfs_sb_version_hascrc(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_V5SB : 0) |\n\t\t\t(xfs_sb_version_hasftype(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FTYPE : 0) |\n\t\t\t(xfs_sb_version_hasfinobt(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_FINOBT : 0);\n\t\tgeo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?\n\t\t\t\tmp->m_sb.sb_logsectsize : BBSIZE;\n\t\tgeo->rtsectsize = mp->m_sb.sb_blocksize;\n\t\tgeo->dirblocksize = mp->m_dir_geo->blksize;\n\t}\n\tif (new_version >= 4) {\n\t\tgeo->flags |=\n\t\t\t(xfs_sb_version_haslogv2(&mp->m_sb) ?\n\t\t\t\tXFS_FSOP_GEOM_FLAGS_LOGV2 : 0);\n\t\tgeo->logsunit = mp->m_sb.sb_logsunit;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC struct;\n\nSTATIC int\nxfs_compat_ioc_fsgeometry_v1(\n\tstruct xfs_mount\t  *mp,\n\tcompat_xfs_fsop_geom_v1_t __user *arg32)\n{\n\txfs_fsop_geom_t\t\t  fsgeo;\n\tint\t\t\t  error;\n\n\terror = xfs_fs_geometry(mp, &fsgeo, 3);\n\tif (error)\n\t\treturn error;\n\t/* The 32-bit variant simply has some padding at the end */\n\tif (copy_to_user(arg32, &fsgeo, sizeof(struct compat_xfs_fsop_geom_v1)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_compat_flock64_copyin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_ioctl32.c",
    "lines": "44-58",
    "snippet": "STATIC int\nxfs_compat_flock64_copyin(\n\txfs_flock64_t\t\t*bf,\n\tcompat_xfs_flock64_t\t__user *arg32)\n{\n\tif (get_user(bf->l_type,\t&arg32->l_type) ||\n\t    get_user(bf->l_whence,\t&arg32->l_whence) ||\n\t    get_user(bf->l_start,\t&arg32->l_start) ||\n\t    get_user(bf->l_len,\t\t&arg32->l_len) ||\n\t    get_user(bf->l_sysid,\t&arg32->l_sysid) ||\n\t    get_user(bf->l_pid,\t\t&arg32->l_pid) ||\n\t    copy_from_user(bf->l_pad,\t&arg32->l_pad,\t4*sizeof(u32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_ioctl32.h\"",
      "#include \"xfs_ioctl.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_fsops.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/ioctl.h>",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "bf->l_pad",
            "&arg32->l_pad",
            "4*sizeof(u32)"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "bf->l_pid",
            "&arg32->l_pid"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_ioctl32.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/ioctl.h>\n#include <linux/compat.h>\n\nSTATIC int\nxfs_compat_flock64_copyin(\n\txfs_flock64_t\t\t*bf,\n\tcompat_xfs_flock64_t\t__user *arg32)\n{\n\tif (get_user(bf->l_type,\t&arg32->l_type) ||\n\t    get_user(bf->l_whence,\t&arg32->l_whence) ||\n\t    get_user(bf->l_start,\t&arg32->l_start) ||\n\t    get_user(bf->l_len,\t\t&arg32->l_len) ||\n\t    get_user(bf->l_sysid,\t&arg32->l_sysid) ||\n\t    get_user(bf->l_pid,\t\t&arg32->l_pid) ||\n\t    copy_from_user(bf->l_pad,\t&arg32->l_pad,\t4*sizeof(u32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  }
]