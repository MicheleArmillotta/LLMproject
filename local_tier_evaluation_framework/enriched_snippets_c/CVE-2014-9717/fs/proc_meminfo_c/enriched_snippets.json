[
  {
    "function_name": "proc_meminfo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
    "lines": "229-233",
    "snippet": "static int __init proc_meminfo_init(void)\n{\n\tproc_create(\"meminfo\", 0, NULL, &meminfo_proc_fops);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/cma.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/swap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quicklist.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations meminfo_proc_fops = {\n\t.open\t\t= meminfo_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"meminfo\"",
            "0",
            "NULL",
            "&meminfo_proc_fops"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "355-391",
          "snippet": "static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  umode_t mode,\n\t\t\t\t\t  nlink_t nlink)\n{\n\tstruct proc_dir_entry *ent = NULL;\n\tconst char *fn;\n\tstruct qstr qstr;\n\n\tif (xlate_proc_name(name, parent, &fn) != 0)\n\t\tgoto out;\n\tqstr.name = fn;\n\tqstr.len = strlen(fn);\n\tif (qstr.len == 0 || qstr.len >= 256) {\n\t\tWARN(1, \"name len %u\\n\", qstr.len);\n\t\treturn NULL;\n\t}\n\tif (*parent == &proc_root && name_to_int(&qstr) != ~0U) {\n\t\tWARN(1, \"create '/proc/%s' by hand\\n\", qstr.name);\n\t\treturn NULL;\n\t}\n\n\tent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);\n\tif (!ent)\n\t\tgoto out;\n\n\tmemcpy(ent->name, fn, qstr.len + 1);\n\tent->namelen = qstr.len;\n\tent->mode = mode;\n\tent->nlink = nlink;\n\tent->subdir = RB_ROOT;\n\tatomic_set(&ent->count, 1);\n\tspin_lock_init(&ent->pde_unload_lock);\n\tINIT_LIST_HEAD(&ent->pde_openers);\nout:\n\treturn ent;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations meminfo_proc_fops = {\n\t.open\t\t= meminfo_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init proc_meminfo_init(void)\n{\n\tproc_create(\"meminfo\", 0, NULL, &meminfo_proc_fops);\n\treturn 0;\n}"
  },
  {
    "function_name": "meminfo_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
    "lines": "217-220",
    "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/cma.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/swap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quicklist.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "meminfo_proc_show",
            "NULL"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
  },
  {
    "function_name": "meminfo_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
    "lines": "26-215",
    "snippet": "static int meminfo_proc_show(struct seq_file *m, void *v)\n{\n\tstruct sysinfo i;\n\tunsigned long committed;\n\tstruct vmalloc_info vmi;\n\tlong cached;\n\tlong available;\n\tunsigned long pagecache;\n\tunsigned long wmark_low = 0;\n\tunsigned long pages[NR_LRU_LISTS];\n\tstruct zone *zone;\n\tint lru;\n\n/*\n * display in kilobytes.\n */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tsi_meminfo(&i);\n\tsi_swapinfo(&i);\n\tcommitted = percpu_counter_read_positive(&vm_committed_as);\n\n\tcached = global_page_state(NR_FILE_PAGES) -\n\t\t\ttotal_swapcache_pages() - i.bufferram;\n\tif (cached < 0)\n\t\tcached = 0;\n\n\tget_vmalloc_info(&vmi);\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_page_state(NR_LRU_BASE + lru);\n\n\tfor_each_zone(zone)\n\t\twmark_low += zone->watermark[WMARK_LOW];\n\n\t/*\n\t * Estimate the amount of memory available for userspace allocations,\n\t * without causing swapping.\n\t *\n\t * Free memory cannot be taken below the low watermark, before the\n\t * system starts swapping.\n\t */\n\tavailable = i.freeram - wmark_low;\n\n\t/*\n\t * Not all the page cache can be freed, otherwise the system will\n\t * start swapping. Assume at least half of the page cache, or the\n\t * low watermark worth of cache, needs to stay.\n\t */\n\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\n\tpagecache -= min(pagecache / 2, wmark_low);\n\tavailable += pagecache;\n\n\t/*\n\t * Part of the reclaimable slab consists of items that are in use,\n\t * and cannot be freed. Cap this estimate at the low watermark.\n\t */\n\tavailable += global_page_state(NR_SLAB_RECLAIMABLE) -\n\t\t     min(global_page_state(NR_SLAB_RECLAIMABLE) / 2, wmark_low);\n\n\tif (available < 0)\n\t\tavailable = 0;\n\n\t/*\n\t * Tagged format, for easy grepping and expansion.\n\t */\n\tseq_printf(m,\n\t\t\"MemTotal:       %8lu kB\\n\"\n\t\t\"MemFree:        %8lu kB\\n\"\n\t\t\"MemAvailable:   %8lu kB\\n\"\n\t\t\"Buffers:        %8lu kB\\n\"\n\t\t\"Cached:         %8lu kB\\n\"\n\t\t\"SwapCached:     %8lu kB\\n\"\n\t\t\"Active:         %8lu kB\\n\"\n\t\t\"Inactive:       %8lu kB\\n\"\n\t\t\"Active(anon):   %8lu kB\\n\"\n\t\t\"Inactive(anon): %8lu kB\\n\"\n\t\t\"Active(file):   %8lu kB\\n\"\n\t\t\"Inactive(file): %8lu kB\\n\"\n\t\t\"Unevictable:    %8lu kB\\n\"\n\t\t\"Mlocked:        %8lu kB\\n\"\n#ifdef CONFIG_HIGHMEM\n\t\t\"HighTotal:      %8lu kB\\n\"\n\t\t\"HighFree:       %8lu kB\\n\"\n\t\t\"LowTotal:       %8lu kB\\n\"\n\t\t\"LowFree:        %8lu kB\\n\"\n#endif\n#ifndef CONFIG_MMU\n\t\t\"MmapCopy:       %8lu kB\\n\"\n#endif\n\t\t\"SwapTotal:      %8lu kB\\n\"\n\t\t\"SwapFree:       %8lu kB\\n\"\n\t\t\"Dirty:          %8lu kB\\n\"\n\t\t\"Writeback:      %8lu kB\\n\"\n\t\t\"AnonPages:      %8lu kB\\n\"\n\t\t\"Mapped:         %8lu kB\\n\"\n\t\t\"Shmem:          %8lu kB\\n\"\n\t\t\"Slab:           %8lu kB\\n\"\n\t\t\"SReclaimable:   %8lu kB\\n\"\n\t\t\"SUnreclaim:     %8lu kB\\n\"\n\t\t\"KernelStack:    %8lu kB\\n\"\n\t\t\"PageTables:     %8lu kB\\n\"\n#ifdef CONFIG_QUICKLIST\n\t\t\"Quicklists:     %8lu kB\\n\"\n#endif\n\t\t\"NFS_Unstable:   %8lu kB\\n\"\n\t\t\"Bounce:         %8lu kB\\n\"\n\t\t\"WritebackTmp:   %8lu kB\\n\"\n\t\t\"CommitLimit:    %8lu kB\\n\"\n\t\t\"Committed_AS:   %8lu kB\\n\"\n\t\t\"VmallocTotal:   %8lu kB\\n\"\n\t\t\"VmallocUsed:    %8lu kB\\n\"\n\t\t\"VmallocChunk:   %8lu kB\\n\"\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t\"HardwareCorrupted: %5lu kB\\n\"\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\"AnonHugePages:  %8lu kB\\n\"\n#endif\n#ifdef CONFIG_CMA\n\t\t\"CmaTotal:       %8lu kB\\n\"\n\t\t\"CmaFree:        %8lu kB\\n\"\n#endif\n\t\t,\n\t\tK(i.totalram),\n\t\tK(i.freeram),\n\t\tK(available),\n\t\tK(i.bufferram),\n\t\tK(cached),\n\t\tK(total_swapcache_pages()),\n\t\tK(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE]),\n\t\tK(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),\n\t\tK(pages[LRU_ACTIVE_ANON]),\n\t\tK(pages[LRU_INACTIVE_ANON]),\n\t\tK(pages[LRU_ACTIVE_FILE]),\n\t\tK(pages[LRU_INACTIVE_FILE]),\n\t\tK(pages[LRU_UNEVICTABLE]),\n\t\tK(global_page_state(NR_MLOCK)),\n#ifdef CONFIG_HIGHMEM\n\t\tK(i.totalhigh),\n\t\tK(i.freehigh),\n\t\tK(i.totalram-i.totalhigh),\n\t\tK(i.freeram-i.freehigh),\n#endif\n#ifndef CONFIG_MMU\n\t\tK((unsigned long) atomic_long_read(&mmap_pages_allocated)),\n#endif\n\t\tK(i.totalswap),\n\t\tK(i.freeswap),\n\t\tK(global_page_state(NR_FILE_DIRTY)),\n\t\tK(global_page_state(NR_WRITEBACK)),\n\t\tK(global_page_state(NR_ANON_PAGES)),\n\t\tK(global_page_state(NR_FILE_MAPPED)),\n\t\tK(i.sharedram),\n\t\tK(global_page_state(NR_SLAB_RECLAIMABLE) +\n\t\t\t\tglobal_page_state(NR_SLAB_UNRECLAIMABLE)),\n\t\tK(global_page_state(NR_SLAB_RECLAIMABLE)),\n\t\tK(global_page_state(NR_SLAB_UNRECLAIMABLE)),\n\t\tglobal_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,\n\t\tK(global_page_state(NR_PAGETABLE)),\n#ifdef CONFIG_QUICKLIST\n\t\tK(quicklist_total_size()),\n#endif\n\t\tK(global_page_state(NR_UNSTABLE_NFS)),\n\t\tK(global_page_state(NR_BOUNCE)),\n\t\tK(global_page_state(NR_WRITEBACK_TEMP)),\n\t\tK(vm_commit_limit()),\n\t\tK(committed),\n\t\t(unsigned long)VMALLOC_TOTAL >> 10,\n\t\tvmi.used >> 10,\n\t\tvmi.largest_chunk >> 10\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t, atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10)\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t, K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *\n\t\t   HPAGE_PMD_NR)\n#endif\n#ifdef CONFIG_CMA\n\t\t, K(totalcma_pages)\n\t\t, K(global_page_state(NR_FREE_CMA_PAGES))\n#endif\n\t\t);\n\n\thugetlb_report_meminfo(m);\n\n\tarch_report_meminfo(m);\n\n\treturn 0;\n#undef K\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/cma.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/swap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quicklist.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_report_meminfo",
          "args": [
            "m"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "arch_report_meminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "22-24",
          "snippet": "void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid __attribute__((weak)) arch_report_meminfo(struct seq_file *m)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hugetlb_report_meminfo",
          "args": [
            "m"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"MemTotal:       %8lu kB\\n\"\n\t\t\"MemFree:        %8lu kB\\n\"\n\t\t\"MemAvailable:   %8lu kB\\n\"\n\t\t\"Buffers:        %8lu kB\\n\"\n\t\t\"Cached:         %8lu kB\\n\"\n\t\t\"SwapCached:     %8lu kB\\n\"\n\t\t\"Active:         %8lu kB\\n\"\n\t\t\"Inactive:       %8lu kB\\n\"\n\t\t\"Active(anon):   %8lu kB\\n\"\n\t\t\"Inactive(anon): %8lu kB\\n\"\n\t\t\"Active(file):   %8lu kB\\n\"\n\t\t\"Inactive(file): %8lu kB\\n\"\n\t\t\"Unevictable:    %8lu kB\\n\"\n\t\t\"Mlocked:        %8lu kB\\n\"\n#ifdef CONFIG_HIGHMEM\n\t\t\"HighTotal:      %8lu kB\\n\"\n\t\t\"HighFree:       %8lu kB\\n\"\n\t\t\"LowTotal:       %8lu kB\\n\"\n\t\t\"LowFree:        %8lu kB\\n\"\n#endif\n#ifndef CONFIG_MMU\n\t\t\"MmapCopy:       %8lu kB\\n\"\n#endif\n\t\t\"SwapTotal:      %8lu kB\\n\"\n\t\t\"SwapFree:       %8lu kB\\n\"\n\t\t\"Dirty:          %8lu kB\\n\"\n\t\t\"Writeback:      %8lu kB\\n\"\n\t\t\"AnonPages:      %8lu kB\\n\"\n\t\t\"Mapped:         %8lu kB\\n\"\n\t\t\"Shmem:          %8lu kB\\n\"\n\t\t\"Slab:           %8lu kB\\n\"\n\t\t\"SReclaimable:   %8lu kB\\n\"\n\t\t\"SUnreclaim:     %8lu kB\\n\"\n\t\t\"KernelStack:    %8lu kB\\n\"\n\t\t\"PageTables:     %8lu kB\\n\"\n#ifdef CONFIG_QUICKLIST\n\t\t\"Quicklists:     %8lu kB\\n\"\n#endif\n\t\t\"NFS_Unstable:   %8lu kB\\n\"\n\t\t\"Bounce:         %8lu kB\\n\"\n\t\t\"WritebackTmp:   %8lu kB\\n\"\n\t\t\"CommitLimit:    %8lu kB\\n\"\n\t\t\"Committed_AS:   %8lu kB\\n\"\n\t\t\"VmallocTotal:   %8lu kB\\n\"\n\t\t\"VmallocUsed:    %8lu kB\\n\"\n\t\t\"VmallocChunk:   %8lu kB\\n\"\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t\"HardwareCorrupted: %5lu kB\\n\"\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\"AnonHugePages:  %8lu kB\\n\"\n#endif\n#ifdefCONFIG_CMA\n\t\t\"CmaTotal:       %8lu kB\\n\"\n\t\t\"CmaFree:        %8lu kB\\n\"#endif",
            "K(i.totalram)",
            "K(i.freeram)",
            "K(available)",
            "K(i.bufferram)",
            "K(cached)",
            "K(total_swapcache_pages())",
            "K(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE])",
            "K(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE])",
            "K(pages[LRU_ACTIVE_ANON])",
            "K(pages[LRU_INACTIVE_ANON])",
            "K(pages[LRU_ACTIVE_FILE])",
            "K(pages[LRU_INACTIVE_FILE])",
            "K(pages[LRU_UNEVICTABLE])",
            "K(global_page_state(NR_MLOCK))",
            "#ifdef CONFIG_HIGHMEMK(i.totalhigh)",
            "K(i.freehigh)",
            "K(i.totalram-i.totalhigh)",
            "K(i.freeram-i.freehigh)",
            "#endif\n#ifndef CONFIG_MMUK((unsigned long) atomic_long_read(&mmap_pages_allocated))",
            "#endifK(i.totalswap)",
            "K(i.freeswap)",
            "K(global_page_state(NR_FILE_DIRTY))",
            "K(global_page_state(NR_WRITEBACK))",
            "K(global_page_state(NR_ANON_PAGES))",
            "K(global_page_state(NR_FILE_MAPPED))",
            "K(i.sharedram)",
            "K(global_page_state(NR_SLAB_RECLAIMABLE) +\n\t\t\t\tglobal_page_state(NR_SLAB_UNRECLAIMABLE))",
            "K(global_page_state(NR_SLAB_RECLAIMABLE))",
            "K(global_page_state(NR_SLAB_UNRECLAIMABLE))",
            "global_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024",
            "K(global_page_state(NR_PAGETABLE))",
            "#ifdef CONFIG_QUICKLISTK(quicklist_total_size())",
            "#endifK(global_page_state(NR_UNSTABLE_NFS))",
            "K(global_page_state(NR_BOUNCE))",
            "K(global_page_state(NR_WRITEBACK_TEMP))",
            "K(vm_commit_limit())",
            "K(committed)",
            "(unsigned long)VMALLOC_TOTAL >> 10",
            "vmi.used >> 10",
            "vmi.largest_chunk >> 10#ifdef CONFIG_MEMORY_FAILURE",
            "atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10)#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE",
            "K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *\n\t\t   HPAGE_PMD_NR)#endif\n#ifdef CONFIG_CMA",
            "K(totalcma_pages)",
            "K(global_page_state(NR_FREE_CMA_PAGES))#endif"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "global_page_state(NR_FREE_CMA_PAGES)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_HAS_BLOCKS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "814-820",
          "snippet": "static inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1\n\nstatic inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FREE_CMA_PAGES"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_ANON_TRANSPARENT_HUGEPAGES"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&num_poisoned_pages"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_commit_limit",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_WRITEBACK_TEMP"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_BOUNCE"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quicklist_total_size",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_PAGETABLE"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_KERNEL_STACK"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_UNRECLAIMABLE"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_UNRECLAIMABLE"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FILE_MAPPED"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_ANON_PAGES"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_WRITEBACK"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&mmap_pages_allocated"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_MLOCK"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "total_swapcache_pages",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "global_page_state(NR_SLAB_RECLAIMABLE) / 2",
            "wmark_low"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_LRU_BASE + lru"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vmalloc_info",
          "args": [
            "&vmi"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "total_swapcache_pages",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_page_state",
          "args": [
            "NR_FILE_PAGES"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&vm_committed_as"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_swapinfo",
          "args": [
            "&i"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&i"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_show(struct seq_file *m, void *v)\n{\n\tstruct sysinfo i;\n\tunsigned long committed;\n\tstruct vmalloc_info vmi;\n\tlong cached;\n\tlong available;\n\tunsigned long pagecache;\n\tunsigned long wmark_low = 0;\n\tunsigned long pages[NR_LRU_LISTS];\n\tstruct zone *zone;\n\tint lru;\n\n/*\n * display in kilobytes.\n */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tsi_meminfo(&i);\n\tsi_swapinfo(&i);\n\tcommitted = percpu_counter_read_positive(&vm_committed_as);\n\n\tcached = global_page_state(NR_FILE_PAGES) -\n\t\t\ttotal_swapcache_pages() - i.bufferram;\n\tif (cached < 0)\n\t\tcached = 0;\n\n\tget_vmalloc_info(&vmi);\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_page_state(NR_LRU_BASE + lru);\n\n\tfor_each_zone(zone)\n\t\twmark_low += zone->watermark[WMARK_LOW];\n\n\t/*\n\t * Estimate the amount of memory available for userspace allocations,\n\t * without causing swapping.\n\t *\n\t * Free memory cannot be taken below the low watermark, before the\n\t * system starts swapping.\n\t */\n\tavailable = i.freeram - wmark_low;\n\n\t/*\n\t * Not all the page cache can be freed, otherwise the system will\n\t * start swapping. Assume at least half of the page cache, or the\n\t * low watermark worth of cache, needs to stay.\n\t */\n\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\n\tpagecache -= min(pagecache / 2, wmark_low);\n\tavailable += pagecache;\n\n\t/*\n\t * Part of the reclaimable slab consists of items that are in use,\n\t * and cannot be freed. Cap this estimate at the low watermark.\n\t */\n\tavailable += global_page_state(NR_SLAB_RECLAIMABLE) -\n\t\t     min(global_page_state(NR_SLAB_RECLAIMABLE) / 2, wmark_low);\n\n\tif (available < 0)\n\t\tavailable = 0;\n\n\t/*\n\t * Tagged format, for easy grepping and expansion.\n\t */\n\tseq_printf(m,\n\t\t\"MemTotal:       %8lu kB\\n\"\n\t\t\"MemFree:        %8lu kB\\n\"\n\t\t\"MemAvailable:   %8lu kB\\n\"\n\t\t\"Buffers:        %8lu kB\\n\"\n\t\t\"Cached:         %8lu kB\\n\"\n\t\t\"SwapCached:     %8lu kB\\n\"\n\t\t\"Active:         %8lu kB\\n\"\n\t\t\"Inactive:       %8lu kB\\n\"\n\t\t\"Active(anon):   %8lu kB\\n\"\n\t\t\"Inactive(anon): %8lu kB\\n\"\n\t\t\"Active(file):   %8lu kB\\n\"\n\t\t\"Inactive(file): %8lu kB\\n\"\n\t\t\"Unevictable:    %8lu kB\\n\"\n\t\t\"Mlocked:        %8lu kB\\n\"\n#ifdef CONFIG_HIGHMEM\n\t\t\"HighTotal:      %8lu kB\\n\"\n\t\t\"HighFree:       %8lu kB\\n\"\n\t\t\"LowTotal:       %8lu kB\\n\"\n\t\t\"LowFree:        %8lu kB\\n\"\n#endif\n#ifndef CONFIG_MMU\n\t\t\"MmapCopy:       %8lu kB\\n\"\n#endif\n\t\t\"SwapTotal:      %8lu kB\\n\"\n\t\t\"SwapFree:       %8lu kB\\n\"\n\t\t\"Dirty:          %8lu kB\\n\"\n\t\t\"Writeback:      %8lu kB\\n\"\n\t\t\"AnonPages:      %8lu kB\\n\"\n\t\t\"Mapped:         %8lu kB\\n\"\n\t\t\"Shmem:          %8lu kB\\n\"\n\t\t\"Slab:           %8lu kB\\n\"\n\t\t\"SReclaimable:   %8lu kB\\n\"\n\t\t\"SUnreclaim:     %8lu kB\\n\"\n\t\t\"KernelStack:    %8lu kB\\n\"\n\t\t\"PageTables:     %8lu kB\\n\"\n#ifdef CONFIG_QUICKLIST\n\t\t\"Quicklists:     %8lu kB\\n\"\n#endif\n\t\t\"NFS_Unstable:   %8lu kB\\n\"\n\t\t\"Bounce:         %8lu kB\\n\"\n\t\t\"WritebackTmp:   %8lu kB\\n\"\n\t\t\"CommitLimit:    %8lu kB\\n\"\n\t\t\"Committed_AS:   %8lu kB\\n\"\n\t\t\"VmallocTotal:   %8lu kB\\n\"\n\t\t\"VmallocUsed:    %8lu kB\\n\"\n\t\t\"VmallocChunk:   %8lu kB\\n\"\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t\"HardwareCorrupted: %5lu kB\\n\"\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\"AnonHugePages:  %8lu kB\\n\"\n#endif\n#ifdef CONFIG_CMA\n\t\t\"CmaTotal:       %8lu kB\\n\"\n\t\t\"CmaFree:        %8lu kB\\n\"\n#endif\n\t\t,\n\t\tK(i.totalram),\n\t\tK(i.freeram),\n\t\tK(available),\n\t\tK(i.bufferram),\n\t\tK(cached),\n\t\tK(total_swapcache_pages()),\n\t\tK(pages[LRU_ACTIVE_ANON]   + pages[LRU_ACTIVE_FILE]),\n\t\tK(pages[LRU_INACTIVE_ANON] + pages[LRU_INACTIVE_FILE]),\n\t\tK(pages[LRU_ACTIVE_ANON]),\n\t\tK(pages[LRU_INACTIVE_ANON]),\n\t\tK(pages[LRU_ACTIVE_FILE]),\n\t\tK(pages[LRU_INACTIVE_FILE]),\n\t\tK(pages[LRU_UNEVICTABLE]),\n\t\tK(global_page_state(NR_MLOCK)),\n#ifdef CONFIG_HIGHMEM\n\t\tK(i.totalhigh),\n\t\tK(i.freehigh),\n\t\tK(i.totalram-i.totalhigh),\n\t\tK(i.freeram-i.freehigh),\n#endif\n#ifndef CONFIG_MMU\n\t\tK((unsigned long) atomic_long_read(&mmap_pages_allocated)),\n#endif\n\t\tK(i.totalswap),\n\t\tK(i.freeswap),\n\t\tK(global_page_state(NR_FILE_DIRTY)),\n\t\tK(global_page_state(NR_WRITEBACK)),\n\t\tK(global_page_state(NR_ANON_PAGES)),\n\t\tK(global_page_state(NR_FILE_MAPPED)),\n\t\tK(i.sharedram),\n\t\tK(global_page_state(NR_SLAB_RECLAIMABLE) +\n\t\t\t\tglobal_page_state(NR_SLAB_UNRECLAIMABLE)),\n\t\tK(global_page_state(NR_SLAB_RECLAIMABLE)),\n\t\tK(global_page_state(NR_SLAB_UNRECLAIMABLE)),\n\t\tglobal_page_state(NR_KERNEL_STACK) * THREAD_SIZE / 1024,\n\t\tK(global_page_state(NR_PAGETABLE)),\n#ifdef CONFIG_QUICKLIST\n\t\tK(quicklist_total_size()),\n#endif\n\t\tK(global_page_state(NR_UNSTABLE_NFS)),\n\t\tK(global_page_state(NR_BOUNCE)),\n\t\tK(global_page_state(NR_WRITEBACK_TEMP)),\n\t\tK(vm_commit_limit()),\n\t\tK(committed),\n\t\t(unsigned long)VMALLOC_TOTAL >> 10,\n\t\tvmi.used >> 10,\n\t\tvmi.largest_chunk >> 10\n#ifdef CONFIG_MEMORY_FAILURE\n\t\t, atomic_long_read(&num_poisoned_pages) << (PAGE_SHIFT - 10)\n#endif\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t, K(global_page_state(NR_ANON_TRANSPARENT_HUGEPAGES) *\n\t\t   HPAGE_PMD_NR)\n#endif\n#ifdef CONFIG_CMA\n\t\t, K(totalcma_pages)\n\t\t, K(global_page_state(NR_FREE_CMA_PAGES))\n#endif\n\t\t);\n\n\thugetlb_report_meminfo(m);\n\n\tarch_report_meminfo(m);\n\n\treturn 0;\n#undef K\n}"
  },
  {
    "function_name": "arch_report_meminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
    "lines": "22-24",
    "snippet": "void __attribute__((weak)) arch_report_meminfo(struct seq_file *m)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <linux/cma.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/swap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/quicklist.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mman.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid __attribute__((weak)) arch_report_meminfo(struct seq_file *m)\n{\n}"
  }
]