[
  {
    "function_name": "ecryptfs_destroy_ecryptfs_miscdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "507-511",
    "snippet": "void ecryptfs_destroy_ecryptfs_miscdev(void)\n{\n\tBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\n\tmisc_deregister(&ecryptfs_miscdev);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ecryptfs_num_miscdev_opens;",
      "static struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&ecryptfs_miscdev"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&ecryptfs_num_miscdev_opens) != 0"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ecryptfs_num_miscdev_opens"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\nstatic struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};\n\nvoid ecryptfs_destroy_ecryptfs_miscdev(void)\n{\n\tBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\n\tmisc_deregister(&ecryptfs_miscdev);\n}"
  },
  {
    "function_name": "ecryptfs_init_ecryptfs_miscdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "488-499",
    "snippet": "int __init ecryptfs_init_ecryptfs_miscdev(void)\n{\n\tint rc;\n\n\tatomic_set(&ecryptfs_num_miscdev_opens, 0);\n\trc = misc_register(&ecryptfs_miscdev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ecryptfs_num_miscdev_opens;",
      "static struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&ecryptfs_miscdev"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ecryptfs_num_miscdev_opens",
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\nstatic struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};\n\nint __init ecryptfs_init_ecryptfs_miscdev(void)\n{\n\tint rc;\n\n\tatomic_set(&ecryptfs_num_miscdev_opens, 0);\n\trc = misc_register(&ecryptfs_miscdev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "368-459",
    "snippet": "static ssize_t\necryptfs_miscdev_write(struct file *file, const char __user *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\t__be32 counter_nbo;\n\tu32 seq;\n\tsize_t packet_size, packet_size_length;\n\tchar *data;\n\tunsigned char packet_size_peek[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tssize_t rc;\n\n\tif (count == 0) {\n\t\treturn 0;\n\t} else if (count == MIN_NON_MSG_PKT_SIZE) {\n\t\t/* Likely a harmless MSG_HELO or MSG_QUIT - no packet length */\n\t\tgoto memdup;\n\t} else if (count < MIN_MSG_PKT_SIZE || count > MAX_MSG_PKT_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: Acceptable packet size range is \"\n\t\t       \"[%d-%zu], but amount of data written is [%zu].\",\n\t\t       __func__, MIN_MSG_PKT_SIZE, MAX_MSG_PKT_SIZE, count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(packet_size_peek, &buf[PKT_LEN_OFFSET],\n\t\t\t   sizeof(packet_size_peek))) {\n\t\tprintk(KERN_WARNING \"%s: Error while inspecting packet size\\n\",\n\t\t       __func__);\n\t\treturn -EFAULT;\n\t}\n\n\trc = ecryptfs_parse_packet_length(packet_size_peek, &packet_size,\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%zd]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif ((PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_size_length + packet_size)\n\t    != count) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet size [%zu]\\n\", __func__,\n\t\t       packet_size);\n\t\treturn -EINVAL;\n\t}\n\nmemdup:\n\tdata = memdup_user(buf, count);\n\tif (IS_ERR(data)) {\n\t\tprintk(KERN_ERR \"%s: memdup_user returned error [%ld]\\n\",\n\t\t       __func__, PTR_ERR(data));\n\t\treturn PTR_ERR(data);\n\t}\n\tswitch (data[PKT_TYPE_OFFSET]) {\n\tcase ECRYPTFS_MSG_RESPONSE:\n\t\tif (count < (MIN_MSG_PKT_SIZE\n\t\t\t     + sizeof(struct ecryptfs_message))) {\n\t\t\tprintk(KERN_WARNING \"%s: Minimum acceptable packet \"\n\t\t\t       \"size is [%zd], but amount of data written is \"\n\t\t\t       \"only [%zd]. Discarding response packet.\\n\",\n\t\t\t       __func__,\n\t\t\t       (MIN_MSG_PKT_SIZE\n\t\t\t\t+ sizeof(struct ecryptfs_message)), count);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(&counter_nbo, &data[PKT_CTR_OFFSET], PKT_CTR_SIZE);\n\t\tseq = be32_to_cpu(counter_nbo);\n\t\trc = ecryptfs_miscdev_response(file->private_data,\n\t\t\t\t&data[PKT_LEN_OFFSET + packet_size_length],\n\t\t\t\tpacket_size, seq);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"%s: Failed to deliver miscdev \"\n\t\t\t       \"response to requesting operation; rc = [%zd]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase ECRYPTFS_MSG_HELO:\n\tcase ECRYPTFS_MSG_QUIT:\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Dropping miscdev \"\n\t\t\t\t\"message of unrecognized type [%d]\\n\",\n\t\t\t\tdata[0]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = count;\nout_free:\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define PKT_LEN_OFFSET\t\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)",
      "#define PKT_CTR_OFFSET\t\tPKT_TYPE_SIZE",
      "#define PKT_TYPE_OFFSET\t\t0",
      "#define MAX_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MAX_PKT_LEN_SIZE \\\n\t\t\t\t + sizeof(struct ecryptfs_message) \\\n\t\t\t\t + 4 + ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES)",
      "#define MIN_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MIN_PKT_LEN_SIZE)",
      "#define MIN_NON_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)",
      "#define PKT_CTR_SIZE\t\t4",
      "#define PKT_TYPE_SIZE\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Dropping miscdev \"\n\t\t\t\t\"message of unrecognized type [%d]\\n\"",
            "data[0]"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_miscdev_response",
          "args": [
            "file->private_data",
            "&data[PKT_LEN_OFFSET + packet_size_length]",
            "packet_size",
            "seq"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_miscdev_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
          "lines": "338-357",
          "snippet": "static int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\n\t\t\t\t     size_t data_size, u32 seq)\n{\n\tstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\n\tint rc;\n\n\tif ((sizeof(*msg) + msg->data_len) != data_size) {\n\t\tprintk(KERN_WARNING \"%s: (sizeof(*msg) + msg->data_len) = \"\n\t\t       \"[%zd]; data_size = [%zd]. Invalid packet.\\n\", __func__,\n\t\t       (sizeof(*msg) + msg->data_len), data_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_process_response(daemon, msg, seq);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/random.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\n\t\t\t\t     size_t data_size, u32 seq)\n{\n\tstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\n\tint rc;\n\n\tif ((sizeof(*msg) + msg->data_len) != data_size) {\n\t\tprintk(KERN_WARNING \"%s: (sizeof(*msg) + msg->data_len) = \"\n\t\t       \"[%zd]; data_size = [%zd]. Invalid packet.\\n\", __func__,\n\t\t       (sizeof(*msg) + msg->data_len), data_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_process_response(daemon, msg, seq);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "counter_nbo"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&counter_nbo",
            "&data[PKT_CTR_OFFSET]",
            "PKT_CTR_SIZE"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "buf",
            "count"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "packet_size_peek",
            "&packet_size",
            "&packet_size_length"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "packet_size_peek",
            "&buf[PKT_LEN_OFFSET]",
            "sizeof(packet_size_peek)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\n#define PKT_LEN_OFFSET\t\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)\n#define PKT_CTR_OFFSET\t\tPKT_TYPE_SIZE\n#define PKT_TYPE_OFFSET\t\t0\n#define MAX_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MAX_PKT_LEN_SIZE \\\n\t\t\t\t + sizeof(struct ecryptfs_message) \\\n\t\t\t\t + 4 + ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES)\n#define MIN_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE \\\n\t\t\t\t + ECRYPTFS_MIN_PKT_LEN_SIZE)\n#define MIN_NON_MSG_PKT_SIZE\t(PKT_TYPE_SIZE + PKT_CTR_SIZE)\n#define PKT_CTR_SIZE\t\t4\n#define PKT_TYPE_SIZE\t\t1\n\nstatic ssize_t\necryptfs_miscdev_write(struct file *file, const char __user *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\t__be32 counter_nbo;\n\tu32 seq;\n\tsize_t packet_size, packet_size_length;\n\tchar *data;\n\tunsigned char packet_size_peek[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tssize_t rc;\n\n\tif (count == 0) {\n\t\treturn 0;\n\t} else if (count == MIN_NON_MSG_PKT_SIZE) {\n\t\t/* Likely a harmless MSG_HELO or MSG_QUIT - no packet length */\n\t\tgoto memdup;\n\t} else if (count < MIN_MSG_PKT_SIZE || count > MAX_MSG_PKT_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: Acceptable packet size range is \"\n\t\t       \"[%d-%zu], but amount of data written is [%zu].\",\n\t\t       __func__, MIN_MSG_PKT_SIZE, MAX_MSG_PKT_SIZE, count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(packet_size_peek, &buf[PKT_LEN_OFFSET],\n\t\t\t   sizeof(packet_size_peek))) {\n\t\tprintk(KERN_WARNING \"%s: Error while inspecting packet size\\n\",\n\t\t       __func__);\n\t\treturn -EFAULT;\n\t}\n\n\trc = ecryptfs_parse_packet_length(packet_size_peek, &packet_size,\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%zd]\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif ((PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_size_length + packet_size)\n\t    != count) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet size [%zu]\\n\", __func__,\n\t\t       packet_size);\n\t\treturn -EINVAL;\n\t}\n\nmemdup:\n\tdata = memdup_user(buf, count);\n\tif (IS_ERR(data)) {\n\t\tprintk(KERN_ERR \"%s: memdup_user returned error [%ld]\\n\",\n\t\t       __func__, PTR_ERR(data));\n\t\treturn PTR_ERR(data);\n\t}\n\tswitch (data[PKT_TYPE_OFFSET]) {\n\tcase ECRYPTFS_MSG_RESPONSE:\n\t\tif (count < (MIN_MSG_PKT_SIZE\n\t\t\t     + sizeof(struct ecryptfs_message))) {\n\t\t\tprintk(KERN_WARNING \"%s: Minimum acceptable packet \"\n\t\t\t       \"size is [%zd], but amount of data written is \"\n\t\t\t       \"only [%zd]. Discarding response packet.\\n\",\n\t\t\t       __func__,\n\t\t\t       (MIN_MSG_PKT_SIZE\n\t\t\t\t+ sizeof(struct ecryptfs_message)), count);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(&counter_nbo, &data[PKT_CTR_OFFSET], PKT_CTR_SIZE);\n\t\tseq = be32_to_cpu(counter_nbo);\n\t\trc = ecryptfs_miscdev_response(file->private_data,\n\t\t\t\t&data[PKT_LEN_OFFSET + packet_size_length],\n\t\t\t\tpacket_size, seq);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"%s: Failed to deliver miscdev \"\n\t\t\t       \"response to requesting operation; rc = [%zd]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tbreak;\n\tcase ECRYPTFS_MSG_HELO:\n\tcase ECRYPTFS_MSG_QUIT:\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Dropping miscdev \"\n\t\t\t\t\"message of unrecognized type [%d]\\n\",\n\t\t\t\tdata[0]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = count;\nout_free:\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "338-357",
    "snippet": "static int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\n\t\t\t\t     size_t data_size, u32 seq)\n{\n\tstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\n\tint rc;\n\n\tif ((sizeof(*msg) + msg->data_len) != data_size) {\n\t\tprintk(KERN_WARNING \"%s: (sizeof(*msg) + msg->data_len) = \"\n\t\t       \"[%zd]; data_size = [%zd]. Invalid packet.\\n\", __func__,\n\t\t       (sizeof(*msg) + msg->data_len), data_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_process_response(daemon, msg, seq);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_process_response",
          "args": [
            "daemon",
            "msg",
            "seq"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_process_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "220-264",
          "snippet": "int ecryptfs_process_response(struct ecryptfs_daemon *daemon,\n\t\t\t      struct ecryptfs_message *msg, u32 seq)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t msg_size;\n\tint rc;\n\n\tif (msg->index >= ecryptfs_message_buf_len) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"%s: Attempt to reference \"\n\t\t       \"context buffer at index [%d]; maximum \"\n\t\t       \"allowable is [%d]\\n\", __func__, msg->index,\n\t\t       (ecryptfs_message_buf_len - 1));\n\t\tgoto out;\n\t}\n\tmsg_ctx = &ecryptfs_msg_ctx_arr[msg->index];\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_PENDING) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Desired context element is not \"\n\t\t       \"pending a response\\n\", __func__);\n\t\tgoto unlock;\n\t} else if (msg_ctx->counter != seq) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Invalid message sequence; \"\n\t\t       \"expected [%d]; received [%d]\\n\", __func__,\n\t\t       msg_ctx->counter, seq);\n\t\tgoto unlock;\n\t}\n\tmsg_size = (sizeof(*msg) + msg->data_len);\n\tmsg_ctx->msg = kmemdup(msg, msg_size, GFP_KERNEL);\n\tif (!msg_ctx->msg) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, msg_size);\n\t\tgoto unlock;\n\t}\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_DONE;\n\twake_up_process(msg_ctx->task);\n\trc = 0;\nunlock:\n\tmutex_unlock(&msg_ctx->mux);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\nint ecryptfs_process_response(struct ecryptfs_daemon *daemon,\n\t\t\t      struct ecryptfs_message *msg, u32 seq)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t msg_size;\n\tint rc;\n\n\tif (msg->index >= ecryptfs_message_buf_len) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"%s: Attempt to reference \"\n\t\t       \"context buffer at index [%d]; maximum \"\n\t\t       \"allowable is [%d]\\n\", __func__, msg->index,\n\t\t       (ecryptfs_message_buf_len - 1));\n\t\tgoto out;\n\t}\n\tmsg_ctx = &ecryptfs_msg_ctx_arr[msg->index];\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_PENDING) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Desired context element is not \"\n\t\t       \"pending a response\\n\", __func__);\n\t\tgoto unlock;\n\t} else if (msg_ctx->counter != seq) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Invalid message sequence; \"\n\t\t       \"expected [%d]; received [%d]\\n\", __func__,\n\t\t       msg_ctx->counter, seq);\n\t\tgoto unlock;\n\t}\n\tmsg_size = (sizeof(*msg) + msg->data_len);\n\tmsg_ctx->msg = kmemdup(msg, msg_size, GFP_KERNEL);\n\tif (!msg_ctx->msg) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, msg_size);\n\t\tgoto unlock;\n\t}\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_DONE;\n\twake_up_process(msg_ctx->task);\n\trc = 0;\nunlock:\n\tmutex_unlock(&msg_ctx->mux);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_miscdev_response(struct ecryptfs_daemon *daemon, char *data,\n\t\t\t\t     size_t data_size, u32 seq)\n{\n\tstruct ecryptfs_message *msg = (struct ecryptfs_message *)data;\n\tint rc;\n\n\tif ((sizeof(*msg) + msg->data_len) != data_size) {\n\t\tprintk(KERN_WARNING \"%s: (sizeof(*msg) + msg->data_len) = \"\n\t\t       \"[%zd]; data_size = [%zd]. Invalid packet.\\n\", __func__,\n\t\t       (sizeof(*msg) + msg->data_len), data_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_process_response(daemon, msg, seq);\n\tif (rc)\n\t\tprintk(KERN_ERR\n\t\t       \"Error processing response message; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "226-328",
    "snippet": "static ssize_t\necryptfs_miscdev_read(struct file *file, char __user *buf, size_t count,\n\t\t      loff_t *ppos)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t packet_length_size;\n\tchar packet_length[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tsize_t i;\n\tsize_t total_length;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Attempt to read from zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\t/* This daemon will not go away so long as this flag is set */\n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_READ;\ncheck_list:\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\tmutex_unlock(&daemon->mux);\n\t\trc = wait_event_interruptible(\n\t\t\tdaemon->wait, !list_empty(&daemon->msg_ctx_out_queue));\n\t\tmutex_lock(&daemon->mux);\n\t\tif (rc < 0) {\n\t\t\trc = 0;\n\t\t\tgoto out_unlock_daemon;\n\t\t}\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\t/* Something else jumped in since the\n\t\t * wait_event_interruptable() and removed the\n\t\t * message from the queue; try again */\n\t\tgoto check_list;\n\t}\n\tmsg_ctx = list_first_entry(&daemon->msg_ctx_out_queue,\n\t\t\t\t   struct ecryptfs_msg_ctx, daemon_out_list);\n\tBUG_ON(!msg_ctx);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->msg) {\n\t\trc = ecryptfs_write_packet_length(packet_length,\n\t\t\t\t\t\t  msg_ctx->msg_size,\n\t\t\t\t\t\t  &packet_length_size);\n\t\tif (rc) {\n\t\t\trc = 0;\n\t\t\tprintk(KERN_WARNING \"%s: Error writing packet length; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out_unlock_msg_ctx;\n\t\t}\n\t} else {\n\t\tpacket_length_size = 0;\n\t\tmsg_ctx->msg_size = 0;\n\t}\n\ttotal_length = (PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_length_size\n\t\t\t+ msg_ctx->msg_size);\n\tif (count < total_length) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Only given user buffer of \"\n\t\t       \"size [%zd], but we need [%zd] to read the \"\n\t\t       \"pending message\\n\", __func__, count, total_length);\n\t\tgoto out_unlock_msg_ctx;\n\t}\n\trc = -EFAULT;\n\tif (put_user(msg_ctx->type, buf))\n\t\tgoto out_unlock_msg_ctx;\n\tif (put_user(cpu_to_be32(msg_ctx->counter),\n\t\t     (__be32 __user *)(&buf[PKT_CTR_OFFSET])))\n\t\tgoto out_unlock_msg_ctx;\n\ti = PKT_TYPE_SIZE + PKT_CTR_SIZE;\n\tif (msg_ctx->msg) {\n\t\tif (copy_to_user(&buf[i], packet_length, packet_length_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += packet_length_size;\n\t\tif (copy_to_user(&buf[i], msg_ctx->msg, msg_ctx->msg_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += msg_ctx->msg_size;\n\t}\n\trc = i;\n\tlist_del(&msg_ctx->daemon_out_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\t/* We do not expect a reply from the userspace daemon for any\n\t * message type other than ECRYPTFS_MSG_REQUEST */\n\tif (msg_ctx->type != ECRYPTFS_MSG_REQUEST)\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\nout_unlock_msg_ctx:\n\tmutex_unlock(&msg_ctx->mux);\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_READ;\n\tmutex_unlock(&daemon->mux);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define PKT_CTR_OFFSET\t\tPKT_TYPE_SIZE",
      "#define PKT_CTR_SIZE\t\t4",
      "#define PKT_TYPE_SIZE\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_msg_ctx_alloc_to_free",
          "args": [
            "msg_ctx"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_msg_ctx_alloc_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "97-103",
          "snippet": "void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nvoid ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg_ctx->msg"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&msg_ctx->daemon_out_list"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&buf[i]",
            "msg_ctx->msg",
            "msg_ctx->msg_size"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&buf[i]",
            "packet_length",
            "packet_length_size"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "cpu_to_be32(msg_ctx->counter)",
            "(__be32 __user *)(&buf[PKT_CTR_OFFSET])"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "msg_ctx->counter"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "msg_ctx->type",
            "buf"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: Only given user buffer of \"\n\t\t       \"size [%zd], but we need [%zd] to read the \"\n\t\t       \"pending message\\n\"",
            "__func__",
            "count",
            "total_length"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "packet_length",
            "msg_ctx->msg_size",
            "&packet_length_size"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!msg_ctx"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&daemon->msg_ctx_out_queue",
            "structecryptfs_msg_ctx",
            "daemon_out_list"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&daemon->msg_ctx_out_queue"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "daemon->wait",
            "!list_empty(&daemon->msg_ctx_out_queue)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\n#define PKT_CTR_OFFSET\t\tPKT_TYPE_SIZE\n#define PKT_CTR_SIZE\t\t4\n#define PKT_TYPE_SIZE\t\t1\n\nstatic ssize_t\necryptfs_miscdev_read(struct file *file, char __user *buf, size_t count,\n\t\t      loff_t *ppos)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t packet_length_size;\n\tchar packet_length[ECRYPTFS_MAX_PKT_LEN_SIZE];\n\tsize_t i;\n\tsize_t total_length;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Attempt to read from zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\t/* This daemon will not go away so long as this flag is set */\n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_READ;\ncheck_list:\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\tmutex_unlock(&daemon->mux);\n\t\trc = wait_event_interruptible(\n\t\t\tdaemon->wait, !list_empty(&daemon->msg_ctx_out_queue));\n\t\tmutex_lock(&daemon->mux);\n\t\tif (rc < 0) {\n\t\t\trc = 0;\n\t\t\tgoto out_unlock_daemon;\n\t\t}\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\trc = 0;\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (list_empty(&daemon->msg_ctx_out_queue)) {\n\t\t/* Something else jumped in since the\n\t\t * wait_event_interruptable() and removed the\n\t\t * message from the queue; try again */\n\t\tgoto check_list;\n\t}\n\tmsg_ctx = list_first_entry(&daemon->msg_ctx_out_queue,\n\t\t\t\t   struct ecryptfs_msg_ctx, daemon_out_list);\n\tBUG_ON(!msg_ctx);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->msg) {\n\t\trc = ecryptfs_write_packet_length(packet_length,\n\t\t\t\t\t\t  msg_ctx->msg_size,\n\t\t\t\t\t\t  &packet_length_size);\n\t\tif (rc) {\n\t\t\trc = 0;\n\t\t\tprintk(KERN_WARNING \"%s: Error writing packet length; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out_unlock_msg_ctx;\n\t\t}\n\t} else {\n\t\tpacket_length_size = 0;\n\t\tmsg_ctx->msg_size = 0;\n\t}\n\ttotal_length = (PKT_TYPE_SIZE + PKT_CTR_SIZE + packet_length_size\n\t\t\t+ msg_ctx->msg_size);\n\tif (count < total_length) {\n\t\trc = 0;\n\t\tprintk(KERN_WARNING \"%s: Only given user buffer of \"\n\t\t       \"size [%zd], but we need [%zd] to read the \"\n\t\t       \"pending message\\n\", __func__, count, total_length);\n\t\tgoto out_unlock_msg_ctx;\n\t}\n\trc = -EFAULT;\n\tif (put_user(msg_ctx->type, buf))\n\t\tgoto out_unlock_msg_ctx;\n\tif (put_user(cpu_to_be32(msg_ctx->counter),\n\t\t     (__be32 __user *)(&buf[PKT_CTR_OFFSET])))\n\t\tgoto out_unlock_msg_ctx;\n\ti = PKT_TYPE_SIZE + PKT_CTR_SIZE;\n\tif (msg_ctx->msg) {\n\t\tif (copy_to_user(&buf[i], packet_length, packet_length_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += packet_length_size;\n\t\tif (copy_to_user(&buf[i], msg_ctx->msg, msg_ctx->msg_size))\n\t\t\tgoto out_unlock_msg_ctx;\n\t\ti += msg_ctx->msg_size;\n\t}\n\trc = i;\n\tlist_del(&msg_ctx->daemon_out_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\t/* We do not expect a reply from the userspace daemon for any\n\t * message type other than ECRYPTFS_MSG_REQUEST */\n\tif (msg_ctx->type != ECRYPTFS_MSG_REQUEST)\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\nout_unlock_msg_ctx:\n\tmutex_unlock(&msg_ctx->mux);\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_READ;\n\tmutex_unlock(&daemon->mux);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_send_miscdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "159-189",
    "snippet": "int ecryptfs_send_miscdev(char *data, size_t data_size,\n\t\t\t  struct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\n\t\t\t  u16 msg_flags, struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_message *msg;\n\n\tmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to kmalloc(%zd, GFP_KERNEL)\\n\", __func__,\n\t\t       (sizeof(*msg) + data_size));\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&msg_ctx->mux);\n\tmsg_ctx->msg = msg;\n\tmsg_ctx->msg->index = msg_ctx->index;\n\tmsg_ctx->msg->data_len = data_size;\n\tmsg_ctx->type = msg_type;\n\tmemcpy(msg_ctx->msg->data, data, data_size);\n\tmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\n\tlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\n\tmutex_unlock(&msg_ctx->mux);\n\n\tmutex_lock(&daemon->mux);\n\tdaemon->num_queued_msg_ctx++;\n\twake_up_interruptible(&daemon->wait);\n\tmutex_unlock(&daemon->mux);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&daemon->wait"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&msg_ctx->daemon_out_list",
            "&daemon->msg_ctx_out_queue"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "msg_ctx->msg->data",
            "data",
            "data_size"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to kmalloc(%zd, GFP_KERNEL)\\n\"",
            "__func__",
            "(sizeof(*msg) + data_size)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(sizeof(*msg) + data_size)",
            "GFP_KERNEL"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nint ecryptfs_send_miscdev(char *data, size_t data_size,\n\t\t\t  struct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\n\t\t\t  u16 msg_flags, struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_message *msg;\n\n\tmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to kmalloc(%zd, GFP_KERNEL)\\n\", __func__,\n\t\t       (sizeof(*msg) + data_size));\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&msg_ctx->mux);\n\tmsg_ctx->msg = msg;\n\tmsg_ctx->msg->index = msg_ctx->index;\n\tmsg_ctx->msg->data_len = data_size;\n\tmsg_ctx->type = msg_type;\n\tmemcpy(msg_ctx->msg->data, data, data_size);\n\tmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\n\tlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\n\tmutex_unlock(&msg_ctx->mux);\n\n\tmutex_lock(&daemon->mux);\n\tdaemon->num_queued_msg_ctx++;\n\twake_up_interruptible(&daemon->wait);\n\tmutex_unlock(&daemon->mux);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "119-141",
    "snippet": "static int\necryptfs_miscdev_release(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tBUG_ON(!(daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN));\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tatomic_dec(&ecryptfs_num_miscdev_opens);\n\tmutex_unlock(&daemon->mux);\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_exorcise_daemon(daemon);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tif (rc) {\n\t\tprintk(KERN_CRIT \"%s: Fatal error whilst attempting to \"\n\t\t       \"shut down daemon; rc = [%d]. Please report this \"\n\t\t       \"bug.\\n\", __func__, rc);\n\t\tBUG();\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ecryptfs_num_miscdev_opens;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"%s: Fatal error whilst attempting to \"\n\t\t       \"shut down daemon; rc = [%d]. Please report this \"\n\t\t       \"bug.\\n\"",
            "__func__",
            "rc"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_exorcise_daemon",
          "args": [
            "daemon"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_exorcise_daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "171-196",
          "snippet": "int ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ecryptfs_num_miscdev_opens"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\n\nstatic int\necryptfs_miscdev_release(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tint rc;\n\n\tmutex_lock(&daemon->mux);\n\tBUG_ON(!(daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN));\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tatomic_dec(&ecryptfs_num_miscdev_opens);\n\tmutex_unlock(&daemon->mux);\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_exorcise_daemon(daemon);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tif (rc) {\n\t\tprintk(KERN_CRIT \"%s: Fatal error whilst attempting to \"\n\t\t       \"shut down daemon; rc = [%d]. Please report this \"\n\t\t       \"bug.\\n\", __func__, rc);\n\t\tBUG();\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "76-107",
    "snippet": "static int\necryptfs_miscdev_open(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = NULL;\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (!rc) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock_daemon_list;\n\t}\n\trc = ecryptfs_spawn_daemon(&daemon, file);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to spawn daemon; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_unlock_daemon_list;\n\t}\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN) {\n\t\trc = -EBUSY;\n\t\tgoto out_unlock_daemon;\n\t}\n\tdaemon->flags |= ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tfile->private_data = daemon;\n\tatomic_inc(&ecryptfs_num_miscdev_opens);\nout_unlock_daemon:\n\tmutex_unlock(&daemon->mux);\nout_unlock_daemon_list:\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t ecryptfs_num_miscdev_opens;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ecryptfs_num_miscdev_opens"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to spawn daemon; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_spawn_daemon",
          "args": [
            "&daemon",
            "file"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_spawn_daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "142-163",
          "snippet": "int\necryptfs_spawn_daemon(struct ecryptfs_daemon **daemon, struct file *file)\n{\n\tint rc = 0;\n\n\t(*daemon) = kzalloc(sizeof(**daemon), GFP_KERNEL);\n\tif (!(*daemon)) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, sizeof(**daemon));\n\t\tgoto out;\n\t}\n\t(*daemon)->file = file;\n\tmutex_init(&(*daemon)->mux);\n\tINIT_LIST_HEAD(&(*daemon)->msg_ctx_out_queue);\n\tinit_waitqueue_head(&(*daemon)->wait);\n\t(*daemon)->num_queued_msg_ctx = 0;\n\thlist_add_head(&(*daemon)->euid_chain,\n\t\t       &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *ecryptfs_daemon_hash;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\n\nint\necryptfs_spawn_daemon(struct ecryptfs_daemon **daemon, struct file *file)\n{\n\tint rc = 0;\n\n\t(*daemon) = kzalloc(sizeof(**daemon), GFP_KERNEL);\n\tif (!(*daemon)) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, sizeof(**daemon));\n\t\tgoto out;\n\t}\n\t(*daemon)->file = file;\n\tmutex_init(&(*daemon)->mux);\n\tINIT_LIST_HEAD(&(*daemon)->msg_ctx_out_queue);\n\tinit_waitqueue_head(&(*daemon)->wait);\n\t(*daemon)->num_queued_msg_ctx = 0;\n\thlist_add_head(&(*daemon)->euid_chain,\n\t\t       &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_daemon_by_euid",
          "args": [
            "&daemon"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_daemon_by_euid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "115-130",
          "snippet": "int ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *ecryptfs_daemon_hash;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\n\nint ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\n\nstatic int\necryptfs_miscdev_open(struct inode *inode, struct file *file)\n{\n\tstruct ecryptfs_daemon *daemon = NULL;\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (!rc) {\n\t\trc = -EINVAL;\n\t\tgoto out_unlock_daemon_list;\n\t}\n\trc = ecryptfs_spawn_daemon(&daemon, file);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to spawn daemon; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_unlock_daemon_list;\n\t}\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_MISCDEV_OPEN) {\n\t\trc = -EBUSY;\n\t\tgoto out_unlock_daemon;\n\t}\n\tdaemon->flags |= ECRYPTFS_DAEMON_MISCDEV_OPEN;\n\tfile->private_data = daemon;\n\tatomic_inc(&ecryptfs_num_miscdev_opens);\nout_unlock_daemon:\n\tmutex_unlock(&daemon->mux);\nout_unlock_daemon_list:\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_miscdev_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
    "lines": "41-67",
    "snippet": "static unsigned int\necryptfs_miscdev_poll(struct file *file, poll_table *pt)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tunsigned int mask = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\tprintk(KERN_WARNING \"%s: Attempt to poll on zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t\tgoto out_unlock_daemon;\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)\n\t\tgoto out_unlock_daemon;\n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\tpoll_wait(file, &daemon->wait, pt);\n\tmutex_lock(&daemon->mux);\n\tif (!list_empty(&daemon->msg_ctx_out_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\treturn mask;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/random.h>",
      "#include <linux/hash.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&daemon->msg_ctx_out_queue"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&daemon->wait",
            "pt"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: Attempt to poll on zombified \"\n\t\t       \"daemon\\n\"",
            "__func__"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic unsigned int\necryptfs_miscdev_poll(struct file *file, poll_table *pt)\n{\n\tstruct ecryptfs_daemon *daemon = file->private_data;\n\tunsigned int mask = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif (daemon->flags & ECRYPTFS_DAEMON_ZOMBIE) {\n\t\tprintk(KERN_WARNING \"%s: Attempt to poll on zombified \"\n\t\t       \"daemon\\n\", __func__);\n\t\tgoto out_unlock_daemon;\n\t}\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t\tgoto out_unlock_daemon;\n\tif (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)\n\t\tgoto out_unlock_daemon;\n\tdaemon->flags |= ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\tpoll_wait(file, &daemon->wait, pt);\n\tmutex_lock(&daemon->mux);\n\tif (!list_empty(&daemon->msg_ctx_out_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\nout_unlock_daemon:\n\tdaemon->flags &= ~ECRYPTFS_DAEMON_IN_POLL;\n\tmutex_unlock(&daemon->mux);\n\treturn mask;\n}"
  }
]