[
  {
    "function_name": "ecryptfs_set_f_namelen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "2121-2166",
    "snippet": "int ecryptfs_set_f_namelen(long *namelen, long lower_namelen,\n\t\t\t   struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct blkcipher_desc desc;\n\tstruct mutex *tfm_mutex;\n\tsize_t cipher_blocksize;\n\tint rc;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n\t\t(*namelen) = lower_namelen;\n\t\treturn 0;\n\t}\n\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\t(*namelen) = 0;\n\t\treturn rc;\n\t}\n\n\tmutex_lock(tfm_mutex);\n\tcipher_blocksize = crypto_blkcipher_blocksize(desc.tfm);\n\tmutex_unlock(tfm_mutex);\n\n\t/* Return an exact amount for the common cases */\n\tif (lower_namelen == NAME_MAX\n\t    && (cipher_blocksize == 8 || cipher_blocksize == 16)) {\n\t\t(*namelen) = ENC_NAME_MAX_BLOCKLEN_8_OR_16;\n\t\treturn 0;\n\t}\n\n\t/* Return a safe estimate for the uncommon cases */\n\t(*namelen) = lower_namelen;\n\t(*namelen) -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t/* Since this is the max decoded size, subtract 1 \"decoded block\" len */\n\t(*namelen) = ecryptfs_max_decoded_size(*namelen) - 3;\n\t(*namelen) -= ECRYPTFS_TAG_70_MAX_METADATA_SIZE;\n\t(*namelen) -= ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES;\n\t/* Worst case is that the filename is padded nearly a full block size */\n\t(*namelen) -= cipher_blocksize - 1;\n\n\tif ((*namelen) < 0)\n\t\t(*namelen) = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ENC_NAME_MAX_BLOCKLEN_8_OR_16\t143"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_max_decoded_size",
          "args": [
            "*namelen"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_max_decoded_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1866-1875",
          "snippet": "static size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "tfm_mutex"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_blocksize",
          "args": [
            "desc.tfm"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "tfm_mutex"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "args": [
            "&desc.tfm",
            "&tfm_mutex",
            "mount_crypt_stat->global_default_fn_cipher_name"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1751-1775",
          "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENC_NAME_MAX_BLOCKLEN_8_OR_16\t143\n\nint ecryptfs_set_f_namelen(long *namelen, long lower_namelen,\n\t\t\t   struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct blkcipher_desc desc;\n\tstruct mutex *tfm_mutex;\n\tsize_t cipher_blocksize;\n\tint rc;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n\t\t(*namelen) = lower_namelen;\n\t\treturn 0;\n\t}\n\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\t(*namelen) = 0;\n\t\treturn rc;\n\t}\n\n\tmutex_lock(tfm_mutex);\n\tcipher_blocksize = crypto_blkcipher_blocksize(desc.tfm);\n\tmutex_unlock(tfm_mutex);\n\n\t/* Return an exact amount for the common cases */\n\tif (lower_namelen == NAME_MAX\n\t    && (cipher_blocksize == 8 || cipher_blocksize == 16)) {\n\t\t(*namelen) = ENC_NAME_MAX_BLOCKLEN_8_OR_16;\n\t\treturn 0;\n\t}\n\n\t/* Return a safe estimate for the uncommon cases */\n\t(*namelen) = lower_namelen;\n\t(*namelen) -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t/* Since this is the max decoded size, subtract 1 \"decoded block\" len */\n\t(*namelen) = ecryptfs_max_decoded_size(*namelen) - 3;\n\t(*namelen) -= ECRYPTFS_TAG_70_MAX_METADATA_SIZE;\n\t(*namelen) -= ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES;\n\t/* Worst case is that the filename is padded nearly a full block size */\n\t(*namelen) -= cipher_blocksize - 1;\n\n\tif ((*namelen) < 0)\n\t\t(*namelen) = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_decode_and_decrypt_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "2058-2117",
    "snippet": "int ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "decoded_name"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_filename",
          "args": [
            "plaintext_name",
            "plaintext_name_size",
            "name",
            "name_size"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1564-1582",
          "snippet": "static int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\"",
            "__func__"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_tag_70_packet",
          "args": [
            "plaintext_name",
            "plaintext_name_size",
            "&packet_size",
            "mount_crypt_stat",
            "decoded_name",
            "decoded_name_size"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_tag_70_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "912-1113",
          "snippet": "int\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *data, size_t max_packet_size)\n{\n\tstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*filename_size) = 0;\n\t(*filename) = NULL;\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; it must be \"\n\t\t       \"at least [%d]\\n\", __func__, max_packet_size,\n\t\t       ECRYPTFS_TAG_70_MIN_METADATA_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random numbers, a \\0\n\t *    separator, and then the filename */\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet tag [0x%.2x]; must be \"\n\t\t       \"tag [0x%.2x]\\n\", __func__,\n\t\t       data[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)],\n\t\t\t\t\t  &s->parsed_tag_70_packet_size,\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\ts->block_aligned_filename_size = (s->parsed_tag_70_packet_size\n\t\t\t\t\t  - ECRYPTFS_SIG_SIZE - 1);\n\tif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\n\t    > max_packet_size) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; real packet \"\n\t\t       \"size is [%zd]\\n\", __func__, max_packet_size,\n\t\t       (1 + s->packet_size_len + 1\n\t\t\t+ s->block_aligned_filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += s->packet_size_len;\n\tecryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\n\t\t\tECRYPTFS_SIG_SIZE);\n\ts->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = data[(*packet_size)++];\n\trc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Cipher code [%d] is invalid\\n\",\n\t\t       __func__, s->cipher_code);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t    &s->auth_tok, mount_crypt_stat,\n\t\t\t\t\t    s->fnek_sig_hex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__, s->fnek_sig_hex,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,\n\t\t\t\t\t\t\t&s->tfm_mutex,\n\t\t\t\t\t\t\ts->cipher_string);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       s->cipher_string, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\trc = virt_to_scatterlist(&data[(*packet_size)],\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_unlock;\n\t}\n\t(*packet_size) += s->block_aligned_filename_size;\n\ts->decrypted_filename = kmalloc(s->block_aligned_filename_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!s->decrypted_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\trc = virt_to_scatterlist(s->decrypted_filename,\n\t\t\t\t s->block_aligned_filename_size, s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert decrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job of\n\t * the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_decrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i = 0;\n\twhile (s->decrypted_filename[s->i] != '\\0'\n\t       && s->i < s->block_aligned_filename_size)\n\t\ts->i++;\n\tif (s->i == s->block_aligned_filename_size) {\n\t\tprintk(KERN_WARNING \"%s: Invalid tag 70 packet; could not \"\n\t\t       \"find valid separator between random characters and \"\n\t\t       \"the filename\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\ts->i++;\n\t(*filename_size) = (s->block_aligned_filename_size - s->i);\n\tif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\n\t\tprintk(KERN_WARNING \"%s: Filename size is [%zd], which is \"\n\t\t       \"invalid\\n\", __func__, (*filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\t(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\n\tif (!(*filename)) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       ((*filename_size) + 1));\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\tmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\n\t(*filename)[(*filename_size)] = '\\0';\nout_free_unlock:\n\tkfree(s->decrypted_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*filename_size) = 0;\n\t\t(*filename) = NULL;\n\t}\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *data, size_t max_packet_size)\n{\n\tstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*filename_size) = 0;\n\t(*filename) = NULL;\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; it must be \"\n\t\t       \"at least [%d]\\n\", __func__, max_packet_size,\n\t\t       ECRYPTFS_TAG_70_MIN_METADATA_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random numbers, a \\0\n\t *    separator, and then the filename */\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet tag [0x%.2x]; must be \"\n\t\t       \"tag [0x%.2x]\\n\", __func__,\n\t\t       data[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)],\n\t\t\t\t\t  &s->parsed_tag_70_packet_size,\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\ts->block_aligned_filename_size = (s->parsed_tag_70_packet_size\n\t\t\t\t\t  - ECRYPTFS_SIG_SIZE - 1);\n\tif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\n\t    > max_packet_size) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; real packet \"\n\t\t       \"size is [%zd]\\n\", __func__, max_packet_size,\n\t\t       (1 + s->packet_size_len + 1\n\t\t\t+ s->block_aligned_filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += s->packet_size_len;\n\tecryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\n\t\t\tECRYPTFS_SIG_SIZE);\n\ts->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = data[(*packet_size)++];\n\trc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Cipher code [%d] is invalid\\n\",\n\t\t       __func__, s->cipher_code);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t    &s->auth_tok, mount_crypt_stat,\n\t\t\t\t\t    s->fnek_sig_hex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__, s->fnek_sig_hex,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,\n\t\t\t\t\t\t\t&s->tfm_mutex,\n\t\t\t\t\t\t\ts->cipher_string);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       s->cipher_string, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\trc = virt_to_scatterlist(&data[(*packet_size)],\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_unlock;\n\t}\n\t(*packet_size) += s->block_aligned_filename_size;\n\ts->decrypted_filename = kmalloc(s->block_aligned_filename_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!s->decrypted_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\trc = virt_to_scatterlist(s->decrypted_filename,\n\t\t\t\t s->block_aligned_filename_size, s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert decrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job of\n\t * the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_decrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i = 0;\n\twhile (s->decrypted_filename[s->i] != '\\0'\n\t       && s->i < s->block_aligned_filename_size)\n\t\ts->i++;\n\tif (s->i == s->block_aligned_filename_size) {\n\t\tprintk(KERN_WARNING \"%s: Invalid tag 70 packet; could not \"\n\t\t       \"find valid separator between random characters and \"\n\t\t       \"the filename\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\ts->i++;\n\t(*filename_size) = (s->block_aligned_filename_size - s->i);\n\tif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\n\t\tprintk(KERN_WARNING \"%s: Filename size is [%zd], which is \"\n\t\t       \"invalid\\n\", __func__, (*filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\t(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\n\tif (!(*filename)) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       ((*filename_size) + 1));\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\tmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\n\t(*filename)[(*filename_size)] = '\\0';\nout_free_unlock:\n\tkfree(s->decrypted_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*filename_size) = 0;\n\t\t(*filename) = NULL;\n\t}\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_decode_from_filename",
          "args": [
            "decoded_name",
            "&decoded_name_size",
            "name",
            "name_size"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_decode_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1886-1928",
          "snippet": "static void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char filename_rev_map[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 7 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 15 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 23 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 31 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 39 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, /* 47 */\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, /* 55 */\n\t0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 63 */\n\t0x00, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, /* 71 */\n\t0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, /* 79 */\n\t0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, /* 87 */\n\t0x23, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, /* 95 */\n\t0x00, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, /* 103 */\n\t0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, /* 111 */\n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, /* 119 */\n\t0x3D, 0x3E, 0x3F /* 123 - 255 initialized to 0x00 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const unsigned char filename_rev_map[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 7 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 15 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 23 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 31 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 39 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, /* 47 */\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, /* 55 */\n\t0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 63 */\n\t0x00, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, /* 71 */\n\t0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, /* 79 */\n\t0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, /* 87 */\n\t0x23, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, /* 95 */\n\t0x00, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, /* 103 */\n\t0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, /* 111 */\n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, /* 119 */\n\t0x3D, 0x3E, 0x3F /* 123 - 255 initialized to 0x00 */\n};\n\nstatic void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "decoded_name_size",
            "GFP_KERNEL"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX",
            "ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "sb"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_decode_and_decrypt_filename(char **plaintext_name,\n\t\t\t\t\t size_t *plaintext_name_size,\n\t\t\t\t\t struct super_block *sb,\n\t\t\t\t\t const char *name, size_t name_size)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(sb)->mount_crypt_stat;\n\tchar *decoded_name;\n\tsize_t decoded_name_size;\n\tsize_t packet_size;\n\tint rc = 0;\n\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !(mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t    && (name_size > ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)\n\t    && (strncmp(name, ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\tECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE) == 0)) {\n\t\tconst char *orig_name = name;\n\t\tsize_t orig_name_size = name_size;\n\n\t\tname += ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tname_size -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n\t\tecryptfs_decode_from_filename(NULL, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\tdecoded_name = kmalloc(decoded_name_size, GFP_KERNEL);\n\t\tif (!decoded_name) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       decoded_name_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_decode_from_filename(decoded_name, &decoded_name_size,\n\t\t\t\t\t      name, name_size);\n\t\trc = ecryptfs_parse_tag_70_packet(plaintext_name,\n\t\t\t\t\t\t  plaintext_name_size,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  decoded_name,\n\t\t\t\t\t\t  decoded_name_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_INFO \"%s: Could not parse tag 70 packet \"\n\t\t\t       \"from filename; copying through filename \"\n\t\t\t       \"as-is\\n\", __func__);\n\t\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t\t    orig_name, orig_name_size);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\trc = ecryptfs_copy_filename(plaintext_name,\n\t\t\t\t\t    plaintext_name_size,\n\t\t\t\t\t    name, name_size);\n\t\tgoto out;\n\t}\nout_free:\n\tkfree(decoded_name);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_encrypt_and_encode_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1945-2044",
    "snippet": "int ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_copy_filename",
          "args": [
            "encoded_name",
            "encoded_name_size",
            "name",
            "name_size"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1564-1582",
          "snippet": "static int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename->encrypted_filename"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(*encoded_name)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_encode_for_filename",
          "args": [
            "((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE)",
            "&encoded_name_no_prefix_size",
            "filename->encrypted_filename",
            "filename->encrypted_filename_size"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encode_for_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1811-1864",
          "snippet": "static void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t\t  unsigned char *src, size_t src_size)\n{\n\tsize_t num_blocks;\n\tsize_t block_num = 0;\n\tsize_t dst_offset = 0;\n\tunsigned char last_block[3];\n\n\tif (src_size == 0) {\n\t\t(*dst_size) = 0;\n\t\tgoto out;\n\t}\n\tnum_blocks = (src_size / 3);\n\tif ((src_size % 3) == 0) {\n\t\tmemcpy(last_block, (&src[src_size - 3]), 3);\n\t} else {\n\t\tnum_blocks++;\n\t\tlast_block[2] = 0x00;\n\t\tswitch (src_size % 3) {\n\t\tcase 1:\n\t\t\tlast_block[0] = src[src_size - 1];\n\t\t\tlast_block[1] = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlast_block[0] = src[src_size - 2];\n\t\t\tlast_block[1] = src[src_size - 1];\n\t\t}\n\t}\n\t(*dst_size) = (num_blocks * 4);\n\tif (!dst)\n\t\tgoto out;\n\twhile (block_num < num_blocks) {\n\t\tunsigned char *src_block;\n\t\tunsigned char dst_block[4];\n\n\t\tif (block_num == (num_blocks - 1))\n\t\t\tsrc_block = last_block;\n\t\telse\n\t\t\tsrc_block = &src[block_num * 3];\n\t\tdst_block[0] = ((src_block[0] >> 2) & 0x3F);\n\t\tdst_block[1] = (((src_block[0] << 4) & 0x30)\n\t\t\t\t| ((src_block[1] >> 4) & 0x0F));\n\t\tdst_block[2] = (((src_block[1] << 2) & 0x3C)\n\t\t\t\t| ((src_block[2] >> 6) & 0x03));\n\t\tdst_block[3] = (src_block[2] & 0x3F);\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[0]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[1]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[2]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[3]];\n\t\tblock_num++;\n\t}\nout:\n\treturn;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char *portable_filename_chars = (\"-.0123456789ABCD\"\n\t\t\t\t\t\t \"EFGHIJKLMNOPQRST\"\n\t\t\t\t\t\t \"UVWXYZabcdefghij\"\n\t\t\t\t\t\t \"klmnopqrstuvwxyz\");"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned char *portable_filename_chars = (\"-.0123456789ABCD\"\n\t\t\t\t\t\t \"EFGHIJKLMNOPQRST\"\n\t\t\t\t\t\t \"UVWXYZabcdefghij\"\n\t\t\t\t\t\t \"klmnopqrstuvwxyz\");\n\nstatic void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t\t  unsigned char *src, size_t src_size)\n{\n\tsize_t num_blocks;\n\tsize_t block_num = 0;\n\tsize_t dst_offset = 0;\n\tunsigned char last_block[3];\n\n\tif (src_size == 0) {\n\t\t(*dst_size) = 0;\n\t\tgoto out;\n\t}\n\tnum_blocks = (src_size / 3);\n\tif ((src_size % 3) == 0) {\n\t\tmemcpy(last_block, (&src[src_size - 3]), 3);\n\t} else {\n\t\tnum_blocks++;\n\t\tlast_block[2] = 0x00;\n\t\tswitch (src_size % 3) {\n\t\tcase 1:\n\t\t\tlast_block[0] = src[src_size - 1];\n\t\t\tlast_block[1] = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlast_block[0] = src[src_size - 2];\n\t\t\tlast_block[1] = src[src_size - 1];\n\t\t}\n\t}\n\t(*dst_size) = (num_blocks * 4);\n\tif (!dst)\n\t\tgoto out;\n\twhile (block_num < num_blocks) {\n\t\tunsigned char *src_block;\n\t\tunsigned char dst_block[4];\n\n\t\tif (block_num == (num_blocks - 1))\n\t\t\tsrc_block = last_block;\n\t\telse\n\t\t\tsrc_block = &src[block_num * 3];\n\t\tdst_block[0] = ((src_block[0] >> 2) & 0x3F);\n\t\tdst_block[1] = (((src_block[0] << 4) & 0x30)\n\t\t\t\t| ((src_block[1] >> 4) & 0x0F));\n\t\tdst_block[2] = (((src_block[1] << 2) & 0x3C)\n\t\t\t\t| ((src_block[2] >> 6) & 0x03));\n\t\tdst_block[3] = (src_block[2] & 0x3F);\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[0]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[1]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[2]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[3]];\n\t\tblock_num++;\n\t}\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*encoded_name)",
            "ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX",
            "ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename->encrypted_filename"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(*encoded_name_size) + 1",
            "GFP_KERNEL"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_encrypt_filename",
          "args": [
            "filename",
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_encrypt_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1501-1562",
          "snippet": "static int\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\n\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t  struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tint rc = 0;\n\n\tfilename->encrypted_filename = NULL;\n\tfilename->encrypted_filename_size = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\tsize_t packet_size;\n\t\tsize_t remaining_bytes;\n\n\t\trc = ecryptfs_write_tag_70_packet(\n\t\t\tNULL, NULL,\n\t\t\t&filename->encrypted_filename_size,\n\t\t\tmount_crypt_stat, NULL,\n\t\t\tfilename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to get packet \"\n\t\t\t       \"size for tag 72; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename =\n\t\t\tkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\n\t\tif (!filename->encrypted_filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       filename->encrypted_filename_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tremaining_bytes = filename->encrypted_filename_size;\n\t\trc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\n\t\t\t\t\t\t  &remaining_bytes,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  filename->filename,\n\t\t\t\t\t\t  filename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to generate \"\n\t\t\t       \"tag 70 packet; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tfilename->encrypted_filename = NULL;\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename_size = packet_size;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\", __func__);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\n\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t  struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tint rc = 0;\n\n\tfilename->encrypted_filename = NULL;\n\tfilename->encrypted_filename_size = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\tsize_t packet_size;\n\t\tsize_t remaining_bytes;\n\n\t\trc = ecryptfs_write_tag_70_packet(\n\t\t\tNULL, NULL,\n\t\t\t&filename->encrypted_filename_size,\n\t\t\tmount_crypt_stat, NULL,\n\t\t\tfilename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to get packet \"\n\t\t\t       \"size for tag 72; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename =\n\t\t\tkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\n\t\tif (!filename->encrypted_filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       filename->encrypted_filename_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tremaining_bytes = filename->encrypted_filename_size;\n\t\trc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\n\t\t\t\t\t\t  &remaining_bytes,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  filename->filename,\n\t\t\t\t\t\t  filename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to generate \"\n\t\t\t       \"tag 70 packet; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tfilename->encrypted_filename = NULL;\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename_size = packet_size;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\", __func__);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*filename)",
            "GFP_KERNEL"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_encrypt_and_encode_filename(\n\tchar **encoded_name,\n\tsize_t *encoded_name_size,\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tconst char *name, size_t name_size)\n{\n\tsize_t encoded_name_no_prefix_size;\n\tint rc = 0;\n\n\t(*encoded_name) = NULL;\n\t(*encoded_name_size) = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCRYPT_FILENAMES))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES))) {\n\t\tstruct ecryptfs_filename *filename;\n\n\t\tfilename = kzalloc(sizeof(*filename), GFP_KERNEL);\n\t\tif (!filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       sizeof(*filename));\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->filename = (char *)name;\n\t\tfilename->filename_size = name_size;\n\t\trc = ecryptfs_encrypt_filename(filename, crypt_stat,\n\t\t\t\t\t       mount_crypt_stat);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt \"\n\t\t\t       \"filename; rc = [%d]\\n\", __func__, rc);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tecryptfs_encode_for_filename(\n\t\t\tNULL, &encoded_name_no_prefix_size,\n\t\t\tfilename->encrypted_filename,\n\t\t\tfilename->encrypted_filename_size);\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)))\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\telse\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t(*encoded_name) = kmalloc((*encoded_name_size) + 1, GFP_KERNEL);\n\t\tif (!(*encoded_name)) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kzalloc [%zd] bytes\\n\", __func__,\n\t\t\t       (*encoded_name_size));\n\t\t\trc = -ENOMEM;\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tkfree(filename);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((crypt_stat && (crypt_stat->flags\n\t\t\t\t    & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t\t    || (mount_crypt_stat\n\t\t\t&& (mount_crypt_stat->flags\n\t\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\t\tmemcpy((*encoded_name),\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX,\n\t\t\t       ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE);\n\t\t\tecryptfs_encode_for_filename(\n\t\t\t    ((*encoded_name)\n\t\t\t     + ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE),\n\t\t\t    &encoded_name_no_prefix_size,\n\t\t\t    filename->encrypted_filename,\n\t\t\t    filename->encrypted_filename_size);\n\t\t\t(*encoded_name_size) =\n\t\t\t\t(ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE\n\t\t\t\t + encoded_name_no_prefix_size);\n\t\t\t(*encoded_name)[(*encoded_name_size)] = '\\0';\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to encode \"\n\t\t\t       \"encrypted filename; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree((*encoded_name));\n\t\t\t(*encoded_name) = NULL;\n\t\t\t(*encoded_name_size) = 0;\n\t\t}\n\t\tkfree(filename->encrypted_filename);\n\t\tkfree(filename);\n\t} else {\n\t\trc = ecryptfs_copy_filename(encoded_name,\n\t\t\t\t\t    encoded_name_size,\n\t\t\t\t\t    name, name_size);\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_decode_from_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1886-1928",
    "snippet": "static void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char filename_rev_map[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 7 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 15 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 23 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 31 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 39 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, /* 47 */\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, /* 55 */\n\t0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 63 */\n\t0x00, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, /* 71 */\n\t0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, /* 79 */\n\t0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, /* 87 */\n\t0x23, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, /* 95 */\n\t0x00, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, /* 103 */\n\t0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, /* 111 */\n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, /* 119 */\n\t0x3D, 0x3E, 0x3F /* 123 - 255 initialized to 0x00 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_max_decoded_size",
          "args": [
            "src_size"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_max_decoded_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1866-1875",
          "snippet": "static size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const unsigned char filename_rev_map[256] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 7 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 15 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 23 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 31 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 39 */\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, /* 47 */\n\t0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, /* 55 */\n\t0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 63 */\n\t0x00, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, /* 71 */\n\t0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, /* 79 */\n\t0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, /* 87 */\n\t0x23, 0x24, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, /* 95 */\n\t0x00, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, /* 103 */\n\t0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, /* 111 */\n\t0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, /* 119 */\n\t0x3D, 0x3E, 0x3F /* 123 - 255 initialized to 0x00 */\n};\n\nstatic void\necryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}"
  },
  {
    "function_name": "ecryptfs_max_decoded_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1866-1875",
    "snippet": "static size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic size_t ecryptfs_max_decoded_size(size_t encoded_size)\n{\n\t/* Not exact; conservatively long. Every block of 4\n\t * encoded characters decodes into a block of 3\n\t * decoded characters. This segment of code provides\n\t * the caller with the maximum amount of allocated\n\t * space that @dst will need to point to in a\n\t * subsequent call. */\n\treturn ((encoded_size + 1) * 3) / 4;\n}"
  },
  {
    "function_name": "ecryptfs_encode_for_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1811-1864",
    "snippet": "static void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t\t  unsigned char *src, size_t src_size)\n{\n\tsize_t num_blocks;\n\tsize_t block_num = 0;\n\tsize_t dst_offset = 0;\n\tunsigned char last_block[3];\n\n\tif (src_size == 0) {\n\t\t(*dst_size) = 0;\n\t\tgoto out;\n\t}\n\tnum_blocks = (src_size / 3);\n\tif ((src_size % 3) == 0) {\n\t\tmemcpy(last_block, (&src[src_size - 3]), 3);\n\t} else {\n\t\tnum_blocks++;\n\t\tlast_block[2] = 0x00;\n\t\tswitch (src_size % 3) {\n\t\tcase 1:\n\t\t\tlast_block[0] = src[src_size - 1];\n\t\t\tlast_block[1] = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlast_block[0] = src[src_size - 2];\n\t\t\tlast_block[1] = src[src_size - 1];\n\t\t}\n\t}\n\t(*dst_size) = (num_blocks * 4);\n\tif (!dst)\n\t\tgoto out;\n\twhile (block_num < num_blocks) {\n\t\tunsigned char *src_block;\n\t\tunsigned char dst_block[4];\n\n\t\tif (block_num == (num_blocks - 1))\n\t\t\tsrc_block = last_block;\n\t\telse\n\t\t\tsrc_block = &src[block_num * 3];\n\t\tdst_block[0] = ((src_block[0] >> 2) & 0x3F);\n\t\tdst_block[1] = (((src_block[0] << 4) & 0x30)\n\t\t\t\t| ((src_block[1] >> 4) & 0x0F));\n\t\tdst_block[2] = (((src_block[1] << 2) & 0x3C)\n\t\t\t\t| ((src_block[2] >> 6) & 0x03));\n\t\tdst_block[3] = (src_block[2] & 0x3F);\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[0]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[1]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[2]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[3]];\n\t\tblock_num++;\n\t}\nout:\n\treturn;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char *portable_filename_chars = (\"-.0123456789ABCD\"\n\t\t\t\t\t\t \"EFGHIJKLMNOPQRST\"\n\t\t\t\t\t\t \"UVWXYZabcdefghij\"\n\t\t\t\t\t\t \"klmnopqrstuvwxyz\");"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "last_block",
            "(&src[src_size - 3])",
            "3"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned char *portable_filename_chars = (\"-.0123456789ABCD\"\n\t\t\t\t\t\t \"EFGHIJKLMNOPQRST\"\n\t\t\t\t\t\t \"UVWXYZabcdefghij\"\n\t\t\t\t\t\t \"klmnopqrstuvwxyz\");\n\nstatic void ecryptfs_encode_for_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t\t  unsigned char *src, size_t src_size)\n{\n\tsize_t num_blocks;\n\tsize_t block_num = 0;\n\tsize_t dst_offset = 0;\n\tunsigned char last_block[3];\n\n\tif (src_size == 0) {\n\t\t(*dst_size) = 0;\n\t\tgoto out;\n\t}\n\tnum_blocks = (src_size / 3);\n\tif ((src_size % 3) == 0) {\n\t\tmemcpy(last_block, (&src[src_size - 3]), 3);\n\t} else {\n\t\tnum_blocks++;\n\t\tlast_block[2] = 0x00;\n\t\tswitch (src_size % 3) {\n\t\tcase 1:\n\t\t\tlast_block[0] = src[src_size - 1];\n\t\t\tlast_block[1] = 0x00;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlast_block[0] = src[src_size - 2];\n\t\t\tlast_block[1] = src[src_size - 1];\n\t\t}\n\t}\n\t(*dst_size) = (num_blocks * 4);\n\tif (!dst)\n\t\tgoto out;\n\twhile (block_num < num_blocks) {\n\t\tunsigned char *src_block;\n\t\tunsigned char dst_block[4];\n\n\t\tif (block_num == (num_blocks - 1))\n\t\t\tsrc_block = last_block;\n\t\telse\n\t\t\tsrc_block = &src[block_num * 3];\n\t\tdst_block[0] = ((src_block[0] >> 2) & 0x3F);\n\t\tdst_block[1] = (((src_block[0] << 4) & 0x30)\n\t\t\t\t| ((src_block[1] >> 4) & 0x0F));\n\t\tdst_block[2] = (((src_block[1] << 2) & 0x3C)\n\t\t\t\t| ((src_block[2] >> 6) & 0x03));\n\t\tdst_block[3] = (src_block[2] & 0x3F);\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[0]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[1]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[2]];\n\t\tdst[dst_offset++] = portable_filename_chars[dst_block[3]];\n\t\tblock_num++;\n\t}\nout:\n\treturn;\n}"
  },
  {
    "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1751-1775",
    "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex key_tfm_list_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\"",
            "rc"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_add_new_key_tfm",
          "args": [
            "&key_tfm",
            "cipher_name",
            "0"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_add_new_key_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1672-1710",
          "snippet": "int\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_tfm_cache;",
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_tfm_exists",
          "args": [
            "cipher_name",
            "&key_tfm"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_tfm_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1722-1738",
          "snippet": "int ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head key_tfm_list;",
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_tfm_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1722-1738",
    "snippet": "int ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head key_tfm_list;",
      "struct mutex key_tfm_list_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp_key_tfm->cipher_name",
            "cipher_name"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp_key_tfm",
            "&key_tfm_list",
            "key_tfm_list"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&key_tfm_list_mutex)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm)\n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_add_new_key_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1672-1710",
    "snippet": "int\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_key_tfm_cache;",
      "static struct list_head key_tfm_list;",
      "struct mutex key_tfm_list_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tmp_tfm->key_tfm_list",
            "&key_tfm_list"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_key_tfm_cache",
            "tmp_tfm"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\"",
            "tmp_tfm->cipher_name",
            "rc"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_process_key_cipher",
          "args": [
            "&tmp_tfm->key_tfm",
            "tmp_tfm->cipher_name",
            "&tmp_tfm->key_size"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_process_key_cipher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1594-1638",
          "snippet": "static int\necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tif (*key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\n\n\t\t*key_size = alg->max_keysize;\n\t}\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tif (*key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\n\n\t\t*key_size = alg->max_keysize;\n\t}\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "tmp_tfm->cipher_name",
            "cipher_name",
            "ECRYPTFS_MAX_CIPHER_NAME_SIZE"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&tmp_tfm->key_tfm_mutex"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_key_tfm_cache",
            "GFP_KERNEL"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&key_tfm_list_mutex)"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint\necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_destroy_crypto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1656-1670",
    "snippet": "int ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_key_tfm_cache;",
      "static struct list_head key_tfm_list;",
      "struct mutex key_tfm_list_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_key_tfm_cache",
            "key_tfm"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_blkcipher",
          "args": [
            "key_tfm->key_tfm"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&key_tfm->key_tfm_list"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "key_tfm",
            "key_tfm_tmp",
            "&key_tfm_list",
            "key_tfm_list"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *ecryptfs_key_tfm_cache;\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_destroy_crypto(void)\n{\n\tstruct ecryptfs_key_tfm *key_tfm, *key_tfm_tmp;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tlist_for_each_entry_safe(key_tfm, key_tfm_tmp, &key_tfm_list,\n\t\t\t\t key_tfm_list) {\n\t\tlist_del(&key_tfm->key_tfm_list);\n\t\tif (key_tfm->key_tfm)\n\t\t\tcrypto_free_blkcipher(key_tfm->key_tfm);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, key_tfm);\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_init_crypto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1644-1649",
    "snippet": "int __init ecryptfs_init_crypto(void)\n{\n\tmutex_init(&key_tfm_list_mutex);\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head key_tfm_list;",
      "struct mutex key_tfm_list_mutex;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&key_tfm_list"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&key_tfm_list_mutex"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct list_head key_tfm_list;\nstruct mutex key_tfm_list_mutex;\n\nint __init ecryptfs_init_crypto(void)\n{\n\tmutex_init(&key_tfm_list_mutex);\n\tINIT_LIST_HEAD(&key_tfm_list);\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_process_key_cipher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1594-1638",
    "snippet": "static int\necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tif (*key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\n\n\t\t*key_size = alg->max_keysize;\n\t}\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_alg_name"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\"",
            "*key_size",
            "full_alg_name",
            "rc"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "*key_tfm",
            "dummy_key",
            "*key_size"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "dummy_key",
            "*key_size"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_alg",
          "args": [
            "*key_tfm"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_set_flags",
          "args": [
            "*key_tfm",
            "CRYPTO_TFM_REQ_WEAK_KEY"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*key_tfm"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*key_tfm"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_blkcipher",
          "args": [
            "full_alg_name",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_crypto_api_algify_cipher_name",
          "args": [
            "&full_alg_name",
            "cipher_name",
            "\"ecb\""
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_crypto_api_algify_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "138-158",
          "snippet": "static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tif (*key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\n\n\t\t*key_size = alg->max_keysize;\n\t}\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_copy_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1564-1582",
    "snippet": "static int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)(*copied_name)",
            "(void *)name",
            "name_size"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(name_size + 1)",
            "GFP_KERNEL"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_encrypt_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1501-1562",
    "snippet": "static int\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\n\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t  struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tint rc = 0;\n\n\tfilename->encrypted_filename = NULL;\n\tfilename->encrypted_filename_size = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\tsize_t packet_size;\n\t\tsize_t remaining_bytes;\n\n\t\trc = ecryptfs_write_tag_70_packet(\n\t\t\tNULL, NULL,\n\t\t\t&filename->encrypted_filename_size,\n\t\t\tmount_crypt_stat, NULL,\n\t\t\tfilename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to get packet \"\n\t\t\t       \"size for tag 72; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename =\n\t\t\tkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\n\t\tif (!filename->encrypted_filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       filename->encrypted_filename_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tremaining_bytes = filename->encrypted_filename_size;\n\t\trc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\n\t\t\t\t\t\t  &remaining_bytes,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  filename->filename,\n\t\t\t\t\t\t  filename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to generate \"\n\t\t\t       \"tag 70 packet; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tfilename->encrypted_filename = NULL;\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename_size = packet_size;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\", __func__);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\"",
            "__func__"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "filename->encrypted_filename"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_tag_70_packet",
          "args": [
            "filename->encrypted_filename",
            "&remaining_bytes",
            "&packet_size",
            "mount_crypt_stat",
            "filename->filename",
            "filename->filename_size"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_tag_70_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "622-876",
          "snippet": "int\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *filename, size_t filename_size)\n{\n\tstruct ecryptfs_write_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\t(*packet_size) = 0;\n\trc = ecryptfs_find_auth_tok_for_sig(\n\t\t&auth_tok_key,\n\t\t&s->auth_tok, mount_crypt_stat,\n\t\tmount_crypt_stat->global_default_fnek_sig);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fnek_sig, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\n\t\t&s->desc.tfm,\n\t\t&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       mount_crypt_stat->global_default_fn_cipher_name, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\ts->block_size = crypto_blkcipher_blocksize(s->desc.tfm);\n\t/* Plus one for the \\0 separator between the random prefix\n\t * and the plaintext filename */\n\ts->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\n\ts->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\n\tif ((s->block_aligned_filename_size % s->block_size) != 0) {\n\t\ts->num_rand_bytes += (s->block_size\n\t\t\t\t      - (s->block_aligned_filename_size\n\t\t\t\t\t % s->block_size));\n\t\ts->block_aligned_filename_size = (s->num_rand_bytes\n\t\t\t\t\t\t  + filename_size);\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random characters, a \\0\n\t *    separator, and then the filename */\n\ts->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\n\t\t\t      + s->block_aligned_filename_size);\n\tif (dest == NULL) {\n\t\t(*packet_size) = s->max_packet_size;\n\t\tgoto out_unlock;\n\t}\n\tif (s->max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_WARNING \"%s: Require [%zd] bytes to write; only \"\n\t\t       \"[%zd] available\\n\", __func__, s->max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ts->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!s->block_aligned_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"kzalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ts->i = 0;\n\tdest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[s->i],\n\t\t\t\t\t  (ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1 /* Cipher code */\n\t\t\t\t\t   + s->block_aligned_filename_size),\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error generating tag 70 packet \"\n\t\t       \"header; cannot generate packet length; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i += s->packet_size_len;\n\tecryptfs_from_hex(&dest[s->i],\n\t\t\t  mount_crypt_stat->global_default_fnek_sig,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\ts->i += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_fn_cipher_name,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (s->cipher_code == 0) {\n\t\tprintk(KERN_WARNING \"%s: Unable to generate code for \"\n\t\t       \"cipher [%s] with key bytes [%zd]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\tdest[s->i++] = s->cipher_code;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\tsg_init_one(\n\t\t&s->hash_sg,\n\t\t(u8 *)s->auth_tok->token.password.session_key_encryption_key,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\ts->hash_desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\ts->hash_desc.tfm = crypto_alloc_hash(ECRYPTFS_TAG_70_DIGEST, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(s->hash_desc.tfm)) {\n\t\t\trc = PTR_ERR(s->hash_desc.tfm);\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to \"\n\t\t\t       \"allocate hash crypto context; rc = [%d]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_hash_init(&s->hash_desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_update(\n\t\t&s->hash_desc, &s->hash_sg,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_final(&s->hash_desc, s->hash);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\tfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\n\t\ts->block_aligned_filename[s->j] =\n\t\t\ts->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\n\t\tif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\n\t\t    == (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\n\t\t\tsg_init_one(&s->hash_sg, (u8 *)s->hash,\n\t\t\t\t    ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\trc = crypto_hash_init(&s->hash_desc);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error initializing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_update(&s->hash_desc, &s->hash_sg,\n\t\t\t\t\t\tECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error updating crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_final(&s->hash_desc, s->tmp_hash);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error finalizing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\tmemcpy(s->hash, s->tmp_hash,\n\t\t\t       ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t}\n\t\tif (s->block_aligned_filename[s->j] == '\\0')\n\t\t\ts->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\n\t}\n\tmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\n\t       filename_size);\n\trc = virt_to_scatterlist(s->block_aligned_filename,\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert filename memory to scatterlist; rc = [%d]. \"\n\t\t       \"block_aligned_filename_size = [%zd]\\n\", __func__, rc,\n\t\t       s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\n\t\t\t\t s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job\n\t * of the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_blkcipher_encrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\ts->i += s->block_aligned_filename_size;\n\t(*packet_size) = s->i;\n\t(*remaining_bytes) -= (*packet_size);\nout_release_free_unlock:\n\tcrypto_free_hash(s->hash_desc.tfm);\nout_free_unlock:\n\tkzfree(s->block_aligned_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *filename, size_t filename_size)\n{\n\tstruct ecryptfs_write_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\t(*packet_size) = 0;\n\trc = ecryptfs_find_auth_tok_for_sig(\n\t\t&auth_tok_key,\n\t\t&s->auth_tok, mount_crypt_stat,\n\t\tmount_crypt_stat->global_default_fnek_sig);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fnek_sig, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\n\t\t&s->desc.tfm,\n\t\t&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       mount_crypt_stat->global_default_fn_cipher_name, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\ts->block_size = crypto_blkcipher_blocksize(s->desc.tfm);\n\t/* Plus one for the \\0 separator between the random prefix\n\t * and the plaintext filename */\n\ts->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\n\ts->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\n\tif ((s->block_aligned_filename_size % s->block_size) != 0) {\n\t\ts->num_rand_bytes += (s->block_size\n\t\t\t\t      - (s->block_aligned_filename_size\n\t\t\t\t\t % s->block_size));\n\t\ts->block_aligned_filename_size = (s->num_rand_bytes\n\t\t\t\t\t\t  + filename_size);\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random characters, a \\0\n\t *    separator, and then the filename */\n\ts->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\n\t\t\t      + s->block_aligned_filename_size);\n\tif (dest == NULL) {\n\t\t(*packet_size) = s->max_packet_size;\n\t\tgoto out_unlock;\n\t}\n\tif (s->max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_WARNING \"%s: Require [%zd] bytes to write; only \"\n\t\t       \"[%zd] available\\n\", __func__, s->max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ts->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!s->block_aligned_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"kzalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ts->i = 0;\n\tdest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[s->i],\n\t\t\t\t\t  (ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1 /* Cipher code */\n\t\t\t\t\t   + s->block_aligned_filename_size),\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error generating tag 70 packet \"\n\t\t       \"header; cannot generate packet length; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i += s->packet_size_len;\n\tecryptfs_from_hex(&dest[s->i],\n\t\t\t  mount_crypt_stat->global_default_fnek_sig,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\ts->i += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_fn_cipher_name,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (s->cipher_code == 0) {\n\t\tprintk(KERN_WARNING \"%s: Unable to generate code for \"\n\t\t       \"cipher [%s] with key bytes [%zd]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\tdest[s->i++] = s->cipher_code;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\tsg_init_one(\n\t\t&s->hash_sg,\n\t\t(u8 *)s->auth_tok->token.password.session_key_encryption_key,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\ts->hash_desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\ts->hash_desc.tfm = crypto_alloc_hash(ECRYPTFS_TAG_70_DIGEST, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(s->hash_desc.tfm)) {\n\t\t\trc = PTR_ERR(s->hash_desc.tfm);\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to \"\n\t\t\t       \"allocate hash crypto context; rc = [%d]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_hash_init(&s->hash_desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_update(\n\t\t&s->hash_desc, &s->hash_sg,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_final(&s->hash_desc, s->hash);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\tfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\n\t\ts->block_aligned_filename[s->j] =\n\t\t\ts->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\n\t\tif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\n\t\t    == (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\n\t\t\tsg_init_one(&s->hash_sg, (u8 *)s->hash,\n\t\t\t\t    ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\trc = crypto_hash_init(&s->hash_desc);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error initializing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_update(&s->hash_desc, &s->hash_sg,\n\t\t\t\t\t\tECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error updating crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_final(&s->hash_desc, s->tmp_hash);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error finalizing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\tmemcpy(s->hash, s->tmp_hash,\n\t\t\t       ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t}\n\t\tif (s->block_aligned_filename[s->j] == '\\0')\n\t\t\ts->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\n\t}\n\tmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\n\t       filename_size);\n\trc = virt_to_scatterlist(s->block_aligned_filename,\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert filename memory to scatterlist; rc = [%d]. \"\n\t\t       \"block_aligned_filename_size = [%zd]\\n\", __func__, rc,\n\t\t       s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\n\t\t\t\t s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job\n\t * of the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_blkcipher_encrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\ts->i += s->block_aligned_filename_size;\n\t(*packet_size) = s->i;\n\t(*remaining_bytes) -= (*packet_size);\nout_release_free_unlock:\n\tcrypto_free_hash(s->hash_desc.tfm);\nout_free_unlock:\n\tkzfree(s->block_aligned_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "filename->encrypted_filename_size",
            "GFP_KERNEL"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_encrypt_filename(struct ecryptfs_filename *filename,\n\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t  struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tint rc = 0;\n\n\tfilename->encrypted_filename = NULL;\n\tfilename->encrypted_filename_size = 0;\n\tif ((crypt_stat && (crypt_stat->flags & ECRYPTFS_ENCFN_USE_MOUNT_FNEK))\n\t    || (mount_crypt_stat && (mount_crypt_stat->flags\n\t\t\t\t     & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK))) {\n\t\tsize_t packet_size;\n\t\tsize_t remaining_bytes;\n\n\t\trc = ecryptfs_write_tag_70_packet(\n\t\t\tNULL, NULL,\n\t\t\t&filename->encrypted_filename_size,\n\t\t\tmount_crypt_stat, NULL,\n\t\t\tfilename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to get packet \"\n\t\t\t       \"size for tag 72; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename =\n\t\t\tkmalloc(filename->encrypted_filename_size, GFP_KERNEL);\n\t\tif (!filename->encrypted_filename) {\n\t\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t\t       \"to kmalloc [%zd] bytes\\n\", __func__,\n\t\t\t       filename->encrypted_filename_size);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tremaining_bytes = filename->encrypted_filename_size;\n\t\trc = ecryptfs_write_tag_70_packet(filename->encrypted_filename,\n\t\t\t\t\t\t  &remaining_bytes,\n\t\t\t\t\t\t  &packet_size,\n\t\t\t\t\t\t  mount_crypt_stat,\n\t\t\t\t\t\t  filename->filename,\n\t\t\t\t\t\t  filename->filename_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to generate \"\n\t\t\t       \"tag 70 packet; rc = [%d]\\n\", __func__,\n\t\t\t       rc);\n\t\t\tkfree(filename->encrypted_filename);\n\t\t\tfilename->encrypted_filename = NULL;\n\t\t\tfilename->encrypted_filename_size = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tfilename->encrypted_filename_size = packet_size;\n\t} else {\n\t\tprintk(KERN_ERR \"%s: No support for requested filename \"\n\t\t       \"encryption method in this release\\n\", __func__);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1424-1490",
    "snippet": "int ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ECRYPTFS_VALIDATE_HEADER_SIZE 1",
      "#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0"
    ],
    "globals_used": [
      "struct kmem_cache *ecryptfs_header_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_header_cache",
            "page_virt"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_virt",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\"",
            "ecryptfs_inode->i_ino"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_headers_virt",
          "args": [
            "page_virt",
            "crypt_stat",
            "ecryptfs_dentry",
            "ECRYPTFS_DONT_VALIDATE_HEADER_SIZE"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_headers_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1312-1361",
          "snippet": "static int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = ecryptfs_validate_marker(page_virt + offset);\n\tif (rc)\n\t\tgoto out;\n\tif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\n\t\tecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\trc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\n\t\t\t\t    &bytes_read);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error processing flags\\n\");\n\t\tgoto out;\n\t}\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = ecryptfs_validate_marker(page_virt + offset);\n\tif (rc)\n\t\tgoto out;\n\tif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\n\t\tecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\trc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\n\t\t\t\t    &bytes_read);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error processing flags\\n\");\n\t\tgoto out;\n\t}\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_xattr_region",
          "args": [
            "page_virt",
            "ecryptfs_inode"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_xattr_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1373-1392",
          "snippet": "int ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_virt",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower",
          "args": [
            "page_virt",
            "0",
            "crypt_stat->extent_size",
            "ecryptfs_inode"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "231-239",
          "snippet": "int ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_header_cache",
            "GFP_USER"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "args": [
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "733-750",
          "snippet": "static void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "ecryptfs_dentry->d_sb"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\n#define ECRYPTFS_DONT_VALIDATE_HEADER_SIZE 0\n\nstruct kmem_cache *ecryptfs_header_cache;\n\nint ecryptfs_read_metadata(struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tchar *page_virt;\n\tstruct inode *ecryptfs_inode = ecryptfs_dentry->d_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\t/* Read the first page from the underlying file */\n\tpage_virt = kmem_cache_alloc(ecryptfs_header_cache, GFP_USER);\n\tif (!page_virt) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Unable to allocate page_virt\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_read_lower(page_virt, 0, crypt_stat->extent_size,\n\t\t\t\t ecryptfs_inode);\n\tif (rc >= 0)\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_VALIDATE_HEADER_SIZE);\n\tif (rc) {\n\t\t/* metadata is not in the file header, so try xattrs */\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\trc = ecryptfs_read_xattr_region(page_virt, ecryptfs_inode);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file header region or xattr region, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ecryptfs_read_headers_virt(page_virt, crypt_stat,\n\t\t\t\t\t\tecryptfs_dentry,\n\t\t\t\t\t\tECRYPTFS_DONT_VALIDATE_HEADER_SIZE);\n\t\tif (rc) {\n\t\t\tprintk(KERN_DEBUG \"Valid eCryptfs headers not found in \"\n\t\t\t       \"file xattr region either, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tif (crypt_stat->mount_crypt_stat->flags\n\t\t    & ECRYPTFS_XATTR_METADATA_ENABLED) {\n\t\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"Attempt to access file with \"\n\t\t\t       \"crypto metadata only in the extended attribute \"\n\t\t\t       \"region, but eCryptfs was mounted without \"\n\t\t\t       \"xattr support enabled. eCryptfs will not treat \"\n\t\t\t       \"this like an encrypted file, inode %lu\\n\",\n\t\t\t\tecryptfs_inode->i_ino);\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\nout:\n\tif (page_virt) {\n\t\tmemset(page_virt, 0, PAGE_CACHE_SIZE);\n\t\tkmem_cache_free(ecryptfs_header_cache, page_virt);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_and_validate_xattr_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1394-1410",
    "snippet": "int ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t     ECRYPTFS_XATTR_NAME, file_size,\n\t\t\t\t     ECRYPTFS_SIZE_AND_MARKER_BYTES);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_i_size_init",
          "args": [
            "file_size",
            "inode"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_i_size_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1281-1298",
          "snippet": "void ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_validate_marker",
          "args": [
            "marker"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_validate_marker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "865-879",
          "snippet": "static int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_getxattr_lower",
          "args": [
            "ecryptfs_dentry_to_lower(dentry)",
            "ECRYPTFS_XATTR_NAME",
            "file_size",
            "ECRYPTFS_SIZE_AND_MARKER_BYTES"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_getxattr_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "1038-1054",
          "snippet": "ssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dentry_to_lower",
          "args": [
            "dentry"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dentry_to_lower_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "524-528",
          "snippet": "static inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct path *\necryptfs_dentry_to_lower_path(struct dentry *dentry)\n{\n\treturn &((struct ecryptfs_dentry_info *)dentry->d_fsdata)->lower_path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_and_validate_xattr_region(struct dentry *dentry,\n\t\t\t\t\t    struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry),\n\t\t\t\t     ECRYPTFS_XATTR_NAME, file_size,\n\t\t\t\t     ECRYPTFS_SIZE_AND_MARKER_BYTES);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_xattr_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1373-1392",
    "snippet": "int ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\"",
            "ECRYPTFS_XATTR_NAME",
            "size"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_getxattr_lower",
          "args": [
            "lower_dentry",
            "ECRYPTFS_XATTR_NAME",
            "page_virt",
            "ECRYPTFS_DEFAULT_EXTENT_SIZE"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_getxattr_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "1038-1054",
          "snippet": "ssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nssize_t\necryptfs_getxattr_lower(struct dentry *lower_dentry, const char *name,\n\t\t\tvoid *value, size_t size)\n{\n\tint rc = 0;\n\n\tif (!lower_dentry->d_inode->i_op->getxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tmutex_lock(&lower_dentry->d_inode->i_mutex);\n\trc = lower_dentry->d_inode->i_op->getxattr(lower_dentry, name, value,\n\t\t\t\t\t\t   size);\n\tmutex_unlock(&lower_dentry->d_inode->i_mutex);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_xattr_region(char *page_virt, struct inode *ecryptfs_inode)\n{\n\tstruct dentry *lower_dentry =\n\t\tecryptfs_inode_to_private(ecryptfs_inode)->lower_file->f_path.dentry;\n\tssize_t size;\n\tint rc = 0;\n\n\tsize = ecryptfs_getxattr_lower(lower_dentry, ECRYPTFS_XATTR_NAME,\n\t\t\t\t       page_virt, ECRYPTFS_DEFAULT_EXTENT_SIZE);\n\tif (size < 0) {\n\t\tif (unlikely(ecryptfs_verbosity > 0))\n\t\t\tprintk(KERN_INFO \"Error attempting to read the [%s] \"\n\t\t\t       \"xattr from the lower file; return value = \"\n\t\t\t       \"[%zd]\\n\", ECRYPTFS_XATTR_NAME, size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_read_headers_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1312-1361",
    "snippet": "static int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = ecryptfs_validate_marker(page_virt + offset);\n\tif (rc)\n\t\tgoto out;\n\tif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\n\t\tecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\trc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\n\t\t\t\t    &bytes_read);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error processing flags\\n\");\n\t\tgoto out;\n\t}\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_set",
          "args": [
            "crypt_stat",
            "(page_virt + offset)",
            "ecryptfs_dentry"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1757-1962",
          "snippet": "int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t      unsigned char *src,\n\t\t\t      struct dentry *ecryptfs_dentry)\n{\n\tsize_t i = 0;\n\tsize_t found_auth_tok;\n\tsize_t next_packet_is_auth_tok_packet;\n\tstruct list_head auth_tok_list;\n\tstruct ecryptfs_auth_tok *matching_auth_tok;\n\tstruct ecryptfs_auth_tok *candidate_auth_tok;\n\tchar *candidate_auth_tok_sig;\n\tsize_t packet_size;\n\tstruct ecryptfs_auth_tok *new_auth_tok;\n\tunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t tag_11_contents_size;\n\tsize_t tag_11_packet_size;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&auth_tok_list);\n\t/* Parse the header to find as many packets as we can; these will be\n\t * added the our &auth_tok_list */\n\tnext_packet_is_auth_tok_packet = 1;\n\twhile (next_packet_is_auth_tok_packet) {\n\t\tsize_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);\n\n\t\tswitch (src[i]) {\n\t\tcase ECRYPTFS_TAG_3_PACKET_TYPE:\n\t\t\trc = parse_tag_3_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\trc = parse_tag_11_packet((unsigned char *)&src[i],\n\t\t\t\t\t\t sig_tmp_space,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\t &tag_11_contents_size,\n\t\t\t\t\t\t &tag_11_packet_size,\n\t\t\t\t\t\t max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"No valid \"\n\t\t\t\t\t\t\"(ecryptfs-specific) literal \"\n\t\t\t\t\t\t\"packet containing \"\n\t\t\t\t\t\t\"authentication token \"\n\t\t\t\t\t\t\"signature found after \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += tag_11_packet_size;\n\t\t\tif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Expected \"\n\t\t\t\t\t\t\"signature of size [%d]; \"\n\t\t\t\t\t\t\"read size [%zd]\\n\",\n\t\t\t\t\t\tECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\ttag_11_contents_size);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\tecryptfs_to_hex(new_auth_tok->token.password.signature,\n\t\t\t\t\tsig_tmp_space, tag_11_contents_size);\n\t\t\tnew_auth_tok->token.password.signature[\n\t\t\t\tECRYPTFS_PASSWORD_SIG_SIZE] = '\\0';\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_1_PACKET_TYPE:\n\t\t\trc = parse_tag_1_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 1 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_11_PACKET_TYPE:\n\t\t\tecryptfs_printk(KERN_WARNING, \"Invalid packet set \"\n\t\t\t\t\t\"(Tag 11 not allowed by itself)\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out_wipe_list;\n\t\tdefault:\n\t\t\tecryptfs_printk(KERN_DEBUG, \"No packet at offset [%zd] \"\n\t\t\t\t\t\"of the file header; hex value of \"\n\t\t\t\t\t\"character is [0x%.2x]\\n\", i, src[i]);\n\t\t\tnext_packet_is_auth_tok_packet = 0;\n\t\t}\n\t}\n\tif (list_empty(&auth_tok_list)) {\n\t\tprintk(KERN_ERR \"The lower file appears to be a non-encrypted \"\n\t\t       \"eCryptfs file; this is not supported in this version \"\n\t\t       \"of the eCryptfs kernel module\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* auth_tok_list contains the set of authentication tokens\n\t * parsed from the metadata. We need to find a matching\n\t * authentication token that has the secret component(s)\n\t * necessary to decrypt the EFEK in the auth_tok parsed from\n\t * the metadata. There may be several potential matches, but\n\t * just one will be sufficient to decrypt to get the FEK. */\nfind_next_matching_auth_tok:\n\tfound_auth_tok = 0;\n\tlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\n\t\tcandidate_auth_tok = &auth_tok_list_item->auth_tok;\n\t\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"Considering cadidate auth tok:\\n\");\n\t\t\tecryptfs_dump_auth_tok(candidate_auth_tok);\n\t\t}\n\t\trc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\n\t\t\t\t\t       candidate_auth_tok);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Unrecognized candidate auth tok type: [%d]\\n\",\n\t\t\t       candidate_auth_tok->token_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_wipe_list;\n\t\t}\n\t\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t       &matching_auth_tok,\n\t\t\t\t\t       crypt_stat->mount_crypt_stat,\n\t\t\t\t\t       candidate_auth_tok_sig);\n\t\tif (!rc) {\n\t\t\tfound_auth_tok = 1;\n\t\t\tgoto found_matching_auth_tok;\n\t\t}\n\t}\n\tif (!found_auth_tok) {\n\t\tecryptfs_printk(KERN_ERR, \"Could not find a usable \"\n\t\t\t\t\"authentication token\\n\");\n\t\trc = -EIO;\n\t\tgoto out_wipe_list;\n\t}\nfound_matching_auth_tok:\n\tif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\tmemcpy(&(candidate_auth_tok->token.private_key),\n\t\t       &(matching_auth_tok->token.private_key),\n\t\t       sizeof(struct ecryptfs_private_key));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\n\t\t\t\t\t\t       crypt_stat);\n\t} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\tmemcpy(&(candidate_auth_tok->token.password),\n\t\t       &(matching_auth_tok->token.password),\n\t\t       sizeof(struct ecryptfs_password));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_passphrase_encrypted_session_key(\n\t\t\tcandidate_auth_tok, crypt_stat);\n\t} else {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = -EINVAL;\n\t}\n\tif (rc) {\n\t\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\t\tecryptfs_printk(KERN_WARNING, \"Error decrypting the \"\n\t\t\t\t\"session key for authentication token with sig \"\n\t\t\t\t\"[%.*s]; rc = [%d]. Removing auth tok \"\n\t\t\t\t\"candidate from the list and searching for \"\n\t\t\t\t\"the next match.\\n\", ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\tcandidate_auth_tok_sig,\trc);\n\t\tlist_for_each_entry_safe(auth_tok_list_item,\n\t\t\t\t\t auth_tok_list_item_tmp,\n\t\t\t\t\t &auth_tok_list, list) {\n\t\t\tif (candidate_auth_tok\n\t\t\t    == &auth_tok_list_item->auth_tok) {\n\t\t\t\tlist_del(&auth_tok_list_item->list);\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tecryptfs_auth_tok_list_item_cache,\n\t\t\t\t\tauth_tok_list_item);\n\t\t\t\tgoto find_next_matching_auth_tok;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\t}\n\trc = ecryptfs_compute_root_iv(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error computing \"\n\t\t\t\t\"the root IV\\n\");\n\t\tgoto out_wipe_list;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\n\t}\nout_wipe_list:\n\twipe_auth_tok_list(&auth_tok_list);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nint ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t      unsigned char *src,\n\t\t\t      struct dentry *ecryptfs_dentry)\n{\n\tsize_t i = 0;\n\tsize_t found_auth_tok;\n\tsize_t next_packet_is_auth_tok_packet;\n\tstruct list_head auth_tok_list;\n\tstruct ecryptfs_auth_tok *matching_auth_tok;\n\tstruct ecryptfs_auth_tok *candidate_auth_tok;\n\tchar *candidate_auth_tok_sig;\n\tsize_t packet_size;\n\tstruct ecryptfs_auth_tok *new_auth_tok;\n\tunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t tag_11_contents_size;\n\tsize_t tag_11_packet_size;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&auth_tok_list);\n\t/* Parse the header to find as many packets as we can; these will be\n\t * added the our &auth_tok_list */\n\tnext_packet_is_auth_tok_packet = 1;\n\twhile (next_packet_is_auth_tok_packet) {\n\t\tsize_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);\n\n\t\tswitch (src[i]) {\n\t\tcase ECRYPTFS_TAG_3_PACKET_TYPE:\n\t\t\trc = parse_tag_3_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\trc = parse_tag_11_packet((unsigned char *)&src[i],\n\t\t\t\t\t\t sig_tmp_space,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\t &tag_11_contents_size,\n\t\t\t\t\t\t &tag_11_packet_size,\n\t\t\t\t\t\t max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"No valid \"\n\t\t\t\t\t\t\"(ecryptfs-specific) literal \"\n\t\t\t\t\t\t\"packet containing \"\n\t\t\t\t\t\t\"authentication token \"\n\t\t\t\t\t\t\"signature found after \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += tag_11_packet_size;\n\t\t\tif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Expected \"\n\t\t\t\t\t\t\"signature of size [%d]; \"\n\t\t\t\t\t\t\"read size [%zd]\\n\",\n\t\t\t\t\t\tECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\ttag_11_contents_size);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\tecryptfs_to_hex(new_auth_tok->token.password.signature,\n\t\t\t\t\tsig_tmp_space, tag_11_contents_size);\n\t\t\tnew_auth_tok->token.password.signature[\n\t\t\t\tECRYPTFS_PASSWORD_SIG_SIZE] = '\\0';\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_1_PACKET_TYPE:\n\t\t\trc = parse_tag_1_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 1 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_11_PACKET_TYPE:\n\t\t\tecryptfs_printk(KERN_WARNING, \"Invalid packet set \"\n\t\t\t\t\t\"(Tag 11 not allowed by itself)\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out_wipe_list;\n\t\tdefault:\n\t\t\tecryptfs_printk(KERN_DEBUG, \"No packet at offset [%zd] \"\n\t\t\t\t\t\"of the file header; hex value of \"\n\t\t\t\t\t\"character is [0x%.2x]\\n\", i, src[i]);\n\t\t\tnext_packet_is_auth_tok_packet = 0;\n\t\t}\n\t}\n\tif (list_empty(&auth_tok_list)) {\n\t\tprintk(KERN_ERR \"The lower file appears to be a non-encrypted \"\n\t\t       \"eCryptfs file; this is not supported in this version \"\n\t\t       \"of the eCryptfs kernel module\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* auth_tok_list contains the set of authentication tokens\n\t * parsed from the metadata. We need to find a matching\n\t * authentication token that has the secret component(s)\n\t * necessary to decrypt the EFEK in the auth_tok parsed from\n\t * the metadata. There may be several potential matches, but\n\t * just one will be sufficient to decrypt to get the FEK. */\nfind_next_matching_auth_tok:\n\tfound_auth_tok = 0;\n\tlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\n\t\tcandidate_auth_tok = &auth_tok_list_item->auth_tok;\n\t\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"Considering cadidate auth tok:\\n\");\n\t\t\tecryptfs_dump_auth_tok(candidate_auth_tok);\n\t\t}\n\t\trc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\n\t\t\t\t\t       candidate_auth_tok);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Unrecognized candidate auth tok type: [%d]\\n\",\n\t\t\t       candidate_auth_tok->token_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_wipe_list;\n\t\t}\n\t\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t       &matching_auth_tok,\n\t\t\t\t\t       crypt_stat->mount_crypt_stat,\n\t\t\t\t\t       candidate_auth_tok_sig);\n\t\tif (!rc) {\n\t\t\tfound_auth_tok = 1;\n\t\t\tgoto found_matching_auth_tok;\n\t\t}\n\t}\n\tif (!found_auth_tok) {\n\t\tecryptfs_printk(KERN_ERR, \"Could not find a usable \"\n\t\t\t\t\"authentication token\\n\");\n\t\trc = -EIO;\n\t\tgoto out_wipe_list;\n\t}\nfound_matching_auth_tok:\n\tif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\tmemcpy(&(candidate_auth_tok->token.private_key),\n\t\t       &(matching_auth_tok->token.private_key),\n\t\t       sizeof(struct ecryptfs_private_key));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\n\t\t\t\t\t\t       crypt_stat);\n\t} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\tmemcpy(&(candidate_auth_tok->token.password),\n\t\t       &(matching_auth_tok->token.password),\n\t\t       sizeof(struct ecryptfs_password));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_passphrase_encrypted_session_key(\n\t\t\tcandidate_auth_tok, crypt_stat);\n\t} else {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = -EINVAL;\n\t}\n\tif (rc) {\n\t\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\t\tecryptfs_printk(KERN_WARNING, \"Error decrypting the \"\n\t\t\t\t\"session key for authentication token with sig \"\n\t\t\t\t\"[%.*s]; rc = [%d]. Removing auth tok \"\n\t\t\t\t\"candidate from the list and searching for \"\n\t\t\t\t\"the next match.\\n\", ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\tcandidate_auth_tok_sig,\trc);\n\t\tlist_for_each_entry_safe(auth_tok_list_item,\n\t\t\t\t\t auth_tok_list_item_tmp,\n\t\t\t\t\t &auth_tok_list, list) {\n\t\t\tif (candidate_auth_tok\n\t\t\t    == &auth_tok_list_item->auth_tok) {\n\t\t\t\tlist_del(&auth_tok_list_item->list);\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tecryptfs_auth_tok_list_item_cache,\n\t\t\t\t\tauth_tok_list_item);\n\t\t\t\tgoto find_next_matching_auth_tok;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\t}\n\trc = ecryptfs_compute_root_iv(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error computing \"\n\t\t\t\t\"the root IV\\n\");\n\t\tgoto out_wipe_list;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\n\t}\nout_wipe_list:\n\twipe_auth_tok_list(&auth_tok_list);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_default_header_data",
          "args": [
            "crypt_stat"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "set_default_header_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1276-1279",
          "snippet": "static void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_header_metadata",
          "args": [
            "crypt_stat",
            "(page_virt + offset)",
            "&bytes_read",
            "validate_header_size"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "parse_header_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1244-1266",
          "snippet": "static int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *virt, int *bytes_read,\n\t\t\t\t int validate_header_size)\n{\n\tint rc = 0;\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = get_unaligned_be32(virt);\n\tvirt += sizeof(__be32);\n\tnum_header_extents_at_front = get_unaligned_be16(virt);\n\tcrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\n\t\t\t\t     * (size_t)header_extent_size));\n\t(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\n\tif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\n\t    && (crypt_stat->metadata_size\n\t\t< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"Invalid header size: [%zd]\\n\",\n\t\t       crypt_stat->metadata_size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_VALIDATE_HEADER_SIZE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\n\nstatic int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *virt, int *bytes_read,\n\t\t\t\t int validate_header_size)\n{\n\tint rc = 0;\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = get_unaligned_be32(virt);\n\tvirt += sizeof(__be32);\n\tnum_header_extents_at_front = get_unaligned_be16(virt);\n\tcrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\n\t\t\t\t     * (size_t)header_extent_size));\n\t(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\n\tif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\n\t    && (crypt_stat->metadata_size\n\t\t< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"Invalid header size: [%zd]\\n\",\n\t\t       crypt_stat->metadata_size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_process_flags",
          "args": [
            "crypt_stat",
            "(page_virt + offset)",
            "&bytes_read"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_process_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "902-920",
          "snippet": "static int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *page_virt, int *bytes_read)\n{\n\tint rc = 0;\n\tint i;\n\tu32 flags;\n\n\tflags = get_unaligned_be32(page_virt);\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (flags & ecryptfs_flag_map[i].file_flag) {\n\t\t\tcrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\n\t\t} else\n\t\t\tcrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tcrypt_stat->file_version = ((flags >> 24) & 0xFF);\n\t(*bytes_read) = 4;\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\nstatic int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *page_virt, int *bytes_read)\n{\n\tint rc = 0;\n\tint i;\n\tu32 flags;\n\n\tflags = get_unaligned_be32(page_virt);\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (flags & ecryptfs_flag_map[i].file_flag) {\n\t\t\tcrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\n\t\t} else\n\t\t\tcrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tcrypt_stat->file_version = ((flags >> 24) & 0xFF);\n\t(*bytes_read) = 4;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_i_size_init",
          "args": [
            "page_virt",
            "ecryptfs_dentry->d_inode"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_i_size_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1281-1298",
          "snippet": "void ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_validate_marker",
          "args": [
            "page_virt + offset"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_validate_marker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "865-879",
          "snippet": "static int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "ecryptfs_dentry->d_sb"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_default_sizes",
          "args": [
            "crypt_stat"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_default_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "660-676",
          "snippet": "void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_read_headers_virt(char *page_virt,\n\t\t\t\t      struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t      struct dentry *ecryptfs_dentry,\n\t\t\t\t      int validate_header_size)\n{\n\tint rc = 0;\n\tint offset;\n\tint bytes_read;\n\n\tecryptfs_set_default_sizes(crypt_stat);\n\tcrypt_stat->mount_crypt_stat = &ecryptfs_superblock_to_private(\n\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\trc = ecryptfs_validate_marker(page_virt + offset);\n\tif (rc)\n\t\tgoto out;\n\tif (!(crypt_stat->flags & ECRYPTFS_I_SIZE_INITIALIZED))\n\t\tecryptfs_i_size_init(page_virt, ecryptfs_dentry->d_inode);\n\toffset += MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n\trc = ecryptfs_process_flags(crypt_stat, (page_virt + offset),\n\t\t\t\t    &bytes_read);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error processing flags\\n\");\n\t\tgoto out;\n\t}\n\tif (crypt_stat->file_version > ECRYPTFS_SUPPORTED_FILE_VERSION) {\n\t\tecryptfs_printk(KERN_WARNING, \"File version is [%d]; only \"\n\t\t\t\t\"file version [%d] is supported by this \"\n\t\t\t\t\"version of eCryptfs\\n\",\n\t\t\t\tcrypt_stat->file_version,\n\t\t\t\tECRYPTFS_SUPPORTED_FILE_VERSION);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += bytes_read;\n\tif (crypt_stat->file_version >= 1) {\n\t\trc = parse_header_metadata(crypt_stat, (page_virt + offset),\n\t\t\t\t\t   &bytes_read, validate_header_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_WARNING, \"Error reading header \"\n\t\t\t\t\t\"metadata; rc = [%d]\\n\", rc);\n\t\t}\n\t\toffset += bytes_read;\n\t} else\n\t\tset_default_header_data(crypt_stat);\n\trc = ecryptfs_parse_packet_set(crypt_stat, (page_virt + offset),\n\t\t\t\t       ecryptfs_dentry);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_i_size_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1281-1298",
    "snippet": "void ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "(loff_t)file_size"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_be64",
          "args": [
            "page_virt"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ecryptfs_inode_to_lower(inode)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_lower",
          "args": [
            "inode"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "462-465",
          "snippet": "static inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct inode *ecryptfs_inode_to_lower(struct inode *inode)\n{\n\treturn ecryptfs_inode_to_private(inode)->wii_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "inode->i_sb"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "inode"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}"
  },
  {
    "function_name": "set_default_header_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1276-1279",
    "snippet": "static void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n}"
  },
  {
    "function_name": "parse_header_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1244-1266",
    "snippet": "static int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *virt, int *bytes_read,\n\t\t\t\t int validate_header_size)\n{\n\tint rc = 0;\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = get_unaligned_be32(virt);\n\tvirt += sizeof(__be32);\n\tnum_header_extents_at_front = get_unaligned_be16(virt);\n\tcrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\n\t\t\t\t     * (size_t)header_extent_size));\n\t(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\n\tif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\n\t    && (crypt_stat->metadata_size\n\t\t< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"Invalid header size: [%zd]\\n\",\n\t\t       crypt_stat->metadata_size);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ECRYPTFS_VALIDATE_HEADER_SIZE 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Invalid header size: [%zd]\\n\"",
            "crypt_stat->metadata_size"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_be16",
          "args": [
            "virt"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be32",
          "args": [
            "virt"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ECRYPTFS_VALIDATE_HEADER_SIZE 1\n\nstatic int parse_header_metadata(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t char *virt, int *bytes_read,\n\t\t\t\t int validate_header_size)\n{\n\tint rc = 0;\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = get_unaligned_be32(virt);\n\tvirt += sizeof(__be32);\n\tnum_header_extents_at_front = get_unaligned_be16(virt);\n\tcrypt_stat->metadata_size = (((size_t)num_header_extents_at_front\n\t\t\t\t     * (size_t)header_extent_size));\n\t(*bytes_read) = (sizeof(__be32) + sizeof(__be16));\n\tif ((validate_header_size == ECRYPTFS_VALIDATE_HEADER_SIZE)\n\t    && (crypt_stat->metadata_size\n\t\t< ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"Invalid header size: [%zd]\\n\",\n\t\t       crypt_stat->metadata_size);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1185-1240",
    "snippet": "int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\n\t\t\t    struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->metadata_size;\n\torder = get_order(virt_len);\n\t/* Released in this function */\n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* Zeroed page ensures the in-header unencrypted i_size is set to 0 */\n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n\t\t\t\t\t\t      size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)virt",
            "order"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_metadata_to_contents",
          "args": [
            "ecryptfs_inode",
            "virt",
            "virt_len"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_metadata_to_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1134-1148",
          "snippet": "static int\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_metadata_to_xattr",
          "args": [
            "ecryptfs_dentry",
            "virt",
            "size"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_metadata_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1150-1159",
          "snippet": "static int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_headers_virt",
          "args": [
            "virt",
            "virt_len",
            "&size",
            "crypt_stat",
            "ecryptfs_dentry"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_headers_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1103-1132",
          "snippet": "static int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n\t\t\t\t       size_t *size,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t       struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tsize_t written;\n\tsize_t offset;\n\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\twrite_ecryptfs_marker((page_virt + offset), &written);\n\toffset += written;\n\tecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\n\t\t\t\t\t&written);\n\toffset += written;\n\tecryptfs_write_header_metadata((page_virt + offset), crypt_stat,\n\t\t\t\t       &written);\n\toffset += written;\n\trc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\n\t\t\t\t\t      ecryptfs_dentry, &written,\n\t\t\t\t\t      max - offset);\n\tif (rc)\n\t\tecryptfs_printk(KERN_WARNING, \"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\", rc);\n\tif (size) {\n\t\toffset += written;\n\t\t*size = offset;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n\t\t\t\t       size_t *size,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t       struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tsize_t written;\n\tsize_t offset;\n\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\twrite_ecryptfs_marker((page_virt + offset), &written);\n\toffset += written;\n\tecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\n\t\t\t\t\t&written);\n\toffset += written;\n\tecryptfs_write_header_metadata((page_virt + offset), crypt_stat,\n\t\t\t\t       &written);\n\toffset += written;\n\trc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\n\t\t\t\t\t      ecryptfs_dentry, &written,\n\t\t\t\t\t      max - offset);\n\tif (rc)\n\t\tecryptfs_printk(KERN_WARNING, \"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\", rc);\n\tif (size) {\n\t\toffset += written;\n\t\t*size = offset;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_zeroed_pages",
          "args": [
            "GFP_KERNEL",
            "order"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_zeroed_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1161-1170",
          "snippet": "static unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "virt_len"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "crypt_stat->flags & ECRYPTFS_ENCRYPTED"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,\n\t\t\t    struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t\t&ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tunsigned int order;\n\tchar *virt;\n\tsize_t virt_len;\n\tsize_t size = 0;\n\tint rc = 0;\n\n\tif (likely(crypt_stat->flags & ECRYPTFS_ENCRYPTED)) {\n\t\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\t\tprintk(KERN_ERR \"Key is invalid; bailing out\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tprintk(KERN_WARNING \"%s: Encrypted flag not set\\n\",\n\t\t       __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tvirt_len = crypt_stat->metadata_size;\n\torder = get_order(virt_len);\n\t/* Released in this function */\n\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n\tif (!virt) {\n\t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* Zeroed page ensures the in-header unencrypted i_size is set to 0 */\n\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n\t\t\t\t\t ecryptfs_dentry);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free;\n\t}\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n\t\t\t\t\t\t      size);\n\telse\n\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_inode, virt,\n\t\t\t\t\t\t\t virt_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free;\n\t}\nout_free:\n\tfree_pages((unsigned long)virt, order);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_get_zeroed_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1161-1170",
    "snippet": "static unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp_mask | __GFP_ZERO",
            "order"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7735-7756",
          "snippet": "static struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic struct page **nfs4_alloc_pages(size_t size, gfp_t gfp_flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kcalloc(size, sizeof(struct page *), gfp_flags);\n\tif (!pages) {\n\t\tdprintk(\"%s: can't alloc array of %zu pages\\n\", __func__, size);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i]) {\n\t\t\tdprintk(\"%s: failed to allocate page\\n\", __func__);\n\t\t\tnfs4_free_pages(pages, size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_write_metadata_to_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1150-1159",
    "snippet": "static int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_setxattr",
          "args": [
            "ecryptfs_dentry",
            "ECRYPTFS_XATTR_NAME",
            "page_virt",
            "size",
            "0"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "1018-1036",
          "snippet": "int\necryptfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->setxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = vfs_setxattr(lower_dentry, name, value, size, flags);\n\tif (!rc && dentry->d_inode)\n\t\tfsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nint\necryptfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tint rc = 0;\n\tstruct dentry *lower_dentry;\n\n\tlower_dentry = ecryptfs_dentry_to_lower(dentry);\n\tif (!lower_dentry->d_inode->i_op->setxattr) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trc = vfs_setxattr(lower_dentry, name, value, size, flags);\n\tif (!rc && dentry->d_inode)\n\t\tfsstack_copy_attr_all(dentry->d_inode, lower_dentry->d_inode);\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n\t\t\t\t char *page_virt, size_t size)\n{\n\tint rc;\n\n\trc = ecryptfs_setxattr(ecryptfs_dentry, ECRYPTFS_XATTR_NAME, page_virt,\n\t\t\t       size, 0);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_metadata_to_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1134-1148",
    "snippet": "static int\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower",
          "args": [
            "ecryptfs_inode",
            "virt",
            "0",
            "virt_len"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int\necryptfs_write_metadata_to_contents(struct inode *ecryptfs_inode,\n\t\t\t\t    char *virt, size_t virt_len)\n{\n\tint rc;\n\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt,\n\t\t\t\t  0, virt_len);\n\tif (rc < 0)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__, rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_headers_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1103-1132",
    "snippet": "static int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n\t\t\t\t       size_t *size,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t       struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tsize_t written;\n\tsize_t offset;\n\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\twrite_ecryptfs_marker((page_virt + offset), &written);\n\toffset += written;\n\tecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\n\t\t\t\t\t&written);\n\toffset += written;\n\tecryptfs_write_header_metadata((page_virt + offset), crypt_stat,\n\t\t\t\t       &written);\n\toffset += written;\n\trc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\n\t\t\t\t\t      ecryptfs_dentry, &written,\n\t\t\t\t\t      max - offset);\n\tif (rc)\n\t\tecryptfs_printk(KERN_WARNING, \"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\", rc);\n\tif (size) {\n\t\toffset += written;\n\t\t*size = offset;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_generate_key_packet_set",
          "args": [
            "(page_virt + offset)",
            "crypt_stat",
            "ecryptfs_dentry",
            "&written",
            "max - offset"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_generate_key_packet_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2389-2480",
          "snippet": "int\necryptfs_generate_key_packet_set(char *dest_base,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t struct dentry *ecryptfs_dentry, size_t *len,\n\t\t\t\t size_t max)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct key *auth_tok_key = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tsize_t written;\n\tstruct ecryptfs_key_record *key_rec;\n\tstruct ecryptfs_key_sig *key_sig;\n\tint rc = 0;\n\n\t(*len) = 0;\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\n\tif (!key_rec) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\n\t\t\t    crypt_stat_list) {\n\t\tmemset(key_rec, 0, sizeof(*key_rec));\n\t\trc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t\t\t   &auth_tok,\n\t\t\t\t\t\t\t   mount_crypt_stat,\n\t\t\t\t\t\t\t   key_sig->keysig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"Unable to retrieve auth tok with \"\n\t\t\t       \"sig = [%s]\\n\", key_sig->keysig);\n\t\t\trc = process_find_global_auth_tok_for_sig_err(rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\t\trc = write_tag_3_packet((dest_base + (*len)),\n\t\t\t\t\t\t&max, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec,\n\t\t\t\t\t\t&written);\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 3 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t\t/* Write auth tok signature packet */\n\t\t\trc = write_tag_11_packet((dest_base + (*len)), &max,\n\t\t\t\t\t\t key_rec->sig,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error writing \"\n\t\t\t\t\t\t\"auth tok signature packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\t\trc = write_tag_1_packet(dest_base + (*len), &max,\n\t\t\t\t\t\tauth_tok_key, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 1 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else {\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tecryptfs_printk(KERN_WARNING, \"Unsupported \"\n\t\t\t\t\t\"authentication token type\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tif (likely(max > 0)) {\n\t\tdest_base[(*len)] = 0x00;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error writing boundary byte\\n\");\n\t\trc = -EIO;\n\t}\nout_free:\n\tkmem_cache_free(ecryptfs_key_record_cache, key_rec);\nout:\n\tif (rc)\n\t\t(*len) = 0;\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_key_record_cache;\n\nint\necryptfs_generate_key_packet_set(char *dest_base,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t struct dentry *ecryptfs_dentry, size_t *len,\n\t\t\t\t size_t max)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct key *auth_tok_key = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tsize_t written;\n\tstruct ecryptfs_key_record *key_rec;\n\tstruct ecryptfs_key_sig *key_sig;\n\tint rc = 0;\n\n\t(*len) = 0;\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\n\tif (!key_rec) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\n\t\t\t    crypt_stat_list) {\n\t\tmemset(key_rec, 0, sizeof(*key_rec));\n\t\trc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t\t\t   &auth_tok,\n\t\t\t\t\t\t\t   mount_crypt_stat,\n\t\t\t\t\t\t\t   key_sig->keysig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"Unable to retrieve auth tok with \"\n\t\t\t       \"sig = [%s]\\n\", key_sig->keysig);\n\t\t\trc = process_find_global_auth_tok_for_sig_err(rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\t\trc = write_tag_3_packet((dest_base + (*len)),\n\t\t\t\t\t\t&max, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec,\n\t\t\t\t\t\t&written);\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 3 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t\t/* Write auth tok signature packet */\n\t\t\trc = write_tag_11_packet((dest_base + (*len)), &max,\n\t\t\t\t\t\t key_rec->sig,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error writing \"\n\t\t\t\t\t\t\"auth tok signature packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\t\trc = write_tag_1_packet(dest_base + (*len), &max,\n\t\t\t\t\t\tauth_tok_key, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 1 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else {\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tecryptfs_printk(KERN_WARNING, \"Unsupported \"\n\t\t\t\t\t\"authentication token type\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tif (likely(max > 0)) {\n\t\tdest_base[(*len)] = 0x00;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error writing boundary byte\\n\");\n\t\trc = -EIO;\n\t}\nout_free:\n\tkmem_cache_free(ecryptfs_key_record_cache, key_rec);\nout:\n\tif (rc)\n\t\t(*len) = 0;\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_header_metadata",
          "args": [
            "(page_virt + offset)",
            "crypt_stat",
            "&written"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_header_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1053-1068",
          "snippet": "void\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_crypt_stat_flags",
          "args": [
            "(page_virt + offset)",
            "crypt_stat",
            "&written"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_crypt_stat_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "941-956",
          "snippet": "void ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\nvoid ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_ecryptfs_marker",
          "args": [
            "(page_virt + offset)",
            "&written"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "write_ecryptfs_marker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "929-939",
          "snippet": "static void write_ecryptfs_marker(char *page_virt, size_t *written)\n{\n\tu32 m_1, m_2;\n\n\tget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\n\tm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\n\tput_unaligned_be32(m_1, page_virt);\n\tpage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\n\tput_unaligned_be32(m_2, page_virt);\n\t(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void write_ecryptfs_marker(char *page_virt, size_t *written)\n{\n\tu32 m_1, m_2;\n\n\tget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\n\tm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\n\tput_unaligned_be32(m_1, page_virt);\n\tpage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\n\tput_unaligned_be32(m_2, page_virt);\n\t(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n\t\t\t\t       size_t *size,\n\t\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t       struct dentry *ecryptfs_dentry)\n{\n\tint rc;\n\tsize_t written;\n\tsize_t offset;\n\n\toffset = ECRYPTFS_FILE_SIZE_BYTES;\n\twrite_ecryptfs_marker((page_virt + offset), &written);\n\toffset += written;\n\tecryptfs_write_crypt_stat_flags((page_virt + offset), crypt_stat,\n\t\t\t\t\t&written);\n\toffset += written;\n\tecryptfs_write_header_metadata((page_virt + offset), crypt_stat,\n\t\t\t\t       &written);\n\toffset += written;\n\trc = ecryptfs_generate_key_packet_set((page_virt + offset), crypt_stat,\n\t\t\t\t\t      ecryptfs_dentry, &written,\n\t\t\t\t\t      max - offset);\n\tif (rc)\n\t\tecryptfs_printk(KERN_WARNING, \"Error generating key packet \"\n\t\t\t\t\"set; rc = [%d]\\n\", rc);\n\tif (size) {\n\t\toffset += written;\n\t\t*size = offset;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_header_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1053-1068",
    "snippet": "void\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_be16",
          "args": [
            "num_header_extents_at_front",
            "virt"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_be32",
          "args": [
            "header_extent_size",
            "virt"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "crypt_stat->metadata_size / crypt_stat->extent_size"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid\necryptfs_write_header_metadata(char *virt,\n\t\t\t       struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t       size_t *written)\n{\n\tu32 header_extent_size;\n\tu16 num_header_extents_at_front;\n\n\theader_extent_size = (u32)crypt_stat->extent_size;\n\tnum_header_extents_at_front =\n\t\t(u16)(crypt_stat->metadata_size / crypt_stat->extent_size);\n\tput_unaligned_be32(header_extent_size, virt);\n\tvirt += 4;\n\tput_unaligned_be16(num_header_extents_at_front, virt);\n\t(*written) = 6;\n}"
  },
  {
    "function_name": "ecryptfs_read_and_validate_header_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1037-1051",
    "snippet": "int ecryptfs_read_and_validate_header_region(struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\n\t\t\t\t inode);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_i_size_init",
          "args": [
            "file_size",
            "inode"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_i_size_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1281-1298",
          "snippet": "void ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_i_size_init(const char *page_virt, struct inode *inode)\n{\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tu64 file_size;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tmount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(inode->i_sb)->mount_crypt_stat;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED) {\n\t\tfile_size = i_size_read(ecryptfs_inode_to_lower(inode));\n\t\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\t\tfile_size += crypt_stat->metadata_size;\n\t} else\n\t\tfile_size = get_unaligned_be64(page_virt);\n\ti_size_write(inode, (loff_t)file_size);\n\tcrypt_stat->flags |= ECRYPTFS_I_SIZE_INITIALIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_validate_marker",
          "args": [
            "marker"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_validate_marker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "865-879",
          "snippet": "static int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower",
          "args": [
            "file_size",
            "0",
            "ECRYPTFS_SIZE_AND_MARKER_BYTES",
            "inode"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "231-239",
          "snippet": "int ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_and_validate_header_region(struct inode *inode)\n{\n\tu8 file_size[ECRYPTFS_SIZE_AND_MARKER_BYTES];\n\tu8 *marker = file_size + ECRYPTFS_FILE_SIZE_BYTES;\n\tint rc;\n\n\trc = ecryptfs_read_lower(file_size, 0, ECRYPTFS_SIZE_AND_MARKER_BYTES,\n\t\t\t\t inode);\n\tif (rc < ECRYPTFS_SIZE_AND_MARKER_BYTES)\n\t\treturn rc >= 0 ? -EINVAL : rc;\n\trc = ecryptfs_validate_marker(marker);\n\tif (!rc)\n\t\tecryptfs_i_size_init(file_size, inode);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_cipher_code_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "1020-1035",
    "snippet": "int ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\"",
            "cipher_code"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "ecryptfs_cipher_code_str_map[i].cipher_str"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ecryptfs_cipher_code_str_map"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_code_for_cipher_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "985-1011",
    "snippet": "u8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher_name",
            "map[i].cipher_str"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ecryptfs_cipher_code_str_map"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}"
  },
  {
    "function_name": "ecryptfs_write_crypt_stat_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "941-956",
    "snippet": "void ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_be32",
          "args": [
            "flags",
            "page_virt"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\nvoid ecryptfs_write_crypt_stat_flags(char *page_virt,\n\t\t\t\t     struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t     size_t *written)\n{\n\tu32 flags = 0;\n\tint i;\n\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (crypt_stat->flags & ecryptfs_flag_map[i].local_flag)\n\t\t\tflags |= ecryptfs_flag_map[i].file_flag;\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tflags |= ((((u8)crypt_stat->file_version) << 24) & 0xFF000000);\n\tput_unaligned_be32(flags, page_virt);\n\t(*written) = 4;\n}"
  },
  {
    "function_name": "write_ecryptfs_marker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "929-939",
    "snippet": "static void write_ecryptfs_marker(char *page_virt, size_t *written)\n{\n\tu32 m_1, m_2;\n\n\tget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\n\tm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\n\tput_unaligned_be32(m_1, page_virt);\n\tpage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\n\tput_unaligned_be32(m_2, page_virt);\n\t(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_be32",
          "args": [
            "m_2",
            "page_virt"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_be32",
          "args": [
            "m_1",
            "page_virt"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&m_1",
            "(MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void write_ecryptfs_marker(char *page_virt, size_t *written)\n{\n\tu32 m_1, m_2;\n\n\tget_random_bytes(&m_1, (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2));\n\tm_2 = (m_1 ^ MAGIC_ECRYPTFS_MARKER);\n\tput_unaligned_be32(m_1, page_virt);\n\tpage_virt += (MAGIC_ECRYPTFS_MARKER_SIZE_BYTES / 2);\n\tput_unaligned_be32(m_2, page_virt);\n\t(*written) = MAGIC_ECRYPTFS_MARKER_SIZE_BYTES;\n}"
  },
  {
    "function_name": "ecryptfs_process_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "902-920",
    "snippet": "static int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *page_virt, int *bytes_read)\n{\n\tint rc = 0;\n\tint i;\n\tu32 flags;\n\n\tflags = get_unaligned_be32(page_virt);\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (flags & ecryptfs_flag_map[i].file_flag) {\n\t\t\tcrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\n\t\t} else\n\t\t\tcrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tcrypt_stat->file_version = ((flags >> 24) & 0xFF);\n\t(*bytes_read) = 4;\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unaligned_be32",
          "args": [
            "page_virt"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_flag_map_elem ecryptfs_flag_map[] = {\n\t{0x00000001, ECRYPTFS_ENABLE_HMAC},\n\t{0x00000002, ECRYPTFS_ENCRYPTED},\n\t{0x00000004, ECRYPTFS_METADATA_IN_XATTR},\n\t{0x00000008, ECRYPTFS_ENCRYPT_FILENAMES}\n};\n\nstatic int ecryptfs_process_flags(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *page_virt, int *bytes_read)\n{\n\tint rc = 0;\n\tint i;\n\tu32 flags;\n\n\tflags = get_unaligned_be32(page_virt);\n\tfor (i = 0; i < ((sizeof(ecryptfs_flag_map)\n\t\t\t  / sizeof(struct ecryptfs_flag_map_elem))); i++)\n\t\tif (flags & ecryptfs_flag_map[i].file_flag) {\n\t\t\tcrypt_stat->flags |= ecryptfs_flag_map[i].local_flag;\n\t\t} else\n\t\t\tcrypt_stat->flags &= ~(ecryptfs_flag_map[i].local_flag);\n\t/* Version is in top 8 bits of the 32-bit flag vector */\n\tcrypt_stat->file_version = ((flags >> 24) & 0xFF);\n\t(*bytes_read) = 4;\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_validate_marker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "865-879",
    "snippet": "static int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\"",
            "(m_1 ^ MAGIC_ECRYPTFS_MARKER)"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_be32",
          "args": [
            "data + 4"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be32",
          "args": [
            "data"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_validate_marker(char *data)\n{\n\tu32 m_1, m_2;\n\n\tm_1 = get_unaligned_be32(data);\n\tm_2 = get_unaligned_be32(data + 4);\n\tif ((m_1 ^ MAGIC_ECRYPTFS_MARKER) == m_2)\n\t\treturn 0;\n\tecryptfs_printk(KERN_DEBUG, \"m_1 = [0x%.8x]; m_2 = [0x%.8x]; \"\n\t\t\t\"MAGIC_ECRYPTFS_MARKER = [0x%.8x]\\n\", m_1, m_2,\n\t\t\tMAGIC_ECRYPTFS_MARKER);\n\tecryptfs_printk(KERN_DEBUG, \"(m_1 ^ MAGIC_ECRYPTFS_MARKER) = \"\n\t\t\t\"[0x%.8x]\\n\", (m_1 ^ MAGIC_ECRYPTFS_MARKER));\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ecryptfs_new_file_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "820-857",
    "snippet": "int ecryptfs_new_file_context(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t    &ecryptfs_superblock_to_private(\n\t\t    ecryptfs_inode->i_sb)->mount_crypt_stat;\n\tint cipher_name_len;\n\tint rc = 0;\n\n\tecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\n\tcrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\trc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\n\t\t\t\t\t\t\t mount_crypt_stat);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to copy mount-wide key sigs \"\n\t\t       \"to the inode key sigs; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tcipher_name_len =\n\t\tstrlen(mount_crypt_stat->global_default_cipher_name);\n\tmemcpy(crypt_stat->cipher,\n\t       mount_crypt_stat->global_default_cipher_name,\n\t       cipher_name_len);\n\tcrypt_stat->cipher[cipher_name_len] = '\\0';\n\tcrypt_stat->key_size =\n\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tecryptfs_generate_new_key(crypt_stat);\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\"",
            "crypt_stat->cipher",
            "rc"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_crypt_ctx",
          "args": [
            "crypt_stat"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_crypt_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "607-642",
          "snippet": "int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_generate_new_key",
          "args": [
            "crypt_stat"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_generate_new_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "713-723",
          "snippet": "static void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tget_random_bytes(crypt_stat->key, crypt_stat->key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tecryptfs_compute_root_iv(crypt_stat);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Generated new session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tget_random_bytes(crypt_stat->key, crypt_stat->key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tecryptfs_compute_root_iv(crypt_stat);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Generated new session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crypt_stat->cipher",
            "mount_crypt_stat->global_default_cipher_name",
            "cipher_name_len"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mount_crypt_stat->global_default_cipher_name"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_mount_wide_sigs_to_inode_sigs",
          "args": [
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_mount_wide_sigs_to_inode_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "752-778",
          "snippet": "static int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\n\t\t\tcontinue;\n\t\trc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding keysig; rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\n\t\t\tcontinue;\n\t\trc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding keysig; rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "args": [
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "733-750",
          "snippet": "static void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_default_crypt_stat_vals",
          "args": [
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_default_crypt_stat_vals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "787-799",
          "snippet": "static void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "ecryptfs_inode->i_sb"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_new_file_context(struct inode *ecryptfs_inode)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat =\n\t    &ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t    &ecryptfs_superblock_to_private(\n\t\t    ecryptfs_inode->i_sb)->mount_crypt_stat;\n\tint cipher_name_len;\n\tint rc = 0;\n\n\tecryptfs_set_default_crypt_stat_vals(crypt_stat, mount_crypt_stat);\n\tcrypt_stat->flags |= (ECRYPTFS_ENCRYPTED | ECRYPTFS_KEY_VALID);\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\trc = ecryptfs_copy_mount_wide_sigs_to_inode_sigs(crypt_stat,\n\t\t\t\t\t\t\t mount_crypt_stat);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to copy mount-wide key sigs \"\n\t\t       \"to the inode key sigs; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tcipher_name_len =\n\t\tstrlen(mount_crypt_stat->global_default_cipher_name);\n\tmemcpy(crypt_stat->cipher,\n\t       mount_crypt_stat->global_default_cipher_name,\n\t       cipher_name_len);\n\tcrypt_stat->cipher[cipher_name_len] = '\\0';\n\tcrypt_stat->key_size =\n\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tecryptfs_generate_new_key(crypt_stat);\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing cryptographic \"\n\t\t\t\t\"context for cipher [%s]: rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_set_default_crypt_stat_vals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "787-799",
    "snippet": "static void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "crypt_stat->cipher",
            "ECRYPTFS_DEFAULT_CIPHER"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_set_default_sizes",
          "args": [
            "crypt_stat"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_set_default_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "660-676",
          "snippet": "void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "args": [
            "crypt_stat",
            "mount_crypt_stat"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "733-750",
          "snippet": "static void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_set_default_crypt_stat_vals(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tecryptfs_copy_mount_wide_flags_to_inode_flags(crypt_stat,\n\t\t\t\t\t\t      mount_crypt_stat);\n\tecryptfs_set_default_sizes(crypt_stat);\n\tstrcpy(crypt_stat->cipher, ECRYPTFS_DEFAULT_CIPHER);\n\tcrypt_stat->key_size = ECRYPTFS_DEFAULT_KEY_BYTES;\n\tcrypt_stat->flags &= ~(ECRYPTFS_KEY_VALID);\n\tcrypt_stat->file_version = ECRYPTFS_FILE_VERSION;\n\tcrypt_stat->mount_crypt_stat = mount_crypt_stat;\n}"
  },
  {
    "function_name": "ecryptfs_copy_mount_wide_sigs_to_inode_sigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "752-778",
    "snippet": "static int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\n\t\t\tcontinue;\n\t\trc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding keysig; rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->keysig_list_mutex"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error adding keysig; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_add_keysig",
          "args": [
            "crypt_stat",
            "global_auth_tok->sig"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_add_keysig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2484-2500",
          "snippet": "int ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\n{\n\tstruct ecryptfs_key_sig *new_key_sig;\n\n\tnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\n\tif (!new_key_sig) {\n\t\tprintk(KERN_ERR\n\t\t       \"Error allocating from ecryptfs_key_sig_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t/* Caller must hold keysig_list_mutex */\n\tlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_key_sig_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_key_sig_cache;\n\nint ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\n{\n\tstruct ecryptfs_key_sig *new_key_sig;\n\n\tnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\n\tif (!new_key_sig) {\n\t\tprintk(KERN_ERR\n\t\t       \"Error allocating from ecryptfs_key_sig_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t/* Caller must hold keysig_list_mutex */\n\tlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "global_auth_tok",
            "&mount_crypt_stat->global_auth_tok_list",
            "mount_crypt_stat_list"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->keysig_list_mutex"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_copy_mount_wide_sigs_to_inode_sigs(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (global_auth_tok->flags & ECRYPTFS_AUTH_TOK_FNEK)\n\t\t\tcontinue;\n\t\trc = ecryptfs_add_keysig(crypt_stat, global_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding keysig; rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_copy_mount_wide_flags_to_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "733-750",
    "snippet": "static void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_copy_mount_wide_flags_to_inode_flags(\n\tstruct ecryptfs_crypt_stat *crypt_stat,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tif (mount_crypt_stat->flags & ECRYPTFS_XATTR_METADATA_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_METADATA_IN_XATTR;\n\tif (mount_crypt_stat->flags & ECRYPTFS_ENCRYPTED_VIEW_ENABLED)\n\t\tcrypt_stat->flags |= ECRYPTFS_VIEW_AS_ENCRYPTED;\n\tif (mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES) {\n\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPT_FILENAMES;\n\t\tif (mount_crypt_stat->flags\n\t\t    & ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_MOUNT_FNEK;\n\t\telse if (mount_crypt_stat->flags\n\t\t\t & ECRYPTFS_GLOBAL_ENCFN_USE_FEK)\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCFN_USE_FEK;\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_generate_new_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "713-723",
    "snippet": "static void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tget_random_bytes(crypt_stat->key, crypt_stat->key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tecryptfs_compute_root_iv(crypt_stat);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Generated new session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"Generated new session key:\\n\""
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_compute_root_iv",
          "args": [
            "crypt_stat"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_compute_root_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "684-711",
          "snippet": "int ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void ecryptfs_generate_new_key(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tget_random_bytes(crypt_stat->key, crypt_stat->key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tecryptfs_compute_root_iv(crypt_stat);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Generated new session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_compute_root_iv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "684-711",
    "snippet": "int ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "crypt_stat->root_iv",
            "0",
            "crypt_stat->iv_bytes"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crypt_stat->root_iv",
            "dst",
            "crypt_stat->iv_bytes"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\""
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_calculate_md5",
          "args": [
            "dst",
            "crypt_stat",
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_calculate_md5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "87-136",
          "snippet": "static int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "crypt_stat->iv_bytes <= 0"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "crypt_stat->iv_bytes > MD5_DIGEST_SIZE"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_set_default_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "660-676",
    "snippet": "void ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_mask_and_shift",
          "args": [
            "crypt_stat"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_mask_and_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "644-658",
          "snippet": "static void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint extent_size_tmp;\n\n\tcrypt_stat->extent_mask = 0xFFFFFFFF;\n\tcrypt_stat->extent_shift = 0;\n\tif (crypt_stat->extent_size == 0)\n\t\treturn;\n\textent_size_tmp = crypt_stat->extent_size;\n\twhile ((extent_size_tmp & 0x01) == 0) {\n\t\textent_size_tmp >>= 1;\n\t\tcrypt_stat->extent_mask <<= 1;\n\t\tcrypt_stat->extent_shift++;\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint extent_size_tmp;\n\n\tcrypt_stat->extent_mask = 0xFFFFFFFF;\n\tcrypt_stat->extent_shift = 0;\n\tif (crypt_stat->extent_size == 0)\n\t\treturn;\n\textent_size_tmp = crypt_stat->extent_size;\n\twhile ((extent_size_tmp & 0x01) == 0) {\n\t\textent_size_tmp >>= 1;\n\t\tcrypt_stat->extent_mask <<= 1;\n\t\tcrypt_stat->extent_shift++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_set_default_sizes(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\t/* Default values; may be overwritten as we are parsing the\n\t * packets. */\n\tcrypt_stat->extent_size = ECRYPTFS_DEFAULT_EXTENT_SIZE;\n\tset_extent_mask_and_shift(crypt_stat);\n\tcrypt_stat->iv_bytes = ECRYPTFS_DEFAULT_IV_BYTES;\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\tcrypt_stat->metadata_size = ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\telse {\n\t\tif (PAGE_CACHE_SIZE <= ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE)\n\t\t\tcrypt_stat->metadata_size =\n\t\t\t\tECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;\n\t\telse\n\t\t\tcrypt_stat->metadata_size = PAGE_CACHE_SIZE;\n\t}\n}"
  },
  {
    "function_name": "set_extent_mask_and_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "644-658",
    "snippet": "static void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint extent_size_tmp;\n\n\tcrypt_stat->extent_mask = 0xFFFFFFFF;\n\tcrypt_stat->extent_shift = 0;\n\tif (crypt_stat->extent_size == 0)\n\t\treturn;\n\textent_size_tmp = crypt_stat->extent_size;\n\twhile ((extent_size_tmp & 0x01) == 0) {\n\t\textent_size_tmp >>= 1;\n\t\tcrypt_stat->extent_mask <<= 1;\n\t\tcrypt_stat->extent_shift++;\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void set_extent_mask_and_shift(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint extent_size_tmp;\n\n\tcrypt_stat->extent_mask = 0xFFFFFFFF;\n\tcrypt_stat->extent_shift = 0;\n\tif (crypt_stat->extent_size == 0)\n\t\treturn;\n\textent_size_tmp = crypt_stat->extent_size;\n\twhile ((extent_size_tmp & 0x01) == 0) {\n\t\textent_size_tmp >>= 1;\n\t\tcrypt_stat->extent_mask <<= 1;\n\t\tcrypt_stat->extent_shift++;\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_init_crypt_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "607-642",
    "snippet": "int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_alg_name"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ablkcipher_set_flags",
          "args": [
            "crypt_stat->tfm",
            "CRYPTO_TFM_REQ_WEAK_KEY"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\"",
            "full_alg_name"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "crypt_stat->tfm"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "crypt_stat->tfm"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_ablkcipher",
          "args": [
            "full_alg_name",
            "0",
            "0"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_crypto_api_algify_cipher_name",
          "args": [
            "&full_alg_name",
            "crypt_stat->cipher",
            "\"cbc\""
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_crypto_api_algify_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "138-158",
          "snippet": "static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "crypt_stat->cipher"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_decrypt_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "555-594",
    "snippet": "int ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define DECRYPT\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypt_extent",
          "args": [
            "crypt_stat",
            "page",
            "page",
            "extent_offset",
            "DECRYPT"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "427-468",
          "snippet": "static int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nstatic int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_read_lower",
          "args": [
            "page_virt",
            "lower_offset",
            "PAGE_CACHE_SIZE",
            "ecryptfs_inode"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_read_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "231-239",
          "snippet": "int ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_read_lower(char *data, loff_t offset, size_t size,\n\t\t\tstruct inode *ecryptfs_inode)\n{\n\tstruct file *lower_file;\n\tlower_file = ecryptfs_inode_to_private(ecryptfs_inode)->lower_file;\n\tif (!lower_file)\n\t\treturn -EIO;\n\treturn kernel_read(lower_file, offset, data, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_offset_for_page",
          "args": [
            "crypt_stat",
            "page"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "lower_offset_for_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "407-412",
          "snippet": "static loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define DECRYPT\t\t0\n\nint ecryptfs_decrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *page_virt;\n\tunsigned long extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tpage_virt = kmap(page);\n\trc = ecryptfs_read_lower(page_virt, lower_offset, PAGE_CACHE_SIZE,\n\t\t\t\t ecryptfs_inode);\n\tkunmap(page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to read lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, page, page,\n\t\t\t\t  extent_offset, DECRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_encrypt_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "486-537",
    "snippet": "int ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ENCRYPT\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "enc_extent_page"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error attempting to write lower page; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "enc_extent_page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_lower",
          "args": [
            "ecryptfs_inode",
            "enc_extent_virt",
            "lower_offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_lower_page_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/read_write.c",
          "lines": "69-85",
          "snippet": "int ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint ecryptfs_write_lower_page_segment(struct inode *ecryptfs_inode,\n\t\t\t\t      struct page *page_for_lower,\n\t\t\t\t      size_t offset_in_page, size_t size)\n{\n\tchar *virt;\n\tloff_t offset;\n\tint rc;\n\n\toffset = ((((loff_t)page_for_lower->index) << PAGE_CACHE_SHIFT)\n\t\t  + offset_in_page);\n\tvirt = kmap(page_for_lower);\n\trc = ecryptfs_write_lower(ecryptfs_inode, virt, offset, size);\n\tif (rc > 0)\n\t\trc = 0;\n\tkunmap(page_for_lower);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "enc_extent_page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_offset_for_page",
          "args": [
            "crypt_stat",
            "page"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "lower_offset_for_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "407-412",
          "snippet": "static loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypt_extent",
          "args": [
            "crypt_stat",
            "enc_extent_page",
            "page",
            "extent_offset",
            "ENCRYPT"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "427-468",
          "snippet": "static int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nstatic int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_USER"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(crypt_stat->flags & ECRYPTFS_ENCRYPTED)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_inode_to_private",
          "args": [
            "ecryptfs_inode"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "456-460",
          "snippet": "static inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_inode_info *\necryptfs_inode_to_private(struct inode *inode)\n{\n\treturn container_of(inode, struct ecryptfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nint ecryptfs_encrypt_page(struct page *page)\n{\n\tstruct inode *ecryptfs_inode;\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tchar *enc_extent_virt;\n\tstruct page *enc_extent_page = NULL;\n\tloff_t extent_offset;\n\tloff_t lower_offset;\n\tint rc = 0;\n\n\tecryptfs_inode = page->mapping->host;\n\tcrypt_stat =\n\t\t&(ecryptfs_inode_to_private(ecryptfs_inode)->crypt_stat);\n\tBUG_ON(!(crypt_stat->flags & ECRYPTFS_ENCRYPTED));\n\tenc_extent_page = alloc_page(GFP_USER);\n\tif (!enc_extent_page) {\n\t\trc = -ENOMEM;\n\t\tecryptfs_printk(KERN_ERR, \"Error allocating memory for \"\n\t\t\t\t\"encrypted extent\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (extent_offset = 0;\n\t     extent_offset < (PAGE_CACHE_SIZE / crypt_stat->extent_size);\n\t     extent_offset++) {\n\t\trc = crypt_extent(crypt_stat, enc_extent_page, page,\n\t\t\t\t  extent_offset, ENCRYPT);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: Error encrypting extent; \"\n\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlower_offset = lower_offset_for_page(crypt_stat, page);\n\tenc_extent_virt = kmap(enc_extent_page);\n\trc = ecryptfs_write_lower(ecryptfs_inode, enc_extent_virt, lower_offset,\n\t\t\t\t  PAGE_CACHE_SIZE);\n\tkunmap(enc_extent_page);\n\tif (rc < 0) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\"Error attempting to write lower page; rc = [%d]\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\tif (enc_extent_page) {\n\t\t__free_page(enc_extent_page);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "crypt_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "427-468",
    "snippet": "static int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ENCRYPT\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "page_index",
            "extent_offset",
            "rc"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypt_scatterlist",
          "args": [
            "crypt_stat",
            "&dst_sg",
            "&src_sg",
            "extent_size",
            "extent_iv",
            "op"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "crypt_scatterlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "341-400",
          "snippet": "static int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t     struct scatterlist *dst_sg,\n\t\t\t     struct scatterlist *src_sg, int size,\n\t\t\t     unsigned char *iv, int op)\n{\n\tstruct ablkcipher_request *req = NULL;\n\tstruct extent_crypt_result ecr;\n\tint rc = 0;\n\n\tBUG_ON(!crypt_stat || !crypt_stat->tfm\n\t       || !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED));\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Key size [%zd]; key:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n\n\tinit_completion(&ecr.completion);\n\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\treq = ablkcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\n\tif (!req) {\n\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tablkcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\textent_crypt_complete, &ecr);\n\t/* Consider doing this once, when the file is opened */\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\n\t\trc = crypto_ablkcipher_setkey(crypt_stat->tfm, crypt_stat->key,\n\t\t\t\t\t      crypt_stat->key_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\t\"Error setting key; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->flags |= ECRYPTFS_KEY_SET;\n\t}\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\tablkcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\n\trc = op == ENCRYPT ? crypto_ablkcipher_encrypt(req) :\n\t\t\t     crypto_ablkcipher_decrypt(req);\n\tif (rc == -EINPROGRESS || rc == -EBUSY) {\n\t\tstruct extent_crypt_result *ecr = req->base.data;\n\n\t\twait_for_completion(&ecr->completion);\n\t\trc = ecr->rc;\n\t\treinit_completion(&ecr->completion);\n\t}\nout:\n\tablkcipher_request_free(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ENCRYPT\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nstatic int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t     struct scatterlist *dst_sg,\n\t\t\t     struct scatterlist *src_sg, int size,\n\t\t\t     unsigned char *iv, int op)\n{\n\tstruct ablkcipher_request *req = NULL;\n\tstruct extent_crypt_result ecr;\n\tint rc = 0;\n\n\tBUG_ON(!crypt_stat || !crypt_stat->tfm\n\t       || !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED));\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Key size [%zd]; key:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n\n\tinit_completion(&ecr.completion);\n\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\treq = ablkcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\n\tif (!req) {\n\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tablkcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\textent_crypt_complete, &ecr);\n\t/* Consider doing this once, when the file is opened */\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\n\t\trc = crypto_ablkcipher_setkey(crypt_stat->tfm, crypt_stat->key,\n\t\t\t\t\t      crypt_stat->key_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\t\"Error setting key; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->flags |= ECRYPTFS_KEY_SET;\n\t}\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\tablkcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\n\trc = op == ENCRYPT ? crypto_ablkcipher_encrypt(req) :\n\t\t\t     crypto_ablkcipher_decrypt(req);\n\tif (rc == -EINPROGRESS || rc == -EBUSY) {\n\t\tstruct extent_crypt_result *ecr = req->base.data;\n\n\t\twait_for_completion(&ecr->completion);\n\t\trc = ecr->rc;\n\t\treinit_completion(&ecr->completion);\n\t}\nout:\n\tablkcipher_request_free(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "&dst_sg",
            "dst_page",
            "extent_size",
            "extent_offset * extent_size"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "&src_sg",
            "src_page",
            "extent_size",
            "extent_offset * extent_size"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "&dst_sg",
            "1"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "&src_sg",
            "1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_derive_iv",
          "args": [
            "extent_iv",
            "crypt_stat",
            "(extent_base + extent_offset)"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_derive_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "171-207",
          "snippet": "int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t/* TODO: It is probably secure to just cast the least\n\t * significant bits of the root IV into an unsigned long and\n\t * add the offset to that rather than go through all this\n\t * hashing business. -Halcrow */\n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t/* TODO: It is probably secure to just cast the least\n\t * significant bits of the root IV into an unsigned long and\n\t * add the offset to that rather than go through all this\n\t * hashing business. -Halcrow */\n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nstatic int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "lower_offset_for_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "407-412",
    "snippet": "static loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_lower_header_size",
          "args": [
            "crypt_stat"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_lower_header_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "423-429",
          "snippet": "static inline size_t\necryptfs_lower_header_size(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn 0;\n\treturn crypt_stat->metadata_size;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [
            "#define ECRYPTFS_METADATA_IN_XATTR    0x00000080"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\n#define ECRYPTFS_METADATA_IN_XATTR    0x00000080\n\nstatic inline size_t\necryptfs_lower_header_size(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n\t\treturn 0;\n\treturn crypt_stat->metadata_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic loff_t lower_offset_for_page(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct page *page)\n{\n\treturn ecryptfs_lower_header_size(crypt_stat) +\n\t       ((loff_t)page->index << PAGE_CACHE_SHIFT);\n}"
  },
  {
    "function_name": "crypt_scatterlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "341-400",
    "snippet": "static int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t     struct scatterlist *dst_sg,\n\t\t\t     struct scatterlist *src_sg, int size,\n\t\t\t     unsigned char *iv, int op)\n{\n\tstruct ablkcipher_request *req = NULL;\n\tstruct extent_crypt_result ecr;\n\tint rc = 0;\n\n\tBUG_ON(!crypt_stat || !crypt_stat->tfm\n\t       || !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED));\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Key size [%zd]; key:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n\n\tinit_completion(&ecr.completion);\n\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\treq = ablkcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\n\tif (!req) {\n\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tablkcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\textent_crypt_complete, &ecr);\n\t/* Consider doing this once, when the file is opened */\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\n\t\trc = crypto_ablkcipher_setkey(crypt_stat->tfm, crypt_stat->key,\n\t\t\t\t\t      crypt_stat->key_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\t\"Error setting key; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->flags |= ECRYPTFS_KEY_SET;\n\t}\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\tablkcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\n\trc = op == ENCRYPT ? crypto_ablkcipher_encrypt(req) :\n\t\t\t     crypto_ablkcipher_decrypt(req);\n\tif (rc == -EINPROGRESS || rc == -EBUSY) {\n\t\tstruct extent_crypt_result *ecr = req->base.data;\n\n\t\twait_for_completion(&ecr->completion);\n\t\trc = ecr->rc;\n\t\treinit_completion(&ecr->completion);\n\t}\nout:\n\tablkcipher_request_free(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ENCRYPT\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ablkcipher_request_free",
          "args": [
            "req"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinit_completion",
          "args": [
            "&ecr->completion"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ecr->completion"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_ablkcipher_decrypt",
          "args": [
            "req"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ablkcipher_encrypt",
          "args": [
            "req"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ablkcipher_request_set_crypt",
          "args": [
            "req",
            "src_sg",
            "dst_sg",
            "size",
            "iv"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error setting key; rc = [%d]\\n\"",
            "rc"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_ablkcipher_setkey",
          "args": [
            "crypt_stat->tfm",
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ablkcipher_request_set_callback",
          "args": [
            "req",
            "CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP",
            "extent_crypt_complete",
            "&ecr"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ablkcipher_request_alloc",
          "args": [
            "crypt_stat->tfm",
            "GFP_NOFS"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ecr.completion"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!crypt_stat || !crypt_stat->tfm\n\t       || !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\n#define ENCRYPT\t\t1\n\nstatic int crypt_scatterlist(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t     struct scatterlist *dst_sg,\n\t\t\t     struct scatterlist *src_sg, int size,\n\t\t\t     unsigned char *iv, int op)\n{\n\tstruct ablkcipher_request *req = NULL;\n\tstruct extent_crypt_result ecr;\n\tint rc = 0;\n\n\tBUG_ON(!crypt_stat || !crypt_stat->tfm\n\t       || !(crypt_stat->flags & ECRYPTFS_STRUCT_INITIALIZED));\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Key size [%zd]; key:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\n\n\tinit_completion(&ecr.completion);\n\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\treq = ablkcipher_request_alloc(crypt_stat->tfm, GFP_NOFS);\n\tif (!req) {\n\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tablkcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\textent_crypt_complete, &ecr);\n\t/* Consider doing this once, when the file is opened */\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_SET)) {\n\t\trc = crypto_ablkcipher_setkey(crypt_stat->tfm, crypt_stat->key,\n\t\t\t\t\t      crypt_stat->key_size);\n\t\tif (rc) {\n\t\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\t\"Error setting key; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->flags |= ECRYPTFS_KEY_SET;\n\t}\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\tablkcipher_request_set_crypt(req, src_sg, dst_sg, size, iv);\n\trc = op == ENCRYPT ? crypto_ablkcipher_encrypt(req) :\n\t\t\t     crypto_ablkcipher_decrypt(req);\n\tif (rc == -EINPROGRESS || rc == -EBUSY) {\n\t\tstruct extent_crypt_result *ecr = req->base.data;\n\n\t\twait_for_completion(&ecr->completion);\n\t\trc = ecr->rc;\n\t\treinit_completion(&ecr->completion);\n\t}\nout:\n\tablkcipher_request_free(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "extent_crypt_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "319-328",
    "snippet": "static void extent_crypt_complete(struct crypto_async_request *req, int rc)\n{\n\tstruct extent_crypt_result *ecr = req->data;\n\n\tif (rc == -EINPROGRESS)\n\t\treturn;\n\n\tecr->rc = rc;\n\tcomplete(&ecr->completion);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ecr->completion"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void extent_crypt_complete(struct crypto_async_request *req, int rc)\n{\n\tstruct extent_crypt_result *ecr = req->data;\n\n\tif (rc == -EINPROGRESS)\n\t\treturn;\n\n\tecr->rc = rc;\n\tcomplete(&ecr->completion);\n}"
  },
  {
    "function_name": "virt_to_scatterlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "283-312",
    "snippet": "int virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "&sg[i]",
            "pg",
            "0",
            "offset"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "sg",
            "sg_size"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}"
  },
  {
    "function_name": "ecryptfs_destroy_mount_crypt_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "249-268",
    "snippet": "void ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mount_crypt_stat",
            "0",
            "sizeof(struct ecryptfs_mount_crypt_stat)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_global_auth_tok_cache",
            "auth_tok"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok->global_auth_tok_key"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&auth_tok->mount_crypt_stat_list"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "auth_tok",
            "auth_tok_tmp",
            "&mount_crypt_stat->global_auth_tok_list",
            "mount_crypt_stat_list"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_destroy_mount_crypt_stat(\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *auth_tok, *auth_tok_tmp;\n\n\tif (!(mount_crypt_stat->flags & ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED))\n\t\treturn;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry_safe(auth_tok, auth_tok_tmp,\n\t\t\t\t &mount_crypt_stat->global_auth_tok_list,\n\t\t\t\t mount_crypt_stat_list) {\n\t\tlist_del(&auth_tok->mount_crypt_stat_list);\n\t\tif (auth_tok->global_auth_tok_key\n\t\t    && !(auth_tok->flags & ECRYPTFS_AUTH_TOK_INVALID))\n\t\t\tkey_put(auth_tok->global_auth_tok_key);\n\t\tkmem_cache_free(ecryptfs_global_auth_tok_cache, auth_tok);\n\t}\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmemset(mount_crypt_stat, 0, sizeof(struct ecryptfs_mount_crypt_stat));\n}"
  },
  {
    "function_name": "ecryptfs_destroy_crypt_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "233-247",
    "snippet": "void ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct ecryptfs_key_sig *key_sig, *key_sig_tmp;\n\n\tif (crypt_stat->tfm)\n\t\tcrypto_free_ablkcipher(crypt_stat->tfm);\n\tif (crypt_stat->hash_tfm)\n\t\tcrypto_free_hash(crypt_stat->hash_tfm);\n\tlist_for_each_entry_safe(key_sig, key_sig_tmp,\n\t\t\t\t &crypt_stat->keysig_list, crypt_stat_list) {\n\t\tlist_del(&key_sig->crypt_stat_list);\n\t\tkmem_cache_free(ecryptfs_key_sig_cache, key_sig);\n\t}\n\tmemset(crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "crypt_stat",
            "0",
            "sizeof(struct ecryptfs_crypt_stat)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_key_sig_cache",
            "key_sig"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&key_sig->crypt_stat_list"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "key_sig",
            "key_sig_tmp",
            "&crypt_stat->keysig_list",
            "crypt_stat_list"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_hash",
          "args": [
            "crypt_stat->hash_tfm"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_ablkcipher",
          "args": [
            "crypt_stat->tfm"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_destroy_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct ecryptfs_key_sig *key_sig, *key_sig_tmp;\n\n\tif (crypt_stat->tfm)\n\t\tcrypto_free_ablkcipher(crypt_stat->tfm);\n\tif (crypt_stat->hash_tfm)\n\t\tcrypto_free_hash(crypt_stat->hash_tfm);\n\tlist_for_each_entry_safe(key_sig, key_sig_tmp,\n\t\t\t\t &crypt_stat->keysig_list, crypt_stat_list) {\n\t\tlist_del(&key_sig->crypt_stat_list);\n\t\tkmem_cache_free(ecryptfs_key_sig_cache, key_sig);\n\t}\n\tmemset(crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n}"
  },
  {
    "function_name": "ecryptfs_init_crypt_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "215-225",
    "snippet": "void\necryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n\tINIT_LIST_HEAD(&crypt_stat->keysig_list);\n\tmutex_init(&crypt_stat->keysig_list_mutex);\n\tmutex_init(&crypt_stat->cs_mutex);\n\tmutex_init(&crypt_stat->cs_tfm_mutex);\n\tmutex_init(&crypt_stat->cs_hash_tfm_mutex);\n\tcrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&crypt_stat->cs_hash_tfm_mutex"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&crypt_stat->cs_tfm_mutex"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&crypt_stat->cs_mutex"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&crypt_stat->keysig_list_mutex"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&crypt_stat->keysig_list"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)crypt_stat",
            "0",
            "sizeof(struct ecryptfs_crypt_stat)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid\necryptfs_init_crypt_stat(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tmemset((void *)crypt_stat, 0, sizeof(struct ecryptfs_crypt_stat));\n\tINIT_LIST_HEAD(&crypt_stat->keysig_list);\n\tmutex_init(&crypt_stat->keysig_list_mutex);\n\tmutex_init(&crypt_stat->cs_mutex);\n\tmutex_init(&crypt_stat->cs_tfm_mutex);\n\tmutex_init(&crypt_stat->cs_hash_tfm_mutex);\n\tcrypt_stat->flags |= ECRYPTFS_STRUCT_INITIALIZED;\n}"
  },
  {
    "function_name": "ecryptfs_derive_iv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "171-207",
    "snippet": "int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t/* TODO: It is probably secure to just cast the least\n\t * significant bits of the root IV into an unsigned long and\n\t * add the offset to that rather than go through all this\n\t * hashing business. -Halcrow */\n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "iv",
            "crypt_stat->iv_bytes"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"derived iv:\\n\""
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "dst",
            "crypt_stat->iv_bytes"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_calculate_md5",
          "args": [
            "dst",
            "crypt_stat",
            "src",
            "(crypt_stat->iv_bytes + 16)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_calculate_md5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "87-136",
          "snippet": "static int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "(src + crypt_stat->iv_bytes)",
            "16",
            "\"%lld\"",
            "offset"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(src + crypt_stat->iv_bytes)",
            "0",
            "16"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "src",
            "crypt_stat->root_iv",
            "crypt_stat->iv_bytes"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t/* TODO: It is probably secure to just cast the least\n\t * significant bits of the root IV into an unsigned long and\n\t * add the offset to that rather than go through all this\n\t * hashing business. -Halcrow */\n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_crypto_api_algify_cipher_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "138-158",
    "snippet": "static int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "(*algified_name)",
            "algified_name_len",
            "\"%s(%s)\"",
            "chaining_modifier",
            "cipher_name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "algified_name_len",
            "GFP_KERNEL"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chaining_modifier"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_crypto_api_algify_cipher_name(char **algified_name,\n\t\t\t\t\t\t  char *cipher_name,\n\t\t\t\t\t\t  char *chaining_modifier)\n{\n\tint cipher_name_len = strlen(cipher_name);\n\tint chaining_modifier_len = strlen(chaining_modifier);\n\tint algified_name_len;\n\tint rc;\n\n\talgified_name_len = (chaining_modifier_len + cipher_name_len + 3);\n\t(*algified_name) = kmalloc(algified_name_len, GFP_KERNEL);\n\tif (!(*algified_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnprintf((*algified_name), algified_name_len, \"%s(%s)\",\n\t\t chaining_modifier, cipher_name);\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_calculate_md5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "87-136",
    "snippet": "static int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->cs_hash_tfm_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_hash_final",
          "args": [
            "&desc",
            "dst"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_update",
          "args": [
            "&desc",
            "&sg",
            "len"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_init",
          "args": [
            "&desc"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "desc.tfm"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "desc.tfm"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_hash",
          "args": [
            "ECRYPTFS_DEFAULT_HASH",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sg",
            "(u8 *)src",
            "len"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->cs_hash_tfm_mutex"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ecryptfs_calculate_md5(char *dst,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t  char *src, int len)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc = {\n\t\t.tfm = crypt_stat->hash_tfm,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tmutex_lock(&crypt_stat->cs_hash_tfm_mutex);\n\tsg_init_one(&sg, (u8 *)src, len);\n\tif (!desc.tfm) {\n\t\tdesc.tfm = crypto_alloc_hash(ECRYPTFS_DEFAULT_HASH, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(desc.tfm)) {\n\t\t\trc = PTR_ERR(desc.tfm);\n\t\t\tecryptfs_printk(KERN_ERR, \"Error attempting to \"\n\t\t\t\t\t\"allocate crypto context; rc = [%d]\\n\",\n\t\t\t\t\trc);\n\t\t\tgoto out;\n\t\t}\n\t\tcrypt_stat->hash_tfm = desc.tfm;\n\t}\n\trc = crypto_hash_init(&desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_update(&desc, &sg, len);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\n\trc = crypto_hash_final(&desc, dst);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&crypt_stat->cs_hash_tfm_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_from_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "65-75",
    "snippet": "void ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "tmp",
            "NULL",
            "16"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}"
  },
  {
    "function_name": "ecryptfs_to_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
    "lines": "50-56",
    "snippet": "void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/file.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/key.h>",
      "#include <linux/compiler.h>",
      "#include <linux/random.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "&dst[x * 2]",
            "\"%.2x\"",
            "(unsigned char)src[x]"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}"
  }
]