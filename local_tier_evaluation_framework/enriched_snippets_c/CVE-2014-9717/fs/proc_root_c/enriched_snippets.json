[
  {
    "function_name": "pid_ns_release_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "270-273",
    "snippet": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tkern_unmount(ns->proc_mnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kern_unmount",
          "args": [
            "ns->proc_mnt"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "kern_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3100-3108",
          "snippet": "void kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid kern_unmount(struct vfsmount *mnt)\n{\n\t/* release long term mount so mount point can be released */\n\tif (!IS_ERR_OR_NULL(mnt)) {\n\t\treal_mount(mnt)->mnt_ns = NULL;\n\t\tsynchronize_rcu();\t/* yecchhh... */\n\t\tmntput(mnt);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nvoid pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tkern_unmount(ns->proc_mnt);\n}"
  },
  {
    "function_name": "pid_ns_prepare_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "258-268",
    "snippet": "int pid_ns_prepare_proc(struct pid_namespace *ns)\n{\n\tstruct vfsmount *mnt;\n\n\tmnt = kern_mount_data(&proc_fs_type, ns);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tns->proc_mnt = mnt;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount_data",
          "args": [
            "&proc_fs_type",
            "ns"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "kern_mount_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3085-3097",
          "snippet": "struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *kern_mount_data(struct file_system_type *type, void *data)\n{\n\tstruct vfsmount *mnt;\n\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);\n\tif (!IS_ERR(mnt)) {\n\t\t/*\n\t\t * it is a longterm mount, don't release mnt until\n\t\t * we unmount before file sys is unregistered\n\t\t*/\n\t\treal_mount(mnt)->mnt_ns = MNT_NS_INTERNAL;\n\t}\n\treturn mnt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\nint pid_ns_prepare_proc(struct pid_namespace *ns)\n{\n\tstruct vfsmount *mnt;\n\n\tmnt = kern_mount_data(&proc_fs_type, ns);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\tns->proc_mnt = mnt;\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_root_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "211-221",
    "snippet": "static int proc_root_readdir(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos < FIRST_PROCESS_ENTRY) {\n\t\tint error = proc_readdir(file, ctx);\n\t\tif (unlikely(error <= 0))\n\t\t\treturn error;\n\t\tctx->pos = FIRST_PROCESS_ENTRY;\n\t}\n\n\treturn proc_pid_readdir(file, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pid_readdir",
          "args": [
            "file",
            "ctx"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2844-2885",
          "snippet": "int proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = ns->proc_self->d_inode;\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = ns->proc_thread_self->d_inode;\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [
            "#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)\n\nint proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = ns->proc_self->d_inode;\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = ns->proc_thread_self->d_inode;\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error <= 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_readdir",
          "args": [
            "file",
            "ctx"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "proc_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "306-311",
          "snippet": "int proc_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn proc_readdir_de(PDE(inode), file, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nint proc_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn proc_readdir_de(PDE(inode), file, ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_root_readdir(struct file *file, struct dir_context *ctx)\n{\n\tif (ctx->pos < FIRST_PROCESS_ENTRY) {\n\t\tint error = proc_readdir(file, ctx);\n\t\tif (unlikely(error <= 0))\n\t\t\treturn error;\n\t\tctx->pos = FIRST_PROCESS_ENTRY;\n\t}\n\n\treturn proc_pid_readdir(file, ctx);\n}"
  },
  {
    "function_name": "proc_root_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "203-209",
    "snippet": "static struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\n{\n\tif (!proc_pid_lookup(dir, dentry, flags))\n\t\treturn NULL;\n\t\n\treturn proc_lookup(dir, dentry, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_lookup",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "proc_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "250-254",
          "snippet": "struct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\treturn proc_lookup_de(PDE(dir), dir, dentry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\treturn proc_lookup_de(PDE(dir), dir, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_lookup",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2772-2796",
          "snippet": "struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\n{\n\tif (!proc_pid_lookup(dir, dentry, flags))\n\t\treturn NULL;\n\t\n\treturn proc_lookup(dir, dentry, flags);\n}"
  },
  {
    "function_name": "proc_root_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "195-201",
    "snippet": "static int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat\n)\n{\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->nlink = proc_root.nlink + nr_processes();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct proc_dir_entry proc_root = {\n\t.low_ino\t= PROC_ROOT_INO, \n\t.namelen\t= 5, \n\t.mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO, \n\t.nlink\t\t= 2, \n\t.count\t\t= ATOMIC_INIT(1),\n\t.proc_iops\t= &proc_root_inode_operations, \n\t.proc_fops\t= &proc_root_operations,\n\t.parent\t\t= &proc_root,\n\t.subdir\t\t= RB_ROOT,\n\t.name\t\t= \"/proc\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_processes",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct proc_dir_entry proc_root = {\n\t.low_ino\t= PROC_ROOT_INO, \n\t.namelen\t= 5, \n\t.mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO, \n\t.nlink\t\t= 2, \n\t.count\t\t= ATOMIC_INIT(1),\n\t.proc_iops\t= &proc_root_inode_operations, \n\t.proc_fops\t= &proc_root_operations,\n\t.parent\t\t= &proc_root,\n\t.subdir\t\t= RB_ROOT,\n\t.name\t\t= \"/proc\",\n};\n\nstatic int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat\n)\n{\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tstat->nlink = proc_root.nlink + nr_processes();\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_root_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "165-193",
    "snippet": "void __init proc_root_init(void)\n{\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\n\tproc_self_init();\n\tproc_thread_self_init();\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); /* somewhere for the nfsd filesystem to be mounted */\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t/* just give it a mountpoint */\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_init",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "248-248",
          "snippet": "static inline void proc_sys_init(void) { }",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void proc_sys_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"bus\"",
            "NULL"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_tty_init",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "proc_tty_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_tty.c",
          "lines": "175-189",
          "snippet": "void __init proc_tty_init(void)\n{\n\tif (!proc_mkdir(\"tty\", NULL))\n\t\treturn;\n\tproc_mkdir(\"tty/ldisc\", NULL);\t/* Preserved: it's userspace visible */\n\t/*\n\t * /proc/tty/driver/serial reveals the exact character counts for\n\t * serial links which is just too easy to abuse for inferring\n\t * password lengths and inter-keystroke timings during password\n\t * entry.\n\t */\n\tproc_tty_driver = proc_mkdir_mode(\"tty/driver\", S_IRUSR|S_IXUSR, NULL);\n\tproc_create(\"tty/ldiscs\", 0, NULL, &tty_ldiscs_proc_fops);\n\tproc_create(\"tty/drivers\", 0, NULL, &proc_tty_drivers_operations);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct proc_dir_entry *proc_tty_driver;",
            "static const struct file_operations proc_tty_drivers_operations = {\n\t.open\t\t= tty_drivers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seq_file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <asm/uaccess.h>\n\nstatic struct proc_dir_entry *proc_tty_driver;\nstatic const struct file_operations proc_tty_drivers_operations = {\n\t.open\t\t= tty_drivers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nvoid __init proc_tty_init(void)\n{\n\tif (!proc_mkdir(\"tty\", NULL))\n\t\treturn;\n\tproc_mkdir(\"tty/ldisc\", NULL);\t/* Preserved: it's userspace visible */\n\t/*\n\t * /proc/tty/driver/serial reveals the exact character counts for\n\t * serial links which is just too easy to abuse for inferring\n\t * password lengths and inter-keystroke timings during password\n\t * entry.\n\t */\n\tproc_tty_driver = proc_mkdir_mode(\"tty/driver\", S_IRUSR|S_IXUSR, NULL);\n\tproc_create(\"tty/ldiscs\", 0, NULL, &tty_ldiscs_proc_fops);\n\tproc_create(\"tty/drivers\", 0, NULL, &proc_tty_drivers_operations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_net_init",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "proc_net_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "227-227",
          "snippet": "static inline int proc_net_init(void) { return 0; }",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline int proc_net_init(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "proc_symlink",
          "args": [
            "\"mounts\"",
            "NULL",
            "\"self/mounts\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "proc_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "393-417",
          "snippet": "struct proc_dir_entry *proc_symlink(const char *name,\n\t\tstruct proc_dir_entry *parent, const char *dest)\n{\n\tstruct proc_dir_entry *ent;\n\n\tent = __proc_create(&parent, name,\n\t\t\t  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);\n\n\tif (ent) {\n\t\tent->data = kmalloc((ent->size=strlen(dest))+1, GFP_KERNEL);\n\t\tif (ent->data) {\n\t\t\tstrcpy((char*)ent->data,dest);\n\t\t\tent->proc_iops = &proc_link_inode_operations;\n\t\t\tif (proc_register(parent, ent) < 0) {\n\t\t\t\tkfree(ent->data);\n\t\t\t\tkfree(ent);\n\t\t\t\tent = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree(ent);\n\t\t\tent = NULL;\n\t\t}\n\t}\n\treturn ent;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_symlink(const char *name,\n\t\tstruct proc_dir_entry *parent, const char *dest)\n{\n\tstruct proc_dir_entry *ent;\n\n\tent = __proc_create(&parent, name,\n\t\t\t  (S_IFLNK | S_IRUGO | S_IWUGO | S_IXUGO),1);\n\n\tif (ent) {\n\t\tent->data = kmalloc((ent->size=strlen(dest))+1, GFP_KERNEL);\n\t\tif (ent->data) {\n\t\t\tstrcpy((char*)ent->data,dest);\n\t\t\tent->proc_iops = &proc_link_inode_operations;\n\t\t\tif (proc_register(parent, ent) < 0) {\n\t\t\t\tkfree(ent->data);\n\t\t\t\tkfree(ent);\n\t\t\t\tent = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree(ent);\n\t\t\tent = NULL;\n\t\t}\n\t}\n\treturn ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_thread_self_init",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "proc_thread_self_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/thread_self.c",
          "lines": "82-85",
          "snippet": "void __init proc_thread_self_init(void)\n{\n\tproc_alloc_inum(&thread_self_inum);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned thread_self_inum;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic unsigned thread_self_inum;\n\nvoid __init proc_thread_self_init(void)\n{\n\tproc_alloc_inum(&thread_self_inum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_self_init",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "proc_self_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/self.c",
          "lines": "81-84",
          "snippet": "void __init proc_self_init(void)\n{\n\tproc_alloc_inum(&self_inum);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned self_inum;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic unsigned self_inum;\n\nvoid __init proc_self_init(void)\n{\n\tproc_alloc_inum(&self_inum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&proc_fs_type"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_init_inodecache",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "proc_init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/inode.c",
          "lines": "94-101",
          "snippet": "void __init proc_init_inodecache(void)\n{\n\tproc_inode_cachep = kmem_cache_create(\"proc_inode_cache\",\n\t\t\t\t\t     sizeof(struct proc_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\t\t\t     init_once);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/limits.h>",
            "#include <linux/file.h>",
            "#include <linux/printk.h>",
            "#include <linux/poll.h>",
            "#include <linux/completion.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * proc_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/limits.h>\n#include <linux/file.h>\n#include <linux/printk.h>\n#include <linux/poll.h>\n#include <linux/completion.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/pid_namespace.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache * proc_inode_cachep;\n\nvoid __init proc_init_inodecache(void)\n{\n\tproc_inode_cachep = kmem_cache_create(\"proc_inode_cache\",\n\t\t\t\t\t     sizeof(struct proc_inode),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\t\t\t     init_once);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct file_system_type proc_fs_type = {\n\t.name\t\t= \"proc\",\n\t.mount\t\t= proc_mount,\n\t.kill_sb\t= proc_kill_sb,\n\t.fs_flags\t= FS_USERNS_MOUNT,\n};\n\nvoid __init proc_root_init(void)\n{\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\n\tproc_self_init();\n\tproc_thread_self_init();\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); /* somewhere for the nfsd filesystem to be mounted */\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\t/* just give it a mountpoint */\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}"
  },
  {
    "function_name": "proc_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "145-156",
    "snippet": "static void proc_kill_sb(struct super_block *sb)\n{\n\tstruct pid_namespace *ns;\n\n\tns = (struct pid_namespace *)sb->s_fs_info;\n\tif (ns->proc_self)\n\t\tdput(ns->proc_self);\n\tif (ns->proc_thread_self)\n\t\tdput(ns->proc_thread_self);\n\tkill_anon_super(sb);\n\tput_pid_ns(ns);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ns->proc_thread_self"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void proc_kill_sb(struct super_block *sb)\n{\n\tstruct pid_namespace *ns;\n\n\tns = (struct pid_namespace *)sb->s_fs_info;\n\tif (ns->proc_self)\n\t\tdput(ns->proc_self);\n\tif (ns->proc_thread_self)\n\t\tdput(ns->proc_thread_self);\n\tkill_anon_super(sb);\n\tput_pid_ns(ns);\n}"
  },
  {
    "function_name": "proc_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "100-143",
    "snippet": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\tif (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!proc_parse_options(options, ns)) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_super",
          "args": [
            "sb"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/inode.c",
          "lines": "455-485",
          "snippet": "int proc_fill_super(struct super_block *s)\n{\n\tstruct inode *root_inode;\n\tint ret;\n\n\ts->s_flags |= MS_NODIRATIME | MS_NOSUID | MS_NOEXEC;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = PROC_SUPER_MAGIC;\n\ts->s_op = &proc_sops;\n\ts->s_time_gran = 1;\n\t\n\tpde_get(&proc_root);\n\troot_inode = proc_get_inode(s, &proc_root);\n\tif (!root_inode) {\n\t\tpr_err(\"proc_fill_super: get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root) {\n\t\tpr_err(\"proc_fill_super: allocate dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = proc_setup_self(s);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\treturn proc_setup_thread_self(s);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/limits.h>",
            "#include <linux/file.h>",
            "#include <linux/printk.h>",
            "#include <linux/poll.h>",
            "#include <linux/completion.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations proc_sops = {\n\t.alloc_inode\t= proc_alloc_inode,\n\t.destroy_inode\t= proc_destroy_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= proc_evict_inode,\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= proc_remount,\n\t.show_options\t= proc_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/limits.h>\n#include <linux/file.h>\n#include <linux/printk.h>\n#include <linux/poll.h>\n#include <linux/completion.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/pid_namespace.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n\nstatic const struct super_operations proc_sops = {\n\t.alloc_inode\t= proc_alloc_inode,\n\t.destroy_inode\t= proc_destroy_inode,\n\t.drop_inode\t= generic_delete_inode,\n\t.evict_inode\t= proc_evict_inode,\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= proc_remount,\n\t.show_options\t= proc_show_options,\n};\n\nint proc_fill_super(struct super_block *s)\n{\n\tstruct inode *root_inode;\n\tint ret;\n\n\ts->s_flags |= MS_NODIRATIME | MS_NOSUID | MS_NOEXEC;\n\ts->s_blocksize = 1024;\n\ts->s_blocksize_bits = 10;\n\ts->s_magic = PROC_SUPER_MAGIC;\n\ts->s_op = &proc_sops;\n\ts->s_time_gran = 1;\n\t\n\tpde_get(&proc_root);\n\troot_inode = proc_get_inode(s, &proc_root);\n\tif (!root_inode) {\n\t\tpr_err(\"proc_fill_super: get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root) {\n\t\tpr_err(\"proc_fill_super: allocate dentry failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = proc_setup_self(s);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\treturn proc_setup_thread_self(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_parse_options",
          "args": [
            "options",
            "ns"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "proc_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
          "lines": "51-90",
          "snippet": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/parser.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/mount.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};\n\nstatic int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "proc_test_super",
            "proc_set_super",
            "flags",
            "ns"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_fully_visible",
          "args": [
            "fs_type"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fs_fully_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3140-3172",
          "snippet": "bool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nbool fs_fully_visible(struct file_system_type *type)\n{\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tstruct mount *mnt;\n\tbool visible = false;\n\n\tif (unlikely(!ns))\n\t\treturn false;\n\n\tdown_read(&namespace_sem);\n\tlist_for_each_entry(mnt, &ns->list, mnt_list) {\n\t\tstruct mount *child;\n\t\tif (mnt->mnt.mnt_sb->s_type != type)\n\t\t\tcontinue;\n\n\t\t/* This mount is not fully visible if there are any child mounts\n\t\t * that cover anything except for empty directories.\n\t\t */\n\t\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\t\tstruct inode *inode = child->mnt_mountpoint->d_inode;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tgoto next;\n\t\t\tif (inode->i_nlink > 2)\n\t\t\t\tgoto next;\n\t\t}\n\t\tvisible = true;\n\t\tgoto found;\n\tnext:\t;\n\t}\nfound:\n\tup_read(&namespace_sem);\n\treturn visible;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\tif (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))\n\t\t\treturn ERR_PTR(-EPERM);\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!proc_parse_options(options, ns)) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}"
  },
  {
    "function_name": "proc_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "92-98",
    "snippet": "int proc_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct pid_namespace *pid = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\treturn !proc_parse_options(data, pid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_parse_options",
          "args": [
            "data",
            "pid"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "proc_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
          "lines": "51-90",
          "snippet": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/parser.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/mount.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};\n\nstatic int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint proc_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct pid_namespace *pid = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\treturn !proc_parse_options(data, pid);\n}"
  },
  {
    "function_name": "proc_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "51-90",
    "snippet": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\"",
            "p"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"proc: hidepid value must be between 0 and 2.\\n\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_hidepid, \"hidepid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_err, NULL},\n};\n\nstatic int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "proc_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "31-39",
    "snippet": "static int proc_set_super(struct super_block *sb, void *data)\n{\n\tint err = set_anon_super(sb, NULL);\n\tif (!err) {\n\t\tstruct pid_namespace *ns = (struct pid_namespace *)data;\n\t\tsb->s_fs_info = get_pid_ns(ns);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "ns"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "sb",
            "NULL"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_set_super(struct super_block *sb, void *data)\n{\n\tint err = set_anon_super(sb, NULL);\n\tif (!err) {\n\t\tstruct pid_namespace *ns = (struct pid_namespace *)data;\n\t\tsb->s_fs_info = get_pid_ns(ns);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "proc_test_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/root.c",
    "lines": "26-29",
    "snippet": "static int proc_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/parser.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/mount.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/bitops.h>",
      "#include <linux/module.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/parser.h>\n#include <linux/pid_namespace.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}"
  }
]