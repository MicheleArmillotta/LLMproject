[
  {
    "function_name": "xit_script_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_script.c",
    "lines": "122-125",
    "snippet": "tatic void __exit exit_script_binfmt(void)\n{\n\tunregister_binfmt(&script_format);\n}",
    "includes": [
      "include <linux/fs.h>",
      "include <linux/err.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct linux_binfmt script_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_script,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nregister_binfmt(",
          "args": [
            "script_format)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/fs.h>\ninclude <linux/err.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct linux_binfmt script_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_script,\n};\n\ntatic void __exit exit_script_binfmt(void)\n{\n\tunregister_binfmt(&script_format);\n}"
  },
  {
    "function_name": "nit_script_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_script.c",
    "lines": "116-120",
    "snippet": "tatic int __init init_script_binfmt(void)\n{\n\tregister_binfmt(&script_format);\n\treturn 0;\n}",
    "includes": [
      "include <linux/fs.h>",
      "include <linux/err.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct linux_binfmt script_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_script,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "egister_binfmt(",
          "args": [
            "script_format)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/fs.h>\ninclude <linux/err.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct linux_binfmt script_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_script,\n};\n\ntatic int __init init_script_binfmt(void)\n{\n\tregister_binfmt(&script_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "oad_script(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_script.c",
    "lines": "17-109",
    "snippet": "tatic int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\n\t/*\n\t * If the script filename will be inaccessible after exec, typically\n\t * because it is a \"/dev/fd/<fd>/..\" path against an O_CLOEXEC fd, give\n\t * up now (on the assumption that the interpreter will want to load\n\t * this file).\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tretval = bprm_change_interp(interp, bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/*\n\t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}",
    "includes": [
      "include <linux/fs.h>",
      "include <linux/err.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/stat.h>\n#",
      "include <linux/string.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "earch_binary_handler(",
          "args": [
            "prm)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_binprm(",
          "args": [
            "prm)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "ile)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "ile)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen_exec(",
          "args": [
            "nterp)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prm_change_interp(",
          "args": [
            "nterp,",
            "prm)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "i_name,",
            "prm)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "i_arg,",
            "prm)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "bprm->interp,",
            "prm)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emove_arg_zero(",
          "args": [
            "prm)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcpy",
          "args": [
            "nterp,",
            "_name)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "181-188",
          "snippet": "static inline wchar_t *\nUniStrcpy(wchar_t *ucs1, const wchar_t *ucs2)\n{\n\twchar_t *anchor = ucs1;\t/* save the start of result string */\n\n\twhile ((*ucs1++ = *ucs2++)) ;\n\treturn anchor;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline wchar_t *\nUniStrcpy(wchar_t *ucs1, const wchar_t *ucs2)\n{\n\twchar_t *anchor = ucs1;\t/* save the start of result string */\n\n\twhile ((*ucs1++ = *ucs2++)) ;\n\treturn anchor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "prm->buf,",
            "\\n')"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "prm->file)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llow_write_access(",
          "args": [
            "prm->file)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/fs.h>\ninclude <linux/err.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/stat.h>\n#\ninclude <linux/string.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\n\t/*\n\t * If the script filename will be inaccessible after exec, typically\n\t * because it is a \"/dev/fd/<fd>/..\" path against an O_CLOEXEC fd, give\n\t * up now (on the assumption that the interpreter will want to load\n\t * this file).\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * This section does the #! interpretation.\n\t * Sorta complicated, but hopefully it will work.  -TYT\n\t */\n\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; /* No interpreter name found */\n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t/* nothing */ ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\t/*\n\t * OK, we've parsed out the interpreter name and\n\t * (optional) argument.\n\t * Splice in (1) the interpreter's name for argv[0]\n\t *           (2) (optional) argument to interpreter\n\t *           (3) filename of shell script (replace argv[0])\n\t *\n\t * This is done in reverse order, because of how the\n\t * user environment and arguments are stored.\n\t */\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tretval = bprm_change_interp(interp, bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/*\n\t * OK, now restart the process with the interpreter's dentry.\n\t */\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}"
  }
]