[
  {
    "function_name": "hfsplus_read_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
    "lines": "157-261",
    "snippet": "int hfsplus_read_wrapper(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_wd wd;\n\tsector_t part_start, part_size;\n\tu32 blocksize;\n\tint error = 0;\n\n\terror = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\n\tif (!blocksize)\n\t\tgoto out;\n\n\tif (hfsplus_get_last_session(sb, &part_start, &part_size))\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_vhdr_buf)\n\t\tgoto out;\n\tsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_backup_vhdr_buf)\n\t\tgoto out_free_vhdr;\n\nreread:\n\terror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\n\t\t\t\t   READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tswitch (sbi->s_vhdr->signature) {\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\n\t\tset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\n\t\t/*FALLTHRU*/\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\n\t\tbreak;\n\tcase cpu_to_be16(HFSP_WRAP_MAGIC):\n\t\tif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\n\t\t\tgoto out_free_backup_vhdr;\n\t\twd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\n\t\tpart_start += (sector_t)wd.ablk_start +\n\t\t\t       (sector_t)wd.embed_start * wd.ablk_size;\n\t\tpart_size = (sector_t)wd.embed_count * wd.ablk_size;\n\t\tgoto reread;\n\tdefault:\n\t\t/*\n\t\t * Check for a partition block.\n\t\t *\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out_free_backup_vhdr;\n\t\tgoto reread;\n\t}\n\n\terror = hfsplus_submit_bio(sb, part_start + part_size - 2,\n\t\t\t\t   sbi->s_backup_vhdr_buf,\n\t\t\t\t   (void **)&sbi->s_backup_vhdr, READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\n\t\tpr_warn(\"invalid secondary volume header\\n\");\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\n\n\t/*\n\t * Block size must be at least as large as a sector and a multiple of 2.\n\t */\n\tif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\n\t\tgoto out_free_backup_vhdr;\n\tsbi->alloc_blksz = blocksize;\n\tsbi->alloc_blksz_shift = ilog2(blocksize);\n\tblocksize = min_t(u32, sbi->alloc_blksz, PAGE_SIZE);\n\n\t/*\n\t * Align block size to block offset.\n\t */\n\twhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\n\t\tblocksize >>= 1;\n\n\tif (sb_set_blocksize(sb, blocksize) != blocksize) {\n\t\tpr_err(\"unable to set blocksize to %u!\\n\", blocksize);\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tsbi->blockoffset =\n\t\tpart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\n\tsbi->part_start = part_start;\n\tsbi->sect_count = part_size;\n\tsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\n\treturn 0;\n\nout_free_backup_vhdr:\n\tkfree(sbi->s_backup_vhdr_buf);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_vhdr_buf"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_backup_vhdr_buf"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to set blocksize to %u!\\n\"",
            "blocksize"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sbi->alloc_blksz",
            "PAGE_SIZE"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "blocksize"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sbi->s_vhdr->blocksize"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"invalid secondary volume header\\n\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_submit_bio",
          "args": [
            "sb",
            "part_start + part_size - 2",
            "sbi->s_backup_vhdr_buf",
            "(void **)&sbi->s_backup_vhdr",
            "READ"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "46-90",
          "snippet": "int hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_part_find",
          "args": [
            "sb",
            "&part_start",
            "&part_size"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_part_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/part_tbl.c",
          "lines": "128-157",
          "snippet": "int hfs_part_find(struct super_block *sb,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tvoid *buf, *data;\n\tint res;\n\n\tbuf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = hfsplus_submit_bio(sb, *part_start + HFS_PMAP_BLK,\n\t\t\t\t buf, &data, READ);\n\tif (res)\n\t\tgoto out;\n\n\tswitch (be16_to_cpu(*((__be16 *)data))) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t\tres = hfs_parse_old_pmap(sb, data, part_start, part_size);\n\t\tbreak;\n\tcase HFS_NEW_PMAP_MAGIC:\n\t\tres = hfs_parse_new_pmap(sb, buf, data, part_start, part_size);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENOENT;\n\t\tbreak;\n\t}\nout:\n\tkfree(buf);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */",
            "#define HFS_OLD_PMAP_MAGIC\t0x5453 /* \"TS\": old-type partition map */",
            "#define HFS_PMAP_BLK\t\t1 /* First block of partition map */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\n#define HFS_NEW_PMAP_MAGIC\t0x504D /* \"PM\": new-type partition map */\n#define HFS_OLD_PMAP_MAGIC\t0x5453 /* \"TS\": old-type partition map */\n#define HFS_PMAP_BLK\t\t1 /* First block of partition map */\n\nint hfs_part_find(struct super_block *sb,\n\t\tsector_t *part_start, sector_t *part_size)\n{\n\tvoid *buf, *data;\n\tint res;\n\n\tbuf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = hfsplus_submit_bio(sb, *part_start + HFS_PMAP_BLK,\n\t\t\t\t buf, &data, READ);\n\tif (res)\n\t\tgoto out;\n\n\tswitch (be16_to_cpu(*((__be16 *)data))) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t\tres = hfs_parse_old_pmap(sb, data, part_start, part_size);\n\t\tbreak;\n\tcase HFS_NEW_PMAP_MAGIC:\n\t\tres = hfs_parse_new_pmap(sb, buf, data, part_start, part_size);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENOENT;\n\t\tbreak;\n\t}\nout:\n\tkfree(buf);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_read_mdb",
          "args": [
            "sbi->s_vhdr",
            "&wd"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_read_mdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "92-122",
          "snippet": "static int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\n{\n\tu32 extent;\n\tu16 attrib;\n\t__be16 sig;\n\n\tsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\n\tif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\n\t    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\n\t\treturn 0;\n\n\tattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\n\tif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\n\t   !(attrib & HFSP_WRAP_ATTRIB_SPARED))\n\t\treturn 0;\n\n\twd->ablk_size =\n\t\tbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\n\tif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\tif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\twd->ablk_start =\n\t\tbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\n\n\textent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\n\twd->embed_start = (extent >> 16) & 0xFFFF;\n\twd->embed_count = extent & 0xFFFF;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\n{\n\tu32 extent;\n\tu16 attrib;\n\t__be16 sig;\n\n\tsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\n\tif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\n\t    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\n\t\treturn 0;\n\n\tattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\n\tif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\n\t   !(attrib & HFSP_WRAP_ATTRIB_SPARED))\n\t\treturn 0;\n\n\twd->ablk_size =\n\t\tbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\n\tif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\tif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\twd->ablk_start =\n\t\tbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\n\n\textent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\n\twd->embed_start = (extent >> 16) & 0xFFFF;\n\twd->embed_count = extent & 0xFFFF;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSP_WRAP_MAGIC"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_VOLHEAD_SIG"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFSPLUS_SB_HFSX",
            "&sbi->flags"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_VOLHEAD_SIGX"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "hfsplus_min_io_size(sb)",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_min_io_size",
          "args": [
            "sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_min_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "304-308",
          "snippet": "static inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_get_last_session",
          "args": [
            "sb",
            "&part_start",
            "&part_size"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_get_last_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
          "lines": "124-153",
          "snippet": "static int hfsplus_get_last_session(struct super_block *sb,\n\t\t\t\t    sector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFSPLUS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFSPLUS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev,\n\t\t\tCDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION,\n\t\t(unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int hfsplus_get_last_session(struct super_block *sb,\n\t\t\t\t    sector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFSPLUS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFSPLUS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev,\n\t\t\tCDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION,\n\t\t(unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "HFSPLUS_SECTOR_SIZE"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_read_wrapper(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_wd wd;\n\tsector_t part_start, part_size;\n\tu32 blocksize;\n\tint error = 0;\n\n\terror = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, HFSPLUS_SECTOR_SIZE);\n\tif (!blocksize)\n\t\tgoto out;\n\n\tif (hfsplus_get_last_session(sb, &part_start, &part_size))\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tsbi->s_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_vhdr_buf)\n\t\tgoto out;\n\tsbi->s_backup_vhdr_buf = kmalloc(hfsplus_min_io_size(sb), GFP_KERNEL);\n\tif (!sbi->s_backup_vhdr_buf)\n\t\tgoto out_free_vhdr;\n\nreread:\n\terror = hfsplus_submit_bio(sb, part_start + HFSPLUS_VOLHEAD_SECTOR,\n\t\t\t\t   sbi->s_vhdr_buf, (void **)&sbi->s_vhdr,\n\t\t\t\t   READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tswitch (sbi->s_vhdr->signature) {\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIGX):\n\t\tset_bit(HFSPLUS_SB_HFSX, &sbi->flags);\n\t\t/*FALLTHRU*/\n\tcase cpu_to_be16(HFSPLUS_VOLHEAD_SIG):\n\t\tbreak;\n\tcase cpu_to_be16(HFSP_WRAP_MAGIC):\n\t\tif (!hfsplus_read_mdb(sbi->s_vhdr, &wd))\n\t\t\tgoto out_free_backup_vhdr;\n\t\twd.ablk_size >>= HFSPLUS_SECTOR_SHIFT;\n\t\tpart_start += (sector_t)wd.ablk_start +\n\t\t\t       (sector_t)wd.embed_start * wd.ablk_size;\n\t\tpart_size = (sector_t)wd.embed_count * wd.ablk_size;\n\t\tgoto reread;\n\tdefault:\n\t\t/*\n\t\t * Check for a partition block.\n\t\t *\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out_free_backup_vhdr;\n\t\tgoto reread;\n\t}\n\n\terror = hfsplus_submit_bio(sb, part_start + part_size - 2,\n\t\t\t\t   sbi->s_backup_vhdr_buf,\n\t\t\t\t   (void **)&sbi->s_backup_vhdr, READ);\n\tif (error)\n\t\tgoto out_free_backup_vhdr;\n\n\terror = -EINVAL;\n\tif (sbi->s_backup_vhdr->signature != sbi->s_vhdr->signature) {\n\t\tpr_warn(\"invalid secondary volume header\\n\");\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tblocksize = be32_to_cpu(sbi->s_vhdr->blocksize);\n\n\t/*\n\t * Block size must be at least as large as a sector and a multiple of 2.\n\t */\n\tif (blocksize < HFSPLUS_SECTOR_SIZE || ((blocksize - 1) & blocksize))\n\t\tgoto out_free_backup_vhdr;\n\tsbi->alloc_blksz = blocksize;\n\tsbi->alloc_blksz_shift = ilog2(blocksize);\n\tblocksize = min_t(u32, sbi->alloc_blksz, PAGE_SIZE);\n\n\t/*\n\t * Align block size to block offset.\n\t */\n\twhile (part_start & ((blocksize >> HFSPLUS_SECTOR_SHIFT) - 1))\n\t\tblocksize >>= 1;\n\n\tif (sb_set_blocksize(sb, blocksize) != blocksize) {\n\t\tpr_err(\"unable to set blocksize to %u!\\n\", blocksize);\n\t\tgoto out_free_backup_vhdr;\n\t}\n\n\tsbi->blockoffset =\n\t\tpart_start >> (sb->s_blocksize_bits - HFSPLUS_SECTOR_SHIFT);\n\tsbi->part_start = part_start;\n\tsbi->sect_count = part_size;\n\tsbi->fs_shift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\n\treturn 0;\n\nout_free_backup_vhdr:\n\tkfree(sbi->s_backup_vhdr_buf);\nout_free_vhdr:\n\tkfree(sbi->s_vhdr_buf);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "hfsplus_get_last_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
    "lines": "124-153",
    "snippet": "static int hfsplus_get_last_session(struct super_block *sb,\n\t\t\t\t    sector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFSPLUS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFSPLUS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev,\n\t\t\tCDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION,\n\t\t(unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl_by_bdev",
          "args": [
            "sb->s_bdev",
            "CDROMMULTISESSION",
            "(unsigned long)&ms_info"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_by_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1677-1685",
          "snippet": "int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid session number or type of track\\n\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int hfsplus_get_last_session(struct super_block *sb,\n\t\t\t\t    sector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFSPLUS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFSPLUS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev,\n\t\t\tCDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION,\n\t\t(unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_read_mdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
    "lines": "92-122",
    "snippet": "static int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\n{\n\tu32 extent;\n\tu16 attrib;\n\t__be16 sig;\n\n\tsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\n\tif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\n\t    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\n\t\treturn 0;\n\n\tattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\n\tif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\n\t   !(attrib & HFSP_WRAP_ATTRIB_SPARED))\n\t\treturn 0;\n\n\twd->ablk_size =\n\t\tbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\n\tif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\tif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\twd->ablk_start =\n\t\tbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\n\n\textent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\n\twd->embed_start = (extent >> 16) & 0xFFFF;\n\twd->embed_count = extent & 0xFFFF;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unaligned_be32",
          "args": [
            "bufptr + HFSP_WRAPOFF_EMBEDEXT"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_VOLHEAD_SIGX"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_VOLHEAD_SIG"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int hfsplus_read_mdb(void *bufptr, struct hfsplus_wd *wd)\n{\n\tu32 extent;\n\tu16 attrib;\n\t__be16 sig;\n\n\tsig = *(__be16 *)(bufptr + HFSP_WRAPOFF_EMBEDSIG);\n\tif (sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIG) &&\n\t    sig != cpu_to_be16(HFSPLUS_VOLHEAD_SIGX))\n\t\treturn 0;\n\n\tattrib = be16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ATTRIB));\n\tif (!(attrib & HFSP_WRAP_ATTRIB_SLOCK) ||\n\t   !(attrib & HFSP_WRAP_ATTRIB_SPARED))\n\t\treturn 0;\n\n\twd->ablk_size =\n\t\tbe32_to_cpu(*(__be32 *)(bufptr + HFSP_WRAPOFF_ABLKSIZE));\n\tif (wd->ablk_size < HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\tif (wd->ablk_size % HFSPLUS_SECTOR_SIZE)\n\t\treturn 0;\n\twd->ablk_start =\n\t\tbe16_to_cpu(*(__be16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));\n\n\textent = get_unaligned_be32(bufptr + HFSP_WRAPOFF_EMBEDEXT);\n\twd->embed_start = (extent >> 16) & 0xFFFF;\n\twd->embed_count = extent & 0xFFFF;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "hfsplus_submit_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/wrapper.c",
    "lines": "46-90",
    "snippet": "int hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "rw",
            "bio"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "virt_to_page(buf)",
            "len",
            "page_offset"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "buf"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "PAGE_SIZE - page_offset",
            "io_size"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "buf"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_min_io_size",
          "args": [
            "sb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_min_io_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "304-308",
          "snippet": "static inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline unsigned short hfsplus_min_io_size(struct super_block *sb)\n{\n\treturn max_t(unsigned short, bdev_logical_block_size(sb->s_bdev),\n\t\t     HFSPLUS_SECTOR_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <asm/unaligned.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint hfsplus_submit_bio(struct super_block *sb, sector_t sector,\n\t\tvoid *buf, void **data, int rw)\n{\n\tstruct bio *bio;\n\tint ret = 0;\n\tu64 io_size;\n\tloff_t start;\n\tint offset;\n\n\t/*\n\t * Align sector to hardware sector size and find offset. We\n\t * assume that io_size is a power of two, which _should_\n\t * be true.\n\t */\n\tio_size = hfsplus_min_io_size(sb);\n\tstart = (loff_t)sector << HFSPLUS_SECTOR_SHIFT;\n\toffset = start & (io_size - 1);\n\tsector &= ~((io_size >> HFSPLUS_SECTOR_SHIFT) - 1);\n\n\tbio = bio_alloc(GFP_NOIO, 1);\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_bdev = sb->s_bdev;\n\n\tif (!(rw & WRITE) && data)\n\t\t*data = (u8 *)buf + offset;\n\n\twhile (io_size > 0) {\n\t\tunsigned int page_offset = offset_in_page(buf);\n\t\tunsigned int len = min_t(unsigned int, PAGE_SIZE - page_offset,\n\t\t\t\t\t io_size);\n\n\t\tret = bio_add_page(bio, virt_to_page(buf), len, page_offset);\n\t\tif (ret != len) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tio_size -= len;\n\t\tbuf = (u8 *)buf + len;\n\t}\n\n\tret = submit_bio_wait(rw, bio);\nout:\n\tbio_put(bio);\n\treturn ret < 0 ? ret : 0;\n}"
  }
]