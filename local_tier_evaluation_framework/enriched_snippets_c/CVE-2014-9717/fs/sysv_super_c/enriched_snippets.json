[
  {
    "function_name": "exit_sysv_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "584-589",
    "snippet": "static void __exit exit_sysv_fs(void)\n{\n\tunregister_filesystem(&sysv_fs_type);\n\tunregister_filesystem(&v7_fs_type);\n\tsysv_destroy_icache();\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type sysv_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sysv\",\n\t.mount\t\t= sysv_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};",
      "static struct file_system_type v7_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"v7\",\n\t.mount\t\t= v7_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_destroy_icache",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_destroy_icache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "362-370",
          "snippet": "void sysv_destroy_icache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(sysv_inode_cachep);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sysv_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic struct kmem_cache *sysv_inode_cachep;\n\nvoid sysv_destroy_icache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(sysv_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&v7_fs_type"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type sysv_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sysv\",\n\t.mount\t\t= sysv_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nstatic struct file_system_type v7_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"v7\",\n\t.mount\t\t= v7_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_sysv_fs(void)\n{\n\tunregister_filesystem(&sysv_fs_type);\n\tunregister_filesystem(&v7_fs_type);\n\tsysv_destroy_icache();\n}"
  },
  {
    "function_name": "init_sysv_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "561-582",
    "snippet": "static int __init init_sysv_fs(void)\n{\n\tint error;\n\n\terror = sysv_init_icache();\n\tif (error)\n\t\tgoto out;\n\terror = register_filesystem(&sysv_fs_type);\n\tif (error)\n\t\tgoto destroy_icache;\n\terror = register_filesystem(&v7_fs_type);\n\tif (error)\n\t\tgoto unregister;\n\treturn 0;\n\nunregister:\n\tunregister_filesystem(&sysv_fs_type);\ndestroy_icache:\n\tsysv_destroy_icache();\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type sysv_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sysv\",\n\t.mount\t\t= sysv_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};",
      "static struct file_system_type v7_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"v7\",\n\t.mount\t\t= v7_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_destroy_icache",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_destroy_icache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "362-370",
          "snippet": "void sysv_destroy_icache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(sysv_inode_cachep);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sysv_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic struct kmem_cache *sysv_inode_cachep;\n\nvoid sysv_destroy_icache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(sysv_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&sysv_fs_type"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_init_icache",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_init_icache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "351-360",
          "snippet": "int __init sysv_init_icache(void)\n{\n\tsysv_inode_cachep = kmem_cache_create(\"sysv_inode_cache\",\n\t\t\tsizeof(struct sysv_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\tinit_once);\n\tif (!sysv_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sysv_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic struct kmem_cache *sysv_inode_cachep;\n\nint __init sysv_init_icache(void)\n{\n\tsysv_inode_cachep = kmem_cache_create(\"sysv_inode_cache\",\n\t\t\tsizeof(struct sysv_inode_info), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\tinit_once);\n\tif (!sysv_inode_cachep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type sysv_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sysv\",\n\t.mount\t\t= sysv_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nstatic struct file_system_type v7_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"v7\",\n\t.mount\t\t= v7_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_sysv_fs(void)\n{\n\tint error;\n\n\terror = sysv_init_icache();\n\tif (error)\n\t\tgoto out;\n\terror = register_filesystem(&sysv_fs_type);\n\tif (error)\n\t\tgoto destroy_icache;\n\terror = register_filesystem(&v7_fs_type);\n\tif (error)\n\t\tgoto unregister;\n\treturn 0;\n\nunregister:\n\tunregister_filesystem(&sysv_fs_type);\ndestroy_icache:\n\tsysv_destroy_icache();\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "v7_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "536-540",
    "snippet": "static struct dentry *v7_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, v7_fill_super);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "v7_fill_super"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *v7_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, v7_fill_super);\n}"
  },
  {
    "function_name": "sysv_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "530-534",
    "snippet": "static struct dentry *sysv_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, sysv_fill_super);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "sysv_fill_super"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct dentry *sysv_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, sysv_fill_super);\n}"
  },
  {
    "function_name": "v7_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "473-526",
    "snippet": "static int v7_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct sysv_sb_info *sbi;\n\tstruct buffer_head *bh;\n\n\tif (440 != sizeof (struct v7_super_block))\n\t\tpanic(\"V7 FS: bad super-block size\");\n\tif (64 != sizeof (struct sysv_inode))\n\t\tpanic(\"sysv fs: bad i-node size\");\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tsbi->s_type = FSTYPE_V7;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\t\n\tsb_set_blocksize(sb, 512);\n\n\tif ((bh = sb_bread(sb, 1)) == NULL) {\n\t\tif (!silent)\n\t\t\tprintk(\"VFS: unable to read V7 FS superblock on \"\n\t\t\t       \"device %s.\\n\", sb->s_id);\n\t\tgoto failed;\n\t}\n\n\t/* Try PDP-11 UNIX */\n\tsbi->s_bytesex = BYTESEX_PDP;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\t/* Try PC/IX, v7/x86 */\n\tsbi->s_bytesex = BYTESEX_LE;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\tgoto failed;\n\ndetected:\n\tsbi->s_bh1 = bh;\n\tsbi->s_bh2 = bh;\n\tif (complete_read_super(sb, silent, 1))\n\t\treturn 0;\n\nfailed:\n\tprintk(KERN_ERR \"VFS: could not find a valid V7 on %s.\\n\",\n\t\tsb->s_id);\n\tbrelse(bh);\n\tkfree(sbi);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"VFS: could not find a valid V7 on %s.\\n\"",
            "sb->s_id"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_read_super",
          "args": [
            "sb",
            "silent",
            "1"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "complete_read_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
          "lines": "302-350",
          "snippet": "static int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};",
            "static void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};\nstatic void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};\n\nstatic int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v7_sanity_check",
          "args": [
            "sb",
            "bh"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "v7_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
          "lines": "437-471",
          "snippet": "static int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct v7_super_block *v7sb;\n\tstruct sysv_inode *v7i;\n\tstruct buffer_head *bh2;\n\tstruct sysv_sb_info *sbi;\n\n\tsbi = sb->s_fs_info;\n\n\t/* plausibility check on superblock */\n\tv7sb = (struct v7_super_block *) bh->b_data;\n\tif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\n\t    fs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\n\t    fs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\n\t\treturn 0;\n\n\t/* plausibility check on root inode: it is a directory,\n\t   with a nonzero size that is a multiple of 16 */\n\tbh2 = sb_bread(sb, 2);\n\tif (bh2 == NULL)\n\t\treturn 0;\n\n\tv7i = (struct sysv_inode *)(bh2->b_data + 64);\n\tif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) == 0) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) & 017) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\n\t     sizeof(struct sysv_dir_entry))) {\n\t\tbrelse(bh2);\n\t\treturn 0;\n\t}\n\n\tbrelse(bh2);\n\treturn 1;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct v7_super_block *v7sb;\n\tstruct sysv_inode *v7i;\n\tstruct buffer_head *bh2;\n\tstruct sysv_sb_info *sbi;\n\n\tsbi = sb->s_fs_info;\n\n\t/* plausibility check on superblock */\n\tv7sb = (struct v7_super_block *) bh->b_data;\n\tif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\n\t    fs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\n\t    fs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\n\t\treturn 0;\n\n\t/* plausibility check on root inode: it is a directory,\n\t   with a nonzero size that is a multiple of 16 */\n\tbh2 = sb_bread(sb, 2);\n\tif (bh2 == NULL)\n\t\treturn 0;\n\n\tv7i = (struct sysv_inode *)(bh2->b_data + 64);\n\tif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) == 0) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) & 017) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\n\t     sizeof(struct sysv_dir_entry))) {\n\t\tbrelse(bh2);\n\t\treturn 0;\n\t}\n\n\tbrelse(bh2);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "1"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "512"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct sysv_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"sysv fs: bad i-node size\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"V7 FS: bad super-block size\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int v7_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct sysv_sb_info *sbi;\n\tstruct buffer_head *bh;\n\n\tif (440 != sizeof (struct v7_super_block))\n\t\tpanic(\"V7 FS: bad super-block size\");\n\tif (64 != sizeof (struct sysv_inode))\n\t\tpanic(\"sysv fs: bad i-node size\");\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tsbi->s_type = FSTYPE_V7;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\t\n\tsb_set_blocksize(sb, 512);\n\n\tif ((bh = sb_bread(sb, 1)) == NULL) {\n\t\tif (!silent)\n\t\t\tprintk(\"VFS: unable to read V7 FS superblock on \"\n\t\t\t       \"device %s.\\n\", sb->s_id);\n\t\tgoto failed;\n\t}\n\n\t/* Try PDP-11 UNIX */\n\tsbi->s_bytesex = BYTESEX_PDP;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\t/* Try PC/IX, v7/x86 */\n\tsbi->s_bytesex = BYTESEX_LE;\n\tif (v7_sanity_check(sb, bh))\n\t\tgoto detected;\n\n\tgoto failed;\n\ndetected:\n\tsbi->s_bh1 = bh;\n\tsbi->s_bh2 = bh;\n\tif (complete_read_super(sb, silent, 1))\n\t\treturn 0;\n\nfailed:\n\tprintk(KERN_ERR \"VFS: could not find a valid V7 on %s.\\n\",\n\t\tsb->s_id);\n\tbrelse(bh);\n\tkfree(sbi);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "v7_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "437-471",
    "snippet": "static int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct v7_super_block *v7sb;\n\tstruct sysv_inode *v7i;\n\tstruct buffer_head *bh2;\n\tstruct sysv_sb_info *sbi;\n\n\tsbi = sb->s_fs_info;\n\n\t/* plausibility check on superblock */\n\tv7sb = (struct v7_super_block *) bh->b_data;\n\tif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\n\t    fs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\n\t    fs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\n\t\treturn 0;\n\n\t/* plausibility check on root inode: it is a directory,\n\t   with a nonzero size that is a multiple of 16 */\n\tbh2 = sb_bread(sb, 2);\n\tif (bh2 == NULL)\n\t\treturn 0;\n\n\tv7i = (struct sysv_inode *)(bh2->b_data + 64);\n\tif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) == 0) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) & 017) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\n\t     sizeof(struct sysv_dir_entry))) {\n\t\tbrelse(bh2);\n\t\treturn 0;\n\t}\n\n\tbrelse(bh2);\n\treturn 1;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh2"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "v7i->i_size"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "v7i->i_mode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "2"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\n{\n\tstruct v7_super_block *v7sb;\n\tstruct sysv_inode *v7i;\n\tstruct buffer_head *bh2;\n\tstruct sysv_sb_info *sbi;\n\n\tsbi = sb->s_fs_info;\n\n\t/* plausibility check on superblock */\n\tv7sb = (struct v7_super_block *) bh->b_data;\n\tif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\n\t    fs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\n\t    fs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\n\t\treturn 0;\n\n\t/* plausibility check on root inode: it is a directory,\n\t   with a nonzero size that is a multiple of 16 */\n\tbh2 = sb_bread(sb, 2);\n\tif (bh2 == NULL)\n\t\treturn 0;\n\n\tv7i = (struct sysv_inode *)(bh2->b_data + 64);\n\tif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) == 0) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) & 017) ||\n\t    (fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\n\t     sizeof(struct sysv_dir_entry))) {\n\t\tbrelse(bh2);\n\t\treturn 0;\n\t}\n\n\tbrelse(bh2);\n\treturn 1;\n}"
  },
  {
    "function_name": "sysv_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "352-435",
    "snippet": "static int sysv_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh1, *bh = NULL;\n\tstruct sysv_sb_info *sbi;\n\tunsigned long blocknr;\n\tint size = 0, i;\n\t\n\tBUILD_BUG_ON(1024 != sizeof (struct xenix_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv4_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv2_super_block));\n\tBUILD_BUG_ON(500 != sizeof (struct coh_super_block));\n\tBUILD_BUG_ON(64 != sizeof (struct sysv_inode));\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\n\tfor (i = 0; i < ARRAY_SIZE(flavours) && !size; i++) {\n\t\tbrelse(bh);\n\t\tbh = sb_bread(sb, flavours[i].block);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tsize = flavours[i].test(SYSV_SB(sb), bh);\n\t}\n\n\tif (!size)\n\t\tgoto Eunknown;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\tblocknr = bh->b_blocknr << 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 512);\n\t\t\tbh1 = sb_bread(sb, blocknr);\n\t\t\tbh = sb_bread(sb, blocknr + 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbh1 = bh;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tblocknr = bh->b_blocknr >> 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 2048);\n\t\t\tbh1 = bh = sb_bread(sb, blocknr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto Ebadsize;\n\t}\n\n\tif (bh && bh1) {\n\t\tsbi->s_bh1 = bh1;\n\t\tsbi->s_bh2 = bh;\n\t\tif (complete_read_super(sb, silent, size))\n\t\t\treturn 0;\n\t}\n\n\tbrelse(bh1);\n\tbrelse(bh);\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tprintk(\"oldfs: cannot read superblock\\n\");\nfailed:\n\tkfree(sbi);\n\treturn -EINVAL;\n\nEunknown:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: unable to find oldfs superblock on device %s\\n\",\n\t\t\tsb->s_id);\n\tgoto failed;\nEbadsize:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: oldfs: unsupported block size (%dKb)\\n\",\n\t\t\t1<<(size-2));\n\tgoto failed;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tint block;\n\tint (*test)(struct sysv_sb_info *, struct buffer_head *);\n} flavours[] = {\n\t{1, detect_xenix},\n\t{0, detect_sysv},\n\t{0, detect_coherent},\n\t{9, detect_sysv_odd},\n\t{15,detect_sysv_odd},\n\t{18,detect_sysv},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"VFS: oldfs: unsupported block size (%dKb)\\n\"",
            "1<<(size-2)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"oldfs: cannot read superblock\\n\""
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "BLOCK_SIZE"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_read_super",
          "args": [
            "sb",
            "silent",
            "size"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "complete_read_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
          "lines": "302-350",
          "snippet": "static int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};",
            "static void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};\nstatic void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};\n\nstatic int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr + 1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flavours[i].test",
          "args": [
            "SYSV_SB(sb)",
            "bh"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "flavours[i].block"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "flavours"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct sysv_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "64 != sizeof (struct sysv_inode)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "500 != sizeof (struct coh_super_block)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "512 != sizeof (struct sysv2_super_block)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "512 != sizeof (struct sysv4_super_block)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "1024 != sizeof (struct xenix_super_block)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct {\n\tint block;\n\tint (*test)(struct sysv_sb_info *, struct buffer_head *);\n} flavours[] = {\n\t{1, detect_xenix},\n\t{0, detect_sysv},\n\t{0, detect_coherent},\n\t{9, detect_sysv_odd},\n\t{15,detect_sysv_odd},\n\t{18,detect_sysv},\n};\n\nstatic int sysv_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh1, *bh = NULL;\n\tstruct sysv_sb_info *sbi;\n\tunsigned long blocknr;\n\tint size = 0, i;\n\t\n\tBUILD_BUG_ON(1024 != sizeof (struct xenix_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv4_super_block));\n\tBUILD_BUG_ON(512 != sizeof (struct sysv2_super_block));\n\tBUILD_BUG_ON(500 != sizeof (struct coh_super_block));\n\tBUILD_BUG_ON(64 != sizeof (struct sysv_inode));\n\n\tsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsbi->s_sb = sb;\n\tsbi->s_block_base = 0;\n\tmutex_init(&sbi->s_lock);\n\tsb->s_fs_info = sbi;\n\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\n\tfor (i = 0; i < ARRAY_SIZE(flavours) && !size; i++) {\n\t\tbrelse(bh);\n\t\tbh = sb_bread(sb, flavours[i].block);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tsize = flavours[i].test(SYSV_SB(sb), bh);\n\t}\n\n\tif (!size)\n\t\tgoto Eunknown;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\tblocknr = bh->b_blocknr << 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 512);\n\t\t\tbh1 = sb_bread(sb, blocknr);\n\t\t\tbh = sb_bread(sb, blocknr + 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbh1 = bh;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tblocknr = bh->b_blocknr >> 1;\n\t\t\tbrelse(bh);\n\t\t\tsb_set_blocksize(sb, 2048);\n\t\t\tbh1 = bh = sb_bread(sb, blocknr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto Ebadsize;\n\t}\n\n\tif (bh && bh1) {\n\t\tsbi->s_bh1 = bh1;\n\t\tsbi->s_bh2 = bh;\n\t\tif (complete_read_super(sb, silent, size))\n\t\t\treturn 0;\n\t}\n\n\tbrelse(bh1);\n\tbrelse(bh);\n\tsb_set_blocksize(sb, BLOCK_SIZE);\n\tprintk(\"oldfs: cannot read superblock\\n\");\nfailed:\n\tkfree(sbi);\n\treturn -EINVAL;\n\nEunknown:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: unable to find oldfs superblock on device %s\\n\",\n\t\t\tsb->s_id);\n\tgoto failed;\nEbadsize:\n\tbrelse(bh);\n\tif (!silent)\n\t\tprintk(\"VFS: oldfs: unsupported block size (%dKb)\\n\",\n\t\t\t1<<(size-2));\n\tgoto failed;\n}"
  },
  {
    "function_name": "complete_read_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "302-350",
    "snippet": "static int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};",
      "static void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"SysV FS: get root dentry failed\\n\""
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root_inode"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_iget",
          "args": [
            "sb",
            "SYSV_ROOT_INO"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "177-235",
          "snippet": "struct inode *sysv_iget(struct super_block *sb, unsigned int ino)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tstruct inode *inode;\n\tunsigned int block;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"Major problem: unable to read inode from dev %s\\n\",\n\t\t       inode->i_sb->s_id);\n\t\tgoto bad_inode;\n\t}\n\t/* SystemV FS: kludge permissions if ino==SYSV_ROOT_INO ?? */\n\tinode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);\n\ti_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));\n\ti_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));\n\tset_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));\n\tinode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\n\tsi = SYSV_I(inode);\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\tread3byte(sbi, &raw_inode->i_data[3*block],\n\t\t\t\t(u8 *)&si->i_data[block]);\n\tbrelse(bh);\n\tsi->i_dir_start_lookup = 0;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsysv_set_inode(inode,\n\t\t\t       old_decode_dev(fs32_to_cpu(sbi, si->i_data[0])));\n\telse\n\t\tsysv_set_inode(inode, 0);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstruct inode *sysv_iget(struct super_block *sb, unsigned int ino)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tstruct inode *inode;\n\tunsigned int block;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"Major problem: unable to read inode from dev %s\\n\",\n\t\t       inode->i_sb->s_id);\n\t\tgoto bad_inode;\n\t}\n\t/* SystemV FS: kludge permissions if ino==SYSV_ROOT_INO ?? */\n\tinode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);\n\ti_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));\n\ti_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));\n\tset_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));\n\tinode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\n\tsi = SYSV_I(inode);\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\tread3byte(sbi, &raw_inode->i_data[3*block],\n\t\t\t\t(u8 *)&si->i_data[block]);\n\tbrelse(bh);\n\tsi->i_dir_start_lookup = 0;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsysv_set_inode(inode,\n\t\t\t       old_decode_dev(fs32_to_cpu(sbi, si->i_data[0])));\n\telse\n\t\tsysv_set_inode(inode, 0);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"VFS: Found a %s FS (block size = %ld) on device %s\\n\"",
            "found",
            "sb->s_blocksize",
            "sb->s_id"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flavour_setup[sbi->s_type]",
          "args": [
            "sbi",
            "&sb->s_max_links"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SYSV_SB",
          "args": [
            "sb"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "SYSV_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "79-82",
          "snippet": "static inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct sysv_sb_info *SYSV_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char *flavour_names[] = {\n\t[FSTYPE_XENIX]\t= \"Xenix\",\n\t[FSTYPE_SYSV4]\t= \"SystemV\",\n\t[FSTYPE_SYSV2]\t= \"SystemV Release 2\",\n\t[FSTYPE_COH]\t= \"Coherent\",\n\t[FSTYPE_V7]\t= \"V7\",\n\t[FSTYPE_AFS]\t= \"AFS\",\n};\nstatic void (*flavour_setup[])(struct sysv_sb_info *, unsigned *) = {\n\t[FSTYPE_XENIX]\t= detected_xenix,\n\t[FSTYPE_SYSV4]\t= detected_sysv4,\n\t[FSTYPE_SYSV2]\t= detected_sysv2,\n\t[FSTYPE_COH]\t= detected_coherent,\n\t[FSTYPE_V7]\t= detected_v7,\n\t[FSTYPE_AFS]\t= detected_sysv4,\n};\n\nstatic int complete_read_super(struct super_block *sb, int silent, int size)\n{\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *root_inode;\n\tchar *found = flavour_names[sbi->s_type];\n\tu_char n_bits = size+8;\n\tint bsize = 1 << n_bits;\n\tint bsize_4 = bsize >> 2;\n\n\tsbi->s_firstinodezone = 2;\n\n\tflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\n\t\n\tsbi->s_truncate = 1;\n\tsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\n\tsbi->s_inodes_per_block = bsize >> 6;\n\tsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\n\tsbi->s_inodes_per_block_bits = n_bits-6;\n\tsbi->s_ind_per_block = bsize_4;\n\tsbi->s_ind_per_block_2 = bsize_4*bsize_4;\n\tsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\n\tsbi->s_ind_per_block_bits = n_bits-2;\n\n\tsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\n\t\t<< sbi->s_inodes_per_block_bits;\n\n\tif (!silent)\n\t\tprintk(\"VFS: Found a %s FS (block size = %ld) on device %s\\n\",\n\t\t       found, sb->s_blocksize, sb->s_id);\n\n\tsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\n\t/* set up enough so that it can read an inode */\n\tsb->s_op = &sysv_sops;\n\tif (sbi->s_forced_ro)\n\t\tsb->s_flags |= MS_RDONLY;\n\tif (sbi->s_truncate)\n\t\tsb->s_d_op = &sysv_dentry_operations;\n\troot_inode = sysv_iget(sb, SYSV_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tprintk(\"SysV FS: get root inode failed\\n\");\n\t\treturn 0;\n\t}\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tprintk(\"SysV FS: get root dentry failed\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "detect_sysv_odd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "265-270",
    "snippet": "static int detect_sysv_odd(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tint size = detect_sysv(sbi, bh);\n\n\treturn size>2 ? 0 : size;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "detect_sysv",
          "args": [
            "sbi",
            "bh"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "detect_sysv_odd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
          "lines": "265-270",
          "snippet": "static int detect_sysv_odd(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tint size = detect_sysv(sbi, bh);\n\n\treturn size>2 ? 0 : size;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int detect_sysv_odd(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tint size = detect_sysv(sbi, bh);\n\n\treturn size>2 ? 0 : size;\n}"
  },
  {
    "function_name": "detect_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "252-263",
    "snippet": "static int detect_coherent(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct coh_super_block * sbd;\n\n\tsbd = (struct coh_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif ((memcmp(sbd->s_fname,\"noname\",6) && memcmp(sbd->s_fname,\"xxxxx \",6))\n\t    || (memcmp(sbd->s_fpack,\"nopack\",6) && memcmp(sbd->s_fpack,\"xxxxx\\n\",6)))\n\t\treturn 0;\n\tsbi->s_bytesex = BYTESEX_PDP;\n\tsbi->s_type = FSTYPE_COH;\n\treturn 1;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sbd->s_fpack",
            "\"xxxxx\\n\"",
            "6"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sbd->s_fpack",
            "\"nopack\"",
            "6"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sbd->s_fname",
            "\"xxxxx \"",
            "6"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sbd->s_fname",
            "\"noname\"",
            "6"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int detect_coherent(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct coh_super_block * sbd;\n\n\tsbd = (struct coh_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif ((memcmp(sbd->s_fname,\"noname\",6) && memcmp(sbd->s_fname,\"xxxxx \",6))\n\t    || (memcmp(sbd->s_fpack,\"nopack\",6) && memcmp(sbd->s_fpack,\"xxxxx\\n\",6)))\n\t\treturn 0;\n\tsbi->s_bytesex = BYTESEX_PDP;\n\tsbi->s_type = FSTYPE_COH;\n\treturn 1;\n}"
  },
  {
    "function_name": "detect_sysv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "199-250",
    "snippet": "static int detect_sysv(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct super_block *sb = sbi->s_sb;\n\t/* All relevant fields are at the same offsets in R2 and R4 */\n\tstruct sysv4_super_block * sbd;\n\tu32 type;\n\n\tsbd = (struct sysv4_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\n\ttype = fs32_to_cpu(sbi, sbd->s_type);\n \n \tif (fs16_to_cpu(sbi, sbd->s_nfree) == 0xffff) {\n \t\tsbi->s_type = FSTYPE_AFS;\n\t\tsbi->s_forced_ro = 1;\n \t\tif (!(sb->s_flags & MS_RDONLY)) {\n \t\t\tprintk(\"SysV FS: SCO EAFS on %s detected, \" \n \t\t\t\t\"forcing read-only mode.\\n\", \n \t\t\t\tsb->s_id);\n \t\t}\n \t\treturn type;\n \t}\n \n\tif (fs32_to_cpu(sbi, sbd->s_time) < JAN_1_1980) {\n\t\t/* this is likely to happen on SystemV2 FS */\n\t\tif (type > 3 || type < 1)\n\t\t\treturn 0;\n\t\tsbi->s_type = FSTYPE_SYSV2;\n\t\treturn type;\n\t}\n\tif ((type > 3 || type < 1) && (type > 0x30 || type < 0x10))\n\t\treturn 0;\n\n\t/* On Interactive Unix (ISC) Version 4.0/3.x s_type field = 0x10,\n\t   0x20 or 0x30 indicates that symbolic links and the 14-character\n\t   filename limit is gone. Due to lack of information about this\n           feature read-only mode seems to be a reasonable approach... -KGB */\n\n\tif (type >= 0x10) {\n\t\tprintk(\"SysV FS: can't handle long file names on %s, \"\n\t\t       \"forcing read-only mode.\\n\", sb->s_id);\n\t\tsbi->s_forced_ro = 1;\n\t}\n\n\tsbi->s_type = FSTYPE_SYSV4;\n\treturn type >= 0x10 ? type >> 4 : type;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"SysV FS: can't handle long file names on %s, \"\n\t\t       \"forcing read-only mode.\\n\"",
            "sb->s_id"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_time"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd->s_nfree"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0xfd187e20"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0xfd187e20"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int detect_sysv(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct super_block *sb = sbi->s_sb;\n\t/* All relevant fields are at the same offsets in R2 and R4 */\n\tstruct sysv4_super_block * sbd;\n\tu32 type;\n\n\tsbd = (struct sysv4_super_block *) (bh->b_data + BLOCK_SIZE/2);\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0xfd187e20))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\n\ttype = fs32_to_cpu(sbi, sbd->s_type);\n \n \tif (fs16_to_cpu(sbi, sbd->s_nfree) == 0xffff) {\n \t\tsbi->s_type = FSTYPE_AFS;\n\t\tsbi->s_forced_ro = 1;\n \t\tif (!(sb->s_flags & MS_RDONLY)) {\n \t\t\tprintk(\"SysV FS: SCO EAFS on %s detected, \" \n \t\t\t\t\"forcing read-only mode.\\n\", \n \t\t\t\tsb->s_id);\n \t\t}\n \t\treturn type;\n \t}\n \n\tif (fs32_to_cpu(sbi, sbd->s_time) < JAN_1_1980) {\n\t\t/* this is likely to happen on SystemV2 FS */\n\t\tif (type > 3 || type < 1)\n\t\t\treturn 0;\n\t\tsbi->s_type = FSTYPE_SYSV2;\n\t\treturn type;\n\t}\n\tif ((type > 3 || type < 1) && (type > 0x30 || type < 0x10))\n\t\treturn 0;\n\n\t/* On Interactive Unix (ISC) Version 4.0/3.x s_type field = 0x10,\n\t   0x20 or 0x30 indicates that symbolic links and the 14-character\n\t   filename limit is gone. Due to lack of information about this\n           feature read-only mode seems to be a reasonable approach... -KGB */\n\n\tif (type >= 0x10) {\n\t\tprintk(\"SysV FS: can't handle long file names on %s, \"\n\t\t       \"forcing read-only mode.\\n\", sb->s_id);\n\t\tsbi->s_forced_ro = 1;\n\t}\n\n\tsbi->s_type = FSTYPE_SYSV4;\n\treturn type >= 0x10 ? type >> 4 : type;\n}"
  },
  {
    "function_name": "detect_xenix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "178-197",
    "snippet": "static int detect_xenix(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct xenix_super_block *sbd = (struct xenix_super_block *)bh->b_data;\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\tswitch (fs32_to_cpu(sbi, sbd->s_type)) {\n\tcase 1:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 1;\n\tcase 2:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_type"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0x2b5544"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0x2b5544"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int detect_xenix(struct sysv_sb_info *sbi, struct buffer_head *bh)\n{\n\tstruct xenix_super_block *sbd = (struct xenix_super_block *)bh->b_data;\n\tif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_LE;\n\telse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0x2b5544))\n\t\tsbi->s_bytesex = BYTESEX_BE;\n\telse\n\t\treturn 0;\n\tswitch (fs32_to_cpu(sbi, sbd->s_type)) {\n\tcase 1:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 1;\n\tcase 2:\n\t\tsbi->s_type = FSTYPE_XENIX;\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "detected_v7",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "157-176",
    "snippet": "static void detected_v7(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct v7_super_block *sbd = (struct v7_super_block *)bh2->b_data;\n\n\t*max_links = V7_LINK_MAX;\n\tsbi->s_fic_size = V7_NICINOD;\n\tsbi->s_flc_size = V7_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_fsize"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd->s_isize"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void detected_v7(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct v7_super_block *sbd = (struct v7_super_block *)bh2->b_data;\n\n\t*max_links = V7_LINK_MAX;\n\tsbi->s_fic_size = V7_NICINOD;\n\tsbi->s_flc_size = V7_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}"
  },
  {
    "function_name": "detected_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "134-155",
    "snippet": "static void detected_coherent(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct coh_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\n\tsbd = (struct coh_super_block *) bh1->b_data;\n\n\t*max_links = COH_LINK_MAX;\n\tsbi->s_fic_size = COH_NICINOD;\n\tsbi->s_flc_size = COH_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_fsize"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd->s_isize"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void detected_coherent(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct coh_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\n\tsbd = (struct coh_super_block *) bh1->b_data;\n\n\t*max_links = COH_LINK_MAX;\n\tsbi->s_fic_size = COH_NICINOD;\n\tsbi->s_flc_size = COH_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}"
  },
  {
    "function_name": "detected_sysv2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "106-132",
    "snippet": "static void detected_sysv2(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv2_super_block *sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv2_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv2_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_fsize"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd->s_isize"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void detected_sysv2(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv2_super_block *sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv2_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv2_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}"
  },
  {
    "function_name": "detected_sysv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "78-104",
    "snippet": "static void detected_sysv4(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv4_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv4_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv4_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd->s_fsize"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd->s_isize"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void detected_sysv4(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct sysv4_super_block * sbd;\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\n\tif (bh1 == bh2)\n\t\tsbd = (struct sysv4_super_block *) (bh1->b_data + BLOCK_SIZE/2);\n\telse\n\t\tsbd = (struct sysv4_super_block *) bh2->b_data;\n\n\t*max_links = SYSV_LINK_MAX;\n\tsbi->s_fic_size = SYSV_NICINOD;\n\tsbi->s_flc_size = SYSV_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd;\n\tsbi->s_sbd2 = (char *)sbd;\n\tsbi->s_sb_fic_count = &sbd->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd->s_tinode;\n\tsbi->s_bcache_count = &sbd->s_nfree;\n\tsbi->s_bcache = &sbd->s_free[0];\n\tsbi->s_free_blocks = &sbd->s_tfree;\n\tsbi->s_sb_time = &sbd->s_time;\n\tsbi->s_sb_state = &sbd->s_state;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\n}"
  },
  {
    "function_name": "detected_xenix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/super.c",
    "lines": "47-76",
    "snippet": "static void detected_xenix(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct xenix_super_block * sbd1;\n\tstruct xenix_super_block * sbd2;\n\n\tif (bh1 != bh2)\n\t\tsbd1 = sbd2 = (struct xenix_super_block *) bh1->b_data;\n\telse {\n\t\t/* block size = 512, so bh1 != bh2 */\n\t\tsbd1 = (struct xenix_super_block *) bh1->b_data;\n\t\tsbd2 = (struct xenix_super_block *) (bh2->b_data - 512);\n\t}\n\n\t*max_links = XENIX_LINK_MAX;\n\tsbi->s_fic_size = XENIX_NICINOD;\n\tsbi->s_flc_size = XENIX_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd1;\n\tsbi->s_sbd2 = (char *)sbd2;\n\tsbi->s_sb_fic_count = &sbd1->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd1->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd2->s_tinode;\n\tsbi->s_bcache_count = &sbd1->s_nfree;\n\tsbi->s_bcache = &sbd1->s_free[0];\n\tsbi->s_free_blocks = &sbd2->s_tfree;\n\tsbi->s_sb_time = &sbd2->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd1->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd1->s_fsize);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sbi",
            "sbd1->s_fsize"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "191-199",
          "snippet": "static inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u32 fs32_to_cpu(struct sysv_sb_info *sbi, __fs32 n)\n{\n\tif (sbi->s_bytesex == BYTESEX_PDP)\n\t\treturn PDP_swab((__force __u32)n);\n\telse if (sbi->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs16_to_cpu",
          "args": [
            "sbi",
            "sbd1->s_isize"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/sysv.h",
          "lines": "222-228",
          "snippet": "static inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}",
          "includes": [
            "#include <linux/sysv_fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysv_fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline __u16 fs16_to_cpu(struct sysv_sb_info *sbi, __fs16 n)\n{\n\tif (sbi->s_bytesex != BYTESEX_BE)\n\t\treturn le16_to_cpu((__force __le16)n);\n\telse\n\t\treturn be16_to_cpu((__force __be16)n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void detected_xenix(struct sysv_sb_info *sbi, unsigned *max_links)\n{\n\tstruct buffer_head *bh1 = sbi->s_bh1;\n\tstruct buffer_head *bh2 = sbi->s_bh2;\n\tstruct xenix_super_block * sbd1;\n\tstruct xenix_super_block * sbd2;\n\n\tif (bh1 != bh2)\n\t\tsbd1 = sbd2 = (struct xenix_super_block *) bh1->b_data;\n\telse {\n\t\t/* block size = 512, so bh1 != bh2 */\n\t\tsbd1 = (struct xenix_super_block *) bh1->b_data;\n\t\tsbd2 = (struct xenix_super_block *) (bh2->b_data - 512);\n\t}\n\n\t*max_links = XENIX_LINK_MAX;\n\tsbi->s_fic_size = XENIX_NICINOD;\n\tsbi->s_flc_size = XENIX_NICFREE;\n\tsbi->s_sbd1 = (char *)sbd1;\n\tsbi->s_sbd2 = (char *)sbd2;\n\tsbi->s_sb_fic_count = &sbd1->s_ninode;\n\tsbi->s_sb_fic_inodes = &sbd1->s_inode[0];\n\tsbi->s_sb_total_free_inodes = &sbd2->s_tinode;\n\tsbi->s_bcache_count = &sbd1->s_nfree;\n\tsbi->s_bcache = &sbd1->s_free[0];\n\tsbi->s_free_blocks = &sbd2->s_tfree;\n\tsbi->s_sb_time = &sbd2->s_time;\n\tsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd1->s_isize);\n\tsbi->s_nzones = fs32_to_cpu(sbi, sbd1->s_fsize);\n}"
  }
]