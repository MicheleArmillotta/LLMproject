[
  {
    "function_name": "nfs3_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "279-296",
    "snippet": "ssize_t\nnfs3_listxattr(struct dentry *dentry, char *data, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tssize_t result = 0;\n\tint error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,\n\t\t\tPOSIX_ACL_XATTR_ACCESS, data, size, &result);\n\tif (error)\n\t\treturn error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,\n\t\t\tPOSIX_ACL_XATTR_DEFAULT, data, size, &result);\n\tif (error)\n\t\treturn error;\n\treturn result;\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs3_list_one_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT",
            "POSIX_ACL_XATTR_DEFAULT",
            "data",
            "size",
            "&result"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3_list_one_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
          "lines": "255-277",
          "snippet": "static int\nnfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tstruct posix_acl *acl;\n\tchar *p = data + *result;\n\n\tacl = get_acl(inode, type);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn 0;\n\n\tposix_acl_release(acl);\n\n\t*result += strlen(name);\n\t*result += 1;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs3_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/nfsacl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int\nnfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tstruct posix_acl *acl;\n\tchar *p = data + *result;\n\n\tacl = get_acl(inode, type);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn 0;\n\n\tposix_acl_release(acl);\n\n\t*result += strlen(name);\n\t*result += 1;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nssize_t\nnfs3_listxattr(struct dentry *dentry, char *data, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tssize_t result = 0;\n\tint error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,\n\t\t\tPOSIX_ACL_XATTR_ACCESS, data, size, &result);\n\tif (error)\n\t\treturn error;\n\n\terror = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,\n\t\t\tPOSIX_ACL_XATTR_DEFAULT, data, size, &result);\n\tif (error)\n\t\treturn error;\n\treturn result;\n}"
  },
  {
    "function_name": "nfs3_list_one_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "255-277",
    "snippet": "static int\nnfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tstruct posix_acl *acl;\n\tchar *p = data + *result;\n\n\tacl = get_acl(inode, type);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn 0;\n\n\tposix_acl_release(acl);\n\n\t*result += strlen(name);\n\t*result += 1;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "name"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "acl"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "type"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
          "lines": "14-115",
          "snippet": "struct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}",
          "includes": [
            "#include \"nfs3_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/nfsacl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstruct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int\nnfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,\n\t\tsize_t size, ssize_t *result)\n{\n\tstruct posix_acl *acl;\n\tchar *p = data + *result;\n\n\tacl = get_acl(inode, type);\n\tif (IS_ERR_OR_NULL(acl))\n\t\treturn 0;\n\n\tposix_acl_release(acl);\n\n\t*result += strlen(name);\n\t*result += 1;\n\tif (!size)\n\t\treturn 0;\n\tif (*result > size)\n\t\treturn -ERANGE;\n\n\tstrcpy(p, name);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs3_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "214-247",
    "snippet": "int nfs3_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct posix_acl *alloc = NULL, *dfacl = NULL;\n\tint status;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\talloc = dfacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tdfacl = acl;\n\t\t\talloc = acl = get_acl(inode, ACL_TYPE_ACCESS);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (acl == NULL) {\n\t\talloc = acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\tif (IS_ERR(alloc))\n\t\t\tgoto fail;\n\t}\n\tstatus = __nfs3_proc_setacls(inode, acl, dfacl);\n\tposix_acl_release(alloc);\n\treturn status;\n\nfail:\n\treturn PTR_ERR(alloc);\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "alloc"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "alloc"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs3_proc_setacls",
          "args": [
            "inode",
            "acl",
            "dfacl"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs3_proc_setacls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
          "lines": "117-203",
          "snippet": "static int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfs3_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/nfsacl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alloc"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_mode",
          "args": [
            "inode->i_mode",
            "GFP_KERNEL"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "288-304",
          "snippet": "struct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_mode(umode_t mode, gfp_t flags)\n{\n\tstruct posix_acl *acl = posix_acl_alloc(3, flags);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tacl->a_entries[0].e_tag  = ACL_USER_OBJ;\n\tacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\n\n\tacl->a_entries[1].e_tag  = ACL_GROUP_OBJ;\n\tacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\n\n\tacl->a_entries[2].e_tag  = ACL_OTHER;\n\tacl->a_entries[2].e_perm = (mode & S_IRWXO);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alloc"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
          "lines": "14-115",
          "snippet": "struct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}",
          "includes": [
            "#include \"nfs3_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/nfsacl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstruct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alloc"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nint nfs3_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct posix_acl *alloc = NULL, *dfacl = NULL;\n\tint status;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\talloc = dfacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tdfacl = acl;\n\t\t\talloc = acl = get_acl(inode, ACL_TYPE_ACCESS);\n\t\t\tif (IS_ERR(alloc))\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (acl == NULL) {\n\t\talloc = acl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\tif (IS_ERR(alloc))\n\t\t\tgoto fail;\n\t}\n\tstatus = __nfs3_proc_setacls(inode, acl, dfacl);\n\tposix_acl_release(alloc);\n\treturn status;\n\nfail:\n\treturn PTR_ERR(alloc);\n}"
  },
  {
    "function_name": "nfs3_proc_setacls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "205-212",
    "snippet": "int nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tint ret;\n\tret = __nfs3_proc_setacls(inode, acl, dfacl);\n\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs3_proc_setacls",
          "args": [
            "inode",
            "acl",
            "dfacl"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs3_proc_setacls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
          "lines": "117-203",
          "snippet": "static int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfs3_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/nfsacl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nint nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tint ret;\n\tret = __nfs3_proc_setacls(inode, acl, dfacl);\n\treturn (ret == -EOPNOTSUPP) ? 0 : ret;\n\n}"
  },
  {
    "function_name": "__nfs3_proc_setacls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "117-203",
    "snippet": "static int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "args.pages[args.npages]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT",
            "dfacl"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_refresh_inode",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1466-1477",
          "snippet": "int nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS reply setacl: %d\\n\"",
            "status"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_zap_acl_cache",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_acl_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "206-216",
          "snippet": "void nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_acl_cache(struct inode *inode)\n{\n\tvoid (*clear_acl_cache)(struct inode *);\n\n\tclear_acl_cache = NFS_PROTO(inode)->clear_acl_cache;\n\tif (clear_acl_cache != NULL)\n\t\tclear_acl_cache(inode);\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity &= ~NFS_INO_INVALID_ACL;\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_access_zap_cache",
          "args": [
            "inode"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_zap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2200-2216",
          "snippet": "void nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs_access_lru_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\n\nvoid nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_call_sync",
          "args": [
            "server->client_acl",
            "&msg",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS call setacl\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsacl_size",
          "args": [
            "acl",
            "NULL"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsacl_size",
          "args": [
            "acl",
            "dfacl"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "inode",
            "NFS_CAP_ACLS"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstatic int __nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,\n\t\tstruct posix_acl *dfacl)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr *fattr;\n\tstruct page *pages[NFSACL_MAXPAGES];\n\tstruct nfs3_setaclargs args = {\n\t\t.inode = inode,\n\t\t.mask = NFS_ACL,\n\t\t.acl_access = acl,\n\t\t.pages = pages,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &fattr,\n\t};\n\tint status = 0;\n\n\tif (acl == NULL && (!S_ISDIR(inode->i_mode) || dfacl == NULL))\n\t\tgoto out;\n\n\tstatus = -EOPNOTSUPP;\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\tgoto out;\n\n\t/* We are doing this here because XDR marshalling does not\n\t * return any results, it BUGs. */\n\tstatus = -ENOSPC;\n\tif (acl != NULL && acl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (dfacl != NULL && dfacl->a_count > NFS_ACL_MAX_ENTRIES)\n\t\tgoto out;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\targs.mask |= NFS_DFACL;\n\t\targs.acl_default = dfacl;\n\t\targs.len = nfsacl_size(acl, dfacl);\n\t} else\n\t\targs.len = nfsacl_size(acl, NULL);\n\n\tif (args.len > NFS_ACL_INLINE_BUFSIZE) {\n\t\tunsigned int npages = 1 + ((args.len - 1) >> PAGE_SHIFT);\n\n\t\tstatus = -ENOMEM;\n\t\tdo {\n\t\t\targs.pages[args.npages] = alloc_page(GFP_KERNEL);\n\t\t\tif (args.pages[args.npages] == NULL)\n\t\t\t\tgoto out_freepages;\n\t\t\targs.npages++;\n\t\t} while (args.npages < npages);\n\t}\n\n\tdprintk(\"NFS call setacl\\n\");\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out_freepages;\n\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_SETACL];\n\tmsg.rpc_resp = fattr;\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\tdprintk(\"NFS reply setacl: %d\\n\", status);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, fattr);\n\t\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dfacl);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL SETACL RPC not supported\"\n\t\t\t\t\t\"(will not retry)\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t}\n\tnfs_free_fattr(fattr);\nout_freepages:\n\twhile (args.npages != 0) {\n\t\targs.npages--;\n\t\t__free_page(args.pages[args.npages]);\n\t}\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs3_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs3acl.c",
    "lines": "14-115",
    "snippet": "struct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}",
    "includes": [
      "#include \"nfs3_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/nfsacl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs3.h>",
      "#include <linux/nfs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "res.fattr"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "res.acl_default"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "res.acl_access"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "res.acl_access"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "res.acl_default"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "res.fattr"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forget_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "forget_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "71-81",
          "snippet": "void forget_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\t*p = ACL_NOT_CACHED;\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid forget_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\t*p = ACL_NOT_CACHED;\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT",
            "res.acl_default"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "res.acl_access"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "res.acl_access",
            "NULL"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS_V3_ACL extension not supported; disabling\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_refresh_inode",
          "args": [
            "inode",
            "res.fattr"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1466-1477",
          "snippet": "int nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "args.pages[count]"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS reply getacl: %d\\n\"",
            "status"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_call_sync",
          "args": [
            "server->client_acl",
            "&msg",
            "0"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS call getacl\\n\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_inode",
          "args": [
            "server",
            "inode"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_inode_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1022-1029",
          "snippet": "int nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "inode",
            "NFS_CAP_ACLS"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "inode"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs3_fs.h\"\n#include \"internal.h\"\n#include <linux/nfsacl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n\nstruct posix_acl *nfs3_get_acl(struct inode *inode, int type)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFSACL_MAXPAGES] = { };\n\tstruct nfs3_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t/* The xdr layer may allocate pages here. */\n\t\t.pages = pages,\n\t};\n\tstruct nfs3_getaclres res = {\n\t\tNULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status, count;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_ACLS))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tstatus = nfs_revalidate_inode(server, inode);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\n\t/*\n\t * Only get the access acl when explicitly requested: We don't\n\t * need it for access decisions, and only some applications use\n\t * it. Applications which request the access acl first are not\n\t * penalized from this optimization.\n\t */\n\tif (type == ACL_TYPE_ACCESS)\n\t\targs.mask |= NFS_ACLCNT|NFS_ACL;\n\tif (S_ISDIR(inode->i_mode))\n\t\targs.mask |= NFS_DFACLCNT|NFS_DFACL;\n\tif (args.mask == 0)\n\t\treturn NULL;\n\n\tdprintk(\"NFS call getacl\\n\");\n\tmsg.rpc_proc = &server->client_acl->cl_procinfo[ACLPROC3_GETACL];\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = rpc_call_sync(server->client_acl, &msg, 0);\n\tdprintk(\"NFS reply getacl: %d\\n\", status);\n\n\t/* pages may have been allocated at the xdr layer. */\n\tfor (count = 0; count < NFSACL_MAXPAGES && args.pages[count]; count++)\n\t\t__free_page(args.pages[count]);\n\n\tswitch (status) {\n\t\tcase 0:\n\t\t\tstatus = nfs_refresh_inode(inode, res.fattr);\n\t\t\tbreak;\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tdprintk(\"NFS_V3_ACL extension not supported; disabling\\n\");\n\t\t\tserver->caps &= ~NFS_CAP_ACLS;\n\t\tcase -ENOTSUPP:\n\t\t\tstatus = -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tgoto getout;\n\t}\n\tif ((args.mask & res.mask) != args.mask) {\n\t\tstatus = -EIO;\n\t\tgoto getout;\n\t}\n\n\tif (res.acl_access != NULL) {\n\t\tif ((posix_acl_equiv_mode(res.acl_access, NULL) == 0) ||\n\t\t    res.acl_access->a_count == 0) {\n\t\t\tposix_acl_release(res.acl_access);\n\t\t\tres.acl_access = NULL;\n\t\t}\n\t}\n\n\tif (res.mask & NFS_ACL)\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, res.acl_access);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_ACCESS);\n\n\tif (res.mask & NFS_DFACL)\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, res.acl_default);\n\telse\n\t\tforget_cached_acl(inode, ACL_TYPE_DEFAULT);\n\n\tnfs_free_fattr(res.fattr);\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tposix_acl_release(res.acl_default);\n\t\treturn res.acl_access;\n\t} else {\n\t\tposix_acl_release(res.acl_access);\n\t\treturn res.acl_default;\n\t}\n\ngetout:\n\tposix_acl_release(res.acl_access);\n\tposix_acl_release(res.acl_default);\n\tnfs_free_fattr(res.fattr);\n\treturn ERR_PTR(status);\n}"
  }
]