[
  {
    "function_name": "btrfs_test_free_space_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "879-909",
    "snippet": "int btrfs_test_free_space_cache(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tint ret;\n\n\ttest_msg(\"Running btrfs free space cache tests\\n\");\n\n\tcache = init_test_block_group();\n\tif (!cache) {\n\t\ttest_msg(\"Couldn't run the tests\\n\");\n\t\treturn 0;\n\t}\n\n\tret = test_extents(cache);\n\tif (ret)\n\t\tgoto out;\n\tret = test_bitmaps(cache);\n\tif (ret)\n\t\tgoto out;\n\tret = test_bitmaps_and_extents(cache);\n\tif (ret)\n\t\tgoto out;\n\n\tret = test_steal_space_from_bitmap_to_extent(cache);\nout:\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tkfree(cache->free_space_ctl);\n\tkfree(cache);\n\ttest_msg(\"Free space cache tests finished\\n\");\n\treturn ret;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Free space cache tests finished\\n\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_steal_space_from_bitmap_to_extent",
          "args": [
            "cache"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "test_steal_space_from_bitmap_to_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "435-877",
          "snippet": "static int\ntest_steal_space_from_bitmap_to_extent(struct btrfs_block_group_cache *cache)\n{\n\tint ret;\n\tu64 offset;\n\tu64 max_extent_size;\n\n\tbool (*use_bitmap_op)(struct btrfs_free_space_ctl *,\n\t\t\t      struct btrfs_free_space *);\n\n\ttest_msg(\"Running space stealing from bitmap to extent\\n\");\n\n\t/*\n\t * For this test, we want to ensure we end up with an extent entry\n\t * immediately adjacent to a bitmap entry, where the bitmap starts\n\t * at an offset where the extent entry ends. We keep adding and\n\t * removing free space to reach into this state, but to get there\n\t * we need to reach a point where marking new free space doesn't\n\t * result in adding new extent entries or merging the new space\n\t * with existing extent entries - the space ends up being marked\n\t * in an existing bitmap that covers the new free space range.\n\t *\n\t * To get there, we need to reach the threshold defined set at\n\t * cache->free_space_ctl->extents_thresh, which currently is\n\t * 256 extents on a x86_64 system at least, and a few other\n\t * conditions (check free_space_cache.c). Instead of making the\n\t * test much longer and complicated, use a \"use_bitmap\" operation\n\t * that forces use of bitmaps as soon as we have at least 1\n\t * extent entry.\n\t */\n\tuse_bitmap_op = cache->free_space_ctl->op->use_bitmap;\n\tcache->free_space_ctl->op->use_bitmap = test_use_bitmap;\n\n\t/*\n\t * Extent entry covering free space range [128Mb - 256Kb, 128Mb - 128Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [128Mb + 512Kb, 256Mb[ */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the first 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb - 256Kb, 128Mb - 128Kb[\n\t * [128Mb + 512Kb, 128Mb + 768Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      128 * 1024 * 1024 + 768 * 1024,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [128Mb + 768Kb, 256Mb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 768 * 1024,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb + 256Kb, 128Mb + 512Kb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 256 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb, 128Mb + 256Kb[, which is covered\n\t * by the bitmap too, isn't marked as free either.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb, 128Mb + 512Kb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the right of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 + 16 * 1024 * 1024,\n\t\t\t\t   4096);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now mark the region [128Mb - 128Kb, 128Mb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb - 256Kb, 128Mb - 128Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t\t   128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 4Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 256Kb, 128Mb + 768Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb - 256Kb, 128Mb[\n\t * bitmap entry covering range: [128Mb, 128Mb + 768Kb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 4096)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 256 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 4Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 4096) {\n\t\ttest_msg(\"Cache free space is not 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 + 16 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 4Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * Now test a similar scenario, but where our extent entry is located\n\t * to the right of the bitmap entry, so that we can check that stealing\n\t * space from a bitmap to the front of an extent entry works.\n\t */\n\n\t/*\n\t * Extent entry covering free space range [128Mb + 128Kb, 128Mb + 256Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [0, 128Mb - 512Kb[ */\n\tret = test_add_free_space_entry(cache, 0,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the last 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb + 128b, 128Mb + 256Kb[\n\t * [128Mb - 768Kb, 128Mb - 512Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      0,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [0, 128Mb - 768Kb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 0,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb - 512Kb, 128Mb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t      512 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb - 512Kb, 128Mb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t\t   512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t       512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the left of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 32 * 1024 * 1024, 8192);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now mark the region [128Mb, 128Mb + 128Kb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb + 128Kb, 128Mb + 256Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 8Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 768Kb, 128Mb + 256Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb, 128Mb + 256Kb[\n\t * bitmap entry covering range: [128Mb - 768Kb, 128Mb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 8192)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 8Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 8192) {\n\t\ttest_msg(\"Cache free space is not 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 8192, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (32 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 8Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\tcache->free_space_ctl->op->use_bitmap = use_bitmap_op;\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int\ntest_steal_space_from_bitmap_to_extent(struct btrfs_block_group_cache *cache)\n{\n\tint ret;\n\tu64 offset;\n\tu64 max_extent_size;\n\n\tbool (*use_bitmap_op)(struct btrfs_free_space_ctl *,\n\t\t\t      struct btrfs_free_space *);\n\n\ttest_msg(\"Running space stealing from bitmap to extent\\n\");\n\n\t/*\n\t * For this test, we want to ensure we end up with an extent entry\n\t * immediately adjacent to a bitmap entry, where the bitmap starts\n\t * at an offset where the extent entry ends. We keep adding and\n\t * removing free space to reach into this state, but to get there\n\t * we need to reach a point where marking new free space doesn't\n\t * result in adding new extent entries or merging the new space\n\t * with existing extent entries - the space ends up being marked\n\t * in an existing bitmap that covers the new free space range.\n\t *\n\t * To get there, we need to reach the threshold defined set at\n\t * cache->free_space_ctl->extents_thresh, which currently is\n\t * 256 extents on a x86_64 system at least, and a few other\n\t * conditions (check free_space_cache.c). Instead of making the\n\t * test much longer and complicated, use a \"use_bitmap\" operation\n\t * that forces use of bitmaps as soon as we have at least 1\n\t * extent entry.\n\t */\n\tuse_bitmap_op = cache->free_space_ctl->op->use_bitmap;\n\tcache->free_space_ctl->op->use_bitmap = test_use_bitmap;\n\n\t/*\n\t * Extent entry covering free space range [128Mb - 256Kb, 128Mb - 128Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [128Mb + 512Kb, 256Mb[ */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the first 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb - 256Kb, 128Mb - 128Kb[\n\t * [128Mb + 512Kb, 128Mb + 768Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      128 * 1024 * 1024 + 768 * 1024,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [128Mb + 768Kb, 256Mb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 768 * 1024,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb + 256Kb, 128Mb + 512Kb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 256 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb, 128Mb + 256Kb[, which is covered\n\t * by the bitmap too, isn't marked as free either.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb, 128Mb + 512Kb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the right of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 + 16 * 1024 * 1024,\n\t\t\t\t   4096);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now mark the region [128Mb - 128Kb, 128Mb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb - 256Kb, 128Mb - 128Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t\t   128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 4Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 256Kb, 128Mb + 768Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb - 256Kb, 128Mb[\n\t * bitmap entry covering range: [128Mb, 128Mb + 768Kb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 4096)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 256 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 4Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 4096) {\n\t\ttest_msg(\"Cache free space is not 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 + 16 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 4Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * Now test a similar scenario, but where our extent entry is located\n\t * to the right of the bitmap entry, so that we can check that stealing\n\t * space from a bitmap to the front of an extent entry works.\n\t */\n\n\t/*\n\t * Extent entry covering free space range [128Mb + 128Kb, 128Mb + 256Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [0, 128Mb - 512Kb[ */\n\tret = test_add_free_space_entry(cache, 0,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the last 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb + 128b, 128Mb + 256Kb[\n\t * [128Mb - 768Kb, 128Mb - 512Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      0,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [0, 128Mb - 768Kb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 0,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb - 512Kb, 128Mb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t      512 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb - 512Kb, 128Mb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t\t   512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t       512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the left of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 32 * 1024 * 1024, 8192);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now mark the region [128Mb, 128Mb + 128Kb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb + 128Kb, 128Mb + 256Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 8Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 768Kb, 128Mb + 256Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb, 128Mb + 256Kb[\n\t * bitmap entry covering range: [128Mb - 768Kb, 128Mb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 8192)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 8Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 8192) {\n\t\ttest_msg(\"Cache free space is not 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 8192, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (32 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 8Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\tcache->free_space_ctl->op->use_bitmap = use_bitmap_op;\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bitmaps_and_extents",
          "args": [
            "cache"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "test_bitmaps_and_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "200-366",
          "snippet": "static int test_bitmaps_and_extents(struct btrfs_block_group_cache *cache)\n{\n\tu64 bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\tint ret;\n\n\ttest_msg(\"Running bitmap and extent tests\\n\");\n\n\t/*\n\t * First let's do something simple, an extent at the same offset as the\n\t * bitmap, but the free space completely in the extent and then\n\t * completely in the bitmap.\n\t */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 1 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants after our remove\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Now to add back the extent entry and remove from the bitmap */\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't re-add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 4 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove from bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 4 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants in the bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ok so a little more evil, extent entry and bitmap at the same offset,\n\t * removing an overlapping chunk.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to a bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 512 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 512 * 1024, 3 * 1024 * 1024)) {\n\t\ttest_msg(\"Left over pieces after removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/* Now with the extent entry offset into the bitmap */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to the bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 2 * 1024 * 1024, 2 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent to the cache %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Problem removing overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left something behind when removing space\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * This has blown up in the past, the extent entry starts before the\n\t * bitmap entry, but we're trying to remove an offset that falls\n\t * completely within the bitmap range and is in both the extent entry\n\t * and the bitmap entry, looks like this\n\t *\n\t *   [ extent ]\n\t *      [ bitmap ]\n\t *        [ del ]\n\t */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tret = test_add_free_space_entry(cache, bitmap_offset + 4 * 1024 * 1024,\n\t\t\t\t   4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, bitmap_offset - 1 * 1024 * 1024,\n\t\t\t\t   5 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t\t      5 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free our space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t 5 * 1024 * 1024)) {\n\t\ttest_msg(\"Left stuff over\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * This blew up before, we have part of the free space in a bitmap and\n\t * then the entirety of the rest of the space in an extent.  This used\n\t * to return -EAGAIN back from btrfs_remove_extent, make sure this\n\t * doesn't happen.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 2 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 3 * 1024 * 1024, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap and extent overlapping %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\treturn 0;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int test_bitmaps_and_extents(struct btrfs_block_group_cache *cache)\n{\n\tu64 bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\tint ret;\n\n\ttest_msg(\"Running bitmap and extent tests\\n\");\n\n\t/*\n\t * First let's do something simple, an extent at the same offset as the\n\t * bitmap, but the free space completely in the extent and then\n\t * completely in the bitmap.\n\t */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 1 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants after our remove\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Now to add back the extent entry and remove from the bitmap */\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't re-add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 4 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove from bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 4 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants in the bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ok so a little more evil, extent entry and bitmap at the same offset,\n\t * removing an overlapping chunk.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to a bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 512 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 512 * 1024, 3 * 1024 * 1024)) {\n\t\ttest_msg(\"Left over pieces after removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/* Now with the extent entry offset into the bitmap */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to the bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 2 * 1024 * 1024, 2 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent to the cache %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Problem removing overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left something behind when removing space\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * This has blown up in the past, the extent entry starts before the\n\t * bitmap entry, but we're trying to remove an offset that falls\n\t * completely within the bitmap range and is in both the extent entry\n\t * and the bitmap entry, looks like this\n\t *\n\t *   [ extent ]\n\t *      [ bitmap ]\n\t *        [ del ]\n\t */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tret = test_add_free_space_entry(cache, bitmap_offset + 4 * 1024 * 1024,\n\t\t\t\t   4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, bitmap_offset - 1 * 1024 * 1024,\n\t\t\t\t   5 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t\t      5 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free our space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t 5 * 1024 * 1024)) {\n\t\ttest_msg(\"Left stuff over\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * This blew up before, we have part of the free space in a bitmap and\n\t * then the entirety of the rest of the space in an extent.  This used\n\t * to return -EAGAIN back from btrfs_remove_extent, make sure this\n\t * doesn't happen.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 2 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 3 * 1024 * 1024, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap and extent overlapping %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_extents",
          "args": [
            "cache"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "test_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "60-128",
          "snippet": "static int test_extents(struct btrfs_block_group_cache *cache)\n{\n\tint ret = 0;\n\n\ttest_msg(\"Running extent only tests\\n\");\n\n\t/* First just make sure we can remove an entire entry */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding initial extents %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Full remove left some lingering space\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Ok edge and middle cases now */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding half extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing tail end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing front end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 2 * 1024 * 1024, 4096);\n\tif (ret) {\n\t\ttest_msg(\"Error removing middle piece %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the front\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 2 * 1024 * 1024, 4096)) {\n\t\ttest_msg(\"Still have space in the middle\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the end\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Cleanup */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int test_extents(struct btrfs_block_group_cache *cache)\n{\n\tint ret = 0;\n\n\ttest_msg(\"Running extent only tests\\n\");\n\n\t/* First just make sure we can remove an entire entry */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding initial extents %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Full remove left some lingering space\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Ok edge and middle cases now */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding half extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing tail end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing front end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 2 * 1024 * 1024, 4096);\n\tif (ret) {\n\t\ttest_msg(\"Error removing middle piece %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the front\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 2 * 1024 * 1024, 4096)) {\n\t\ttest_msg(\"Still have space in the middle\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the end\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Cleanup */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't run the tests\\n\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_test_block_group",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "init_test_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "25-53",
          "snippet": "static struct btrfs_block_group_cache *init_test_block_group(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->key.objectid = 0;\n\tcache->key.offset = 1024 * 1024 * 1024;\n\tcache->key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tcache->sectorsize = 4096;\n\tcache->full_stripe_len = 4096;\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\n\tbtrfs_init_free_space_ctl(cache);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_block_group_cache *init_test_block_group(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->key.objectid = 0;\n\tcache->key.offset = 1024 * 1024 * 1024;\n\tcache->key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tcache->sectorsize = 4096;\n\tcache->full_stripe_len = 4096;\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\n\tbtrfs_init_free_space_ctl(cache);\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running btrfs free space cache tests\\n\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nint btrfs_test_free_space_cache(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tint ret;\n\n\ttest_msg(\"Running btrfs free space cache tests\\n\");\n\n\tcache = init_test_block_group();\n\tif (!cache) {\n\t\ttest_msg(\"Couldn't run the tests\\n\");\n\t\treturn 0;\n\t}\n\n\tret = test_extents(cache);\n\tif (ret)\n\t\tgoto out;\n\tret = test_bitmaps(cache);\n\tif (ret)\n\t\tgoto out;\n\tret = test_bitmaps_and_extents(cache);\n\tif (ret)\n\t\tgoto out;\n\n\tret = test_steal_space_from_bitmap_to_extent(cache);\nout:\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tkfree(cache->free_space_ctl);\n\tkfree(cache);\n\ttest_msg(\"Free space cache tests finished\\n\");\n\treturn ret;\n}"
  },
  {
    "function_name": "test_steal_space_from_bitmap_to_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "435-877",
    "snippet": "static int\ntest_steal_space_from_bitmap_to_extent(struct btrfs_block_group_cache *cache)\n{\n\tint ret;\n\tu64 offset;\n\tu64 max_extent_size;\n\n\tbool (*use_bitmap_op)(struct btrfs_free_space_ctl *,\n\t\t\t      struct btrfs_free_space *);\n\n\ttest_msg(\"Running space stealing from bitmap to extent\\n\");\n\n\t/*\n\t * For this test, we want to ensure we end up with an extent entry\n\t * immediately adjacent to a bitmap entry, where the bitmap starts\n\t * at an offset where the extent entry ends. We keep adding and\n\t * removing free space to reach into this state, but to get there\n\t * we need to reach a point where marking new free space doesn't\n\t * result in adding new extent entries or merging the new space\n\t * with existing extent entries - the space ends up being marked\n\t * in an existing bitmap that covers the new free space range.\n\t *\n\t * To get there, we need to reach the threshold defined set at\n\t * cache->free_space_ctl->extents_thresh, which currently is\n\t * 256 extents on a x86_64 system at least, and a few other\n\t * conditions (check free_space_cache.c). Instead of making the\n\t * test much longer and complicated, use a \"use_bitmap\" operation\n\t * that forces use of bitmaps as soon as we have at least 1\n\t * extent entry.\n\t */\n\tuse_bitmap_op = cache->free_space_ctl->op->use_bitmap;\n\tcache->free_space_ctl->op->use_bitmap = test_use_bitmap;\n\n\t/*\n\t * Extent entry covering free space range [128Mb - 256Kb, 128Mb - 128Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [128Mb + 512Kb, 256Mb[ */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the first 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb - 256Kb, 128Mb - 128Kb[\n\t * [128Mb + 512Kb, 128Mb + 768Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      128 * 1024 * 1024 + 768 * 1024,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [128Mb + 768Kb, 256Mb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 768 * 1024,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb + 256Kb, 128Mb + 512Kb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 256 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb, 128Mb + 256Kb[, which is covered\n\t * by the bitmap too, isn't marked as free either.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb, 128Mb + 512Kb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the right of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 + 16 * 1024 * 1024,\n\t\t\t\t   4096);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now mark the region [128Mb - 128Kb, 128Mb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb - 256Kb, 128Mb - 128Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t\t   128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 4Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 256Kb, 128Mb + 768Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb - 256Kb, 128Mb[\n\t * bitmap entry covering range: [128Mb, 128Mb + 768Kb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 4096)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 256 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 4Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 4096) {\n\t\ttest_msg(\"Cache free space is not 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 + 16 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 4Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * Now test a similar scenario, but where our extent entry is located\n\t * to the right of the bitmap entry, so that we can check that stealing\n\t * space from a bitmap to the front of an extent entry works.\n\t */\n\n\t/*\n\t * Extent entry covering free space range [128Mb + 128Kb, 128Mb + 256Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [0, 128Mb - 512Kb[ */\n\tret = test_add_free_space_entry(cache, 0,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the last 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb + 128b, 128Mb + 256Kb[\n\t * [128Mb - 768Kb, 128Mb - 512Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      0,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [0, 128Mb - 768Kb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 0,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb - 512Kb, 128Mb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t      512 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb - 512Kb, 128Mb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t\t   512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t       512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the left of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 32 * 1024 * 1024, 8192);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now mark the region [128Mb, 128Mb + 128Kb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb + 128Kb, 128Mb + 256Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 8Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 768Kb, 128Mb + 256Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb, 128Mb + 256Kb[\n\t * bitmap entry covering range: [128Mb - 768Kb, 128Mb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 8192)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 8Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 8192) {\n\t\ttest_msg(\"Cache free space is not 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 8192, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (32 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 8Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\tcache->free_space_ctl->op->use_bitmap = use_bitmap_op;\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cache_empty",
          "args": [
            "cache"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "check_cache_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "395-420",
          "snippet": "static int check_cache_empty(struct btrfs_block_group_cache *cache)\n{\n\tu64 offset;\n\tu64 max_extent_size;\n\n\t/*\n\t * Now lets confirm that there's absolutely no free space left to\n\t * allocate.\n\t */\n\tif (cache->free_space_ctl->free_space != 0) {\n\t\ttest_msg(\"Cache free space is not 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And any allocation request, no matter how small, should fail now. */\n\toffset = btrfs_find_space_for_alloc(cache, 0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != 0) {\n\t\ttest_msg(\"Space allocation did not fail, returned offset: %llu\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* And no extent nor bitmap entries in the cache anymore. */\n\treturn check_num_extents_and_bitmaps(cache, 0, 0);\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int check_cache_empty(struct btrfs_block_group_cache *cache)\n{\n\tu64 offset;\n\tu64 max_extent_size;\n\n\t/*\n\t * Now lets confirm that there's absolutely no free space left to\n\t * allocate.\n\t */\n\tif (cache->free_space_ctl->free_space != 0) {\n\t\ttest_msg(\"Cache free space is not 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And any allocation request, no matter how small, should fail now. */\n\toffset = btrfs_find_space_for_alloc(cache, 0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != 0) {\n\t\ttest_msg(\"Space allocation did not fail, returned offset: %llu\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* And no extent nor bitmap entries in the cache anymore. */\n\treturn check_num_extents_and_bitmaps(cache, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate 8Kb from space cache, returned offset is: %llu\\n\"",
            "offset"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_space_for_alloc",
          "args": [
            "cache",
            "0",
            "8192",
            "0",
            "&max_extent_size"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_space_for_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2445-2487",
          "snippet": "u64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Cache free space is not 8Kb\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_num_extents_and_bitmaps",
          "args": [
            "cache",
            "1",
            "1"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "check_num_extents_and_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "376-392",
          "snippet": "static int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\"",
            "offset"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Cache free space is not 1Mb + 8Kb\\n\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected region not marked as free\\n\""
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_check_exists",
          "args": [
            "cache",
            "128 * 1024 * 1024 - 768 * 1024",
            "1 * 1024 * 1024"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "test_check_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3439-3517",
          "snippet": "int test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Extent region not marked as free\\n\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_free_space",
          "args": [
            "cache",
            "128 * 1024 * 1024",
            "128 * 1024"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.h",
          "lines": "86-92",
          "snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Bitmap region not marked as free\\n\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid bitmap region marked as free\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Bitmap region not removed from space cache\\n\""
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Free space range missing\\n\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Free space range missing\\n\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to free part of bitmap space %d\\n\"",
            "ret"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_free_space",
          "args": [
            "cache",
            "0",
            "128 * 1024 * 1024 - 768 * 1024"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2209-2297",
          "snippet": "int btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_add_free_space_entry",
          "args": [
            "cache",
            "0",
            "128 * 1024 * 1024 - 512 * 1024",
            "1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "test_add_free_space_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3373-3432",
          "snippet": "int test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent entry %d\\n\"",
            "ret"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate 4Kb from space cache, returned offset is: %llu\\n\"",
            "offset"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Cache free space is not 4Kb\\n\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\"",
            "offset"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Cache free space is not 1Mb + 4Kb\\n\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected region not marked as free\\n\""
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Extent region not marked as free\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Bitmap region not marked as free\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding free space: %d\\n\"",
            "ret"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid bitmap region marked as free\\n\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid bitmap region marked as free\\n\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Bitmap region not removed from space cache\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Free space range missing\\n\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Free space range missing\\n\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to free part of bitmap space %d\\n\"",
            "ret"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent entry %d\\n\"",
            "ret"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running space stealing from bitmap to extent\\n\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int\ntest_steal_space_from_bitmap_to_extent(struct btrfs_block_group_cache *cache)\n{\n\tint ret;\n\tu64 offset;\n\tu64 max_extent_size;\n\n\tbool (*use_bitmap_op)(struct btrfs_free_space_ctl *,\n\t\t\t      struct btrfs_free_space *);\n\n\ttest_msg(\"Running space stealing from bitmap to extent\\n\");\n\n\t/*\n\t * For this test, we want to ensure we end up with an extent entry\n\t * immediately adjacent to a bitmap entry, where the bitmap starts\n\t * at an offset where the extent entry ends. We keep adding and\n\t * removing free space to reach into this state, but to get there\n\t * we need to reach a point where marking new free space doesn't\n\t * result in adding new extent entries or merging the new space\n\t * with existing extent entries - the space ends up being marked\n\t * in an existing bitmap that covers the new free space range.\n\t *\n\t * To get there, we need to reach the threshold defined set at\n\t * cache->free_space_ctl->extents_thresh, which currently is\n\t * 256 extents on a x86_64 system at least, and a few other\n\t * conditions (check free_space_cache.c). Instead of making the\n\t * test much longer and complicated, use a \"use_bitmap\" operation\n\t * that forces use of bitmaps as soon as we have at least 1\n\t * extent entry.\n\t */\n\tuse_bitmap_op = cache->free_space_ctl->op->use_bitmap;\n\tcache->free_space_ctl->op->use_bitmap = test_use_bitmap;\n\n\t/*\n\t * Extent entry covering free space range [128Mb - 256Kb, 128Mb - 128Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [128Mb + 512Kb, 256Mb[ */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the first 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb - 256Kb, 128Mb - 128Kb[\n\t * [128Mb + 512Kb, 128Mb + 768Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      128 * 1024 * 1024 + 768 * 1024,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 512 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [128Mb + 768Kb, 256Mb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 768 * 1024,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb + 256Kb, 128Mb + 512Kb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 + 256 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb, 128Mb + 256Kb[, which is covered\n\t * by the bitmap too, isn't marked as free either.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024,\n\t\t\t      256 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb, 128Mb + 512Kb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the right of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 + 16 * 1024 * 1024,\n\t\t\t\t   4096);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now mark the region [128Mb - 128Kb, 128Mb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb - 256Kb, 128Mb - 128Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t\t   128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 4Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 256Kb, 128Mb + 768Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb - 256Kb, 128Mb[\n\t * bitmap entry covering range: [128Mb, 128Mb + 768Kb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 256 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 4096)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 256 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 4Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 4096) {\n\t\ttest_msg(\"Cache free space is not 4Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 + 16 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 4Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * Now test a similar scenario, but where our extent entry is located\n\t * to the right of the bitmap entry, so that we can check that stealing\n\t * space from a bitmap to the front of an extent entry works.\n\t */\n\n\t/*\n\t * Extent entry covering free space range [128Mb + 128Kb, 128Mb + 256Kb[\n\t */\n\tret = test_add_free_space_entry(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t\t\t128 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Bitmap entry covering free space range [0, 128Mb - 512Kb[ */\n\tret = test_add_free_space_entry(cache, 0,\n\t\t\t\t\t128 * 1024 * 1024 - 512 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now make only the last 256Kb of the bitmap marked as free, so that\n\t * we end up with only the following ranges marked as free space:\n\t *\n\t * [128Mb + 128b, 128Mb + 256Kb[\n\t * [128Mb - 768Kb, 128Mb - 512Kb[\n\t */\n\tret = btrfs_remove_free_space(cache,\n\t\t\t\t      0,\n\t\t\t\t      128 * 1024 * 1024 - 768 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free part of bitmap space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Confirm that only those 2 ranges are marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 + 128 * 1024,\n\t\t\t       128 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       256 * 1024)) {\n\t\ttest_msg(\"Free space range missing\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that the bitmap range [0, 128Mb - 768Kb[ isn't marked\n\t * as free anymore.\n\t */\n\tif (test_check_exists(cache, 0,\n\t\t\t      128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Bitmap region not removed from space cache\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Confirm that the region [128Mb - 512Kb, 128Mb[, which is\n\t * covered by the bitmap, isn't marked as free.\n\t */\n\tif (test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t      512 * 1024)) {\n\t\ttest_msg(\"Invalid bitmap region marked as free\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Now lets mark the region [128Mb - 512Kb, 128Mb[ as free too. But,\n\t * lets make sure the free space cache marks it as free in the bitmap,\n\t * and doesn't insert a new extent entry to represent this region.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t\t   512 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 512 * 1024,\n\t\t\t       512 * 1024)) {\n\t\ttest_msg(\"Bitmap region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that no new extent entries or bitmap entries were added to\n\t * the cache after adding that free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Now lets add a small free space region to the left of the previous\n\t * one, which is not contiguous with it and is part of the bitmap too.\n\t * The goal is to test that the bitmap entry space stealing doesn't\n\t * steal this space region.\n\t */\n\tret = btrfs_add_free_space(cache, 32 * 1024 * 1024, 8192);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now mark the region [128Mb, 128Mb + 128Kb[ as free too. This will\n\t * expand the range covered by the existing extent entry that represents\n\t * the free space [128Mb + 128Kb, 128Mb + 256Kb[.\n\t */\n\tret = btrfs_add_free_space(cache, 128 * 1024 * 1024, 128 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding free space: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\t/* Confirm the region is marked as free. */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024, 128 * 1024)) {\n\t\ttest_msg(\"Extent region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/*\n\t * Confirm that our extent entry didn't stole all free space from the\n\t * bitmap, because of the small 8Kb free space region.\n\t */\n\tret = check_num_extents_and_bitmaps(cache, 2, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * So now we have the range [128Mb - 768Kb, 128Mb + 256Kb[ as free\n\t * space. Without stealing bitmap free space into extent entry space,\n\t * we would have all this free space represented by 2 entries in the\n\t * cache:\n\t *\n\t * extent entry covering range: [128Mb, 128Mb + 256Kb[\n\t * bitmap entry covering range: [128Mb - 768Kb, 128Mb[\n\t *\n\t * Attempting to allocate the whole free space (1Mb) would fail, because\n\t * we can't allocate from multiple entries.\n\t * With the bitmap free space stealing, we get a single extent entry\n\t * that represents the 1Mb free space, and therefore we're able to\n\t * allocate the whole free space at once.\n\t */\n\tif (!test_check_exists(cache, 128 * 1024 * 1024 - 768 * 1024,\n\t\t\t       1 * 1024 * 1024)) {\n\t\ttest_msg(\"Expected region not marked as free\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (cache->free_space_ctl->free_space != (1 * 1024 * 1024 + 8192)) {\n\t\ttest_msg(\"Cache free space is not 1Mb + 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 1 * 1024 * 1024, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (128 * 1024 * 1024 - 768 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 1Mb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* All that remains is a 8Kb free space region in a bitmap. Confirm. */\n\tret = check_num_extents_and_bitmaps(cache, 1, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache->free_space_ctl->free_space != 8192) {\n\t\ttest_msg(\"Cache free space is not 8Kb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toffset = btrfs_find_space_for_alloc(cache,\n\t\t\t\t\t    0, 8192, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != (32 * 1024 * 1024)) {\n\t\ttest_msg(\"Failed to allocate 8Kb from space cache, returned offset is: %llu\\n\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\tret = check_cache_empty(cache);\n\tif (ret)\n\t\treturn ret;\n\n\tcache->free_space_ctl->op->use_bitmap = use_bitmap_op;\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_cache_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "395-420",
    "snippet": "static int check_cache_empty(struct btrfs_block_group_cache *cache)\n{\n\tu64 offset;\n\tu64 max_extent_size;\n\n\t/*\n\t * Now lets confirm that there's absolutely no free space left to\n\t * allocate.\n\t */\n\tif (cache->free_space_ctl->free_space != 0) {\n\t\ttest_msg(\"Cache free space is not 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And any allocation request, no matter how small, should fail now. */\n\toffset = btrfs_find_space_for_alloc(cache, 0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != 0) {\n\t\ttest_msg(\"Space allocation did not fail, returned offset: %llu\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* And no extent nor bitmap entries in the cache anymore. */\n\treturn check_num_extents_and_bitmaps(cache, 0, 0);\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_num_extents_and_bitmaps",
          "args": [
            "cache",
            "0",
            "0"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "check_num_extents_and_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
          "lines": "376-392",
          "snippet": "static int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../free-space-cache.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Space allocation did not fail, returned offset: %llu\"",
            "offset"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_space_for_alloc",
          "args": [
            "cache",
            "0",
            "4096",
            "0",
            "&max_extent_size"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_space_for_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2445-2487",
          "snippet": "u64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nu64 btrfs_find_space_for_alloc(struct btrfs_block_group_cache *block_group,\n\t\t\t       u64 offset, u64 bytes, u64 empty_size,\n\t\t\t       u64 *max_extent_size)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *entry = NULL;\n\tu64 bytes_search = bytes + empty_size;\n\tu64 ret = 0;\n\tu64 align_gap = 0;\n\tu64 align_gap_len = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tentry = find_free_space(ctl, &offset, &bytes_search,\n\t\t\t\tblock_group->full_stripe_len, max_extent_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tret = offset;\n\tif (entry->bitmap) {\n\t\tbitmap_clear_bits(ctl, entry, offset, bytes);\n\t\tif (!entry->bytes)\n\t\t\tfree_bitmap(ctl, entry);\n\t} else {\n\t\tunlink_free_space(ctl, entry);\n\t\talign_gap_len = offset - entry->offset;\n\t\talign_gap = entry->offset;\n\n\t\tentry->offset = offset + bytes;\n\t\tWARN_ON(entry->bytes < bytes + align_gap_len);\n\n\t\tentry->bytes -= bytes + align_gap_len;\n\t\tif (!entry->bytes)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, entry);\n\t\telse\n\t\t\tlink_free_space(ctl, entry);\n\t}\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (align_gap_len)\n\t\t__btrfs_add_free_space(ctl, align_gap, align_gap_len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Cache free space is not 0\\n\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int check_cache_empty(struct btrfs_block_group_cache *cache)\n{\n\tu64 offset;\n\tu64 max_extent_size;\n\n\t/*\n\t * Now lets confirm that there's absolutely no free space left to\n\t * allocate.\n\t */\n\tif (cache->free_space_ctl->free_space != 0) {\n\t\ttest_msg(\"Cache free space is not 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* And any allocation request, no matter how small, should fail now. */\n\toffset = btrfs_find_space_for_alloc(cache, 0, 4096, 0,\n\t\t\t\t\t    &max_extent_size);\n\tif (offset != 0) {\n\t\ttest_msg(\"Space allocation did not fail, returned offset: %llu\",\n\t\t\t offset);\n\t\treturn -EINVAL;\n\t}\n\n\t/* And no extent nor bitmap entries in the cache anymore. */\n\treturn check_num_extents_and_bitmaps(cache, 0, 0);\n}"
  },
  {
    "function_name": "check_num_extents_and_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "376-392",
    "snippet": "static int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Incorrect # of extent entries in the cache: %d, expected %d\\n\"",
            "cache->free_space_ctl->total_bitmaps",
            "num_bitmaps"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_proc_test_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "276-281",
          "snippet": "static __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int\ncheck_num_extents_and_bitmaps(const struct btrfs_block_group_cache *cache,\n\t\t\t      const int num_extents,\n\t\t\t      const int num_bitmaps)\n{\n\tif (cache->free_space_ctl->free_extents != num_extents) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->free_extents, num_extents);\n\t\treturn -EINVAL;\n\t}\n\tif (cache->free_space_ctl->total_bitmaps != num_bitmaps) {\n\t\ttest_msg(\"Incorrect # of extent entries in the cache: %d, expected %d\\n\",\n\t\t\t cache->free_space_ctl->total_bitmaps, num_bitmaps);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "test_use_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "369-373",
    "snippet": "static bool test_use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info)\n{\n\treturn ctl->free_extents > 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic bool test_use_bitmap(struct btrfs_free_space_ctl *ctl,\n\t\t\t    struct btrfs_free_space *info)\n{\n\treturn ctl->free_extents > 0;\n}"
  },
  {
    "function_name": "test_bitmaps_and_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "200-366",
    "snippet": "static int test_bitmaps_and_extents(struct btrfs_block_group_cache *cache)\n{\n\tu64 bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\tint ret;\n\n\ttest_msg(\"Running bitmap and extent tests\\n\");\n\n\t/*\n\t * First let's do something simple, an extent at the same offset as the\n\t * bitmap, but the free space completely in the extent and then\n\t * completely in the bitmap.\n\t */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 1 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants after our remove\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Now to add back the extent entry and remove from the bitmap */\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't re-add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 4 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove from bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 4 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants in the bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ok so a little more evil, extent entry and bitmap at the same offset,\n\t * removing an overlapping chunk.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to a bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 512 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 512 * 1024, 3 * 1024 * 1024)) {\n\t\ttest_msg(\"Left over pieces after removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/* Now with the extent entry offset into the bitmap */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to the bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 2 * 1024 * 1024, 2 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent to the cache %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Problem removing overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left something behind when removing space\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * This has blown up in the past, the extent entry starts before the\n\t * bitmap entry, but we're trying to remove an offset that falls\n\t * completely within the bitmap range and is in both the extent entry\n\t * and the bitmap entry, looks like this\n\t *\n\t *   [ extent ]\n\t *      [ bitmap ]\n\t *        [ del ]\n\t */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tret = test_add_free_space_entry(cache, bitmap_offset + 4 * 1024 * 1024,\n\t\t\t\t   4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, bitmap_offset - 1 * 1024 * 1024,\n\t\t\t\t   5 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t\t      5 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free our space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t 5 * 1024 * 1024)) {\n\t\ttest_msg(\"Left stuff over\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * This blew up before, we have part of the free space in a bitmap and\n\t * then the entirety of the rest of the space in an extent.  This used\n\t * to return -EAGAIN back from btrfs_remove_extent, make sure this\n\t * doesn't happen.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 2 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 3 * 1024 * 1024, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap and extent overlapping %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\treturn 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing bitmap and extent overlapping %d\\n\"",
            "ret"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_free_space",
          "args": [
            "cache",
            "1 * 1024 * 1024",
            "3 * 1024 * 1024"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2209-2297",
          "snippet": "int btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent entry %d\\n\"",
            "ret"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_add_free_space_entry",
          "args": [
            "cache",
            "3 * 1024 * 1024",
            "1 * 1024 * 1024",
            "0"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "test_add_free_space_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3373-3432",
          "snippet": "int test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left stuff over\\n\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_check_exists",
          "args": [
            "cache",
            "bitmap_offset + 1 * 1024 * 1024",
            "5 * 1024 * 1024"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "test_check_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3439-3517",
          "snippet": "int test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to free our space %d\\n\"",
            "ret"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent entry %d\\n\"",
            "ret"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add bitmap %d\\n\"",
            "ret"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left something behind when removing space\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Problem removing overlapping space %d\\n\"",
            "ret"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent to the cache %d\\n\"",
            "ret"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add space to the bitmap %d\\n\"",
            "ret"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left over pieces after removing overlapping\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove overlapping space %d\\n\"",
            "ret"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add to a bitmap %d\\n\"",
            "ret"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left remnants in the bitmap\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove from bitmap %d\\n\"",
            "ret"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't re-add extent entry %d\\n\"",
            "ret"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left remnants after our remove\\n\""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove extent entry %d\\n\"",
            "ret"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add extent entry %d\\n\"",
            "ret"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't create bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running bitmap and extent tests\\n\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "BITS_PER_BITMAP * 4096"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int test_bitmaps_and_extents(struct btrfs_block_group_cache *cache)\n{\n\tu64 bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\tint ret;\n\n\ttest_msg(\"Running bitmap and extent tests\\n\");\n\n\t/*\n\t * First let's do something simple, an extent at the same offset as the\n\t * bitmap, but the free space completely in the extent and then\n\t * completely in the bitmap.\n\t */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 1 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants after our remove\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Now to add back the extent entry and remove from the bitmap */\n\tret = test_add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't re-add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 4 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove from bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 4 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Left remnants in the bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Ok so a little more evil, extent entry and bitmap at the same offset,\n\t * removing an overlapping chunk.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to a bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 512 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 512 * 1024, 3 * 1024 * 1024)) {\n\t\ttest_msg(\"Left over pieces after removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/* Now with the extent entry offset into the bitmap */\n\tret = test_add_free_space_entry(cache, 4 * 1024 * 1024, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space to the bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 2 * 1024 * 1024, 2 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent to the cache %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Problem removing overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left something behind when removing space\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * This has blown up in the past, the extent entry starts before the\n\t * bitmap entry, but we're trying to remove an offset that falls\n\t * completely within the bitmap range and is in both the extent entry\n\t * and the bitmap entry, looks like this\n\t *\n\t *   [ extent ]\n\t *      [ bitmap ]\n\t *        [ del ]\n\t */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\tret = test_add_free_space_entry(cache, bitmap_offset + 4 * 1024 * 1024,\n\t\t\t\t   4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, bitmap_offset - 1 * 1024 * 1024,\n\t\t\t\t   5 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t\t      5 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Failed to free our space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, bitmap_offset + 1 * 1024 * 1024,\n\t\t\t 5 * 1024 * 1024)) {\n\t\ttest_msg(\"Left stuff over\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\t/*\n\t * This blew up before, we have part of the free space in a bitmap and\n\t * then the entirety of the rest of the space in an extent.  This used\n\t * to return -EAGAIN back from btrfs_remove_extent, make sure this\n\t * doesn't happen.\n\t */\n\tret = test_add_free_space_entry(cache, 1 * 1024 * 1024, 2 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = test_add_free_space_entry(cache, 3 * 1024 * 1024, 1 * 1024 * 1024, 0);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add extent entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 3 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap and extent overlapping %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\treturn 0;\n}"
  },
  {
    "function_name": "test_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "130-197",
    "snippet": "static int test_bitmaps(struct btrfs_block_group_cache *cache)\n{\n\tu64 next_bitmap_offset;\n\tint ret;\n\n\ttest_msg(\"Running bitmap only tests\\n\");\n\n\tret = test_add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap full range %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left some space in bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to our bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 2 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove middle chunk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The first bitmap we have starts at offset 0 so the next one is just\n\t * at the end of the first bitmap.\n\t */\n\tnext_bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\n\t/* Test a bit straddling two bitmaps */\n\tret = test_add_free_space_entry(cache, next_bitmap_offset -\n\t\t\t\t   (2 * 1024 * 1024), 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space that straddles two bitmaps %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, next_bitmap_offset -\n\t\t\t\t      (1 * 1024 * 1024), 2 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, next_bitmap_offset - (1 * 1024 * 1024),\n\t\t\t 2 * 1024 * 1024)) {\n\t\ttest_msg(\"Left some space when removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left some space when removing overlapping\\n\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_check_exists",
          "args": [
            "cache",
            "next_bitmap_offset - (1 * 1024 * 1024)",
            "2 * 1024 * 1024"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "test_check_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3439-3517",
          "snippet": "int test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove overlapping space %d\\n\"",
            "ret"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_free_space",
          "args": [
            "cache",
            "next_bitmap_offset -\n\t\t\t\t      (1 * 1024 * 1024)",
            "2 * 1024 * 1024"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2209-2297",
          "snippet": "int btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add space that straddles two bitmaps %d\\n\"",
            "ret"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_add_free_space_entry",
          "args": [
            "cache",
            "next_bitmap_offset -\n\t\t\t\t   (2 * 1024 * 1024)",
            "4 * 1024 * 1024",
            "1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "test_add_free_space_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3373-3432",
          "snippet": "int test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_add_free_space_entry(struct btrfs_block_group_cache *cache,\n\t\t\t      u64 offset, u64 bytes, bool bitmap)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info = NULL, *bitmap_info;\n\tvoid *map = NULL;\n\tu64 bytes_added;\n\tint ret;\n\nagain:\n\tif (!info) {\n\t\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!bitmap) {\n\t\tspin_lock(&ctl->tree_lock);\n\t\tinfo->offset = offset;\n\t\tinfo->bytes = bytes;\n\t\tret = link_free_space(ctl, info);\n\t\tspin_unlock(&ctl->tree_lock);\n\t\tif (ret)\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\treturn ret;\n\t}\n\n\tif (!map) {\n\t\tmap = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);\n\t\tif (!map) {\n\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&ctl->tree_lock);\n\tbitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t 1, 0);\n\tif (!bitmap_info) {\n\t\tinfo->bitmap = map;\n\t\tmap = NULL;\n\t\tadd_new_bitmap(ctl, info, offset);\n\t\tbitmap_info = info;\n\t\tinfo = NULL;\n\t}\n\n\tbytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);\n\tbytes -= bytes_added;\n\toffset += bytes_added;\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (bytes)\n\t\tgoto again;\n\n\tif (info)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\tif (map)\n\t\tkfree(map);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "BITS_PER_BITMAP * 4096"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't remove middle chunk %d\\n\"",
            "ret"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't add to our bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Left some space in bitmap\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing bitmap full range %d\\n\"",
            "ret"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't create a bitmap entry %d\\n\"",
            "ret"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running bitmap only tests\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\n#define BITS_PER_BITMAP\t\t(PAGE_CACHE_SIZE * 8)\n\nstatic int test_bitmaps(struct btrfs_block_group_cache *cache)\n{\n\tu64 next_bitmap_offset;\n\tint ret;\n\n\ttest_msg(\"Running bitmap only tests\\n\");\n\n\tret = test_add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't create a bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing bitmap full range %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Left some space in bitmap\\n\");\n\t\treturn -1;\n\t}\n\n\tret = test_add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add to our bitmap entry %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 2 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove middle chunk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The first bitmap we have starts at offset 0 so the next one is just\n\t * at the end of the first bitmap.\n\t */\n\tnext_bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);\n\n\t/* Test a bit straddling two bitmaps */\n\tret = test_add_free_space_entry(cache, next_bitmap_offset -\n\t\t\t\t   (2 * 1024 * 1024), 4 * 1024 * 1024, 1);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't add space that straddles two bitmaps %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, next_bitmap_offset -\n\t\t\t\t      (1 * 1024 * 1024), 2 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't remove overlapping space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, next_bitmap_offset - (1 * 1024 * 1024),\n\t\t\t 2 * 1024 * 1024)) {\n\t\ttest_msg(\"Left some space when removing overlapping\\n\");\n\t\treturn -1;\n\t}\n\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "60-128",
    "snippet": "static int test_extents(struct btrfs_block_group_cache *cache)\n{\n\tint ret = 0;\n\n\ttest_msg(\"Running extent only tests\\n\");\n\n\t/* First just make sure we can remove an entire entry */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding initial extents %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Full remove left some lingering space\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Ok edge and middle cases now */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding half extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing tail end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing front end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 2 * 1024 * 1024, 4096);\n\tif (ret) {\n\t\ttest_msg(\"Error removing middle piece %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the front\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 2 * 1024 * 1024, 4096)) {\n\t\ttest_msg(\"Still have space in the middle\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the end\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Cleanup */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_remove_free_space_cache",
          "args": [
            "cache->free_space_ctl"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_remove_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2413-2418",
          "snippet": "void __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nvoid __btrfs_remove_free_space_cache(struct btrfs_free_space_ctl *ctl)\n{\n\tspin_lock(&ctl->tree_lock);\n\t__btrfs_remove_free_space_cache_locked(ctl);\n\tspin_unlock(&ctl->tree_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Still have space at the end\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_check_exists",
          "args": [
            "cache",
            "3 * 1024 * 1024",
            "1 * 1024 * 1024"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "test_check_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "3439-3517",
          "snippet": "int test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint test_check_exists(struct btrfs_block_group_cache *cache,\n\t\t      u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = cache->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tspin_lock(&ctl->tree_lock);\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info)\n\t\t\tgoto out;\n\t}\n\nhave_info:\n\tif (info->bitmap) {\n\t\tu64 bit_off, bit_bytes;\n\t\tstruct rb_node *n;\n\t\tstruct btrfs_free_space *tmp;\n\n\t\tbit_off = offset;\n\t\tbit_bytes = ctl->unit;\n\t\tret = search_bitmap(ctl, info, &bit_off, &bit_bytes);\n\t\tif (!ret) {\n\t\t\tif (bit_off == offset) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (bit_off > offset &&\n\t\t\t\t   offset + bytes > bit_off) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tn = rb_prev(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (tmp->offset + tmp->bytes < offset)\n\t\t\t\tbreak;\n\t\t\tif (offset + bytes < tmp->offset) {\n\t\t\t\tn = rb_prev(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tn = rb_next(&info->offset_index);\n\t\twhile (n) {\n\t\t\ttmp = rb_entry(n, struct btrfs_free_space,\n\t\t\t\t       offset_index);\n\t\t\tif (offset + bytes < tmp->offset)\n\t\t\t\tbreak;\n\t\t\tif (tmp->offset + tmp->bytes < offset) {\n\t\t\t\tn = rb_next(&info->offset_index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tinfo = tmp;\n\t\t\tgoto have_info;\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (info->offset == offset) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (offset > info->offset && offset < info->offset + info->bytes)\n\t\tret = 1;\nout:\n\tspin_unlock(&ctl->tree_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Still have space in the middle\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Still have space at the front\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing middle piece %d\\n\"",
            "ret"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_free_space",
          "args": [
            "cache",
            "2 * 1024 * 1024",
            "4096"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2209-2297",
          "snippet": "int btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint btrfs_remove_free_space(struct btrfs_block_group_cache *block_group,\n\t\t\t    u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\tstruct btrfs_free_space *info;\n\tint ret;\n\tbool re_search = false;\n\n\tspin_lock(&ctl->tree_lock);\n\nagain:\n\tret = 0;\n\tif (!bytes)\n\t\tgoto out_lock;\n\n\tinfo = tree_search_offset(ctl, offset, 0, 0);\n\tif (!info) {\n\t\t/*\n\t\t * oops didn't find an extent that matched the space we wanted\n\t\t * to remove, look for a bitmap instead\n\t\t */\n\t\tinfo = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),\n\t\t\t\t\t  1, 0);\n\t\tif (!info) {\n\t\t\t/*\n\t\t\t * If we found a partial bit of our free space in a\n\t\t\t * bitmap but then couldn't find the other part this may\n\t\t\t * be a problem, so WARN about it.\n\t\t\t */\n\t\t\tWARN_ON(re_search);\n\t\t\tgoto out_lock;\n\t\t}\n\t}\n\n\tre_search = false;\n\tif (!info->bitmap) {\n\t\tunlink_free_space(ctl, info);\n\t\tif (offset == info->offset) {\n\t\t\tu64 to_free = min(bytes, info->bytes);\n\n\t\t\tinfo->bytes -= to_free;\n\t\t\tinfo->offset += to_free;\n\t\t\tif (info->bytes) {\n\t\t\t\tret = link_free_space(ctl, info);\n\t\t\t\tWARN_ON(ret);\n\t\t\t} else {\n\t\t\t\tkmem_cache_free(btrfs_free_space_cachep, info);\n\t\t\t}\n\n\t\t\toffset += to_free;\n\t\t\tbytes -= to_free;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tu64 old_end = info->bytes + info->offset;\n\n\t\t\tinfo->bytes = offset - info->offset;\n\t\t\tret = link_free_space(ctl, info);\n\t\t\tWARN_ON(ret);\n\t\t\tif (ret)\n\t\t\t\tgoto out_lock;\n\n\t\t\t/* Not enough bytes in this entry to satisfy us */\n\t\t\tif (old_end < offset + bytes) {\n\t\t\t\tbytes -= old_end - offset;\n\t\t\t\toffset = old_end;\n\t\t\t\tgoto again;\n\t\t\t} else if (old_end == offset + bytes) {\n\t\t\t\t/* all done */\n\t\t\t\tgoto out_lock;\n\t\t\t}\n\t\t\tspin_unlock(&ctl->tree_lock);\n\n\t\t\tret = btrfs_add_free_space(block_group, offset + bytes,\n\t\t\t\t\t\t   old_end - (offset + bytes));\n\t\t\tWARN_ON(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = remove_from_bitmap(ctl, info, &offset, &bytes);\n\tif (ret == -EAGAIN) {\n\t\tre_search = true;\n\t\tgoto again;\n\t}\nout_lock:\n\tspin_unlock(&ctl->tree_lock);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing front end %d\\n\"",
            "ret"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing tail end %d\\n\"",
            "ret"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding half extent %d\\n\"",
            "ret"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_free_space",
          "args": [
            "cache",
            "0",
            "4 * 1024 * 1024"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.h",
          "lines": "86-92",
          "snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Full remove left some lingering space\\n\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error removing extent %d\\n\"",
            "ret"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Error adding initial extents %d\\n\"",
            "ret"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running extent only tests\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int test_extents(struct btrfs_block_group_cache *cache)\n{\n\tint ret = 0;\n\n\ttest_msg(\"Running extent only tests\\n\");\n\n\t/* First just make sure we can remove an entire entry */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding initial extents %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 4 * 1024 * 1024)) {\n\t\ttest_msg(\"Full remove left some lingering space\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Ok edge and middle cases now */\n\tret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error adding half extent %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing tail end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);\n\tif (ret) {\n\t\ttest_msg(\"Error removing front end %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_remove_free_space(cache, 2 * 1024 * 1024, 4096);\n\tif (ret) {\n\t\ttest_msg(\"Error removing middle piece %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (test_check_exists(cache, 0, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the front\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 2 * 1024 * 1024, 4096)) {\n\t\ttest_msg(\"Still have space in the middle\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_check_exists(cache, 3 * 1024 * 1024, 1 * 1024 * 1024)) {\n\t\ttest_msg(\"Still have space at the end\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Cleanup */\n\t__btrfs_remove_free_space_cache(cache->free_space_ctl);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_test_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/free-space-tests.c",
    "lines": "25-53",
    "snippet": "static struct btrfs_block_group_cache *init_test_block_group(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->key.objectid = 0;\n\tcache->key.offset = 1024 * 1024 * 1024;\n\tcache->key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tcache->sectorsize = 4096;\n\tcache->full_stripe_len = 4096;\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\n\tbtrfs_init_free_space_ctl(cache);\n\n\treturn cache;\n}",
    "includes": [
      "#include \"../free-space-cache.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_init_free_space_ctl",
          "args": [
            "cache"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_free_space_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2322-2341",
          "snippet": "void btrfs_init_free_space_ctl(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = block_group->sectorsize;\n\tctl->start = block_group->key.objectid;\n\tctl->private = block_group;\n\tctl->op = &free_space_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * we only want to have 32k of ram per block group for keeping\n\t * track of free space, and if we pass 1/2 of that we want to\n\t * start converting things over to using bitmaps\n\t */\n\tctl->extents_thresh = ((1024 * 32) / 2) /\n\t\t\t\tsizeof(struct btrfs_free_space);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic struct btrfs_free_space_op free_space_op = {\n\t.recalc_thresholds\t= recalculate_thresholds,\n\t.use_bitmap\t\t= use_bitmap,\n};\n\nvoid btrfs_init_free_space_ctl(struct btrfs_block_group_cache *block_group)\n{\n\tstruct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;\n\n\tspin_lock_init(&ctl->tree_lock);\n\tctl->unit = block_group->sectorsize;\n\tctl->start = block_group->key.objectid;\n\tctl->private = block_group;\n\tctl->op = &free_space_op;\n\tINIT_LIST_HEAD(&ctl->trimming_ranges);\n\tmutex_init(&ctl->cache_writeout_mutex);\n\n\t/*\n\t * we only want to have 32k of ram per block group for keeping\n\t * track of free space, and if we pass 1/2 of that we want to\n\t * start converting things over to using bitmaps\n\t */\n\tctl->extents_thresh = ((1024 * 32) / 2) /\n\t\t\t\tsizeof(struct btrfs_free_space);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->bg_list"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->cluster_list"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->list"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cache->lock"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cache"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cache->free_space_ctl)",
            "GFP_NOFS"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cache)",
            "GFP_NOFS"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../free-space-cache.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic struct btrfs_block_group_cache *init_test_block_group(void)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->key.objectid = 0;\n\tcache->key.offset = 1024 * 1024 * 1024;\n\tcache->key.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tcache->sectorsize = 4096;\n\tcache->full_stripe_len = 4096;\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\n\tbtrfs_init_free_space_ctl(cache);\n\n\treturn cache;\n}"
  }
]